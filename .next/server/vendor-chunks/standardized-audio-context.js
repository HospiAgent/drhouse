/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/standardized-audio-context";
exports.ids = ["vendor-chunks/standardized-audio-context"];
exports.modules = {

/***/ "(ssr)/./node_modules/standardized-audio-context/build/es5/bundle.js":
/*!*********************************************************************!*\
  !*** ./node_modules/standardized-audio-context/build/es5/bundle.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("(function (global, factory) {\n     true ? factory(exports, __webpack_require__(/*! automation-events */ \"(ssr)/./node_modules/automation-events/build/node/module.js\"), __webpack_require__(/*! @babel/runtime/helpers/slicedToArray */ \"(ssr)/./node_modules/@babel/runtime/helpers/slicedToArray.js\"), __webpack_require__(/*! @babel/runtime/helpers/createClass */ \"(ssr)/./node_modules/@babel/runtime/helpers/createClass.js\"), __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ \"(ssr)/./node_modules/@babel/runtime/helpers/classCallCheck.js\"), __webpack_require__(/*! @babel/runtime/helpers/typeof */ \"(ssr)/./node_modules/@babel/runtime/helpers/typeof.js\"), __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ \"(ssr)/./node_modules/@babel/runtime/helpers/defineProperty.js\"), __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ \"(ssr)/./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js\"), __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ \"(ssr)/./node_modules/@babel/runtime/helpers/getPrototypeOf.js\"), __webpack_require__(/*! @babel/runtime/helpers/inherits */ \"(ssr)/./node_modules/@babel/runtime/helpers/inherits.js\"), __webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ \"(ssr)/./node_modules/@babel/runtime/helpers/asyncToGenerator.js\"), __webpack_require__(/*! @babel/runtime/regenerator */ \"(ssr)/./node_modules/@babel/runtime/regenerator/index.js\"), __webpack_require__(/*! @babel/runtime/helpers/toConsumableArray */ \"(ssr)/./node_modules/@babel/runtime/helpers/toConsumableArray.js\"), __webpack_require__(/*! @babel/runtime/helpers/objectWithoutProperties */ \"(ssr)/./node_modules/@babel/runtime/helpers/objectWithoutProperties.js\")) :\n    0;\n})(this, (function (exports, automationEvents, _slicedToArray, _createClass, _classCallCheck, _typeof, _defineProperty, _possibleConstructorReturn, _getPrototypeOf, _inherits, _asyncToGenerator, _regeneratorRuntime, _toConsumableArray, _objectWithoutProperties) { 'use strict';\n\n    var createAbortError = function createAbortError() {\n      return new DOMException('', 'AbortError');\n    };\n\n    var createAddActiveInputConnectionToAudioNode = function createAddActiveInputConnectionToAudioNode(insertElementInSet) {\n      return function (activeInputs, source, _ref, ignoreDuplicates) {\n        var _ref2 = _slicedToArray(_ref, 3),\n          output = _ref2[0],\n          input = _ref2[1],\n          eventListener = _ref2[2];\n        insertElementInSet(activeInputs[input], [source, output, eventListener], function (activeInputConnection) {\n          return activeInputConnection[0] === source && activeInputConnection[1] === output;\n        }, ignoreDuplicates);\n      };\n    };\n\n    var createAddAudioNodeConnections = function createAddAudioNodeConnections(audioNodeConnectionsStore) {\n      return function (audioNode, audioNodeRenderer, nativeAudioNode) {\n        var activeInputs = [];\n        for (var i = 0; i < nativeAudioNode.numberOfInputs; i += 1) {\n          activeInputs.push(new Set());\n        }\n        audioNodeConnectionsStore.set(audioNode, {\n          activeInputs: activeInputs,\n          outputs: new Set(),\n          passiveInputs: new WeakMap(),\n          renderer: audioNodeRenderer\n        });\n      };\n    };\n\n    var createAddAudioParamConnections = function createAddAudioParamConnections(audioParamConnectionsStore) {\n      return function (audioParam, audioParamRenderer) {\n        audioParamConnectionsStore.set(audioParam, {\n          activeInputs: new Set(),\n          passiveInputs: new WeakMap(),\n          renderer: audioParamRenderer\n        });\n      };\n    };\n\n    var ACTIVE_AUDIO_NODE_STORE = new WeakSet();\n    var AUDIO_NODE_CONNECTIONS_STORE = new WeakMap();\n    var AUDIO_NODE_STORE = new WeakMap();\n    var AUDIO_PARAM_CONNECTIONS_STORE = new WeakMap();\n    var AUDIO_PARAM_STORE = new WeakMap();\n    var CONTEXT_STORE = new WeakMap();\n    var EVENT_LISTENERS = new WeakMap();\n    var CYCLE_COUNTERS = new WeakMap();\n    // This clunky name is borrowed from the spec. :-)\n    var NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS = new WeakMap();\n    var NODE_TO_PROCESSOR_MAPS = new WeakMap();\n\n    var handler = {\n      construct: function construct() {\n        return handler;\n      }\n    };\n    var isConstructible = function isConstructible(constructible) {\n      try {\n        var proxy = new Proxy(constructible, handler);\n        new proxy(); // tslint:disable-line:no-unused-expression\n      } catch (_unused) {\n        return false;\n      }\n      return true;\n    };\n\n    /*\n     * This massive regex tries to cover all the following cases.\n     *\n     * import './path';\n     * import defaultImport from './path';\n     * import { namedImport } from './path';\n     * import { namedImport as renamendImport } from './path';\n     * import * as namespaceImport from './path';\n     * import defaultImport, { namedImport } from './path';\n     * import defaultImport, { namedImport as renamendImport } from './path';\n     * import defaultImport, * as namespaceImport from './path';\n     */\n    var IMPORT_STATEMENT_REGEX = /^import(?:(?:[\\s]+[\\w]+|(?:[\\s]+[\\w]+[\\s]*,)?[\\s]*\\{[\\s]*[\\w]+(?:[\\s]+as[\\s]+[\\w]+)?(?:[\\s]*,[\\s]*[\\w]+(?:[\\s]+as[\\s]+[\\w]+)?)*[\\s]*}|(?:[\\s]+[\\w]+[\\s]*,)?[\\s]*\\*[\\s]+as[\\s]+[\\w]+)[\\s]+from)?(?:[\\s]*)(\"([^\"\\\\]|\\\\.)+\"|'([^'\\\\]|\\\\.)+')(?:[\\s]*);?/; // tslint:disable-line:max-line-length\n    var splitImportStatements = function splitImportStatements(source, url) {\n      var importStatements = [];\n      var sourceWithoutImportStatements = source.replace(/^[\\s]+/, '');\n      var result = sourceWithoutImportStatements.match(IMPORT_STATEMENT_REGEX);\n      while (result !== null) {\n        var unresolvedUrl = result[1].slice(1, -1);\n        var importStatementWithResolvedUrl = result[0].replace(/([\\s]+)?;?$/, '').replace(unresolvedUrl, new URL(unresolvedUrl, url).toString());\n        importStatements.push(importStatementWithResolvedUrl);\n        sourceWithoutImportStatements = sourceWithoutImportStatements.slice(result[0].length).replace(/^[\\s]+/, '');\n        result = sourceWithoutImportStatements.match(IMPORT_STATEMENT_REGEX);\n      }\n      return [importStatements.join(';'), sourceWithoutImportStatements];\n    };\n\n    var verifyParameterDescriptors = function verifyParameterDescriptors(parameterDescriptors) {\n      if (parameterDescriptors !== undefined && !Array.isArray(parameterDescriptors)) {\n        throw new TypeError('The parameterDescriptors property of given value for processorCtor is not an array.');\n      }\n    };\n    var verifyProcessorCtor = function verifyProcessorCtor(processorCtor) {\n      if (!isConstructible(processorCtor)) {\n        throw new TypeError('The given value for processorCtor should be a constructor.');\n      }\n      if (processorCtor.prototype === null || _typeof(processorCtor.prototype) !== 'object') {\n        throw new TypeError('The given value for processorCtor should have a prototype.');\n      }\n    };\n    var createAddAudioWorkletModule = function createAddAudioWorkletModule(cacheTestResult, createNotSupportedError, evaluateSource, exposeCurrentFrameAndCurrentTime, fetchSource, getNativeContext, getOrCreateBackupOfflineAudioContext, isNativeOfflineAudioContext, nativeAudioWorkletNodeConstructor, ongoingRequests, resolvedRequests, testAudioWorkletProcessorPostMessageSupport, window) {\n      var index = 0;\n      return function (context, moduleURL) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n          credentials: 'omit'\n        };\n        var resolvedRequestsOfContext = resolvedRequests.get(context);\n        if (resolvedRequestsOfContext !== undefined && resolvedRequestsOfContext.has(moduleURL)) {\n          return Promise.resolve();\n        }\n        var ongoingRequestsOfContext = ongoingRequests.get(context);\n        if (ongoingRequestsOfContext !== undefined) {\n          var promiseOfOngoingRequest = ongoingRequestsOfContext.get(moduleURL);\n          if (promiseOfOngoingRequest !== undefined) {\n            return promiseOfOngoingRequest;\n          }\n        }\n        var nativeContext = getNativeContext(context);\n        // Bug #59: Safari does not implement the audioWorklet property.\n        var promise = nativeContext.audioWorklet === undefined ? fetchSource(moduleURL).then(function (_ref) {\n          var _ref2 = _slicedToArray(_ref, 2),\n            source = _ref2[0],\n            absoluteUrl = _ref2[1];\n          var _splitImportStatement = splitImportStatements(source, absoluteUrl),\n            _splitImportStatement2 = _slicedToArray(_splitImportStatement, 2),\n            importStatements = _splitImportStatement2[0],\n            sourceWithoutImportStatements = _splitImportStatement2[1];\n          /*\n           * This is the unminified version of the code used below:\n           *\n           * ```js\n           * ${ importStatements };\n           * ((a, b) => {\n           *     (a[b] = a[b] || [ ]).push(\n           *         (AudioWorkletProcessor, global, registerProcessor, sampleRate, self, window) => {\n           *             ${ sourceWithoutImportStatements }\n           *         }\n           *     );\n           * })(window, '_AWGS');\n           * ```\n           */\n          // tslint:disable-next-line:max-line-length\n          var wrappedSource = \"\".concat(importStatements, \";((a,b)=>{(a[b]=a[b]||[]).push((AudioWorkletProcessor,global,registerProcessor,sampleRate,self,window)=>{\").concat(sourceWithoutImportStatements, \"\\n})})(window,'_AWGS')\");\n          // @todo Evaluating the given source code is a possible security problem.\n          return evaluateSource(wrappedSource);\n        }).then(function () {\n          var evaluateAudioWorkletGlobalScope = window._AWGS.pop();\n          if (evaluateAudioWorkletGlobalScope === undefined) {\n            // Bug #182 Chrome and Edge do throw an instance of a SyntaxError instead of a DOMException.\n            throw new SyntaxError();\n          }\n          exposeCurrentFrameAndCurrentTime(nativeContext.currentTime, nativeContext.sampleRate, function () {\n            return evaluateAudioWorkletGlobalScope(/*#__PURE__*/_createClass(function AudioWorkletProcessor() {\n              _classCallCheck(this, AudioWorkletProcessor);\n            }), undefined, function (name, processorCtor) {\n              if (name.trim() === '') {\n                throw createNotSupportedError();\n              }\n              var nodeNameToProcessorConstructorMap = NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS.get(nativeContext);\n              if (nodeNameToProcessorConstructorMap !== undefined) {\n                if (nodeNameToProcessorConstructorMap.has(name)) {\n                  throw createNotSupportedError();\n                }\n                verifyProcessorCtor(processorCtor);\n                verifyParameterDescriptors(processorCtor.parameterDescriptors);\n                nodeNameToProcessorConstructorMap.set(name, processorCtor);\n              } else {\n                verifyProcessorCtor(processorCtor);\n                verifyParameterDescriptors(processorCtor.parameterDescriptors);\n                NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS.set(nativeContext, new Map([[name, processorCtor]]));\n              }\n            }, nativeContext.sampleRate, undefined, undefined);\n          });\n        }) : Promise.all([fetchSource(moduleURL), Promise.resolve(cacheTestResult(testAudioWorkletProcessorPostMessageSupport, testAudioWorkletProcessorPostMessageSupport))]).then(function (_ref3) {\n          var _ref4 = _slicedToArray(_ref3, 2),\n            _ref4$ = _slicedToArray(_ref4[0], 2),\n            source = _ref4$[0],\n            absoluteUrl = _ref4$[1],\n            isSupportingPostMessage = _ref4[1];\n          var currentIndex = index + 1;\n          index = currentIndex;\n          var _splitImportStatement3 = splitImportStatements(source, absoluteUrl),\n            _splitImportStatement4 = _slicedToArray(_splitImportStatement3, 2),\n            importStatements = _splitImportStatement4[0],\n            sourceWithoutImportStatements = _splitImportStatement4[1];\n          /*\n           * Bug #179: Firefox does not allow to transfer any buffer which has been passed to the process() method as an argument.\n           *\n           * This is the unminified version of the code used below.\n           *\n           * ```js\n           * class extends AudioWorkletProcessor {\n           *\n           *     __buffers = new WeakSet();\n           *\n           *     constructor () {\n           *         super();\n           *\n           *         this.port.postMessage = ((postMessage) => {\n           *             return (message, transferables) => {\n           *                 const filteredTransferables = (transferables)\n           *                     ? transferables.filter((transferable) => !this.__buffers.has(transferable))\n           *                     : transferables;\n           *\n           *                 return postMessage.call(this.port, message, filteredTransferables);\n           *              };\n           *         })(this.port.postMessage);\n           *     }\n           * }\n           * ```\n           */\n          var patchedAudioWorkletProcessor = isSupportingPostMessage ? 'AudioWorkletProcessor' : 'class extends AudioWorkletProcessor {__b=new WeakSet();constructor(){super();(p=>p.postMessage=(q=>(m,t)=>q.call(p,m,t?t.filter(u=>!this.__b.has(u)):t))(p.postMessage))(this.port)}}';\n          /*\n           * Bug #170: Chrome and Edge do call process() with an array with empty channelData for each input if no input is connected.\n           *\n           * Bug #179: Firefox does not allow to transfer any buffer which has been passed to the process() method as an argument.\n           *\n           * Bug #190: Safari doesn't throw an error when loading an unparsable module.\n           *\n           * This is the unminified version of the code used below:\n           *\n           * ```js\n           * `${ importStatements };\n           * ((AudioWorkletProcessor, registerProcessor) => {${ sourceWithoutImportStatements }\n           * })(\n           *     ${Â patchedAudioWorkletProcessor },\n           *     (name, processorCtor) => registerProcessor(name, class extends processorCtor {\n           *\n           *         __collectBuffers = (array) => {\n           *             array.forEach((element) => this.__buffers.add(element.buffer));\n           *         };\n           *\n           *         process (inputs, outputs, parameters) {\n           *             inputs.forEach(this.__collectBuffers);\n           *             outputs.forEach(this.__collectBuffers);\n           *             this.__collectBuffers(Object.values(parameters));\n           *\n           *             return super.process(\n           *                 (inputs.map((input) => input.some((channelData) => channelData.length === 0)) ? [ ] : input),\n           *                 outputs,\n           *                 parameters\n           *             );\n           *         }\n           *\n           *     })\n           * );\n           *\n           * registerProcessor(`__sac${currentIndex}`, class extends AudioWorkletProcessor{\n           *\n           *     process () {\n           *         return false;\n           *     }\n           *\n           * })`\n           * ```\n           */\n          var memberDefinition = isSupportingPostMessage ? '' : '__c = (a) => a.forEach(e=>this.__b.add(e.buffer));';\n          var bufferRegistration = isSupportingPostMessage ? '' : 'i.forEach(this.__c);o.forEach(this.__c);this.__c(Object.values(p));';\n          var wrappedSource = \"\".concat(importStatements, \";((AudioWorkletProcessor,registerProcessor)=>{\").concat(sourceWithoutImportStatements, \"\\n})(\").concat(patchedAudioWorkletProcessor, \",(n,p)=>registerProcessor(n,class extends p{\").concat(memberDefinition, \"process(i,o,p){\").concat(bufferRegistration, \"return super.process(i.map(j=>j.some(k=>k.length===0)?[]:j),o,p)}}));registerProcessor('__sac\").concat(currentIndex, \"',class extends AudioWorkletProcessor{process(){return !1}})\");\n          var blob = new Blob([wrappedSource], {\n            type: 'application/javascript; charset=utf-8'\n          });\n          var url = URL.createObjectURL(blob);\n          return nativeContext.audioWorklet.addModule(url, options).then(function () {\n            if (isNativeOfflineAudioContext(nativeContext)) {\n              return nativeContext;\n            }\n            // Bug #186: Chrome and Edge do not allow to create an AudioWorkletNode on a closed AudioContext.\n            var backupOfflineAudioContext = getOrCreateBackupOfflineAudioContext(nativeContext);\n            return backupOfflineAudioContext.audioWorklet.addModule(url, options).then(function () {\n              return backupOfflineAudioContext;\n            });\n          }).then(function (nativeContextOrBackupOfflineAudioContext) {\n            if (nativeAudioWorkletNodeConstructor === null) {\n              throw new SyntaxError();\n            }\n            try {\n              // Bug #190: Safari doesn't throw an error when loading an unparsable module.\n              new nativeAudioWorkletNodeConstructor(nativeContextOrBackupOfflineAudioContext, \"__sac\".concat(currentIndex)); // tslint:disable-line:no-unused-expression\n            } catch (_unused) {\n              throw new SyntaxError();\n            }\n          })[\"finally\"](function () {\n            return URL.revokeObjectURL(url);\n          });\n        });\n        if (ongoingRequestsOfContext === undefined) {\n          ongoingRequests.set(context, new Map([[moduleURL, promise]]));\n        } else {\n          ongoingRequestsOfContext.set(moduleURL, promise);\n        }\n        promise.then(function () {\n          var updatedResolvedRequestsOfContext = resolvedRequests.get(context);\n          if (updatedResolvedRequestsOfContext === undefined) {\n            resolvedRequests.set(context, new Set([moduleURL]));\n          } else {\n            updatedResolvedRequestsOfContext.add(moduleURL);\n          }\n        })[\"finally\"](function () {\n          var updatedOngoingRequestsOfContext = ongoingRequests.get(context);\n          if (updatedOngoingRequestsOfContext !== undefined) {\n            updatedOngoingRequestsOfContext[\"delete\"](moduleURL);\n          }\n        });\n        return promise;\n      };\n    };\n\n    var getValueForKey = function getValueForKey(map, key) {\n      var value = map.get(key);\n      if (value === undefined) {\n        throw new Error('A value with the given key could not be found.');\n      }\n      return value;\n    };\n\n    var pickElementFromSet = function pickElementFromSet(set, predicate) {\n      var matchingElements = Array.from(set).filter(predicate);\n      if (matchingElements.length > 1) {\n        throw Error('More than one element was found.');\n      }\n      if (matchingElements.length === 0) {\n        throw Error('No element was found.');\n      }\n      var _matchingElements = _slicedToArray(matchingElements, 1),\n        matchingElement = _matchingElements[0];\n      set[\"delete\"](matchingElement);\n      return matchingElement;\n    };\n\n    var deletePassiveInputConnectionToAudioNode = function deletePassiveInputConnectionToAudioNode(passiveInputs, source, output, input) {\n      var passiveInputConnections = getValueForKey(passiveInputs, source);\n      var matchingConnection = pickElementFromSet(passiveInputConnections, function (passiveInputConnection) {\n        return passiveInputConnection[0] === output && passiveInputConnection[1] === input;\n      });\n      if (passiveInputConnections.size === 0) {\n        passiveInputs[\"delete\"](source);\n      }\n      return matchingConnection;\n    };\n\n    var getEventListenersOfAudioNode = function getEventListenersOfAudioNode(audioNode) {\n      return getValueForKey(EVENT_LISTENERS, audioNode);\n    };\n\n    var setInternalStateToActive = function setInternalStateToActive(audioNode) {\n      if (ACTIVE_AUDIO_NODE_STORE.has(audioNode)) {\n        throw new Error('The AudioNode is already stored.');\n      }\n      ACTIVE_AUDIO_NODE_STORE.add(audioNode);\n      getEventListenersOfAudioNode(audioNode).forEach(function (eventListener) {\n        return eventListener(true);\n      });\n    };\n\n    var isAudioWorkletNode = function isAudioWorkletNode(audioNode) {\n      return 'port' in audioNode;\n    };\n\n    var setInternalStateToPassive = function setInternalStateToPassive(audioNode) {\n      if (!ACTIVE_AUDIO_NODE_STORE.has(audioNode)) {\n        throw new Error('The AudioNode is not stored.');\n      }\n      ACTIVE_AUDIO_NODE_STORE[\"delete\"](audioNode);\n      getEventListenersOfAudioNode(audioNode).forEach(function (eventListener) {\n        return eventListener(false);\n      });\n    };\n\n    // Set the internalState of the audioNode to 'passive' if it is not an AudioWorkletNode and if it has no 'active' input connections.\n    var setInternalStateToPassiveWhenNecessary = function setInternalStateToPassiveWhenNecessary(audioNode, activeInputs) {\n      if (!isAudioWorkletNode(audioNode) && activeInputs.every(function (connections) {\n        return connections.size === 0;\n      })) {\n        setInternalStateToPassive(audioNode);\n      }\n    };\n\n    var createAddConnectionToAudioNode = function createAddConnectionToAudioNode(addActiveInputConnectionToAudioNode, addPassiveInputConnectionToAudioNode, connectNativeAudioNodeToNativeAudioNode, deleteActiveInputConnectionToAudioNode, disconnectNativeAudioNodeFromNativeAudioNode, getAudioNodeConnections, getAudioNodeTailTime, getEventListenersOfAudioNode, getNativeAudioNode, insertElementInSet, isActiveAudioNode, isPartOfACycle, isPassiveAudioNode) {\n      var tailTimeTimeoutIds = new WeakMap();\n      return function (source, destination, output, input, isOffline) {\n        var _getAudioNodeConnecti = getAudioNodeConnections(destination),\n          activeInputs = _getAudioNodeConnecti.activeInputs,\n          passiveInputs = _getAudioNodeConnecti.passiveInputs;\n        var _getAudioNodeConnecti2 = getAudioNodeConnections(source),\n          outputs = _getAudioNodeConnecti2.outputs;\n        var eventListeners = getEventListenersOfAudioNode(source);\n        var eventListener = function eventListener(isActive) {\n          var nativeDestinationAudioNode = getNativeAudioNode(destination);\n          var nativeSourceAudioNode = getNativeAudioNode(source);\n          if (isActive) {\n            var partialConnection = deletePassiveInputConnectionToAudioNode(passiveInputs, source, output, input);\n            addActiveInputConnectionToAudioNode(activeInputs, source, partialConnection, false);\n            if (!isOffline && !isPartOfACycle(source)) {\n              connectNativeAudioNodeToNativeAudioNode(nativeSourceAudioNode, nativeDestinationAudioNode, output, input);\n            }\n            if (isPassiveAudioNode(destination)) {\n              setInternalStateToActive(destination);\n            }\n          } else {\n            var _partialConnection = deleteActiveInputConnectionToAudioNode(activeInputs, source, output, input);\n            addPassiveInputConnectionToAudioNode(passiveInputs, input, _partialConnection, false);\n            if (!isOffline && !isPartOfACycle(source)) {\n              disconnectNativeAudioNodeFromNativeAudioNode(nativeSourceAudioNode, nativeDestinationAudioNode, output, input);\n            }\n            var tailTime = getAudioNodeTailTime(destination);\n            if (tailTime === 0) {\n              if (isActiveAudioNode(destination)) {\n                setInternalStateToPassiveWhenNecessary(destination, activeInputs);\n              }\n            } else {\n              var tailTimeTimeoutId = tailTimeTimeoutIds.get(destination);\n              if (tailTimeTimeoutId !== undefined) {\n                clearTimeout(tailTimeTimeoutId);\n              }\n              tailTimeTimeoutIds.set(destination, setTimeout(function () {\n                if (isActiveAudioNode(destination)) {\n                  setInternalStateToPassiveWhenNecessary(destination, activeInputs);\n                }\n              }, tailTime * 1000));\n            }\n          }\n        };\n        if (insertElementInSet(outputs, [destination, output, input], function (outputConnection) {\n          return outputConnection[0] === destination && outputConnection[1] === output && outputConnection[2] === input;\n        }, true)) {\n          eventListeners.add(eventListener);\n          if (isActiveAudioNode(source)) {\n            addActiveInputConnectionToAudioNode(activeInputs, source, [output, input, eventListener], true);\n          } else {\n            addPassiveInputConnectionToAudioNode(passiveInputs, input, [source, output, eventListener], true);\n          }\n          return true;\n        }\n        return false;\n      };\n    };\n\n    var createAddPassiveInputConnectionToAudioNode = function createAddPassiveInputConnectionToAudioNode(insertElementInSet) {\n      return function (passiveInputs, input, _ref, ignoreDuplicates) {\n        var _ref2 = _slicedToArray(_ref, 3),\n          source = _ref2[0],\n          output = _ref2[1],\n          eventListener = _ref2[2];\n        var passiveInputConnections = passiveInputs.get(source);\n        if (passiveInputConnections === undefined) {\n          passiveInputs.set(source, new Set([[output, input, eventListener]]));\n        } else {\n          insertElementInSet(passiveInputConnections, [output, input, eventListener], function (passiveInputConnection) {\n            return passiveInputConnection[0] === output && passiveInputConnection[1] === input;\n          }, ignoreDuplicates);\n        }\n      };\n    };\n\n    var createAddSilentConnection = function createAddSilentConnection(createNativeGainNode) {\n      return function (nativeContext, nativeAudioScheduledSourceNode) {\n        var nativeGainNode = createNativeGainNode(nativeContext, {\n          channelCount: 1,\n          channelCountMode: 'explicit',\n          channelInterpretation: 'discrete',\n          gain: 0\n        });\n        nativeAudioScheduledSourceNode.connect(nativeGainNode).connect(nativeContext.destination);\n        var _disconnect = function disconnect() {\n          nativeAudioScheduledSourceNode.removeEventListener('ended', _disconnect);\n          nativeAudioScheduledSourceNode.disconnect(nativeGainNode);\n          nativeGainNode.disconnect();\n        };\n        nativeAudioScheduledSourceNode.addEventListener('ended', _disconnect);\n      };\n    };\n\n    var createAddUnrenderedAudioWorkletNode = function createAddUnrenderedAudioWorkletNode(getUnrenderedAudioWorkletNodes) {\n      return function (nativeContext, audioWorkletNode) {\n        getUnrenderedAudioWorkletNodes(nativeContext).add(audioWorkletNode);\n      };\n    };\n\n    function ownKeys$w(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\n    function _objectSpread$w(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$w(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$w(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n    function _callSuper$r(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$r() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\n    function _isNativeReflectConstruct$r() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$r = function _isNativeReflectConstruct() { return !!t; })(); }\n    var DEFAULT_OPTIONS$k = {\n      channelCount: 2,\n      channelCountMode: 'max',\n      channelInterpretation: 'speakers',\n      fftSize: 2048,\n      maxDecibels: -30,\n      minDecibels: -100,\n      smoothingTimeConstant: 0.8\n    };\n    var createAnalyserNodeConstructor = function createAnalyserNodeConstructor(audionNodeConstructor, createAnalyserNodeRenderer, createIndexSizeError, createNativeAnalyserNode, getNativeContext, isNativeOfflineAudioContext) {\n      return /*#__PURE__*/function (_audionNodeConstructo) {\n        function AnalyserNode(context, options) {\n          var _this;\n          _classCallCheck(this, AnalyserNode);\n          var nativeContext = getNativeContext(context);\n          var mergedOptions = _objectSpread$w(_objectSpread$w({}, DEFAULT_OPTIONS$k), options);\n          var nativeAnalyserNode = createNativeAnalyserNode(nativeContext, mergedOptions);\n          var analyserNodeRenderer = isNativeOfflineAudioContext(nativeContext) ? createAnalyserNodeRenderer() : null;\n          _this = _callSuper$r(this, AnalyserNode, [context, false, nativeAnalyserNode, analyserNodeRenderer]);\n          _this._nativeAnalyserNode = nativeAnalyserNode;\n          return _this;\n        }\n        _inherits(AnalyserNode, _audionNodeConstructo);\n        return _createClass(AnalyserNode, [{\n          key: \"fftSize\",\n          get: function get() {\n            return this._nativeAnalyserNode.fftSize;\n          },\n          set: function set(value) {\n            this._nativeAnalyserNode.fftSize = value;\n          }\n        }, {\n          key: \"frequencyBinCount\",\n          get: function get() {\n            return this._nativeAnalyserNode.frequencyBinCount;\n          }\n        }, {\n          key: \"maxDecibels\",\n          get: function get() {\n            return this._nativeAnalyserNode.maxDecibels;\n          },\n          set: function set(value) {\n            // Bug #118: Safari does not throw an error if maxDecibels is not more than minDecibels.\n            var maxDecibels = this._nativeAnalyserNode.maxDecibels;\n            this._nativeAnalyserNode.maxDecibels = value;\n            if (!(value > this._nativeAnalyserNode.minDecibels)) {\n              this._nativeAnalyserNode.maxDecibels = maxDecibels;\n              throw createIndexSizeError();\n            }\n          }\n        }, {\n          key: \"minDecibels\",\n          get: function get() {\n            return this._nativeAnalyserNode.minDecibels;\n          },\n          set: function set(value) {\n            // Bug #118: Safari does not throw an error if maxDecibels is not more than minDecibels.\n            var minDecibels = this._nativeAnalyserNode.minDecibels;\n            this._nativeAnalyserNode.minDecibels = value;\n            if (!(this._nativeAnalyserNode.maxDecibels > value)) {\n              this._nativeAnalyserNode.minDecibels = minDecibels;\n              throw createIndexSizeError();\n            }\n          }\n        }, {\n          key: \"smoothingTimeConstant\",\n          get: function get() {\n            return this._nativeAnalyserNode.smoothingTimeConstant;\n          },\n          set: function set(value) {\n            this._nativeAnalyserNode.smoothingTimeConstant = value;\n          }\n        }, {\n          key: \"getByteFrequencyData\",\n          value: function getByteFrequencyData(array) {\n            this._nativeAnalyserNode.getByteFrequencyData(array);\n          }\n        }, {\n          key: \"getByteTimeDomainData\",\n          value: function getByteTimeDomainData(array) {\n            this._nativeAnalyserNode.getByteTimeDomainData(array);\n          }\n        }, {\n          key: \"getFloatFrequencyData\",\n          value: function getFloatFrequencyData(array) {\n            this._nativeAnalyserNode.getFloatFrequencyData(array);\n          }\n        }, {\n          key: \"getFloatTimeDomainData\",\n          value: function getFloatTimeDomainData(array) {\n            this._nativeAnalyserNode.getFloatTimeDomainData(array);\n          }\n        }]);\n      }(audionNodeConstructor);\n    };\n\n    var isOwnedByContext = function isOwnedByContext(nativeAudioNode, nativeContext) {\n      return nativeAudioNode.context === nativeContext;\n    };\n\n    var createAnalyserNodeRendererFactory = function createAnalyserNodeRendererFactory(createNativeAnalyserNode, getNativeAudioNode, renderInputsOfAudioNode) {\n      return function () {\n        var renderedNativeAnalyserNodes = new WeakMap();\n        var createAnalyserNode = /*#__PURE__*/function () {\n          var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(proxy, nativeOfflineAudioContext) {\n            var nativeAnalyserNode, nativeAnalyserNodeIsOwnedByContext, options;\n            return _regeneratorRuntime.wrap(function _callee$(_context) {\n              while (1) switch (_context.prev = _context.next) {\n                case 0:\n                  nativeAnalyserNode = getNativeAudioNode(proxy); // If the initially used nativeAnalyserNode was not constructed on the same OfflineAudioContext it needs to be created again.\n                  nativeAnalyserNodeIsOwnedByContext = isOwnedByContext(nativeAnalyserNode, nativeOfflineAudioContext);\n                  if (!nativeAnalyserNodeIsOwnedByContext) {\n                    options = {\n                      channelCount: nativeAnalyserNode.channelCount,\n                      channelCountMode: nativeAnalyserNode.channelCountMode,\n                      channelInterpretation: nativeAnalyserNode.channelInterpretation,\n                      fftSize: nativeAnalyserNode.fftSize,\n                      maxDecibels: nativeAnalyserNode.maxDecibels,\n                      minDecibels: nativeAnalyserNode.minDecibels,\n                      smoothingTimeConstant: nativeAnalyserNode.smoothingTimeConstant\n                    };\n                    nativeAnalyserNode = createNativeAnalyserNode(nativeOfflineAudioContext, options);\n                  }\n                  renderedNativeAnalyserNodes.set(nativeOfflineAudioContext, nativeAnalyserNode);\n                  _context.next = 6;\n                  return renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAnalyserNode);\n                case 6:\n                  return _context.abrupt(\"return\", nativeAnalyserNode);\n                case 7:\n                case \"end\":\n                  return _context.stop();\n              }\n            }, _callee);\n          }));\n          return function createAnalyserNode(_x, _x2) {\n            return _ref.apply(this, arguments);\n          };\n        }();\n        return {\n          render: function render(proxy, nativeOfflineAudioContext) {\n            var renderedNativeAnalyserNode = renderedNativeAnalyserNodes.get(nativeOfflineAudioContext);\n            if (renderedNativeAnalyserNode !== undefined) {\n              return Promise.resolve(renderedNativeAnalyserNode);\n            }\n            return createAnalyserNode(proxy, nativeOfflineAudioContext);\n          }\n        };\n      };\n    };\n\n    var testAudioBufferCopyChannelMethodsOutOfBoundsSupport = function testAudioBufferCopyChannelMethodsOutOfBoundsSupport(nativeAudioBuffer) {\n      try {\n        nativeAudioBuffer.copyToChannel(new Float32Array(1), 0, -1);\n      } catch (_unused) {\n        return false;\n      }\n      return true;\n    };\n\n    var createIndexSizeError = function createIndexSizeError() {\n      return new DOMException('', 'IndexSizeError');\n    };\n\n    var wrapAudioBufferGetChannelDataMethod = function wrapAudioBufferGetChannelDataMethod(audioBuffer) {\n      audioBuffer.getChannelData = function (getChannelData) {\n        return function (channel) {\n          try {\n            return getChannelData.call(audioBuffer, channel);\n          } catch (err) {\n            if (err.code === 12) {\n              throw createIndexSizeError();\n            }\n            throw err;\n          }\n        };\n      }(audioBuffer.getChannelData);\n    };\n\n    function ownKeys$v(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\n    function _objectSpread$v(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$v(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$v(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n    var DEFAULT_OPTIONS$j = {\n      numberOfChannels: 1\n    };\n    var createAudioBufferConstructor = function createAudioBufferConstructor(audioBufferStore, cacheTestResult, createNotSupportedError, nativeAudioBufferConstructor, nativeOfflineAudioContextConstructor, testNativeAudioBufferConstructorSupport, wrapAudioBufferCopyChannelMethods, wrapAudioBufferCopyChannelMethodsOutOfBounds) {\n      var nativeOfflineAudioContext = null;\n      return /*#__PURE__*/function () {\n        function AudioBuffer(options) {\n          _classCallCheck(this, AudioBuffer);\n          if (nativeOfflineAudioContextConstructor === null) {\n            throw new Error('Missing the native OfflineAudioContext constructor.');\n          }\n          var _DEFAULT_OPTIONS$opti = _objectSpread$v(_objectSpread$v({}, DEFAULT_OPTIONS$j), options),\n            length = _DEFAULT_OPTIONS$opti.length,\n            numberOfChannels = _DEFAULT_OPTIONS$opti.numberOfChannels,\n            sampleRate = _DEFAULT_OPTIONS$opti.sampleRate;\n          if (nativeOfflineAudioContext === null) {\n            nativeOfflineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n          }\n          /*\n           * Bug #99: Firefox does not throw a NotSupportedError when the numberOfChannels is zero. But it only does it when using the\n           * factory function. But since Firefox also supports the constructor everything should be fine.\n           */\n          var audioBuffer = nativeAudioBufferConstructor !== null && cacheTestResult(testNativeAudioBufferConstructorSupport, testNativeAudioBufferConstructorSupport) ? new nativeAudioBufferConstructor({\n            length: length,\n            numberOfChannels: numberOfChannels,\n            sampleRate: sampleRate\n          }) : nativeOfflineAudioContext.createBuffer(numberOfChannels, length, sampleRate);\n          // Bug #99: Safari does not throw an error when the numberOfChannels is zero.\n          if (audioBuffer.numberOfChannels === 0) {\n            throw createNotSupportedError();\n          }\n          // Bug #5: Safari does not support copyFromChannel() and copyToChannel().\n          // Bug #100: Safari does throw a wrong error when calling getChannelData() with an out-of-bounds value.\n          if (typeof audioBuffer.copyFromChannel !== 'function') {\n            wrapAudioBufferCopyChannelMethods(audioBuffer);\n            wrapAudioBufferGetChannelDataMethod(audioBuffer);\n            // Bug #157: Firefox does not allow the bufferOffset to be out-of-bounds.\n          } else if (!cacheTestResult(testAudioBufferCopyChannelMethodsOutOfBoundsSupport, function () {\n            return testAudioBufferCopyChannelMethodsOutOfBoundsSupport(audioBuffer);\n          })) {\n            wrapAudioBufferCopyChannelMethodsOutOfBounds(audioBuffer);\n          }\n          audioBufferStore.add(audioBuffer);\n          /*\n           * This does violate all good pratices but it is necessary to allow this AudioBuffer to be used with native\n           * (Offline)AudioContexts.\n           */\n          return audioBuffer;\n        }\n        return _createClass(AudioBuffer, null, [{\n          key: Symbol.hasInstance,\n          value: function value(instance) {\n            return instance !== null && _typeof(instance) === 'object' && Object.getPrototypeOf(instance) === AudioBuffer.prototype || audioBufferStore.has(instance);\n          }\n        }]);\n      }();\n    };\n\n    var MOST_NEGATIVE_SINGLE_FLOAT = -3.4028234663852886e38;\n    var MOST_POSITIVE_SINGLE_FLOAT = -MOST_NEGATIVE_SINGLE_FLOAT;\n\n    var isActiveAudioNode = function isActiveAudioNode(audioNode) {\n      return ACTIVE_AUDIO_NODE_STORE.has(audioNode);\n    };\n\n    function ownKeys$u(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\n    function _objectSpread$u(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$u(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$u(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n    function _callSuper$q(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$q() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\n    function _isNativeReflectConstruct$q() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$q = function _isNativeReflectConstruct() { return !!t; })(); }\n    var DEFAULT_OPTIONS$i = {\n      buffer: null,\n      channelCount: 2,\n      channelCountMode: 'max',\n      channelInterpretation: 'speakers',\n      // Bug #149: Safari does not yet support the detune AudioParam.\n      loop: false,\n      loopEnd: 0,\n      loopStart: 0,\n      playbackRate: 1\n    };\n    var createAudioBufferSourceNodeConstructor = function createAudioBufferSourceNodeConstructor(audioNodeConstructor, createAudioBufferSourceNodeRenderer, createAudioParam, createInvalidStateError, createNativeAudioBufferSourceNode, getNativeContext, isNativeOfflineAudioContext, wrapEventListener) {\n      return /*#__PURE__*/function (_audioNodeConstructor) {\n        function AudioBufferSourceNode(context, options) {\n          var _this;\n          _classCallCheck(this, AudioBufferSourceNode);\n          var nativeContext = getNativeContext(context);\n          var mergedOptions = _objectSpread$u(_objectSpread$u({}, DEFAULT_OPTIONS$i), options);\n          var nativeAudioBufferSourceNode = createNativeAudioBufferSourceNode(nativeContext, mergedOptions);\n          var isOffline = isNativeOfflineAudioContext(nativeContext);\n          var audioBufferSourceNodeRenderer = isOffline ? createAudioBufferSourceNodeRenderer() : null;\n          _this = _callSuper$q(this, AudioBufferSourceNode, [context, false, nativeAudioBufferSourceNode, audioBufferSourceNodeRenderer]);\n          _this._audioBufferSourceNodeRenderer = audioBufferSourceNodeRenderer;\n          _this._isBufferNullified = false;\n          _this._isBufferSet = mergedOptions.buffer !== null;\n          _this._nativeAudioBufferSourceNode = nativeAudioBufferSourceNode;\n          _this._onended = null;\n          // Bug #73: Safari does not export the correct values for maxValue and minValue.\n          _this._playbackRate = createAudioParam(_this, isOffline, nativeAudioBufferSourceNode.playbackRate, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n          return _this;\n        }\n        _inherits(AudioBufferSourceNode, _audioNodeConstructor);\n        return _createClass(AudioBufferSourceNode, [{\n          key: \"buffer\",\n          get: function get() {\n            if (this._isBufferNullified) {\n              return null;\n            }\n            return this._nativeAudioBufferSourceNode.buffer;\n          },\n          set: function set(value) {\n            this._nativeAudioBufferSourceNode.buffer = value;\n            // Bug #72: Only Chrome & Edge do not allow to reassign the buffer yet.\n            if (value !== null) {\n              if (this._isBufferSet) {\n                throw createInvalidStateError();\n              }\n              this._isBufferSet = true;\n            }\n          }\n        }, {\n          key: \"loop\",\n          get: function get() {\n            return this._nativeAudioBufferSourceNode.loop;\n          },\n          set: function set(value) {\n            this._nativeAudioBufferSourceNode.loop = value;\n          }\n        }, {\n          key: \"loopEnd\",\n          get: function get() {\n            return this._nativeAudioBufferSourceNode.loopEnd;\n          },\n          set: function set(value) {\n            this._nativeAudioBufferSourceNode.loopEnd = value;\n          }\n        }, {\n          key: \"loopStart\",\n          get: function get() {\n            return this._nativeAudioBufferSourceNode.loopStart;\n          },\n          set: function set(value) {\n            this._nativeAudioBufferSourceNode.loopStart = value;\n          }\n        }, {\n          key: \"onended\",\n          get: function get() {\n            return this._onended;\n          },\n          set: function set(value) {\n            var wrappedListener = typeof value === 'function' ? wrapEventListener(this, value) : null;\n            this._nativeAudioBufferSourceNode.onended = wrappedListener;\n            var nativeOnEnded = this._nativeAudioBufferSourceNode.onended;\n            this._onended = nativeOnEnded !== null && nativeOnEnded === wrappedListener ? value : nativeOnEnded;\n          }\n        }, {\n          key: \"playbackRate\",\n          get: function get() {\n            return this._playbackRate;\n          }\n        }, {\n          key: \"start\",\n          value: function start() {\n            var _this2 = this;\n            var when = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n            var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n            var duration = arguments.length > 2 ? arguments[2] : undefined;\n            this._nativeAudioBufferSourceNode.start(when, offset, duration);\n            if (this._audioBufferSourceNodeRenderer !== null) {\n              this._audioBufferSourceNodeRenderer.start = duration === undefined ? [when, offset] : [when, offset, duration];\n            }\n            if (this.context.state !== 'closed') {\n              setInternalStateToActive(this);\n              var _resetInternalStateToPassive = function resetInternalStateToPassive() {\n                _this2._nativeAudioBufferSourceNode.removeEventListener('ended', _resetInternalStateToPassive);\n                if (isActiveAudioNode(_this2)) {\n                  setInternalStateToPassive(_this2);\n                }\n              };\n              this._nativeAudioBufferSourceNode.addEventListener('ended', _resetInternalStateToPassive);\n            }\n          }\n        }, {\n          key: \"stop\",\n          value: function stop() {\n            var when = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n            this._nativeAudioBufferSourceNode.stop(when);\n            if (this._audioBufferSourceNodeRenderer !== null) {\n              this._audioBufferSourceNodeRenderer.stop = when;\n            }\n          }\n        }]);\n      }(audioNodeConstructor);\n    };\n\n    var createAudioBufferSourceNodeRendererFactory = function createAudioBufferSourceNodeRendererFactory(connectAudioParam, createNativeAudioBufferSourceNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode) {\n      return function () {\n        var renderedNativeAudioBufferSourceNodes = new WeakMap();\n        var start = null;\n        var stop = null;\n        var createAudioBufferSourceNode = /*#__PURE__*/function () {\n          var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(proxy, nativeOfflineAudioContext) {\n            var nativeAudioBufferSourceNode, nativeAudioBufferSourceNodeIsOwnedByContext, options, _nativeAudioBufferSou;\n            return _regeneratorRuntime.wrap(function _callee$(_context) {\n              while (1) switch (_context.prev = _context.next) {\n                case 0:\n                  nativeAudioBufferSourceNode = getNativeAudioNode(proxy);\n                  /*\n                   * If the initially used nativeAudioBufferSourceNode was not constructed on the same OfflineAudioContext it needs to be created\n                   * again.\n                   */\n                  nativeAudioBufferSourceNodeIsOwnedByContext = isOwnedByContext(nativeAudioBufferSourceNode, nativeOfflineAudioContext);\n                  if (!nativeAudioBufferSourceNodeIsOwnedByContext) {\n                    options = {\n                      buffer: nativeAudioBufferSourceNode.buffer,\n                      channelCount: nativeAudioBufferSourceNode.channelCount,\n                      channelCountMode: nativeAudioBufferSourceNode.channelCountMode,\n                      channelInterpretation: nativeAudioBufferSourceNode.channelInterpretation,\n                      // Bug #149: Safari does not yet support the detune AudioParam.\n                      loop: nativeAudioBufferSourceNode.loop,\n                      loopEnd: nativeAudioBufferSourceNode.loopEnd,\n                      loopStart: nativeAudioBufferSourceNode.loopStart,\n                      playbackRate: nativeAudioBufferSourceNode.playbackRate.value\n                    };\n                    nativeAudioBufferSourceNode = createNativeAudioBufferSourceNode(nativeOfflineAudioContext, options);\n                    if (start !== null) {\n                      (_nativeAudioBufferSou = nativeAudioBufferSourceNode).start.apply(_nativeAudioBufferSou, _toConsumableArray(start));\n                    }\n                    if (stop !== null) {\n                      nativeAudioBufferSourceNode.stop(stop);\n                    }\n                  }\n                  renderedNativeAudioBufferSourceNodes.set(nativeOfflineAudioContext, nativeAudioBufferSourceNode);\n                  if (nativeAudioBufferSourceNodeIsOwnedByContext) {\n                    _context.next = 9;\n                    break;\n                  }\n                  _context.next = 7;\n                  return renderAutomation(nativeOfflineAudioContext, proxy.playbackRate, nativeAudioBufferSourceNode.playbackRate);\n                case 7:\n                  _context.next = 11;\n                  break;\n                case 9:\n                  _context.next = 11;\n                  return connectAudioParam(nativeOfflineAudioContext, proxy.playbackRate, nativeAudioBufferSourceNode.playbackRate);\n                case 11:\n                  _context.next = 13;\n                  return renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioBufferSourceNode);\n                case 13:\n                  return _context.abrupt(\"return\", nativeAudioBufferSourceNode);\n                case 14:\n                case \"end\":\n                  return _context.stop();\n              }\n            }, _callee);\n          }));\n          return function createAudioBufferSourceNode(_x, _x2) {\n            return _ref.apply(this, arguments);\n          };\n        }();\n        return {\n          set start(value) {\n            start = value;\n          },\n          set stop(value) {\n            stop = value;\n          },\n          render: function render(proxy, nativeOfflineAudioContext) {\n            var renderedNativeAudioBufferSourceNode = renderedNativeAudioBufferSourceNodes.get(nativeOfflineAudioContext);\n            if (renderedNativeAudioBufferSourceNode !== undefined) {\n              return Promise.resolve(renderedNativeAudioBufferSourceNode);\n            }\n            return createAudioBufferSourceNode(proxy, nativeOfflineAudioContext);\n          }\n        };\n      };\n    };\n\n    var isAudioBufferSourceNode = function isAudioBufferSourceNode(audioNode) {\n      return 'playbackRate' in audioNode;\n    };\n\n    var isBiquadFilterNode = function isBiquadFilterNode(audioNode) {\n      return 'frequency' in audioNode && 'gain' in audioNode;\n    };\n\n    var isConstantSourceNode = function isConstantSourceNode(audioNode) {\n      return 'offset' in audioNode;\n    };\n\n    var isGainNode = function isGainNode(audioNode) {\n      return !('frequency' in audioNode) && 'gain' in audioNode;\n    };\n\n    var isOscillatorNode = function isOscillatorNode(audioNode) {\n      return 'detune' in audioNode && 'frequency' in audioNode && !('gain' in audioNode);\n    };\n\n    var isStereoPannerNode = function isStereoPannerNode(audioNode) {\n      return 'pan' in audioNode;\n    };\n\n    var getAudioNodeConnections = function getAudioNodeConnections(audioNode) {\n      return getValueForKey(AUDIO_NODE_CONNECTIONS_STORE, audioNode);\n    };\n\n    var getAudioParamConnections = function getAudioParamConnections(audioParam) {\n      return getValueForKey(AUDIO_PARAM_CONNECTIONS_STORE, audioParam);\n    };\n\n    function _createForOfIteratorHelper$b(r, e) { var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray$b(r)) || e) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t[\"return\"] || t[\"return\"](); } finally { if (u) throw o; } } }; }\n    function _unsupportedIterableToArray$b(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray$b(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$b(r, a) : void 0; } }\n    function _arrayLikeToArray$b(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\n    var _deactivateActiveAudioNodeInputConnections = function deactivateActiveAudioNodeInputConnections(audioNode, trace) {\n      var _getAudioNodeConnecti = getAudioNodeConnections(audioNode),\n        activeInputs = _getAudioNodeConnecti.activeInputs;\n      activeInputs.forEach(function (connections) {\n        return connections.forEach(function (_ref) {\n          var _ref2 = _slicedToArray(_ref, 1),\n            source = _ref2[0];\n          if (!trace.includes(audioNode)) {\n            _deactivateActiveAudioNodeInputConnections(source, [].concat(_toConsumableArray(trace), [audioNode]));\n          }\n        });\n      });\n      var audioParams = isAudioBufferSourceNode(audioNode) ? [\n      // Bug #149: Safari does not yet support the detune AudioParam.\n      audioNode.playbackRate] : isAudioWorkletNode(audioNode) ? Array.from(audioNode.parameters.values()) : isBiquadFilterNode(audioNode) ? [audioNode.Q, audioNode.detune, audioNode.frequency, audioNode.gain] : isConstantSourceNode(audioNode) ? [audioNode.offset] : isGainNode(audioNode) ? [audioNode.gain] : isOscillatorNode(audioNode) ? [audioNode.detune, audioNode.frequency] : isStereoPannerNode(audioNode) ? [audioNode.pan] : [];\n      var _iterator = _createForOfIteratorHelper$b(audioParams),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var audioParam = _step.value;\n          var audioParamConnections = getAudioParamConnections(audioParam);\n          if (audioParamConnections !== undefined) {\n            audioParamConnections.activeInputs.forEach(function (_ref3) {\n              var _ref4 = _slicedToArray(_ref3, 1),\n                source = _ref4[0];\n              return _deactivateActiveAudioNodeInputConnections(source, trace);\n            });\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      if (isActiveAudioNode(audioNode)) {\n        setInternalStateToPassive(audioNode);\n      }\n    };\n\n    var deactivateAudioGraph = function deactivateAudioGraph(context) {\n      _deactivateActiveAudioNodeInputConnections(context.destination, []);\n    };\n\n    var isValidLatencyHint = function isValidLatencyHint(latencyHint) {\n      return latencyHint === undefined || typeof latencyHint === 'number' || typeof latencyHint === 'string' && (latencyHint === 'balanced' || latencyHint === 'interactive' || latencyHint === 'playback');\n    };\n\n    function _callSuper$p(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$p() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\n    function _isNativeReflectConstruct$p() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$p = function _isNativeReflectConstruct() { return !!t; })(); }\n    var createAudioContextConstructor = function createAudioContextConstructor(baseAudioContextConstructor, createInvalidStateError, createNotSupportedError, createUnknownError, mediaElementAudioSourceNodeConstructor, mediaStreamAudioDestinationNodeConstructor, mediaStreamAudioSourceNodeConstructor, mediaStreamTrackAudioSourceNodeConstructor, nativeAudioContextConstructor) {\n      return /*#__PURE__*/function (_baseAudioContextCons) {\n        function AudioContext() {\n          var _this;\n          var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n          _classCallCheck(this, AudioContext);\n          if (nativeAudioContextConstructor === null) {\n            throw new Error('Missing the native AudioContext constructor.');\n          }\n          var nativeAudioContext;\n          try {\n            nativeAudioContext = new nativeAudioContextConstructor(options);\n          } catch (err) {\n            // Bug #192 Safari does throw a SyntaxError if the sampleRate is not supported.\n            if (err.code === 12 && err.message === 'sampleRate is not in range') {\n              throw createNotSupportedError();\n            }\n            throw err;\n          }\n          // Bug #131 Safari returns null when there are four other AudioContexts running already.\n          if (nativeAudioContext === null) {\n            throw createUnknownError();\n          }\n          // Bug #51 Only Chrome and Edge throw an error if the given latencyHint is invalid.\n          if (!isValidLatencyHint(options.latencyHint)) {\n            throw new TypeError(\"The provided value '\".concat(options.latencyHint, \"' is not a valid enum value of type AudioContextLatencyCategory.\"));\n          }\n          // Bug #150 Safari does not support setting the sampleRate.\n          if (options.sampleRate !== undefined && nativeAudioContext.sampleRate !== options.sampleRate) {\n            throw createNotSupportedError();\n          }\n          _this = _callSuper$p(this, AudioContext, [nativeAudioContext, 2]);\n          var latencyHint = options.latencyHint;\n          var _nativeAudioContext = nativeAudioContext,\n            sampleRate = _nativeAudioContext.sampleRate;\n          // @todo The values for 'balanced', 'interactive' and 'playback' are just copied from Chrome's implementation.\n          _this._baseLatency = typeof nativeAudioContext.baseLatency === 'number' ? nativeAudioContext.baseLatency : latencyHint === 'balanced' ? 512 / sampleRate : latencyHint === 'interactive' || latencyHint === undefined ? 256 / sampleRate : latencyHint === 'playback' ? 1024 / sampleRate :\n          /*\n           * @todo The min (256) and max (16384) values are taken from the allowed bufferSize values of a\n           * ScriptProcessorNode.\n           */\n          Math.max(2, Math.min(128, Math.round(latencyHint * sampleRate / 128))) * 128 / sampleRate;\n          _this._nativeAudioContext = nativeAudioContext;\n          // Bug #188: Safari will set the context's state to 'interrupted' in case the user switches tabs.\n          if (nativeAudioContextConstructor.name === 'webkitAudioContext') {\n            _this._nativeGainNode = nativeAudioContext.createGain();\n            _this._nativeOscillatorNode = nativeAudioContext.createOscillator();\n            _this._nativeGainNode.gain.value = 1e-37;\n            _this._nativeOscillatorNode.connect(_this._nativeGainNode).connect(nativeAudioContext.destination);\n            _this._nativeOscillatorNode.start();\n          } else {\n            _this._nativeGainNode = null;\n            _this._nativeOscillatorNode = null;\n          }\n          _this._state = null;\n          /*\n           * Bug #34: Chrome and Edge pretend to be running right away, but fire an onstatechange event when the state actually changes\n           * to 'running'.\n           */\n          if (nativeAudioContext.state === 'running') {\n            _this._state = 'suspended';\n            var _revokeState = function revokeState() {\n              if (_this._state === 'suspended') {\n                _this._state = null;\n              }\n              nativeAudioContext.removeEventListener('statechange', _revokeState);\n            };\n            nativeAudioContext.addEventListener('statechange', _revokeState);\n          }\n          return _this;\n        }\n        _inherits(AudioContext, _baseAudioContextCons);\n        return _createClass(AudioContext, [{\n          key: \"baseLatency\",\n          get: function get() {\n            return this._baseLatency;\n          }\n        }, {\n          key: \"state\",\n          get: function get() {\n            return this._state !== null ? this._state : this._nativeAudioContext.state;\n          }\n        }, {\n          key: \"close\",\n          value: function close() {\n            var _this2 = this;\n            // Bug #35: Firefox does not throw an error if the AudioContext was closed before.\n            if (this.state === 'closed') {\n              return this._nativeAudioContext.close().then(function () {\n                throw createInvalidStateError();\n              });\n            }\n            // Bug #34: If the state was set to suspended before it should be revoked now.\n            if (this._state === 'suspended') {\n              this._state = null;\n            }\n            return this._nativeAudioContext.close().then(function () {\n              if (_this2._nativeGainNode !== null && _this2._nativeOscillatorNode !== null) {\n                _this2._nativeOscillatorNode.stop();\n                _this2._nativeGainNode.disconnect();\n                _this2._nativeOscillatorNode.disconnect();\n              }\n              deactivateAudioGraph(_this2);\n            });\n          }\n        }, {\n          key: \"createMediaElementSource\",\n          value: function createMediaElementSource(mediaElement) {\n            return new mediaElementAudioSourceNodeConstructor(this, {\n              mediaElement: mediaElement\n            });\n          }\n        }, {\n          key: \"createMediaStreamDestination\",\n          value: function createMediaStreamDestination() {\n            return new mediaStreamAudioDestinationNodeConstructor(this);\n          }\n        }, {\n          key: \"createMediaStreamSource\",\n          value: function createMediaStreamSource(mediaStream) {\n            return new mediaStreamAudioSourceNodeConstructor(this, {\n              mediaStream: mediaStream\n            });\n          }\n        }, {\n          key: \"createMediaStreamTrackSource\",\n          value: function createMediaStreamTrackSource(mediaStreamTrack) {\n            return new mediaStreamTrackAudioSourceNodeConstructor(this, {\n              mediaStreamTrack: mediaStreamTrack\n            });\n          }\n        }, {\n          key: \"resume\",\n          value: function resume() {\n            var _this3 = this;\n            if (this._state === 'suspended') {\n              return new Promise(function (resolve, reject) {\n                var _resolvePromise = function resolvePromise() {\n                  _this3._nativeAudioContext.removeEventListener('statechange', _resolvePromise);\n                  if (_this3._nativeAudioContext.state === 'running') {\n                    resolve();\n                  } else {\n                    _this3.resume().then(resolve, reject);\n                  }\n                };\n                _this3._nativeAudioContext.addEventListener('statechange', _resolvePromise);\n              });\n            }\n            return this._nativeAudioContext.resume()[\"catch\"](function (err) {\n              // Bug #55: Chrome and Edge do throw an InvalidAccessError instead of an InvalidStateError.\n              // Bug #56: Safari invokes the catch handler but without an error.\n              if (err === undefined || err.code === 15) {\n                throw createInvalidStateError();\n              }\n              throw err;\n            });\n          }\n        }, {\n          key: \"suspend\",\n          value: function suspend() {\n            return this._nativeAudioContext.suspend()[\"catch\"](function (err) {\n              // Bug #56: Safari invokes the catch handler but without an error.\n              if (err === undefined) {\n                throw createInvalidStateError();\n              }\n              throw err;\n            });\n          }\n        }]);\n      }(baseAudioContextConstructor);\n    };\n\n    function _callSuper$o(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$o() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\n    function _isNativeReflectConstruct$o() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$o = function _isNativeReflectConstruct() { return !!t; })(); }\n    var createAudioDestinationNodeConstructor = function createAudioDestinationNodeConstructor(audioNodeConstructor, createAudioDestinationNodeRenderer, createIndexSizeError, createInvalidStateError, createNativeAudioDestinationNode, getNativeContext, isNativeOfflineAudioContext, renderInputsOfAudioNode) {\n      return /*#__PURE__*/function (_audioNodeConstructor) {\n        function AudioDestinationNode(context, channelCount) {\n          var _this;\n          _classCallCheck(this, AudioDestinationNode);\n          var nativeContext = getNativeContext(context);\n          var isOffline = isNativeOfflineAudioContext(nativeContext);\n          var nativeAudioDestinationNode = createNativeAudioDestinationNode(nativeContext, channelCount, isOffline);\n          var audioDestinationNodeRenderer = isOffline ? createAudioDestinationNodeRenderer(renderInputsOfAudioNode) : null;\n          _this = _callSuper$o(this, AudioDestinationNode, [context, false, nativeAudioDestinationNode, audioDestinationNodeRenderer]);\n          _this._isNodeOfNativeOfflineAudioContext = isOffline;\n          _this._nativeAudioDestinationNode = nativeAudioDestinationNode;\n          return _this;\n        }\n        _inherits(AudioDestinationNode, _audioNodeConstructor);\n        return _createClass(AudioDestinationNode, [{\n          key: \"channelCount\",\n          get: function get() {\n            return this._nativeAudioDestinationNode.channelCount;\n          },\n          set: function set(value) {\n            // Bug #52: Chrome, Edge & Safari do not throw an exception at all.\n            // Bug #54: Firefox does throw an IndexSizeError.\n            if (this._isNodeOfNativeOfflineAudioContext) {\n              throw createInvalidStateError();\n            }\n            // Bug #47: The AudioDestinationNode in Safari does not initialize the maxChannelCount property correctly.\n            if (value > this._nativeAudioDestinationNode.maxChannelCount) {\n              throw createIndexSizeError();\n            }\n            this._nativeAudioDestinationNode.channelCount = value;\n          }\n        }, {\n          key: \"channelCountMode\",\n          get: function get() {\n            return this._nativeAudioDestinationNode.channelCountMode;\n          },\n          set: function set(value) {\n            // Bug #53: No browser does throw an exception yet.\n            if (this._isNodeOfNativeOfflineAudioContext) {\n              throw createInvalidStateError();\n            }\n            this._nativeAudioDestinationNode.channelCountMode = value;\n          }\n        }, {\n          key: \"maxChannelCount\",\n          get: function get() {\n            return this._nativeAudioDestinationNode.maxChannelCount;\n          }\n        }]);\n      }(audioNodeConstructor);\n    };\n\n    var createAudioDestinationNodeRenderer = function createAudioDestinationNodeRenderer(renderInputsOfAudioNode) {\n      var renderedNativeAudioDestinationNodes = new WeakMap();\n      var createAudioDestinationNode = /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(proxy, nativeOfflineAudioContext) {\n          var nativeAudioDestinationNode;\n          return _regeneratorRuntime.wrap(function _callee$(_context) {\n            while (1) switch (_context.prev = _context.next) {\n              case 0:\n                nativeAudioDestinationNode = nativeOfflineAudioContext.destination;\n                renderedNativeAudioDestinationNodes.set(nativeOfflineAudioContext, nativeAudioDestinationNode);\n                _context.next = 4;\n                return renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioDestinationNode);\n              case 4:\n                return _context.abrupt(\"return\", nativeAudioDestinationNode);\n              case 5:\n              case \"end\":\n                return _context.stop();\n            }\n          }, _callee);\n        }));\n        return function createAudioDestinationNode(_x, _x2) {\n          return _ref.apply(this, arguments);\n        };\n      }();\n      return {\n        render: function render(proxy, nativeOfflineAudioContext) {\n          var renderedNativeAudioDestinationNode = renderedNativeAudioDestinationNodes.get(nativeOfflineAudioContext);\n          if (renderedNativeAudioDestinationNode !== undefined) {\n            return Promise.resolve(renderedNativeAudioDestinationNode);\n          }\n          return createAudioDestinationNode(proxy, nativeOfflineAudioContext);\n        }\n      };\n    };\n\n    var createAudioListenerFactory = function createAudioListenerFactory(createAudioParam, createNativeChannelMergerNode, createNativeConstantSourceNode, createNativeScriptProcessorNode, createNotSupportedError, getFirstSample, isNativeOfflineAudioContext, overwriteAccessors) {\n      return function (context, nativeContext) {\n        var nativeListener = nativeContext.listener;\n        // Bug #117: Only Chrome & Edge support the new interface already.\n        var createFakeAudioParams = function createFakeAudioParams() {\n          var buffer = new Float32Array(1);\n          var channelMergerNode = createNativeChannelMergerNode(nativeContext, {\n            channelCount: 1,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'speakers',\n            numberOfInputs: 9\n          });\n          var isOffline = isNativeOfflineAudioContext(nativeContext);\n          var isScriptProcessorNodeCreated = false;\n          var lastOrientation = [0, 0, -1, 0, 1, 0];\n          var lastPosition = [0, 0, 0];\n          var createScriptProcessorNode = function createScriptProcessorNode() {\n            if (isScriptProcessorNodeCreated) {\n              return;\n            }\n            isScriptProcessorNodeCreated = true;\n            var scriptProcessorNode = createNativeScriptProcessorNode(nativeContext, 256, 9, 0);\n            // tslint:disable-next-line:deprecation\n            scriptProcessorNode.onaudioprocess = function (_ref) {\n              var inputBuffer = _ref.inputBuffer;\n              var orientation = [getFirstSample(inputBuffer, buffer, 0), getFirstSample(inputBuffer, buffer, 1), getFirstSample(inputBuffer, buffer, 2), getFirstSample(inputBuffer, buffer, 3), getFirstSample(inputBuffer, buffer, 4), getFirstSample(inputBuffer, buffer, 5)];\n              if (orientation.some(function (value, index) {\n                return value !== lastOrientation[index];\n              })) {\n                nativeListener.setOrientation.apply(nativeListener, orientation); // tslint:disable-line:deprecation\n                lastOrientation = orientation;\n              }\n              var positon = [getFirstSample(inputBuffer, buffer, 6), getFirstSample(inputBuffer, buffer, 7), getFirstSample(inputBuffer, buffer, 8)];\n              if (positon.some(function (value, index) {\n                return value !== lastPosition[index];\n              })) {\n                nativeListener.setPosition.apply(nativeListener, positon); // tslint:disable-line:deprecation\n                lastPosition = positon;\n              }\n            };\n            channelMergerNode.connect(scriptProcessorNode);\n          };\n          var createSetOrientation = function createSetOrientation(index) {\n            return function (value) {\n              if (value !== lastOrientation[index]) {\n                lastOrientation[index] = value;\n                nativeListener.setOrientation.apply(nativeListener, _toConsumableArray(lastOrientation)); // tslint:disable-line:deprecation\n              }\n            };\n          };\n          var createSetPosition = function createSetPosition(index) {\n            return function (value) {\n              if (value !== lastPosition[index]) {\n                lastPosition[index] = value;\n                nativeListener.setPosition.apply(nativeListener, _toConsumableArray(lastPosition)); // tslint:disable-line:deprecation\n              }\n            };\n          };\n          var createFakeAudioParam = function createFakeAudioParam(input, initialValue, setValue) {\n            var constantSourceNode = createNativeConstantSourceNode(nativeContext, {\n              channelCount: 1,\n              channelCountMode: 'explicit',\n              channelInterpretation: 'discrete',\n              offset: initialValue\n            });\n            constantSourceNode.connect(channelMergerNode, 0, input);\n            // @todo This should be stopped when the context is closed.\n            constantSourceNode.start();\n            Object.defineProperty(constantSourceNode.offset, 'defaultValue', {\n              get: function get() {\n                return initialValue;\n              }\n            });\n            /*\n             * Bug #62 & #74: Safari does not support ConstantSourceNodes and does not export the correct values for maxValue and\n             * minValue for GainNodes.\n             */\n            var audioParam = createAudioParam({\n              context: context\n            }, isOffline, constantSourceNode.offset, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n            overwriteAccessors(audioParam, 'value', function (get) {\n              return function () {\n                return get.call(audioParam);\n              };\n            }, function (set) {\n              return function (value) {\n                try {\n                  set.call(audioParam, value);\n                } catch (err) {\n                  if (err.code !== 9) {\n                    throw err;\n                  }\n                }\n                createScriptProcessorNode();\n                if (isOffline) {\n                  // Bug #117: Using setOrientation() and setPosition() doesn't work with an OfflineAudioContext.\n                  setValue(value);\n                }\n              };\n            });\n            audioParam.cancelAndHoldAtTime = function (cancelAndHoldAtTime) {\n              if (isOffline) {\n                return function () {\n                  throw createNotSupportedError();\n                };\n              }\n              return function () {\n                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n                  args[_key] = arguments[_key];\n                }\n                var value = cancelAndHoldAtTime.apply(audioParam, args);\n                createScriptProcessorNode();\n                return value;\n              };\n            }(audioParam.cancelAndHoldAtTime);\n            audioParam.cancelScheduledValues = function (cancelScheduledValues) {\n              if (isOffline) {\n                return function () {\n                  throw createNotSupportedError();\n                };\n              }\n              return function () {\n                for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n                  args[_key2] = arguments[_key2];\n                }\n                var value = cancelScheduledValues.apply(audioParam, args);\n                createScriptProcessorNode();\n                return value;\n              };\n            }(audioParam.cancelScheduledValues);\n            audioParam.exponentialRampToValueAtTime = function (exponentialRampToValueAtTime) {\n              if (isOffline) {\n                return function () {\n                  throw createNotSupportedError();\n                };\n              }\n              return function () {\n                for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n                  args[_key3] = arguments[_key3];\n                }\n                var value = exponentialRampToValueAtTime.apply(audioParam, args);\n                createScriptProcessorNode();\n                return value;\n              };\n            }(audioParam.exponentialRampToValueAtTime);\n            audioParam.linearRampToValueAtTime = function (linearRampToValueAtTime) {\n              if (isOffline) {\n                return function () {\n                  throw createNotSupportedError();\n                };\n              }\n              return function () {\n                for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n                  args[_key4] = arguments[_key4];\n                }\n                var value = linearRampToValueAtTime.apply(audioParam, args);\n                createScriptProcessorNode();\n                return value;\n              };\n            }(audioParam.linearRampToValueAtTime);\n            audioParam.setTargetAtTime = function (setTargetAtTime) {\n              if (isOffline) {\n                return function () {\n                  throw createNotSupportedError();\n                };\n              }\n              return function () {\n                for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n                  args[_key5] = arguments[_key5];\n                }\n                var value = setTargetAtTime.apply(audioParam, args);\n                createScriptProcessorNode();\n                return value;\n              };\n            }(audioParam.setTargetAtTime);\n            audioParam.setValueAtTime = function (setValueAtTime) {\n              if (isOffline) {\n                return function () {\n                  throw createNotSupportedError();\n                };\n              }\n              return function () {\n                for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n                  args[_key6] = arguments[_key6];\n                }\n                var value = setValueAtTime.apply(audioParam, args);\n                createScriptProcessorNode();\n                return value;\n              };\n            }(audioParam.setValueAtTime);\n            audioParam.setValueCurveAtTime = function (setValueCurveAtTime) {\n              if (isOffline) {\n                return function () {\n                  throw createNotSupportedError();\n                };\n              }\n              return function () {\n                for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n                  args[_key7] = arguments[_key7];\n                }\n                var value = setValueCurveAtTime.apply(audioParam, args);\n                createScriptProcessorNode();\n                return value;\n              };\n            }(audioParam.setValueCurveAtTime);\n            return audioParam;\n          };\n          return {\n            forwardX: createFakeAudioParam(0, 0, createSetOrientation(0)),\n            forwardY: createFakeAudioParam(1, 0, createSetOrientation(1)),\n            forwardZ: createFakeAudioParam(2, -1, createSetOrientation(2)),\n            positionX: createFakeAudioParam(6, 0, createSetPosition(0)),\n            positionY: createFakeAudioParam(7, 0, createSetPosition(1)),\n            positionZ: createFakeAudioParam(8, 0, createSetPosition(2)),\n            upX: createFakeAudioParam(3, 0, createSetOrientation(3)),\n            upY: createFakeAudioParam(4, 1, createSetOrientation(4)),\n            upZ: createFakeAudioParam(5, 0, createSetOrientation(5))\n          };\n        };\n        var _ref2 = nativeListener.forwardX === undefined ? createFakeAudioParams() : nativeListener,\n          forwardX = _ref2.forwardX,\n          forwardY = _ref2.forwardY,\n          forwardZ = _ref2.forwardZ,\n          positionX = _ref2.positionX,\n          positionY = _ref2.positionY,\n          positionZ = _ref2.positionZ,\n          upX = _ref2.upX,\n          upY = _ref2.upY,\n          upZ = _ref2.upZ;\n        return {\n          get forwardX() {\n            return forwardX;\n          },\n          get forwardY() {\n            return forwardY;\n          },\n          get forwardZ() {\n            return forwardZ;\n          },\n          get positionX() {\n            return positionX;\n          },\n          get positionY() {\n            return positionY;\n          },\n          get positionZ() {\n            return positionZ;\n          },\n          get upX() {\n            return upX;\n          },\n          get upY() {\n            return upY;\n          },\n          get upZ() {\n            return upZ;\n          }\n        };\n      };\n    };\n\n    var isAudioNode = function isAudioNode(audioNodeOrAudioParam) {\n      return 'context' in audioNodeOrAudioParam;\n    };\n\n    var isAudioNodeOutputConnection = function isAudioNodeOutputConnection(outputConnection) {\n      return isAudioNode(outputConnection[0]);\n    };\n\n    function _createForOfIteratorHelper$a(r, e) { var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray$a(r)) || e) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t[\"return\"] || t[\"return\"](); } finally { if (u) throw o; } } }; }\n    function _unsupportedIterableToArray$a(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray$a(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$a(r, a) : void 0; } }\n    function _arrayLikeToArray$a(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\n    var insertElementInSet = function insertElementInSet(set, element, predicate, ignoreDuplicates) {\n      var _iterator = _createForOfIteratorHelper$a(set),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var lmnt = _step.value;\n          if (predicate(lmnt)) {\n            if (ignoreDuplicates) {\n              return false;\n            }\n            throw Error('The set contains at least one similar element.');\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      set.add(element);\n      return true;\n    };\n\n    var addActiveInputConnectionToAudioParam = function addActiveInputConnectionToAudioParam(activeInputs, source, _ref, ignoreDuplicates) {\n      var _ref2 = _slicedToArray(_ref, 2),\n        output = _ref2[0],\n        eventListener = _ref2[1];\n      insertElementInSet(activeInputs, [source, output, eventListener], function (activeInputConnection) {\n        return activeInputConnection[0] === source && activeInputConnection[1] === output;\n      }, ignoreDuplicates);\n    };\n\n    var addPassiveInputConnectionToAudioParam = function addPassiveInputConnectionToAudioParam(passiveInputs, _ref, ignoreDuplicates) {\n      var _ref2 = _slicedToArray(_ref, 3),\n        source = _ref2[0],\n        output = _ref2[1],\n        eventListener = _ref2[2];\n      var passiveInputConnections = passiveInputs.get(source);\n      if (passiveInputConnections === undefined) {\n        passiveInputs.set(source, new Set([[output, eventListener]]));\n      } else {\n        insertElementInSet(passiveInputConnections, [output, eventListener], function (passiveInputConnection) {\n          return passiveInputConnection[0] === output;\n        }, ignoreDuplicates);\n      }\n    };\n\n    var isNativeAudioNodeFaker = function isNativeAudioNodeFaker(nativeAudioNodeOrNativeAudioNodeFaker) {\n      return 'inputs' in nativeAudioNodeOrNativeAudioNodeFaker;\n    };\n\n    var connectNativeAudioNodeToNativeAudioNode = function connectNativeAudioNodeToNativeAudioNode(nativeSourceAudioNode, nativeDestinationAudioNode, output, input) {\n      if (isNativeAudioNodeFaker(nativeDestinationAudioNode)) {\n        var fakeNativeDestinationAudioNode = nativeDestinationAudioNode.inputs[input];\n        nativeSourceAudioNode.connect(fakeNativeDestinationAudioNode, output, 0);\n        return [fakeNativeDestinationAudioNode, output, 0];\n      }\n      nativeSourceAudioNode.connect(nativeDestinationAudioNode, output, input);\n      return [nativeDestinationAudioNode, output, input];\n    };\n\n    function _createForOfIteratorHelper$9(r, e) { var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray$9(r)) || e) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t[\"return\"] || t[\"return\"](); } finally { if (u) throw o; } } }; }\n    function _unsupportedIterableToArray$9(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray$9(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$9(r, a) : void 0; } }\n    function _arrayLikeToArray$9(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\n    var deleteActiveInputConnection = function deleteActiveInputConnection(activeInputConnections, source, output) {\n      var _iterator = _createForOfIteratorHelper$9(activeInputConnections),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var activeInputConnection = _step.value;\n          if (activeInputConnection[0] === source && activeInputConnection[1] === output) {\n            activeInputConnections[\"delete\"](activeInputConnection);\n            return activeInputConnection;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return null;\n    };\n\n    var deleteActiveInputConnectionToAudioParam = function deleteActiveInputConnectionToAudioParam(activeInputs, source, output) {\n      return pickElementFromSet(activeInputs, function (activeInputConnection) {\n        return activeInputConnection[0] === source && activeInputConnection[1] === output;\n      });\n    };\n\n    var deleteEventListenerOfAudioNode = function deleteEventListenerOfAudioNode(audioNode, eventListener) {\n      var eventListeners = getEventListenersOfAudioNode(audioNode);\n      if (!eventListeners[\"delete\"](eventListener)) {\n        throw new Error('Missing the expected event listener.');\n      }\n    };\n\n    var deletePassiveInputConnectionToAudioParam = function deletePassiveInputConnectionToAudioParam(passiveInputs, source, output) {\n      var passiveInputConnections = getValueForKey(passiveInputs, source);\n      var matchingConnection = pickElementFromSet(passiveInputConnections, function (passiveInputConnection) {\n        return passiveInputConnection[0] === output;\n      });\n      if (passiveInputConnections.size === 0) {\n        passiveInputs[\"delete\"](source);\n      }\n      return matchingConnection;\n    };\n\n    var disconnectNativeAudioNodeFromNativeAudioNode = function disconnectNativeAudioNodeFromNativeAudioNode(nativeSourceAudioNode, nativeDestinationAudioNode, output, input) {\n      if (isNativeAudioNodeFaker(nativeDestinationAudioNode)) {\n        nativeSourceAudioNode.disconnect(nativeDestinationAudioNode.inputs[input], output, 0);\n      } else {\n        nativeSourceAudioNode.disconnect(nativeDestinationAudioNode, output, input);\n      }\n    };\n\n    var getNativeAudioNode = function getNativeAudioNode(audioNode) {\n      return getValueForKey(AUDIO_NODE_STORE, audioNode);\n    };\n\n    var getNativeAudioParam = function getNativeAudioParam(audioParam) {\n      return getValueForKey(AUDIO_PARAM_STORE, audioParam);\n    };\n\n    var isPartOfACycle = function isPartOfACycle(audioNode) {\n      return CYCLE_COUNTERS.has(audioNode);\n    };\n\n    var isPassiveAudioNode = function isPassiveAudioNode(audioNode) {\n      return !ACTIVE_AUDIO_NODE_STORE.has(audioNode);\n    };\n\n    var testAudioNodeDisconnectMethodSupport = function testAudioNodeDisconnectMethodSupport(nativeAudioContext, nativeAudioWorkletNodeConstructor) {\n      return new Promise(function (resolve) {\n        /*\n         * This bug existed in Safari up until v14.0.2. Since AudioWorklets were not supported in Safari until v14.1 the presence of the\n         * constructor for an AudioWorkletNode can be used here to skip the test.\n         */\n        if (nativeAudioWorkletNodeConstructor !== null) {\n          resolve(true);\n        } else {\n          var analyzer = nativeAudioContext.createScriptProcessor(256, 1, 1); // tslint:disable-line deprecation\n          var dummy = nativeAudioContext.createGain();\n          // Bug #95: Safari does not play one sample buffers.\n          var ones = nativeAudioContext.createBuffer(1, 2, 44100);\n          var channelData = ones.getChannelData(0);\n          channelData[0] = 1;\n          channelData[1] = 1;\n          var source = nativeAudioContext.createBufferSource();\n          source.buffer = ones;\n          source.loop = true;\n          source.connect(analyzer).connect(nativeAudioContext.destination);\n          source.connect(dummy);\n          source.disconnect(dummy);\n          // tslint:disable-next-line:deprecation\n          analyzer.onaudioprocess = function (event) {\n            var chnnlDt = event.inputBuffer.getChannelData(0); // tslint:disable-line deprecation\n            if (Array.prototype.some.call(chnnlDt, function (sample) {\n              return sample === 1;\n            })) {\n              resolve(true);\n            } else {\n              resolve(false);\n            }\n            source.stop();\n            analyzer.onaudioprocess = null; // tslint:disable-line:deprecation\n            source.disconnect(analyzer);\n            analyzer.disconnect(nativeAudioContext.destination);\n          };\n          source.start();\n        }\n      });\n    };\n\n    function _createForOfIteratorHelper$8(r, e) { var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray$8(r)) || e) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t[\"return\"] || t[\"return\"](); } finally { if (u) throw o; } } }; }\n    function _unsupportedIterableToArray$8(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray$8(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$8(r, a) : void 0; } }\n    function _arrayLikeToArray$8(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\n    var visitEachAudioNodeOnce = function visitEachAudioNodeOnce(cycles, visitor) {\n      var counts = new Map();\n      var _iterator = _createForOfIteratorHelper$8(cycles),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var cycle = _step.value;\n          var _iterator2 = _createForOfIteratorHelper$8(cycle),\n            _step2;\n          try {\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              var audioNode = _step2.value;\n              var count = counts.get(audioNode);\n              counts.set(audioNode, count === undefined ? 1 : count + 1);\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      counts.forEach(function (count, audioNode) {\n        return visitor(audioNode, count);\n      });\n    };\n\n    var isNativeAudioNode$1 = function isNativeAudioNode(nativeAudioNodeOrAudioParam) {\n      return 'context' in nativeAudioNodeOrAudioParam;\n    };\n\n    function _createForOfIteratorHelper$7(r, e) { var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray$7(r)) || e) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t[\"return\"] || t[\"return\"](); } finally { if (u) throw o; } } }; }\n    function _unsupportedIterableToArray$7(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray$7(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$7(r, a) : void 0; } }\n    function _arrayLikeToArray$7(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\n    var wrapAudioNodeDisconnectMethod = function wrapAudioNodeDisconnectMethod(nativeAudioNode) {\n      var connections = new Map();\n      nativeAudioNode.connect = function (connect) {\n        // tslint:disable-next-line:invalid-void no-inferrable-types\n        return function (destination) {\n          var output = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n          var input = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n          var returnValue = isNativeAudioNode$1(destination) ? connect(destination, output, input) : connect(destination, output);\n          // Save the new connection only if the calls to connect above didn't throw an error.\n          var connectionsToDestination = connections.get(destination);\n          if (connectionsToDestination === undefined) {\n            connections.set(destination, [{\n              input: input,\n              output: output\n            }]);\n          } else {\n            if (connectionsToDestination.every(function (connection) {\n              return connection.input !== input || connection.output !== output;\n            })) {\n              connectionsToDestination.push({\n                input: input,\n                output: output\n              });\n            }\n          }\n          return returnValue;\n        };\n      }(nativeAudioNode.connect.bind(nativeAudioNode));\n      nativeAudioNode.disconnect = function (disconnect) {\n        return function (destinationOrOutput, output, input) {\n          disconnect.apply(nativeAudioNode);\n          if (destinationOrOutput === undefined) {\n            connections.clear();\n          } else if (typeof destinationOrOutput === 'number') {\n            var _iterator = _createForOfIteratorHelper$7(connections),\n              _step;\n            try {\n              for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                var _step$value = _slicedToArray(_step.value, 2),\n                  destination = _step$value[0],\n                  connectionsToDestination = _step$value[1];\n                var filteredConnections = connectionsToDestination.filter(function (connection) {\n                  return connection.output !== destinationOrOutput;\n                });\n                if (filteredConnections.length === 0) {\n                  connections[\"delete\"](destination);\n                } else {\n                  connections.set(destination, filteredConnections);\n                }\n              }\n            } catch (err) {\n              _iterator.e(err);\n            } finally {\n              _iterator.f();\n            }\n          } else if (connections.has(destinationOrOutput)) {\n            if (output === undefined) {\n              connections[\"delete\"](destinationOrOutput);\n            } else {\n              var _connectionsToDestination = connections.get(destinationOrOutput);\n              if (_connectionsToDestination !== undefined) {\n                var _filteredConnections = _connectionsToDestination.filter(function (connection) {\n                  return connection.output !== output && (connection.input !== input || input === undefined);\n                });\n                if (_filteredConnections.length === 0) {\n                  connections[\"delete\"](destinationOrOutput);\n                } else {\n                  connections.set(destinationOrOutput, _filteredConnections);\n                }\n              }\n            }\n          }\n          var _iterator2 = _createForOfIteratorHelper$7(connections),\n            _step2;\n          try {\n            var _loop = function _loop() {\n              var _step2$value = _slicedToArray(_step2.value, 2),\n                destination = _step2$value[0],\n                connectionsToDestination = _step2$value[1];\n              connectionsToDestination.forEach(function (connection) {\n                if (isNativeAudioNode$1(destination)) {\n                  nativeAudioNode.connect(destination, connection.output, connection.input);\n                } else {\n                  nativeAudioNode.connect(destination, connection.output);\n                }\n              });\n            };\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              _loop();\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n        };\n      }(nativeAudioNode.disconnect);\n    };\n\n    function _callSuper$n(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$n() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\n    function _isNativeReflectConstruct$n() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$n = function _isNativeReflectConstruct() { return !!t; })(); }\n    function _createForOfIteratorHelper$6(r, e) { var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray$6(r)) || e) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t[\"return\"] || t[\"return\"](); } finally { if (u) throw o; } } }; }\n    function _unsupportedIterableToArray$6(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray$6(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$6(r, a) : void 0; } }\n    function _arrayLikeToArray$6(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\n    var addConnectionToAudioParamOfAudioContext = function addConnectionToAudioParamOfAudioContext(source, destination, output, isOffline) {\n      var _getAudioParamConnect = getAudioParamConnections(destination),\n        activeInputs = _getAudioParamConnect.activeInputs,\n        passiveInputs = _getAudioParamConnect.passiveInputs;\n      var _getAudioNodeConnecti = getAudioNodeConnections(source),\n        outputs = _getAudioNodeConnecti.outputs;\n      var eventListeners = getEventListenersOfAudioNode(source);\n      var eventListener = function eventListener(isActive) {\n        var nativeAudioNode = getNativeAudioNode(source);\n        var nativeAudioParam = getNativeAudioParam(destination);\n        if (isActive) {\n          var partialConnection = deletePassiveInputConnectionToAudioParam(passiveInputs, source, output);\n          addActiveInputConnectionToAudioParam(activeInputs, source, partialConnection, false);\n          if (!isOffline && !isPartOfACycle(source)) {\n            nativeAudioNode.connect(nativeAudioParam, output);\n          }\n        } else {\n          var _partialConnection = deleteActiveInputConnectionToAudioParam(activeInputs, source, output);\n          addPassiveInputConnectionToAudioParam(passiveInputs, _partialConnection, false);\n          if (!isOffline && !isPartOfACycle(source)) {\n            nativeAudioNode.disconnect(nativeAudioParam, output);\n          }\n        }\n      };\n      if (insertElementInSet(outputs, [destination, output], function (outputConnection) {\n        return outputConnection[0] === destination && outputConnection[1] === output;\n      }, true)) {\n        eventListeners.add(eventListener);\n        if (isActiveAudioNode(source)) {\n          addActiveInputConnectionToAudioParam(activeInputs, source, [output, eventListener], true);\n        } else {\n          addPassiveInputConnectionToAudioParam(passiveInputs, [source, output, eventListener], true);\n        }\n        return true;\n      }\n      return false;\n    };\n    var deleteInputConnectionOfAudioNode = function deleteInputConnectionOfAudioNode(source, destination, output, input) {\n      var _getAudioNodeConnecti2 = getAudioNodeConnections(destination),\n        activeInputs = _getAudioNodeConnecti2.activeInputs,\n        passiveInputs = _getAudioNodeConnecti2.passiveInputs;\n      var activeInputConnection = deleteActiveInputConnection(activeInputs[input], source, output);\n      if (activeInputConnection === null) {\n        var passiveInputConnection = deletePassiveInputConnectionToAudioNode(passiveInputs, source, output, input);\n        return [passiveInputConnection[2], false];\n      }\n      return [activeInputConnection[2], true];\n    };\n    var deleteInputConnectionOfAudioParam = function deleteInputConnectionOfAudioParam(source, destination, output) {\n      var _getAudioParamConnect2 = getAudioParamConnections(destination),\n        activeInputs = _getAudioParamConnect2.activeInputs,\n        passiveInputs = _getAudioParamConnect2.passiveInputs;\n      var activeInputConnection = deleteActiveInputConnection(activeInputs, source, output);\n      if (activeInputConnection === null) {\n        var passiveInputConnection = deletePassiveInputConnectionToAudioParam(passiveInputs, source, output);\n        return [passiveInputConnection[1], false];\n      }\n      return [activeInputConnection[2], true];\n    };\n    var deleteInputsOfAudioNode = function deleteInputsOfAudioNode(source, isOffline, destination, output, input) {\n      var _deleteInputConnectio = deleteInputConnectionOfAudioNode(source, destination, output, input),\n        _deleteInputConnectio2 = _slicedToArray(_deleteInputConnectio, 2),\n        listener = _deleteInputConnectio2[0],\n        isActive = _deleteInputConnectio2[1];\n      if (listener !== null) {\n        deleteEventListenerOfAudioNode(source, listener);\n        if (isActive && !isOffline && !isPartOfACycle(source)) {\n          disconnectNativeAudioNodeFromNativeAudioNode(getNativeAudioNode(source), getNativeAudioNode(destination), output, input);\n        }\n      }\n      if (isActiveAudioNode(destination)) {\n        var _getAudioNodeConnecti3 = getAudioNodeConnections(destination),\n          activeInputs = _getAudioNodeConnecti3.activeInputs;\n        setInternalStateToPassiveWhenNecessary(destination, activeInputs);\n      }\n    };\n    var deleteInputsOfAudioParam = function deleteInputsOfAudioParam(source, isOffline, destination, output) {\n      var _deleteInputConnectio3 = deleteInputConnectionOfAudioParam(source, destination, output),\n        _deleteInputConnectio4 = _slicedToArray(_deleteInputConnectio3, 2),\n        listener = _deleteInputConnectio4[0],\n        isActive = _deleteInputConnectio4[1];\n      if (listener !== null) {\n        deleteEventListenerOfAudioNode(source, listener);\n        if (isActive && !isOffline && !isPartOfACycle(source)) {\n          getNativeAudioNode(source).disconnect(getNativeAudioParam(destination), output);\n        }\n      }\n    };\n    var deleteAnyConnection = function deleteAnyConnection(source, isOffline) {\n      var audioNodeConnectionsOfSource = getAudioNodeConnections(source);\n      var destinations = [];\n      var _iterator = _createForOfIteratorHelper$6(audioNodeConnectionsOfSource.outputs),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var outputConnection = _step.value;\n          if (isAudioNodeOutputConnection(outputConnection)) {\n            deleteInputsOfAudioNode.apply(void 0, [source, isOffline].concat(_toConsumableArray(outputConnection)));\n          } else {\n            deleteInputsOfAudioParam.apply(void 0, [source, isOffline].concat(_toConsumableArray(outputConnection)));\n          }\n          destinations.push(outputConnection[0]);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      audioNodeConnectionsOfSource.outputs.clear();\n      return destinations;\n    };\n    var deleteConnectionAtOutput = function deleteConnectionAtOutput(source, isOffline, output) {\n      var audioNodeConnectionsOfSource = getAudioNodeConnections(source);\n      var destinations = [];\n      var _iterator2 = _createForOfIteratorHelper$6(audioNodeConnectionsOfSource.outputs),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var outputConnection = _step2.value;\n          if (outputConnection[1] === output) {\n            if (isAudioNodeOutputConnection(outputConnection)) {\n              deleteInputsOfAudioNode.apply(void 0, [source, isOffline].concat(_toConsumableArray(outputConnection)));\n            } else {\n              deleteInputsOfAudioParam.apply(void 0, [source, isOffline].concat(_toConsumableArray(outputConnection)));\n            }\n            destinations.push(outputConnection[0]);\n            audioNodeConnectionsOfSource.outputs[\"delete\"](outputConnection);\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      return destinations;\n    };\n    var deleteConnectionToDestination = function deleteConnectionToDestination(source, isOffline, destination, output, input) {\n      var audioNodeConnectionsOfSource = getAudioNodeConnections(source);\n      return Array.from(audioNodeConnectionsOfSource.outputs).filter(function (outputConnection) {\n        return outputConnection[0] === destination && (output === undefined || outputConnection[1] === output) && (input === undefined || outputConnection[2] === input);\n      }).map(function (outputConnection) {\n        if (isAudioNodeOutputConnection(outputConnection)) {\n          deleteInputsOfAudioNode.apply(void 0, [source, isOffline].concat(_toConsumableArray(outputConnection)));\n        } else {\n          deleteInputsOfAudioParam.apply(void 0, [source, isOffline].concat(_toConsumableArray(outputConnection)));\n        }\n        audioNodeConnectionsOfSource.outputs[\"delete\"](outputConnection);\n        return outputConnection[0];\n      });\n    };\n    var createAudioNodeConstructor = function createAudioNodeConstructor(addAudioNodeConnections, addConnectionToAudioNode, cacheTestResult, createIncrementCycleCounter, createIndexSizeError, createInvalidAccessError, createNotSupportedError, decrementCycleCounter, detectCycles, eventTargetConstructor, getNativeContext, isNativeAudioContext, isNativeAudioNode, isNativeAudioParam, isNativeOfflineAudioContext, nativeAudioWorkletNodeConstructor) {\n      return /*#__PURE__*/function (_eventTargetConstruct) {\n        function AudioNode(context, isActive, nativeAudioNode, audioNodeRenderer) {\n          var _this;\n          _classCallCheck(this, AudioNode);\n          _this = _callSuper$n(this, AudioNode, [nativeAudioNode]);\n          _this._context = context;\n          _this._nativeAudioNode = nativeAudioNode;\n          var nativeContext = getNativeContext(context);\n          // Bug #12: Safari does not support to disconnect a specific destination.\n          if (isNativeAudioContext(nativeContext) && true !== cacheTestResult(testAudioNodeDisconnectMethodSupport, function () {\n            return testAudioNodeDisconnectMethodSupport(nativeContext, nativeAudioWorkletNodeConstructor);\n          })) {\n            wrapAudioNodeDisconnectMethod(nativeAudioNode);\n          }\n          AUDIO_NODE_STORE.set(_this, nativeAudioNode);\n          EVENT_LISTENERS.set(_this, new Set());\n          if (context.state !== 'closed' && isActive) {\n            setInternalStateToActive(_this);\n          }\n          addAudioNodeConnections(_this, audioNodeRenderer, nativeAudioNode);\n          return _this;\n        }\n        _inherits(AudioNode, _eventTargetConstruct);\n        return _createClass(AudioNode, [{\n          key: \"channelCount\",\n          get: function get() {\n            return this._nativeAudioNode.channelCount;\n          },\n          set: function set(value) {\n            this._nativeAudioNode.channelCount = value;\n          }\n        }, {\n          key: \"channelCountMode\",\n          get: function get() {\n            return this._nativeAudioNode.channelCountMode;\n          },\n          set: function set(value) {\n            this._nativeAudioNode.channelCountMode = value;\n          }\n        }, {\n          key: \"channelInterpretation\",\n          get: function get() {\n            return this._nativeAudioNode.channelInterpretation;\n          },\n          set: function set(value) {\n            this._nativeAudioNode.channelInterpretation = value;\n          }\n        }, {\n          key: \"context\",\n          get: function get() {\n            return this._context;\n          }\n        }, {\n          key: \"numberOfInputs\",\n          get: function get() {\n            return this._nativeAudioNode.numberOfInputs;\n          }\n        }, {\n          key: \"numberOfOutputs\",\n          get: function get() {\n            return this._nativeAudioNode.numberOfOutputs;\n          }\n          // tslint:disable-next-line:invalid-void\n        }, {\n          key: \"connect\",\n          value: function connect(destination) {\n            var output = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n            var input = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n            // Bug #174: Safari does expose a wrong numberOfOutputs for MediaStreamAudioDestinationNodes.\n            if (output < 0 || output >= this._nativeAudioNode.numberOfOutputs) {\n              throw createIndexSizeError();\n            }\n            var nativeContext = getNativeContext(this._context);\n            var isOffline = isNativeOfflineAudioContext(nativeContext);\n            if (isNativeAudioNode(destination) || isNativeAudioParam(destination)) {\n              throw createInvalidAccessError();\n            }\n            if (isAudioNode(destination)) {\n              var nativeDestinationAudioNode = getNativeAudioNode(destination);\n              try {\n                var connection = connectNativeAudioNodeToNativeAudioNode(this._nativeAudioNode, nativeDestinationAudioNode, output, input);\n                var isPassive = isPassiveAudioNode(this);\n                if (isOffline || isPassive) {\n                  var _this$_nativeAudioNod;\n                  (_this$_nativeAudioNod = this._nativeAudioNode).disconnect.apply(_this$_nativeAudioNod, _toConsumableArray(connection));\n                }\n                if (this.context.state !== 'closed' && !isPassive && isPassiveAudioNode(destination)) {\n                  setInternalStateToActive(destination);\n                }\n              } catch (err) {\n                // Bug #41: Safari does not throw the correct exception so far.\n                if (err.code === 12) {\n                  throw createInvalidAccessError();\n                }\n                throw err;\n              }\n              var isNewConnectionToAudioNode = addConnectionToAudioNode(this, destination, output, input, isOffline);\n              // Bug #164: Only Firefox detects cycles so far.\n              if (isNewConnectionToAudioNode) {\n                var cycles = detectCycles([this], destination);\n                visitEachAudioNodeOnce(cycles, createIncrementCycleCounter(isOffline));\n              }\n              return destination;\n            }\n            var nativeAudioParam = getNativeAudioParam(destination);\n            /*\n             * Bug #73, #147 & #153: Safari does not support to connect an input signal to the playbackRate AudioParam of an\n             * AudioBufferSourceNode. This can't be easily detected and that's why the outdated name property is used here to identify\n             * Safari. In addition to that the maxValue property is used to only detect the affected versions below v14.0.2.\n             */\n            if (nativeAudioParam.name === 'playbackRate' && nativeAudioParam.maxValue === 1024) {\n              throw createNotSupportedError();\n            }\n            try {\n              this._nativeAudioNode.connect(nativeAudioParam, output);\n              if (isOffline || isPassiveAudioNode(this)) {\n                this._nativeAudioNode.disconnect(nativeAudioParam, output);\n              }\n            } catch (err) {\n              // Bug #58: Safari doesn't throw an InvalidAccessError yet.\n              if (err.code === 12) {\n                throw createInvalidAccessError();\n              }\n              throw err;\n            }\n            var isNewConnectionToAudioParam = addConnectionToAudioParamOfAudioContext(this, destination, output, isOffline);\n            // Bug #164: Only Firefox detects cycles so far.\n            if (isNewConnectionToAudioParam) {\n              var _cycles = detectCycles([this], destination);\n              visitEachAudioNodeOnce(_cycles, createIncrementCycleCounter(isOffline));\n            }\n          }\n        }, {\n          key: \"disconnect\",\n          value: function disconnect(destinationOrOutput, output, input) {\n            var destinations;\n            var nativeContext = getNativeContext(this._context);\n            var isOffline = isNativeOfflineAudioContext(nativeContext);\n            if (destinationOrOutput === undefined) {\n              destinations = deleteAnyConnection(this, isOffline);\n            } else if (typeof destinationOrOutput === 'number') {\n              if (destinationOrOutput < 0 || destinationOrOutput >= this.numberOfOutputs) {\n                throw createIndexSizeError();\n              }\n              destinations = deleteConnectionAtOutput(this, isOffline, destinationOrOutput);\n            } else {\n              if (output !== undefined && (output < 0 || output >= this.numberOfOutputs)) {\n                throw createIndexSizeError();\n              }\n              if (isAudioNode(destinationOrOutput) && input !== undefined && (input < 0 || input >= destinationOrOutput.numberOfInputs)) {\n                throw createIndexSizeError();\n              }\n              destinations = deleteConnectionToDestination(this, isOffline, destinationOrOutput, output, input);\n              if (destinations.length === 0) {\n                throw createInvalidAccessError();\n              }\n            }\n            // Bug #164: Only Firefox detects cycles so far.\n            var _iterator3 = _createForOfIteratorHelper$6(destinations),\n              _step3;\n            try {\n              for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n                var destination = _step3.value;\n                var cycles = detectCycles([this], destination);\n                visitEachAudioNodeOnce(cycles, decrementCycleCounter);\n              }\n            } catch (err) {\n              _iterator3.e(err);\n            } finally {\n              _iterator3.f();\n            }\n          }\n        }]);\n      }(eventTargetConstructor);\n    };\n\n    var createAudioParamFactory = function createAudioParamFactory(addAudioParamConnections, audioParamAudioNodeStore, audioParamStore, createAudioParamRenderer, createCancelAndHoldAutomationEvent, createCancelScheduledValuesAutomationEvent, createExponentialRampToValueAutomationEvent, createLinearRampToValueAutomationEvent, createSetTargetAutomationEvent, createSetValueAutomationEvent, createSetValueCurveAutomationEvent, nativeAudioContextConstructor, setValueAtTimeUntilPossible) {\n      return function (audioNode, isAudioParamOfOfflineAudioContext, nativeAudioParam) {\n        var maxValue = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n        var minValue = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n        // Bug #196 Only Safari sets the defaultValue to the initial value.\n        var defaultValue = nativeAudioParam.value;\n        var automationEventList = new automationEvents.AutomationEventList(defaultValue);\n        var audioParamRenderer = isAudioParamOfOfflineAudioContext ? createAudioParamRenderer(automationEventList) : null;\n        var audioParam = {\n          get defaultValue() {\n            return defaultValue;\n          },\n          get maxValue() {\n            return maxValue === null ? nativeAudioParam.maxValue : maxValue;\n          },\n          get minValue() {\n            return minValue === null ? nativeAudioParam.minValue : minValue;\n          },\n          get value() {\n            return nativeAudioParam.value;\n          },\n          set value(value) {\n            nativeAudioParam.value = value;\n            // Bug #98: Firefox & Safari do not yet treat the value setter like a call to setValueAtTime().\n            audioParam.setValueAtTime(value, audioNode.context.currentTime);\n          },\n          cancelAndHoldAtTime: function cancelAndHoldAtTime(cancelTime) {\n            // Bug #28: Firefox & Safari do not yet implement cancelAndHoldAtTime().\n            if (typeof nativeAudioParam.cancelAndHoldAtTime === 'function') {\n              if (audioParamRenderer === null) {\n                automationEventList.flush(audioNode.context.currentTime);\n              }\n              automationEventList.add(createCancelAndHoldAutomationEvent(cancelTime));\n              nativeAudioParam.cancelAndHoldAtTime(cancelTime);\n            } else {\n              var previousLastEvent = Array.from(automationEventList).pop();\n              if (audioParamRenderer === null) {\n                automationEventList.flush(audioNode.context.currentTime);\n              }\n              automationEventList.add(createCancelAndHoldAutomationEvent(cancelTime));\n              var currentLastEvent = Array.from(automationEventList).pop();\n              nativeAudioParam.cancelScheduledValues(cancelTime);\n              if (previousLastEvent !== currentLastEvent && currentLastEvent !== undefined) {\n                if (currentLastEvent.type === 'exponentialRampToValue') {\n                  nativeAudioParam.exponentialRampToValueAtTime(currentLastEvent.value, currentLastEvent.endTime);\n                } else if (currentLastEvent.type === 'linearRampToValue') {\n                  nativeAudioParam.linearRampToValueAtTime(currentLastEvent.value, currentLastEvent.endTime);\n                } else if (currentLastEvent.type === 'setValue') {\n                  nativeAudioParam.setValueAtTime(currentLastEvent.value, currentLastEvent.startTime);\n                } else if (currentLastEvent.type === 'setValueCurve') {\n                  nativeAudioParam.setValueCurveAtTime(currentLastEvent.values, currentLastEvent.startTime, currentLastEvent.duration);\n                }\n              }\n            }\n            return audioParam;\n          },\n          cancelScheduledValues: function cancelScheduledValues(cancelTime) {\n            if (audioParamRenderer === null) {\n              automationEventList.flush(audioNode.context.currentTime);\n            }\n            automationEventList.add(createCancelScheduledValuesAutomationEvent(cancelTime));\n            nativeAudioParam.cancelScheduledValues(cancelTime);\n            return audioParam;\n          },\n          exponentialRampToValueAtTime: function exponentialRampToValueAtTime(value, endTime) {\n            // Bug #45: Safari does not throw an error yet.\n            if (value === 0) {\n              throw new RangeError();\n            }\n            // Bug #187: Safari does not throw an error yet.\n            if (!Number.isFinite(endTime) || endTime < 0) {\n              throw new RangeError();\n            }\n            var currentTime = audioNode.context.currentTime;\n            if (audioParamRenderer === null) {\n              automationEventList.flush(currentTime);\n            }\n            // Bug #194: Firefox does not implicitly call setValueAtTime() if there is no previous event.\n            if (Array.from(automationEventList).length === 0) {\n              automationEventList.add(createSetValueAutomationEvent(defaultValue, currentTime));\n              nativeAudioParam.setValueAtTime(defaultValue, currentTime);\n            }\n            automationEventList.add(createExponentialRampToValueAutomationEvent(value, endTime));\n            nativeAudioParam.exponentialRampToValueAtTime(value, endTime);\n            return audioParam;\n          },\n          linearRampToValueAtTime: function linearRampToValueAtTime(value, endTime) {\n            var currentTime = audioNode.context.currentTime;\n            if (audioParamRenderer === null) {\n              automationEventList.flush(currentTime);\n            }\n            // Bug #195: Firefox does not implicitly call setValueAtTime() if there is no previous event.\n            if (Array.from(automationEventList).length === 0) {\n              automationEventList.add(createSetValueAutomationEvent(defaultValue, currentTime));\n              nativeAudioParam.setValueAtTime(defaultValue, currentTime);\n            }\n            automationEventList.add(createLinearRampToValueAutomationEvent(value, endTime));\n            nativeAudioParam.linearRampToValueAtTime(value, endTime);\n            return audioParam;\n          },\n          setTargetAtTime: function setTargetAtTime(target, startTime, timeConstant) {\n            if (audioParamRenderer === null) {\n              automationEventList.flush(audioNode.context.currentTime);\n            }\n            automationEventList.add(createSetTargetAutomationEvent(target, startTime, timeConstant));\n            nativeAudioParam.setTargetAtTime(target, startTime, timeConstant);\n            return audioParam;\n          },\n          setValueAtTime: function setValueAtTime(value, startTime) {\n            if (audioParamRenderer === null) {\n              automationEventList.flush(audioNode.context.currentTime);\n            }\n            automationEventList.add(createSetValueAutomationEvent(value, startTime));\n            nativeAudioParam.setValueAtTime(value, startTime);\n            return audioParam;\n          },\n          setValueCurveAtTime: function setValueCurveAtTime(values, startTime, duration) {\n            // Bug 183: Safari only accepts a Float32Array.\n            var convertedValues = values instanceof Float32Array ? values : new Float32Array(values);\n            /*\n             * Bug #152: Safari does not correctly interpolate the values of the curve.\n             * @todo Unfortunately there is no way to test for this behavior in a synchronous fashion which is why testing for the\n             * existence of the webkitAudioContext is used as a workaround here.\n             */\n            if (nativeAudioContextConstructor !== null && nativeAudioContextConstructor.name === 'webkitAudioContext') {\n              var endTime = startTime + duration;\n              var sampleRate = audioNode.context.sampleRate;\n              var firstSample = Math.ceil(startTime * sampleRate);\n              var lastSample = Math.floor(endTime * sampleRate);\n              var numberOfInterpolatedValues = lastSample - firstSample;\n              var interpolatedValues = new Float32Array(numberOfInterpolatedValues);\n              for (var i = 0; i < numberOfInterpolatedValues; i += 1) {\n                var theoreticIndex = (convertedValues.length - 1) / duration * ((firstSample + i) / sampleRate - startTime);\n                var lowerIndex = Math.floor(theoreticIndex);\n                var upperIndex = Math.ceil(theoreticIndex);\n                interpolatedValues[i] = lowerIndex === upperIndex ? convertedValues[lowerIndex] : (1 - (theoreticIndex - lowerIndex)) * convertedValues[lowerIndex] + (1 - (upperIndex - theoreticIndex)) * convertedValues[upperIndex];\n              }\n              if (audioParamRenderer === null) {\n                automationEventList.flush(audioNode.context.currentTime);\n              }\n              automationEventList.add(createSetValueCurveAutomationEvent(interpolatedValues, startTime, duration));\n              nativeAudioParam.setValueCurveAtTime(interpolatedValues, startTime, duration);\n              var timeOfLastSample = lastSample / sampleRate;\n              if (timeOfLastSample < endTime) {\n                setValueAtTimeUntilPossible(audioParam, interpolatedValues[interpolatedValues.length - 1], timeOfLastSample);\n              }\n              setValueAtTimeUntilPossible(audioParam, convertedValues[convertedValues.length - 1], endTime);\n            } else {\n              if (audioParamRenderer === null) {\n                automationEventList.flush(audioNode.context.currentTime);\n              }\n              automationEventList.add(createSetValueCurveAutomationEvent(convertedValues, startTime, duration));\n              nativeAudioParam.setValueCurveAtTime(convertedValues, startTime, duration);\n            }\n            return audioParam;\n          }\n        };\n        audioParamStore.set(audioParam, nativeAudioParam);\n        audioParamAudioNodeStore.set(audioParam, audioNode);\n        addAudioParamConnections(audioParam, audioParamRenderer);\n        return audioParam;\n      };\n    };\n\n    function _createForOfIteratorHelper$5(r, e) { var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray$5(r)) || e) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t[\"return\"] || t[\"return\"](); } finally { if (u) throw o; } } }; }\n    function _unsupportedIterableToArray$5(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray$5(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$5(r, a) : void 0; } }\n    function _arrayLikeToArray$5(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\n    var createAudioParamRenderer = function createAudioParamRenderer(automationEventList) {\n      return {\n        replay: function replay(audioParam) {\n          var _iterator = _createForOfIteratorHelper$5(automationEventList),\n            _step;\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var automationEvent = _step.value;\n              if (automationEvent.type === 'exponentialRampToValue') {\n                var endTime = automationEvent.endTime,\n                  value = automationEvent.value;\n                audioParam.exponentialRampToValueAtTime(value, endTime);\n              } else if (automationEvent.type === 'linearRampToValue') {\n                var _endTime = automationEvent.endTime,\n                  _value = automationEvent.value;\n                audioParam.linearRampToValueAtTime(_value, _endTime);\n              } else if (automationEvent.type === 'setTarget') {\n                var startTime = automationEvent.startTime,\n                  target = automationEvent.target,\n                  timeConstant = automationEvent.timeConstant;\n                audioParam.setTargetAtTime(target, startTime, timeConstant);\n              } else if (automationEvent.type === 'setValue') {\n                var _startTime = automationEvent.startTime,\n                  _value2 = automationEvent.value;\n                audioParam.setValueAtTime(_value2, _startTime);\n              } else if (automationEvent.type === 'setValueCurve') {\n                var duration = automationEvent.duration,\n                  _startTime2 = automationEvent.startTime,\n                  values = automationEvent.values;\n                audioParam.setValueCurveAtTime(values, _startTime2, duration);\n              } else {\n                throw new Error(\"Can't apply an unknown automation.\");\n              }\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n        }\n      };\n    };\n\n    var ReadOnlyMap = /*#__PURE__*/function () {\n      function ReadOnlyMap(parameters) {\n        _classCallCheck(this, ReadOnlyMap);\n        this._map = new Map(parameters);\n      }\n      return _createClass(ReadOnlyMap, [{\n        key: \"size\",\n        get: function get() {\n          return this._map.size;\n        }\n      }, {\n        key: \"entries\",\n        value: function entries() {\n          return this._map.entries();\n        }\n      }, {\n        key: \"forEach\",\n        value: function forEach(callback) {\n          var _this = this;\n          var thisArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n          return this._map.forEach(function (value, key) {\n            return callback.call(thisArg, value, key, _this);\n          });\n        }\n      }, {\n        key: \"get\",\n        value: function get(name) {\n          return this._map.get(name);\n        }\n      }, {\n        key: \"has\",\n        value: function has(name) {\n          return this._map.has(name);\n        }\n      }, {\n        key: \"keys\",\n        value: function keys() {\n          return this._map.keys();\n        }\n      }, {\n        key: \"values\",\n        value: function values() {\n          return this._map.values();\n        }\n      }]);\n    }();\n\n    function ownKeys$t(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\n    function _objectSpread$t(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$t(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$t(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n    function _callSuper$m(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$m() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\n    function _isNativeReflectConstruct$m() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$m = function _isNativeReflectConstruct() { return !!t; })(); }\n    var DEFAULT_OPTIONS$h = {\n      channelCount: 2,\n      // Bug #61: The channelCountMode should be 'max' according to the spec but is set to 'explicit' to achieve consistent behavior.\n      channelCountMode: 'explicit',\n      channelInterpretation: 'speakers',\n      numberOfInputs: 1,\n      numberOfOutputs: 1,\n      parameterData: {},\n      processorOptions: {}\n    };\n    var createAudioWorkletNodeConstructor = function createAudioWorkletNodeConstructor(addUnrenderedAudioWorkletNode, audioNodeConstructor, createAudioParam, createAudioWorkletNodeRenderer, createNativeAudioWorkletNode, getAudioNodeConnections, getBackupOfflineAudioContext, getNativeContext, isNativeOfflineAudioContext, nativeAudioWorkletNodeConstructor, sanitizeAudioWorkletNodeOptions, setActiveAudioWorkletNodeInputs, testAudioWorkletNodeOptionsClonability, wrapEventListener) {\n      return /*#__PURE__*/function (_audioNodeConstructor) {\n        function AudioWorkletNode(context, name, options) {\n          var _this;\n          _classCallCheck(this, AudioWorkletNode);\n          var _a;\n          var nativeContext = getNativeContext(context);\n          var isOffline = isNativeOfflineAudioContext(nativeContext);\n          var mergedOptions = sanitizeAudioWorkletNodeOptions(_objectSpread$t(_objectSpread$t({}, DEFAULT_OPTIONS$h), options));\n          // Bug #191: Safari doesn't throw an error if the options aren't clonable.\n          testAudioWorkletNodeOptionsClonability(mergedOptions);\n          var nodeNameToProcessorConstructorMap = NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS.get(nativeContext);\n          var processorConstructor = nodeNameToProcessorConstructorMap === null || nodeNameToProcessorConstructorMap === void 0 ? void 0 : nodeNameToProcessorConstructorMap.get(name);\n          // Bug #186: Chrome and Edge do not allow to create an AudioWorkletNode on a closed AudioContext.\n          var nativeContextOrBackupOfflineAudioContext = isOffline || nativeContext.state !== 'closed' ? nativeContext : (_a = getBackupOfflineAudioContext(nativeContext)) !== null && _a !== void 0 ? _a : nativeContext;\n          var nativeAudioWorkletNode = createNativeAudioWorkletNode(nativeContextOrBackupOfflineAudioContext, isOffline ? null : context.baseLatency, nativeAudioWorkletNodeConstructor, name, processorConstructor, mergedOptions);\n          var audioWorkletNodeRenderer = isOffline ? createAudioWorkletNodeRenderer(name, mergedOptions, processorConstructor) : null;\n          /*\n           * @todo Add a mechanism to switch an AudioWorkletNode to passive once the process() function of the AudioWorkletProcessor\n           * returns false.\n           */\n          _this = _callSuper$m(this, AudioWorkletNode, [context, true, nativeAudioWorkletNode, audioWorkletNodeRenderer]);\n          var parameters = [];\n          nativeAudioWorkletNode.parameters.forEach(function (nativeAudioParam, nm) {\n            var audioParam = createAudioParam(_this, isOffline, nativeAudioParam);\n            parameters.push([nm, audioParam]);\n          });\n          _this._nativeAudioWorkletNode = nativeAudioWorkletNode;\n          _this._onprocessorerror = null;\n          _this._parameters = new ReadOnlyMap(parameters);\n          /*\n           * Bug #86 & #87: Invoking the renderer of an AudioWorkletNode might be necessary if it has no direct or indirect connection to\n           * the destination.\n           */\n          if (isOffline) {\n            addUnrenderedAudioWorkletNode(nativeContext, _this);\n          }\n          var _getAudioNodeConnecti = getAudioNodeConnections(_this),\n            activeInputs = _getAudioNodeConnecti.activeInputs;\n          setActiveAudioWorkletNodeInputs(nativeAudioWorkletNode, activeInputs);\n          return _this;\n        }\n        _inherits(AudioWorkletNode, _audioNodeConstructor);\n        return _createClass(AudioWorkletNode, [{\n          key: \"onprocessorerror\",\n          get: function get() {\n            return this._onprocessorerror;\n          },\n          set: function set(value) {\n            var wrappedListener = typeof value === 'function' ? wrapEventListener(this, value) : null;\n            this._nativeAudioWorkletNode.onprocessorerror = wrappedListener;\n            var nativeOnProcessorError = this._nativeAudioWorkletNode.onprocessorerror;\n            this._onprocessorerror = nativeOnProcessorError !== null && nativeOnProcessorError === wrappedListener ? value : nativeOnProcessorError;\n          }\n        }, {\n          key: \"parameters\",\n          get: function get() {\n            if (this._parameters === null) {\n              // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\n              return this._nativeAudioWorkletNode.parameters;\n            }\n            return this._parameters;\n          }\n        }, {\n          key: \"port\",\n          get: function get() {\n            return this._nativeAudioWorkletNode.port;\n          }\n        }]);\n      }(audioNodeConstructor);\n    };\n\n    function copyFromChannel(audioBuffer,\n    // @todo There is currently no way to define something like { [ key: number | string ]: Float32Array }\n    parent, key, channelNumber, bufferOffset) {\n      if (typeof audioBuffer.copyFromChannel === 'function') {\n        // The byteLength will be 0 when the ArrayBuffer was transferred.\n        if (parent[key].byteLength === 0) {\n          parent[key] = new Float32Array(128);\n        }\n        audioBuffer.copyFromChannel(parent[key], channelNumber, bufferOffset);\n        // Bug #5: Safari does not support copyFromChannel().\n      } else {\n        var channelData = audioBuffer.getChannelData(channelNumber);\n        // The byteLength will be 0 when the ArrayBuffer was transferred.\n        if (parent[key].byteLength === 0) {\n          parent[key] = channelData.slice(bufferOffset, bufferOffset + 128);\n        } else {\n          var slicedInput = new Float32Array(channelData.buffer, bufferOffset * Float32Array.BYTES_PER_ELEMENT, 128);\n          parent[key].set(slicedInput);\n        }\n      }\n    }\n\n    var copyToChannel = function copyToChannel(audioBuffer, parent, key, channelNumber, bufferOffset) {\n      if (typeof audioBuffer.copyToChannel === 'function') {\n        // The byteLength will be 0 when the ArrayBuffer was transferred.\n        if (parent[key].byteLength !== 0) {\n          audioBuffer.copyToChannel(parent[key], channelNumber, bufferOffset);\n        }\n        // Bug #5: Safari does not support copyToChannel().\n      } else {\n        // The byteLength will be 0 when the ArrayBuffer was transferred.\n        if (parent[key].byteLength !== 0) {\n          audioBuffer.getChannelData(channelNumber).set(parent[key], bufferOffset);\n        }\n      }\n    };\n\n    var createNestedArrays = function createNestedArrays(x, y) {\n      var arrays = [];\n      for (var i = 0; i < x; i += 1) {\n        var array = [];\n        var length = typeof y === 'number' ? y : y[i];\n        for (var j = 0; j < length; j += 1) {\n          array.push(new Float32Array(128));\n        }\n        arrays.push(array);\n      }\n      return arrays;\n    };\n\n    var getAudioWorkletProcessor = function getAudioWorkletProcessor(nativeOfflineAudioContext, proxy) {\n      var nodeToProcessorMap = getValueForKey(NODE_TO_PROCESSOR_MAPS, nativeOfflineAudioContext);\n      var nativeAudioWorkletNode = getNativeAudioNode(proxy);\n      return getValueForKey(nodeToProcessorMap, nativeAudioWorkletNode);\n    };\n\n    function _createForOfIteratorHelper$4(r, e) { var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray$4(r)) || e) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t[\"return\"] || t[\"return\"](); } finally { if (u) throw o; } } }; }\n    function _unsupportedIterableToArray$4(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray$4(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$4(r, a) : void 0; } }\n    function _arrayLikeToArray$4(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\n    function ownKeys$s(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\n    function _objectSpread$s(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$s(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$s(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n    var processBuffer = /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(proxy, renderedBuffer, nativeOfflineAudioContext, options, outputChannelCount, processorConstructor, exposeCurrentFrameAndCurrentTime) {\n        var length, numberOfInputChannels, numberOfOutputChannels, processedBuffer, audioNodeConnections, audioWorkletProcessor, inputs, outputs, parameters, _loop, _ret, i;\n        return _regeneratorRuntime.wrap(function _callee$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              // Ceil the length to the next full render quantum.\n              // Bug #17: Safari does not yet expose the length.\n              length = renderedBuffer === null ? Math.ceil(proxy.context.length / 128) * 128 : renderedBuffer.length;\n              numberOfInputChannels = options.channelCount * options.numberOfInputs;\n              numberOfOutputChannels = outputChannelCount.reduce(function (sum, value) {\n                return sum + value;\n              }, 0);\n              processedBuffer = numberOfOutputChannels === 0 ? null : nativeOfflineAudioContext.createBuffer(numberOfOutputChannels, length, nativeOfflineAudioContext.sampleRate);\n              if (!(processorConstructor === undefined)) {\n                _context2.next = 6;\n                break;\n              }\n              throw new Error('Missing the processor constructor.');\n            case 6:\n              audioNodeConnections = getAudioNodeConnections(proxy);\n              _context2.next = 9;\n              return getAudioWorkletProcessor(nativeOfflineAudioContext, proxy);\n            case 9:\n              audioWorkletProcessor = _context2.sent;\n              inputs = createNestedArrays(options.numberOfInputs, options.channelCount);\n              outputs = createNestedArrays(options.numberOfOutputs, outputChannelCount);\n              parameters = Array.from(proxy.parameters.keys()).reduce(function (prmtrs, name) {\n                return _objectSpread$s(_objectSpread$s({}, prmtrs), {}, _defineProperty({}, name, new Float32Array(128)));\n              }, {});\n              _loop = /*#__PURE__*/_regeneratorRuntime.mark(function _loop(i) {\n                var j, k, _j, _k, potentiallyEmptyInputs, activeSourceFlag, _j2, outputChannelSplitterNodeOutput, _k2;\n                return _regeneratorRuntime.wrap(function _loop$(_context) {\n                  while (1) switch (_context.prev = _context.next) {\n                    case 0:\n                      if (options.numberOfInputs > 0 && renderedBuffer !== null) {\n                        for (j = 0; j < options.numberOfInputs; j += 1) {\n                          for (k = 0; k < options.channelCount; k += 1) {\n                            copyFromChannel(renderedBuffer, inputs[j], k, k, i);\n                          }\n                        }\n                      }\n                      if (processorConstructor.parameterDescriptors !== undefined && renderedBuffer !== null) {\n                        processorConstructor.parameterDescriptors.forEach(function (_ref2, index) {\n                          var name = _ref2.name;\n                          copyFromChannel(renderedBuffer, parameters, name, numberOfInputChannels + index, i);\n                        });\n                      }\n                      for (_j = 0; _j < options.numberOfInputs; _j += 1) {\n                        for (_k = 0; _k < outputChannelCount[_j]; _k += 1) {\n                          // The byteLength will be 0 when the ArrayBuffer was transferred.\n                          if (outputs[_j][_k].byteLength === 0) {\n                            outputs[_j][_k] = new Float32Array(128);\n                          }\n                        }\n                      }\n                      _context.prev = 3;\n                      potentiallyEmptyInputs = inputs.map(function (input, index) {\n                        if (audioNodeConnections.activeInputs[index].size === 0) {\n                          return [];\n                        }\n                        return input;\n                      });\n                      activeSourceFlag = exposeCurrentFrameAndCurrentTime(i / nativeOfflineAudioContext.sampleRate, nativeOfflineAudioContext.sampleRate, function () {\n                        return audioWorkletProcessor.process(potentiallyEmptyInputs, outputs, parameters);\n                      });\n                      if (processedBuffer !== null) {\n                        for (_j2 = 0, outputChannelSplitterNodeOutput = 0; _j2 < options.numberOfOutputs; _j2 += 1) {\n                          for (_k2 = 0; _k2 < outputChannelCount[_j2]; _k2 += 1) {\n                            copyToChannel(processedBuffer, outputs[_j2], _k2, outputChannelSplitterNodeOutput + _k2, i);\n                          }\n                          outputChannelSplitterNodeOutput += outputChannelCount[_j2];\n                        }\n                      }\n                      if (activeSourceFlag) {\n                        _context.next = 9;\n                        break;\n                      }\n                      return _context.abrupt(\"return\", 0);\n                    case 9:\n                      _context.next = 15;\n                      break;\n                    case 11:\n                      _context.prev = 11;\n                      _context.t0 = _context[\"catch\"](3);\n                      proxy.dispatchEvent(new ErrorEvent('processorerror', {\n                        colno: _context.t0.colno,\n                        filename: _context.t0.filename,\n                        lineno: _context.t0.lineno,\n                        message: _context.t0.message\n                      }));\n                      return _context.abrupt(\"return\", 0);\n                    case 15:\n                    case \"end\":\n                      return _context.stop();\n                  }\n                }, _loop, null, [[3, 11]]);\n              });\n              i = 0;\n            case 15:\n              if (!(i < length)) {\n                _context2.next = 23;\n                break;\n              }\n              return _context2.delegateYield(_loop(i), \"t0\", 17);\n            case 17:\n              _ret = _context2.t0;\n              if (!(_ret === 0)) {\n                _context2.next = 20;\n                break;\n              }\n              return _context2.abrupt(\"break\", 23);\n            case 20:\n              i += 128;\n              _context2.next = 15;\n              break;\n            case 23:\n              return _context2.abrupt(\"return\", processedBuffer);\n            case 24:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee);\n      }));\n      return function processBuffer(_x, _x2, _x3, _x4, _x5, _x6, _x7) {\n        return _ref.apply(this, arguments);\n      };\n    }();\n    var createAudioWorkletNodeRendererFactory = function createAudioWorkletNodeRendererFactory(connectAudioParam, connectMultipleOutputs, createNativeAudioBufferSourceNode, createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeConstantSourceNode, createNativeGainNode, deleteUnrenderedAudioWorkletNode, disconnectMultipleOutputs, exposeCurrentFrameAndCurrentTime, getNativeAudioNode, nativeAudioWorkletNodeConstructor, nativeOfflineAudioContextConstructor, renderAutomation, renderInputsOfAudioNode, renderNativeOfflineAudioContext) {\n      return function (name, options, processorConstructor) {\n        var renderedNativeAudioNodes = new WeakMap();\n        var processedBufferPromise = null;\n        var createAudioNode = /*#__PURE__*/function () {\n          var _ref3 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee4(proxy, nativeOfflineAudioContext) {\n            var nativeAudioWorkletNode, nativeOutputNodes, nativeAudioWorkletNodeIsOwnedByContext, outputChannelCount, numberOfOutputChannels, outputChannelSplitterNode, outputChannelMergerNodes, i, outputGainNode, numberOfInputChannels, numberOfParameters, numberOfChannels, renderBuffer, processedBuffer, audioBufferSourceNode, _nativeOutputNodes, _nativeOutputNodes2, _outputChannelSplitterNode, _outputChannelMergerNodes, _outputGainNode, _i3, outputChannelSplitterNodeOutput, outputChannelMergerNode, j, _iterator2, _step2, _step2$value, nm, audioParam, _iterator3, _step3, _step3$value, _nm, _audioParam;\n            return _regeneratorRuntime.wrap(function _callee4$(_context5) {\n              while (1) switch (_context5.prev = _context5.next) {\n                case 0:\n                  nativeAudioWorkletNode = getNativeAudioNode(proxy);\n                  nativeOutputNodes = null;\n                  nativeAudioWorkletNodeIsOwnedByContext = isOwnedByContext(nativeAudioWorkletNode, nativeOfflineAudioContext);\n                  outputChannelCount = Array.isArray(options.outputChannelCount) ? options.outputChannelCount : Array.from(options.outputChannelCount); // Bug #61: Only Chrome, Edge & Firefox have an implementation of the AudioWorkletNode yet.\n                  if (nativeAudioWorkletNodeConstructor === null) {\n                    numberOfOutputChannels = outputChannelCount.reduce(function (sum, value) {\n                      return sum + value;\n                    }, 0);\n                    outputChannelSplitterNode = createNativeChannelSplitterNode(nativeOfflineAudioContext, {\n                      channelCount: Math.max(1, numberOfOutputChannels),\n                      channelCountMode: 'explicit',\n                      channelInterpretation: 'discrete',\n                      numberOfOutputs: Math.max(1, numberOfOutputChannels)\n                    });\n                    outputChannelMergerNodes = [];\n                    for (i = 0; i < proxy.numberOfOutputs; i += 1) {\n                      outputChannelMergerNodes.push(createNativeChannelMergerNode(nativeOfflineAudioContext, {\n                        channelCount: 1,\n                        channelCountMode: 'explicit',\n                        channelInterpretation: 'speakers',\n                        numberOfInputs: outputChannelCount[i]\n                      }));\n                    }\n                    outputGainNode = createNativeGainNode(nativeOfflineAudioContext, {\n                      channelCount: options.channelCount,\n                      channelCountMode: options.channelCountMode,\n                      channelInterpretation: options.channelInterpretation,\n                      gain: 1\n                    });\n                    outputGainNode.connect = connectMultipleOutputs.bind(null, outputChannelMergerNodes);\n                    outputGainNode.disconnect = disconnectMultipleOutputs.bind(null, outputChannelMergerNodes);\n                    nativeOutputNodes = [outputChannelSplitterNode, outputChannelMergerNodes, outputGainNode];\n                  } else if (!nativeAudioWorkletNodeIsOwnedByContext) {\n                    nativeAudioWorkletNode = new nativeAudioWorkletNodeConstructor(nativeOfflineAudioContext, name);\n                  }\n                  renderedNativeAudioNodes.set(nativeOfflineAudioContext, nativeOutputNodes === null ? nativeAudioWorkletNode : nativeOutputNodes[2]);\n                  if (!(nativeOutputNodes !== null)) {\n                    _context5.next = 41;\n                    break;\n                  }\n                  if (!(processedBufferPromise === null)) {\n                    _context5.next = 32;\n                    break;\n                  }\n                  if (!(processorConstructor === undefined)) {\n                    _context5.next = 10;\n                    break;\n                  }\n                  throw new Error('Missing the processor constructor.');\n                case 10:\n                  if (!(nativeOfflineAudioContextConstructor === null)) {\n                    _context5.next = 12;\n                    break;\n                  }\n                  throw new Error('Missing the native OfflineAudioContext constructor.');\n                case 12:\n                  // Bug #47: The AudioDestinationNode in Safari gets not initialized correctly.\n                  numberOfInputChannels = proxy.channelCount * proxy.numberOfInputs;\n                  numberOfParameters = processorConstructor.parameterDescriptors === undefined ? 0 : processorConstructor.parameterDescriptors.length;\n                  numberOfChannels = numberOfInputChannels + numberOfParameters;\n                  renderBuffer = /*#__PURE__*/function () {\n                    var _ref4 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n                      var partialOfflineAudioContext, gainNodes, inputChannelSplitterNodes, _i, constantSourceNodes, inputChannelMergerNode, _i2, j, _iterator, _step, _step$value, index, constantSourceNode;\n                      return _regeneratorRuntime.wrap(function _callee3$(_context4) {\n                        while (1) switch (_context4.prev = _context4.next) {\n                          case 0:\n                            partialOfflineAudioContext = new nativeOfflineAudioContextConstructor(numberOfChannels,\n                            // Ceil the length to the next full render quantum.\n                            // Bug #17: Safari does not yet expose the length.\n                            Math.ceil(proxy.context.length / 128) * 128, nativeOfflineAudioContext.sampleRate);\n                            gainNodes = [];\n                            inputChannelSplitterNodes = [];\n                            for (_i = 0; _i < options.numberOfInputs; _i += 1) {\n                              gainNodes.push(createNativeGainNode(partialOfflineAudioContext, {\n                                channelCount: options.channelCount,\n                                channelCountMode: options.channelCountMode,\n                                channelInterpretation: options.channelInterpretation,\n                                gain: 1\n                              }));\n                              inputChannelSplitterNodes.push(createNativeChannelSplitterNode(partialOfflineAudioContext, {\n                                channelCount: options.channelCount,\n                                channelCountMode: 'explicit',\n                                channelInterpretation: 'discrete',\n                                numberOfOutputs: options.channelCount\n                              }));\n                            }\n                            _context4.next = 6;\n                            return Promise.all(Array.from(proxy.parameters.values()).map(/*#__PURE__*/function () {\n                              var _ref5 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee2(audioParam) {\n                                var constantSourceNode;\n                                return _regeneratorRuntime.wrap(function _callee2$(_context3) {\n                                  while (1) switch (_context3.prev = _context3.next) {\n                                    case 0:\n                                      constantSourceNode = createNativeConstantSourceNode(partialOfflineAudioContext, {\n                                        channelCount: 1,\n                                        channelCountMode: 'explicit',\n                                        channelInterpretation: 'discrete',\n                                        offset: audioParam.value\n                                      });\n                                      _context3.next = 3;\n                                      return renderAutomation(partialOfflineAudioContext, audioParam, constantSourceNode.offset);\n                                    case 3:\n                                      return _context3.abrupt(\"return\", constantSourceNode);\n                                    case 4:\n                                    case \"end\":\n                                      return _context3.stop();\n                                  }\n                                }, _callee2);\n                              }));\n                              return function (_x10) {\n                                return _ref5.apply(this, arguments);\n                              };\n                            }()));\n                          case 6:\n                            constantSourceNodes = _context4.sent;\n                            inputChannelMergerNode = createNativeChannelMergerNode(partialOfflineAudioContext, {\n                              channelCount: 1,\n                              channelCountMode: 'explicit',\n                              channelInterpretation: 'speakers',\n                              numberOfInputs: Math.max(1, numberOfInputChannels + numberOfParameters)\n                            });\n                            for (_i2 = 0; _i2 < options.numberOfInputs; _i2 += 1) {\n                              gainNodes[_i2].connect(inputChannelSplitterNodes[_i2]);\n                              for (j = 0; j < options.channelCount; j += 1) {\n                                inputChannelSplitterNodes[_i2].connect(inputChannelMergerNode, j, _i2 * options.channelCount + j);\n                              }\n                            }\n                            _iterator = _createForOfIteratorHelper$4(constantSourceNodes.entries());\n                            try {\n                              for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                                _step$value = _slicedToArray(_step.value, 2), index = _step$value[0], constantSourceNode = _step$value[1];\n                                constantSourceNode.connect(inputChannelMergerNode, 0, numberOfInputChannels + index);\n                                constantSourceNode.start(0);\n                              }\n                            } catch (err) {\n                              _iterator.e(err);\n                            } finally {\n                              _iterator.f();\n                            }\n                            inputChannelMergerNode.connect(partialOfflineAudioContext.destination);\n                            _context4.next = 14;\n                            return Promise.all(gainNodes.map(function (gainNode) {\n                              return renderInputsOfAudioNode(proxy, partialOfflineAudioContext, gainNode);\n                            }));\n                          case 14:\n                            return _context4.abrupt(\"return\", renderNativeOfflineAudioContext(partialOfflineAudioContext));\n                          case 15:\n                          case \"end\":\n                            return _context4.stop();\n                        }\n                      }, _callee3);\n                    }));\n                    return function renderBuffer() {\n                      return _ref4.apply(this, arguments);\n                    };\n                  }();\n                  _context5.t0 = processBuffer;\n                  _context5.t1 = proxy;\n                  if (!(numberOfChannels === 0)) {\n                    _context5.next = 22;\n                    break;\n                  }\n                  _context5.t2 = null;\n                  _context5.next = 25;\n                  break;\n                case 22:\n                  _context5.next = 24;\n                  return renderBuffer();\n                case 24:\n                  _context5.t2 = _context5.sent;\n                case 25:\n                  _context5.t3 = _context5.t2;\n                  _context5.t4 = nativeOfflineAudioContext;\n                  _context5.t5 = options;\n                  _context5.t6 = outputChannelCount;\n                  _context5.t7 = processorConstructor;\n                  _context5.t8 = exposeCurrentFrameAndCurrentTime;\n                  processedBufferPromise = (0, _context5.t0)(_context5.t1, _context5.t3, _context5.t4, _context5.t5, _context5.t6, _context5.t7, _context5.t8);\n                case 32:\n                  _context5.next = 34;\n                  return processedBufferPromise;\n                case 34:\n                  processedBuffer = _context5.sent;\n                  audioBufferSourceNode = createNativeAudioBufferSourceNode(nativeOfflineAudioContext, {\n                    buffer: null,\n                    channelCount: 2,\n                    channelCountMode: 'max',\n                    channelInterpretation: 'speakers',\n                    loop: false,\n                    loopEnd: 0,\n                    loopStart: 0,\n                    playbackRate: 1\n                  });\n                  _nativeOutputNodes = nativeOutputNodes, _nativeOutputNodes2 = _slicedToArray(_nativeOutputNodes, 3), _outputChannelSplitterNode = _nativeOutputNodes2[0], _outputChannelMergerNodes = _nativeOutputNodes2[1], _outputGainNode = _nativeOutputNodes2[2];\n                  if (processedBuffer !== null) {\n                    audioBufferSourceNode.buffer = processedBuffer;\n                    audioBufferSourceNode.start(0);\n                  }\n                  audioBufferSourceNode.connect(_outputChannelSplitterNode);\n                  for (_i3 = 0, outputChannelSplitterNodeOutput = 0; _i3 < proxy.numberOfOutputs; _i3 += 1) {\n                    outputChannelMergerNode = _outputChannelMergerNodes[_i3];\n                    for (j = 0; j < outputChannelCount[_i3]; j += 1) {\n                      _outputChannelSplitterNode.connect(outputChannelMergerNode, outputChannelSplitterNodeOutput + j, j);\n                    }\n                    outputChannelSplitterNodeOutput += outputChannelCount[_i3];\n                  }\n                  return _context5.abrupt(\"return\", _outputGainNode);\n                case 41:\n                  if (nativeAudioWorkletNodeIsOwnedByContext) {\n                    _context5.next = 61;\n                    break;\n                  }\n                  _iterator2 = _createForOfIteratorHelper$4(proxy.parameters.entries());\n                  _context5.prev = 43;\n                  _iterator2.s();\n                case 45:\n                  if ((_step2 = _iterator2.n()).done) {\n                    _context5.next = 51;\n                    break;\n                  }\n                  _step2$value = _slicedToArray(_step2.value, 2), nm = _step2$value[0], audioParam = _step2$value[1];\n                  _context5.next = 49;\n                  return renderAutomation(nativeOfflineAudioContext, audioParam,\n                  // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\n                  nativeAudioWorkletNode.parameters.get(nm));\n                case 49:\n                  _context5.next = 45;\n                  break;\n                case 51:\n                  _context5.next = 56;\n                  break;\n                case 53:\n                  _context5.prev = 53;\n                  _context5.t9 = _context5[\"catch\"](43);\n                  _iterator2.e(_context5.t9);\n                case 56:\n                  _context5.prev = 56;\n                  _iterator2.f();\n                  return _context5.finish(56);\n                case 59:\n                  _context5.next = 78;\n                  break;\n                case 61:\n                  _iterator3 = _createForOfIteratorHelper$4(proxy.parameters.entries());\n                  _context5.prev = 62;\n                  _iterator3.s();\n                case 64:\n                  if ((_step3 = _iterator3.n()).done) {\n                    _context5.next = 70;\n                    break;\n                  }\n                  _step3$value = _slicedToArray(_step3.value, 2), _nm = _step3$value[0], _audioParam = _step3$value[1];\n                  _context5.next = 68;\n                  return connectAudioParam(nativeOfflineAudioContext, _audioParam,\n                  // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\n                  nativeAudioWorkletNode.parameters.get(_nm));\n                case 68:\n                  _context5.next = 64;\n                  break;\n                case 70:\n                  _context5.next = 75;\n                  break;\n                case 72:\n                  _context5.prev = 72;\n                  _context5.t10 = _context5[\"catch\"](62);\n                  _iterator3.e(_context5.t10);\n                case 75:\n                  _context5.prev = 75;\n                  _iterator3.f();\n                  return _context5.finish(75);\n                case 78:\n                  _context5.next = 80;\n                  return renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioWorkletNode);\n                case 80:\n                  return _context5.abrupt(\"return\", nativeAudioWorkletNode);\n                case 81:\n                case \"end\":\n                  return _context5.stop();\n              }\n            }, _callee4, null, [[43, 53, 56, 59], [62, 72, 75, 78]]);\n          }));\n          return function createAudioNode(_x8, _x9) {\n            return _ref3.apply(this, arguments);\n          };\n        }();\n        return {\n          render: function render(proxy, nativeOfflineAudioContext) {\n            deleteUnrenderedAudioWorkletNode(nativeOfflineAudioContext, proxy);\n            var renderedNativeAudioWorkletNodeOrGainNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);\n            if (renderedNativeAudioWorkletNodeOrGainNode !== undefined) {\n              return Promise.resolve(renderedNativeAudioWorkletNodeOrGainNode);\n            }\n            return createAudioNode(proxy, nativeOfflineAudioContext);\n          }\n        };\n      };\n    };\n\n    function ownKeys$r(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\n    function _objectSpread$r(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$r(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$r(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n    function _callSuper$l(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$l() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\n    function _isNativeReflectConstruct$l() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$l = function _isNativeReflectConstruct() { return !!t; })(); }\n    var createBaseAudioContextConstructor = function createBaseAudioContextConstructor(addAudioWorkletModule, analyserNodeConstructor, audioBufferConstructor, audioBufferSourceNodeConstructor, biquadFilterNodeConstructor, channelMergerNodeConstructor, channelSplitterNodeConstructor, constantSourceNodeConstructor, convolverNodeConstructor, _decodeAudioData, delayNodeConstructor, dynamicsCompressorNodeConstructor, gainNodeConstructor, iIRFilterNodeConstructor, minimalBaseAudioContextConstructor, oscillatorNodeConstructor, pannerNodeConstructor, periodicWaveConstructor, stereoPannerNodeConstructor, waveShaperNodeConstructor) {\n      return /*#__PURE__*/function (_minimalBaseAudioCont) {\n        function BaseAudioContext(_nativeContext, numberOfChannels) {\n          var _this;\n          _classCallCheck(this, BaseAudioContext);\n          _this = _callSuper$l(this, BaseAudioContext, [_nativeContext, numberOfChannels]);\n          _this._nativeContext = _nativeContext;\n          _this._audioWorklet = addAudioWorkletModule === undefined ? undefined : {\n            addModule: function addModule(moduleURL, options) {\n              return addAudioWorkletModule(_this, moduleURL, options);\n            }\n          };\n          return _this;\n        }\n        _inherits(BaseAudioContext, _minimalBaseAudioCont);\n        return _createClass(BaseAudioContext, [{\n          key: \"audioWorklet\",\n          get: function get() {\n            return this._audioWorklet;\n          }\n        }, {\n          key: \"createAnalyser\",\n          value: function createAnalyser() {\n            return new analyserNodeConstructor(this);\n          }\n        }, {\n          key: \"createBiquadFilter\",\n          value: function createBiquadFilter() {\n            return new biquadFilterNodeConstructor(this);\n          }\n        }, {\n          key: \"createBuffer\",\n          value: function createBuffer(numberOfChannels, length, sampleRate) {\n            return new audioBufferConstructor({\n              length: length,\n              numberOfChannels: numberOfChannels,\n              sampleRate: sampleRate\n            });\n          }\n        }, {\n          key: \"createBufferSource\",\n          value: function createBufferSource() {\n            return new audioBufferSourceNodeConstructor(this);\n          }\n        }, {\n          key: \"createChannelMerger\",\n          value: function createChannelMerger() {\n            var numberOfInputs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 6;\n            return new channelMergerNodeConstructor(this, {\n              numberOfInputs: numberOfInputs\n            });\n          }\n        }, {\n          key: \"createChannelSplitter\",\n          value: function createChannelSplitter() {\n            var numberOfOutputs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 6;\n            return new channelSplitterNodeConstructor(this, {\n              numberOfOutputs: numberOfOutputs\n            });\n          }\n        }, {\n          key: \"createConstantSource\",\n          value: function createConstantSource() {\n            return new constantSourceNodeConstructor(this);\n          }\n        }, {\n          key: \"createConvolver\",\n          value: function createConvolver() {\n            return new convolverNodeConstructor(this);\n          }\n        }, {\n          key: \"createDelay\",\n          value: function createDelay() {\n            var maxDelayTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n            return new delayNodeConstructor(this, {\n              maxDelayTime: maxDelayTime\n            });\n          }\n        }, {\n          key: \"createDynamicsCompressor\",\n          value: function createDynamicsCompressor() {\n            return new dynamicsCompressorNodeConstructor(this);\n          }\n        }, {\n          key: \"createGain\",\n          value: function createGain() {\n            return new gainNodeConstructor(this);\n          }\n        }, {\n          key: \"createIIRFilter\",\n          value: function createIIRFilter(feedforward, feedback) {\n            return new iIRFilterNodeConstructor(this, {\n              feedback: feedback,\n              feedforward: feedforward\n            });\n          }\n        }, {\n          key: \"createOscillator\",\n          value: function createOscillator() {\n            return new oscillatorNodeConstructor(this);\n          }\n        }, {\n          key: \"createPanner\",\n          value: function createPanner() {\n            return new pannerNodeConstructor(this);\n          }\n        }, {\n          key: \"createPeriodicWave\",\n          value: function createPeriodicWave(real, imag) {\n            var constraints = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n              disableNormalization: false\n            };\n            return new periodicWaveConstructor(this, _objectSpread$r(_objectSpread$r({}, constraints), {}, {\n              imag: imag,\n              real: real\n            }));\n          }\n        }, {\n          key: \"createStereoPanner\",\n          value: function createStereoPanner() {\n            return new stereoPannerNodeConstructor(this);\n          }\n        }, {\n          key: \"createWaveShaper\",\n          value: function createWaveShaper() {\n            return new waveShaperNodeConstructor(this);\n          }\n        }, {\n          key: \"decodeAudioData\",\n          value: function decodeAudioData(audioData, successCallback, errorCallback) {\n            return _decodeAudioData(this._nativeContext, audioData).then(function (audioBuffer) {\n              if (typeof successCallback === 'function') {\n                successCallback(audioBuffer);\n              }\n              return audioBuffer;\n            }, function (err) {\n              if (typeof errorCallback === 'function') {\n                errorCallback(err);\n              }\n              throw err;\n            });\n          }\n        }]);\n      }(minimalBaseAudioContextConstructor);\n    };\n\n    function ownKeys$q(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\n    function _objectSpread$q(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$q(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$q(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n    function _callSuper$k(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$k() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\n    function _isNativeReflectConstruct$k() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$k = function _isNativeReflectConstruct() { return !!t; })(); }\n    var DEFAULT_OPTIONS$g = {\n      Q: 1,\n      channelCount: 2,\n      channelCountMode: 'max',\n      channelInterpretation: 'speakers',\n      detune: 0,\n      frequency: 350,\n      gain: 0,\n      type: 'lowpass'\n    };\n    var createBiquadFilterNodeConstructor = function createBiquadFilterNodeConstructor(audioNodeConstructor, createAudioParam, createBiquadFilterNodeRenderer, createInvalidAccessError, createNativeBiquadFilterNode, getNativeContext, isNativeOfflineAudioContext, setAudioNodeTailTime) {\n      return /*#__PURE__*/function (_audioNodeConstructor) {\n        function BiquadFilterNode(context, options) {\n          var _this;\n          _classCallCheck(this, BiquadFilterNode);\n          var nativeContext = getNativeContext(context);\n          var mergedOptions = _objectSpread$q(_objectSpread$q({}, DEFAULT_OPTIONS$g), options);\n          var nativeBiquadFilterNode = createNativeBiquadFilterNode(nativeContext, mergedOptions);\n          var isOffline = isNativeOfflineAudioContext(nativeContext);\n          var biquadFilterNodeRenderer = isOffline ? createBiquadFilterNodeRenderer() : null;\n          _this = _callSuper$k(this, BiquadFilterNode, [context, false, nativeBiquadFilterNode, biquadFilterNodeRenderer]);\n          // Bug #80: Safari does not export the correct values for maxValue and minValue.\n          _this._Q = createAudioParam(_this, isOffline, nativeBiquadFilterNode.Q, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n          // Bug #78: Firefox & Safari do not export the correct values for maxValue and minValue.\n          _this._detune = createAudioParam(_this, isOffline, nativeBiquadFilterNode.detune, 1200 * Math.log2(MOST_POSITIVE_SINGLE_FLOAT), -1200 * Math.log2(MOST_POSITIVE_SINGLE_FLOAT));\n          // Bug #77: Firefox & Safari do not export the correct value for minValue.\n          _this._frequency = createAudioParam(_this, isOffline, nativeBiquadFilterNode.frequency, context.sampleRate / 2, 0);\n          // Bug #79: Firefox & Safari do not export the correct values for maxValue and minValue.\n          _this._gain = createAudioParam(_this, isOffline, nativeBiquadFilterNode.gain, 40 * Math.log10(MOST_POSITIVE_SINGLE_FLOAT), MOST_NEGATIVE_SINGLE_FLOAT);\n          _this._nativeBiquadFilterNode = nativeBiquadFilterNode;\n          // @todo Determine a meaningful tail-time instead of just using one second.\n          setAudioNodeTailTime(_this, 1);\n          return _this;\n        }\n        _inherits(BiquadFilterNode, _audioNodeConstructor);\n        return _createClass(BiquadFilterNode, [{\n          key: \"detune\",\n          get: function get() {\n            return this._detune;\n          }\n        }, {\n          key: \"frequency\",\n          get: function get() {\n            return this._frequency;\n          }\n        }, {\n          key: \"gain\",\n          get: function get() {\n            return this._gain;\n          }\n        }, {\n          key: \"Q\",\n          get: function get() {\n            return this._Q;\n          }\n        }, {\n          key: \"type\",\n          get: function get() {\n            return this._nativeBiquadFilterNode.type;\n          },\n          set: function set(value) {\n            this._nativeBiquadFilterNode.type = value;\n          }\n        }, {\n          key: \"getFrequencyResponse\",\n          value: function getFrequencyResponse(frequencyHz, magResponse, phaseResponse) {\n            // Bug #189: Safari does throw an InvalidStateError.\n            try {\n              this._nativeBiquadFilterNode.getFrequencyResponse(frequencyHz, magResponse, phaseResponse);\n            } catch (err) {\n              if (err.code === 11) {\n                throw createInvalidAccessError();\n              }\n              throw err;\n            }\n            // Bug #68: Safari does not throw an error if the parameters differ in their length.\n            if (frequencyHz.length !== magResponse.length || magResponse.length !== phaseResponse.length) {\n              throw createInvalidAccessError();\n            }\n          }\n        }]);\n      }(audioNodeConstructor);\n    };\n\n    var createBiquadFilterNodeRendererFactory = function createBiquadFilterNodeRendererFactory(connectAudioParam, createNativeBiquadFilterNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode) {\n      return function () {\n        var renderedNativeBiquadFilterNodes = new WeakMap();\n        var createBiquadFilterNode = /*#__PURE__*/function () {\n          var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(proxy, nativeOfflineAudioContext) {\n            var nativeBiquadFilterNode, nativeBiquadFilterNodeIsOwnedByContext, options;\n            return _regeneratorRuntime.wrap(function _callee$(_context) {\n              while (1) switch (_context.prev = _context.next) {\n                case 0:\n                  nativeBiquadFilterNode = getNativeAudioNode(proxy);\n                  /*\n                   * If the initially used nativeBiquadFilterNode was not constructed on the same OfflineAudioContext it needs to be created\n                   * again.\n                   */\n                  nativeBiquadFilterNodeIsOwnedByContext = isOwnedByContext(nativeBiquadFilterNode, nativeOfflineAudioContext);\n                  if (!nativeBiquadFilterNodeIsOwnedByContext) {\n                    options = {\n                      Q: nativeBiquadFilterNode.Q.value,\n                      channelCount: nativeBiquadFilterNode.channelCount,\n                      channelCountMode: nativeBiquadFilterNode.channelCountMode,\n                      channelInterpretation: nativeBiquadFilterNode.channelInterpretation,\n                      detune: nativeBiquadFilterNode.detune.value,\n                      frequency: nativeBiquadFilterNode.frequency.value,\n                      gain: nativeBiquadFilterNode.gain.value,\n                      type: nativeBiquadFilterNode.type\n                    };\n                    nativeBiquadFilterNode = createNativeBiquadFilterNode(nativeOfflineAudioContext, options);\n                  }\n                  renderedNativeBiquadFilterNodes.set(nativeOfflineAudioContext, nativeBiquadFilterNode);\n                  if (nativeBiquadFilterNodeIsOwnedByContext) {\n                    _context.next = 15;\n                    break;\n                  }\n                  _context.next = 7;\n                  return renderAutomation(nativeOfflineAudioContext, proxy.Q, nativeBiquadFilterNode.Q);\n                case 7:\n                  _context.next = 9;\n                  return renderAutomation(nativeOfflineAudioContext, proxy.detune, nativeBiquadFilterNode.detune);\n                case 9:\n                  _context.next = 11;\n                  return renderAutomation(nativeOfflineAudioContext, proxy.frequency, nativeBiquadFilterNode.frequency);\n                case 11:\n                  _context.next = 13;\n                  return renderAutomation(nativeOfflineAudioContext, proxy.gain, nativeBiquadFilterNode.gain);\n                case 13:\n                  _context.next = 23;\n                  break;\n                case 15:\n                  _context.next = 17;\n                  return connectAudioParam(nativeOfflineAudioContext, proxy.Q, nativeBiquadFilterNode.Q);\n                case 17:\n                  _context.next = 19;\n                  return connectAudioParam(nativeOfflineAudioContext, proxy.detune, nativeBiquadFilterNode.detune);\n                case 19:\n                  _context.next = 21;\n                  return connectAudioParam(nativeOfflineAudioContext, proxy.frequency, nativeBiquadFilterNode.frequency);\n                case 21:\n                  _context.next = 23;\n                  return connectAudioParam(nativeOfflineAudioContext, proxy.gain, nativeBiquadFilterNode.gain);\n                case 23:\n                  _context.next = 25;\n                  return renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeBiquadFilterNode);\n                case 25:\n                  return _context.abrupt(\"return\", nativeBiquadFilterNode);\n                case 26:\n                case \"end\":\n                  return _context.stop();\n              }\n            }, _callee);\n          }));\n          return function createBiquadFilterNode(_x, _x2) {\n            return _ref.apply(this, arguments);\n          };\n        }();\n        return {\n          render: function render(proxy, nativeOfflineAudioContext) {\n            var renderedNativeBiquadFilterNode = renderedNativeBiquadFilterNodes.get(nativeOfflineAudioContext);\n            if (renderedNativeBiquadFilterNode !== undefined) {\n              return Promise.resolve(renderedNativeBiquadFilterNode);\n            }\n            return createBiquadFilterNode(proxy, nativeOfflineAudioContext);\n          }\n        };\n      };\n    };\n\n    var createCacheTestResult = function createCacheTestResult(ongoingTests, testResults) {\n      return function (tester, test) {\n        var cachedTestResult = testResults.get(tester);\n        if (cachedTestResult !== undefined) {\n          return cachedTestResult;\n        }\n        var ongoingTest = ongoingTests.get(tester);\n        if (ongoingTest !== undefined) {\n          return ongoingTest;\n        }\n        try {\n          var synchronousTestResult = test();\n          if (synchronousTestResult instanceof Promise) {\n            ongoingTests.set(tester, synchronousTestResult);\n            return synchronousTestResult[\"catch\"](function () {\n              return false;\n            }).then(function (finalTestResult) {\n              ongoingTests[\"delete\"](tester);\n              testResults.set(tester, finalTestResult);\n              return finalTestResult;\n            });\n          }\n          testResults.set(tester, synchronousTestResult);\n          return synchronousTestResult;\n        } catch (_unused) {\n          testResults.set(tester, false);\n          return false;\n        }\n      };\n    };\n\n    function ownKeys$p(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\n    function _objectSpread$p(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$p(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$p(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n    function _callSuper$j(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$j() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\n    function _isNativeReflectConstruct$j() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$j = function _isNativeReflectConstruct() { return !!t; })(); }\n    var DEFAULT_OPTIONS$f = {\n      channelCount: 1,\n      channelCountMode: 'explicit',\n      channelInterpretation: 'speakers',\n      numberOfInputs: 6\n    };\n    var createChannelMergerNodeConstructor = function createChannelMergerNodeConstructor(audioNodeConstructor, createChannelMergerNodeRenderer, createNativeChannelMergerNode, getNativeContext, isNativeOfflineAudioContext) {\n      return /*#__PURE__*/function (_audioNodeConstructor) {\n        function ChannelMergerNode(context, options) {\n          _classCallCheck(this, ChannelMergerNode);\n          var nativeContext = getNativeContext(context);\n          var mergedOptions = _objectSpread$p(_objectSpread$p({}, DEFAULT_OPTIONS$f), options);\n          var nativeChannelMergerNode = createNativeChannelMergerNode(nativeContext, mergedOptions);\n          var channelMergerNodeRenderer = isNativeOfflineAudioContext(nativeContext) ? createChannelMergerNodeRenderer() : null;\n          return _callSuper$j(this, ChannelMergerNode, [context, false, nativeChannelMergerNode, channelMergerNodeRenderer]);\n        }\n        _inherits(ChannelMergerNode, _audioNodeConstructor);\n        return _createClass(ChannelMergerNode);\n      }(audioNodeConstructor);\n    };\n\n    var createChannelMergerNodeRendererFactory = function createChannelMergerNodeRendererFactory(createNativeChannelMergerNode, getNativeAudioNode, renderInputsOfAudioNode) {\n      return function () {\n        var renderedNativeAudioNodes = new WeakMap();\n        var createAudioNode = /*#__PURE__*/function () {\n          var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(proxy, nativeOfflineAudioContext) {\n            var nativeAudioNode, nativeAudioNodeIsOwnedByContext, options;\n            return _regeneratorRuntime.wrap(function _callee$(_context) {\n              while (1) switch (_context.prev = _context.next) {\n                case 0:\n                  nativeAudioNode = getNativeAudioNode(proxy); // If the initially used nativeAudioNode was not constructed on the same OfflineAudioContext it needs to be created again.\n                  nativeAudioNodeIsOwnedByContext = isOwnedByContext(nativeAudioNode, nativeOfflineAudioContext);\n                  if (!nativeAudioNodeIsOwnedByContext) {\n                    options = {\n                      channelCount: nativeAudioNode.channelCount,\n                      channelCountMode: nativeAudioNode.channelCountMode,\n                      channelInterpretation: nativeAudioNode.channelInterpretation,\n                      numberOfInputs: nativeAudioNode.numberOfInputs\n                    };\n                    nativeAudioNode = createNativeChannelMergerNode(nativeOfflineAudioContext, options);\n                  }\n                  renderedNativeAudioNodes.set(nativeOfflineAudioContext, nativeAudioNode);\n                  _context.next = 6;\n                  return renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioNode);\n                case 6:\n                  return _context.abrupt(\"return\", nativeAudioNode);\n                case 7:\n                case \"end\":\n                  return _context.stop();\n              }\n            }, _callee);\n          }));\n          return function createAudioNode(_x, _x2) {\n            return _ref.apply(this, arguments);\n          };\n        }();\n        return {\n          render: function render(proxy, nativeOfflineAudioContext) {\n            var renderedNativeAudioNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);\n            if (renderedNativeAudioNode !== undefined) {\n              return Promise.resolve(renderedNativeAudioNode);\n            }\n            return createAudioNode(proxy, nativeOfflineAudioContext);\n          }\n        };\n      };\n    };\n\n    function ownKeys$o(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\n    function _objectSpread$o(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$o(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$o(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n    function _callSuper$i(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$i() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\n    function _isNativeReflectConstruct$i() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$i = function _isNativeReflectConstruct() { return !!t; })(); }\n    var DEFAULT_OPTIONS$e = {\n      channelCount: 6,\n      channelCountMode: 'explicit',\n      channelInterpretation: 'discrete',\n      numberOfOutputs: 6\n    };\n    var createChannelSplitterNodeConstructor = function createChannelSplitterNodeConstructor(audioNodeConstructor, createChannelSplitterNodeRenderer, createNativeChannelSplitterNode, getNativeContext, isNativeOfflineAudioContext, sanitizeChannelSplitterOptions) {\n      return /*#__PURE__*/function (_audioNodeConstructor) {\n        function ChannelSplitterNode(context, options) {\n          _classCallCheck(this, ChannelSplitterNode);\n          var nativeContext = getNativeContext(context);\n          var mergedOptions = sanitizeChannelSplitterOptions(_objectSpread$o(_objectSpread$o({}, DEFAULT_OPTIONS$e), options));\n          var nativeChannelSplitterNode = createNativeChannelSplitterNode(nativeContext, mergedOptions);\n          var channelSplitterNodeRenderer = isNativeOfflineAudioContext(nativeContext) ? createChannelSplitterNodeRenderer() : null;\n          return _callSuper$i(this, ChannelSplitterNode, [context, false, nativeChannelSplitterNode, channelSplitterNodeRenderer]);\n        }\n        _inherits(ChannelSplitterNode, _audioNodeConstructor);\n        return _createClass(ChannelSplitterNode);\n      }(audioNodeConstructor);\n    };\n\n    var createChannelSplitterNodeRendererFactory = function createChannelSplitterNodeRendererFactory(createNativeChannelSplitterNode, getNativeAudioNode, renderInputsOfAudioNode) {\n      return function () {\n        var renderedNativeAudioNodes = new WeakMap();\n        var createAudioNode = /*#__PURE__*/function () {\n          var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(proxy, nativeOfflineAudioContext) {\n            var nativeAudioNode, nativeAudioNodeIsOwnedByContext, options;\n            return _regeneratorRuntime.wrap(function _callee$(_context) {\n              while (1) switch (_context.prev = _context.next) {\n                case 0:\n                  nativeAudioNode = getNativeAudioNode(proxy); // If the initially used nativeAudioNode was not constructed on the same OfflineAudioContext it needs to be created again.\n                  nativeAudioNodeIsOwnedByContext = isOwnedByContext(nativeAudioNode, nativeOfflineAudioContext);\n                  if (!nativeAudioNodeIsOwnedByContext) {\n                    options = {\n                      channelCount: nativeAudioNode.channelCount,\n                      channelCountMode: nativeAudioNode.channelCountMode,\n                      channelInterpretation: nativeAudioNode.channelInterpretation,\n                      numberOfOutputs: nativeAudioNode.numberOfOutputs\n                    };\n                    nativeAudioNode = createNativeChannelSplitterNode(nativeOfflineAudioContext, options);\n                  }\n                  renderedNativeAudioNodes.set(nativeOfflineAudioContext, nativeAudioNode);\n                  _context.next = 6;\n                  return renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioNode);\n                case 6:\n                  return _context.abrupt(\"return\", nativeAudioNode);\n                case 7:\n                case \"end\":\n                  return _context.stop();\n              }\n            }, _callee);\n          }));\n          return function createAudioNode(_x, _x2) {\n            return _ref.apply(this, arguments);\n          };\n        }();\n        return {\n          render: function render(proxy, nativeOfflineAudioContext) {\n            var renderedNativeAudioNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);\n            if (renderedNativeAudioNode !== undefined) {\n              return Promise.resolve(renderedNativeAudioNode);\n            }\n            return createAudioNode(proxy, nativeOfflineAudioContext);\n          }\n        };\n      };\n    };\n\n    var createConnectAudioParam = function createConnectAudioParam(renderInputsOfAudioParam) {\n      return function (nativeOfflineAudioContext, audioParam, nativeAudioParam) {\n        return renderInputsOfAudioParam(audioParam, nativeOfflineAudioContext, nativeAudioParam);\n      };\n    };\n\n    var createConnectMultipleOutputs = function createConnectMultipleOutputs(createIndexSizeError) {\n      return function (outputAudioNodes, destination) {\n        var output = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n        var input = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n        var outputAudioNode = outputAudioNodes[output];\n        if (outputAudioNode === undefined) {\n          throw createIndexSizeError();\n        }\n        if (isNativeAudioNode$1(destination)) {\n          return outputAudioNode.connect(destination, 0, input);\n        }\n        return outputAudioNode.connect(destination, 0);\n      };\n    };\n\n    var createConnectedNativeAudioBufferSourceNodeFactory = function createConnectedNativeAudioBufferSourceNodeFactory(createNativeAudioBufferSourceNode) {\n      return function (nativeContext, nativeAudioNode) {\n        var nativeAudioBufferSourceNode = createNativeAudioBufferSourceNode(nativeContext, {\n          buffer: null,\n          channelCount: 2,\n          channelCountMode: 'max',\n          channelInterpretation: 'speakers',\n          loop: false,\n          loopEnd: 0,\n          loopStart: 0,\n          playbackRate: 1\n        });\n        var nativeAudioBuffer = nativeContext.createBuffer(1, 2, 44100);\n        nativeAudioBufferSourceNode.buffer = nativeAudioBuffer;\n        nativeAudioBufferSourceNode.loop = true;\n        nativeAudioBufferSourceNode.connect(nativeAudioNode);\n        nativeAudioBufferSourceNode.start();\n        return function () {\n          nativeAudioBufferSourceNode.stop();\n          nativeAudioBufferSourceNode.disconnect(nativeAudioNode);\n        };\n      };\n    };\n\n    function ownKeys$n(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\n    function _objectSpread$n(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$n(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$n(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n    function _callSuper$h(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$h() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\n    function _isNativeReflectConstruct$h() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$h = function _isNativeReflectConstruct() { return !!t; })(); }\n    var DEFAULT_OPTIONS$d = {\n      channelCount: 2,\n      channelCountMode: 'max',\n      channelInterpretation: 'speakers',\n      offset: 1\n    };\n    var createConstantSourceNodeConstructor = function createConstantSourceNodeConstructor(audioNodeConstructor, createAudioParam, createConstantSourceNodeRendererFactory, createNativeConstantSourceNode, getNativeContext, isNativeOfflineAudioContext, wrapEventListener) {\n      return /*#__PURE__*/function (_audioNodeConstructor) {\n        function ConstantSourceNode(context, options) {\n          var _this;\n          _classCallCheck(this, ConstantSourceNode);\n          var nativeContext = getNativeContext(context);\n          var mergedOptions = _objectSpread$n(_objectSpread$n({}, DEFAULT_OPTIONS$d), options);\n          var nativeConstantSourceNode = createNativeConstantSourceNode(nativeContext, mergedOptions);\n          var isOffline = isNativeOfflineAudioContext(nativeContext);\n          var constantSourceNodeRenderer = isOffline ? createConstantSourceNodeRendererFactory() : null;\n          _this = _callSuper$h(this, ConstantSourceNode, [context, false, nativeConstantSourceNode, constantSourceNodeRenderer]);\n          _this._constantSourceNodeRenderer = constantSourceNodeRenderer;\n          _this._nativeConstantSourceNode = nativeConstantSourceNode;\n          /*\n           * Bug #62 & #74: Safari does not support ConstantSourceNodes and does not export the correct values for maxValue and minValue\n           * for GainNodes.\n           */\n          _this._offset = createAudioParam(_this, isOffline, nativeConstantSourceNode.offset, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n          _this._onended = null;\n          return _this;\n        }\n        _inherits(ConstantSourceNode, _audioNodeConstructor);\n        return _createClass(ConstantSourceNode, [{\n          key: \"offset\",\n          get: function get() {\n            return this._offset;\n          }\n        }, {\n          key: \"onended\",\n          get: function get() {\n            return this._onended;\n          },\n          set: function set(value) {\n            var wrappedListener = typeof value === 'function' ? wrapEventListener(this, value) : null;\n            this._nativeConstantSourceNode.onended = wrappedListener;\n            var nativeOnEnded = this._nativeConstantSourceNode.onended;\n            this._onended = nativeOnEnded !== null && nativeOnEnded === wrappedListener ? value : nativeOnEnded;\n          }\n        }, {\n          key: \"start\",\n          value: function start() {\n            var _this2 = this;\n            var when = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n            this._nativeConstantSourceNode.start(when);\n            if (this._constantSourceNodeRenderer !== null) {\n              this._constantSourceNodeRenderer.start = when;\n            }\n            if (this.context.state !== 'closed') {\n              setInternalStateToActive(this);\n              var _resetInternalStateToPassive = function resetInternalStateToPassive() {\n                _this2._nativeConstantSourceNode.removeEventListener('ended', _resetInternalStateToPassive);\n                if (isActiveAudioNode(_this2)) {\n                  setInternalStateToPassive(_this2);\n                }\n              };\n              this._nativeConstantSourceNode.addEventListener('ended', _resetInternalStateToPassive);\n            }\n          }\n        }, {\n          key: \"stop\",\n          value: function stop() {\n            var when = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n            this._nativeConstantSourceNode.stop(when);\n            if (this._constantSourceNodeRenderer !== null) {\n              this._constantSourceNodeRenderer.stop = when;\n            }\n          }\n        }]);\n      }(audioNodeConstructor);\n    };\n\n    var createConstantSourceNodeRendererFactory = function createConstantSourceNodeRendererFactory(connectAudioParam, createNativeConstantSourceNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode) {\n      return function () {\n        var renderedNativeConstantSourceNodes = new WeakMap();\n        var start = null;\n        var stop = null;\n        var createConstantSourceNode = /*#__PURE__*/function () {\n          var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(proxy, nativeOfflineAudioContext) {\n            var nativeConstantSourceNode, nativeConstantSourceNodeIsOwnedByContext, options;\n            return _regeneratorRuntime.wrap(function _callee$(_context) {\n              while (1) switch (_context.prev = _context.next) {\n                case 0:\n                  nativeConstantSourceNode = getNativeAudioNode(proxy);\n                  /*\n                   * If the initially used nativeConstantSourceNode was not constructed on the same OfflineAudioContext it needs to be created\n                   * again.\n                   */\n                  nativeConstantSourceNodeIsOwnedByContext = isOwnedByContext(nativeConstantSourceNode, nativeOfflineAudioContext);\n                  if (!nativeConstantSourceNodeIsOwnedByContext) {\n                    options = {\n                      channelCount: nativeConstantSourceNode.channelCount,\n                      channelCountMode: nativeConstantSourceNode.channelCountMode,\n                      channelInterpretation: nativeConstantSourceNode.channelInterpretation,\n                      offset: nativeConstantSourceNode.offset.value\n                    };\n                    nativeConstantSourceNode = createNativeConstantSourceNode(nativeOfflineAudioContext, options);\n                    if (start !== null) {\n                      nativeConstantSourceNode.start(start);\n                    }\n                    if (stop !== null) {\n                      nativeConstantSourceNode.stop(stop);\n                    }\n                  }\n                  renderedNativeConstantSourceNodes.set(nativeOfflineAudioContext, nativeConstantSourceNode);\n                  if (nativeConstantSourceNodeIsOwnedByContext) {\n                    _context.next = 9;\n                    break;\n                  }\n                  _context.next = 7;\n                  return renderAutomation(nativeOfflineAudioContext, proxy.offset, nativeConstantSourceNode.offset);\n                case 7:\n                  _context.next = 11;\n                  break;\n                case 9:\n                  _context.next = 11;\n                  return connectAudioParam(nativeOfflineAudioContext, proxy.offset, nativeConstantSourceNode.offset);\n                case 11:\n                  _context.next = 13;\n                  return renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeConstantSourceNode);\n                case 13:\n                  return _context.abrupt(\"return\", nativeConstantSourceNode);\n                case 14:\n                case \"end\":\n                  return _context.stop();\n              }\n            }, _callee);\n          }));\n          return function createConstantSourceNode(_x, _x2) {\n            return _ref.apply(this, arguments);\n          };\n        }();\n        return {\n          set start(value) {\n            start = value;\n          },\n          set stop(value) {\n            stop = value;\n          },\n          render: function render(proxy, nativeOfflineAudioContext) {\n            var renderedNativeConstantSourceNode = renderedNativeConstantSourceNodes.get(nativeOfflineAudioContext);\n            if (renderedNativeConstantSourceNode !== undefined) {\n              return Promise.resolve(renderedNativeConstantSourceNode);\n            }\n            return createConstantSourceNode(proxy, nativeOfflineAudioContext);\n          }\n        };\n      };\n    };\n\n    var createConvertNumberToUnsignedLong = function createConvertNumberToUnsignedLong(unit32Array) {\n      return function (value) {\n        unit32Array[0] = value;\n        return unit32Array[0];\n      };\n    };\n\n    function ownKeys$m(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\n    function _objectSpread$m(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$m(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$m(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n    function _callSuper$g(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$g() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\n    function _isNativeReflectConstruct$g() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$g = function _isNativeReflectConstruct() { return !!t; })(); }\n    var DEFAULT_OPTIONS$c = {\n      buffer: null,\n      channelCount: 2,\n      channelCountMode: 'clamped-max',\n      channelInterpretation: 'speakers',\n      disableNormalization: false\n    };\n    var createConvolverNodeConstructor = function createConvolverNodeConstructor(audioNodeConstructor, createConvolverNodeRenderer, createNativeConvolverNode, getNativeContext, isNativeOfflineAudioContext, setAudioNodeTailTime) {\n      return /*#__PURE__*/function (_audioNodeConstructor) {\n        function ConvolverNode(context, options) {\n          var _this;\n          _classCallCheck(this, ConvolverNode);\n          var nativeContext = getNativeContext(context);\n          var mergedOptions = _objectSpread$m(_objectSpread$m({}, DEFAULT_OPTIONS$c), options);\n          var nativeConvolverNode = createNativeConvolverNode(nativeContext, mergedOptions);\n          var isOffline = isNativeOfflineAudioContext(nativeContext);\n          var convolverNodeRenderer = isOffline ? createConvolverNodeRenderer() : null;\n          _this = _callSuper$g(this, ConvolverNode, [context, false, nativeConvolverNode, convolverNodeRenderer]);\n          _this._isBufferNullified = false;\n          _this._nativeConvolverNode = nativeConvolverNode;\n          if (mergedOptions.buffer !== null) {\n            setAudioNodeTailTime(_this, mergedOptions.buffer.duration);\n          }\n          return _this;\n        }\n        _inherits(ConvolverNode, _audioNodeConstructor);\n        return _createClass(ConvolverNode, [{\n          key: \"buffer\",\n          get: function get() {\n            if (this._isBufferNullified) {\n              return null;\n            }\n            return this._nativeConvolverNode.buffer;\n          },\n          set: function set(value) {\n            this._nativeConvolverNode.buffer = value;\n            // Bug #115: Safari does not allow to set the buffer to null.\n            if (value === null && this._nativeConvolverNode.buffer !== null) {\n              var nativeContext = this._nativeConvolverNode.context;\n              this._nativeConvolverNode.buffer = nativeContext.createBuffer(1, 1, nativeContext.sampleRate);\n              this._isBufferNullified = true;\n              setAudioNodeTailTime(this, 0);\n            } else {\n              this._isBufferNullified = false;\n              setAudioNodeTailTime(this, this._nativeConvolverNode.buffer === null ? 0 : this._nativeConvolverNode.buffer.duration);\n            }\n          }\n        }, {\n          key: \"normalize\",\n          get: function get() {\n            return this._nativeConvolverNode.normalize;\n          },\n          set: function set(value) {\n            this._nativeConvolverNode.normalize = value;\n          }\n        }]);\n      }(audioNodeConstructor);\n    };\n\n    var createConvolverNodeRendererFactory = function createConvolverNodeRendererFactory(createNativeConvolverNode, getNativeAudioNode, renderInputsOfAudioNode) {\n      return function () {\n        var renderedNativeConvolverNodes = new WeakMap();\n        var createConvolverNode = /*#__PURE__*/function () {\n          var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(proxy, nativeOfflineAudioContext) {\n            var nativeConvolverNode, nativeConvolverNodeIsOwnedByContext, options;\n            return _regeneratorRuntime.wrap(function _callee$(_context) {\n              while (1) switch (_context.prev = _context.next) {\n                case 0:\n                  nativeConvolverNode = getNativeAudioNode(proxy); // If the initially used nativeConvolverNode was not constructed on the same OfflineAudioContext it needs to be created again.\n                  nativeConvolverNodeIsOwnedByContext = isOwnedByContext(nativeConvolverNode, nativeOfflineAudioContext);\n                  if (!nativeConvolverNodeIsOwnedByContext) {\n                    options = {\n                      buffer: nativeConvolverNode.buffer,\n                      channelCount: nativeConvolverNode.channelCount,\n                      channelCountMode: nativeConvolverNode.channelCountMode,\n                      channelInterpretation: nativeConvolverNode.channelInterpretation,\n                      disableNormalization: !nativeConvolverNode.normalize\n                    };\n                    nativeConvolverNode = createNativeConvolverNode(nativeOfflineAudioContext, options);\n                  }\n                  renderedNativeConvolverNodes.set(nativeOfflineAudioContext, nativeConvolverNode);\n                  if (!isNativeAudioNodeFaker(nativeConvolverNode)) {\n                    _context.next = 9;\n                    break;\n                  }\n                  _context.next = 7;\n                  return renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeConvolverNode.inputs[0]);\n                case 7:\n                  _context.next = 11;\n                  break;\n                case 9:\n                  _context.next = 11;\n                  return renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeConvolverNode);\n                case 11:\n                  return _context.abrupt(\"return\", nativeConvolverNode);\n                case 12:\n                case \"end\":\n                  return _context.stop();\n              }\n            }, _callee);\n          }));\n          return function createConvolverNode(_x, _x2) {\n            return _ref.apply(this, arguments);\n          };\n        }();\n        return {\n          render: function render(proxy, nativeOfflineAudioContext) {\n            var renderedNativeConvolverNode = renderedNativeConvolverNodes.get(nativeOfflineAudioContext);\n            if (renderedNativeConvolverNode !== undefined) {\n              return Promise.resolve(renderedNativeConvolverNode);\n            }\n            return createConvolverNode(proxy, nativeOfflineAudioContext);\n          }\n        };\n      };\n    };\n\n    var createCreateNativeOfflineAudioContext = function createCreateNativeOfflineAudioContext(createNotSupportedError, nativeOfflineAudioContextConstructor) {\n      return function (numberOfChannels, length, sampleRate) {\n        if (nativeOfflineAudioContextConstructor === null) {\n          throw new Error('Missing the native OfflineAudioContext constructor.');\n        }\n        try {\n          return new nativeOfflineAudioContextConstructor(numberOfChannels, length, sampleRate);\n        } catch (err) {\n          // Bug #143, #144 & #146: Safari throws a SyntaxError when numberOfChannels, length or sampleRate are invalid.\n          if (err.name === 'SyntaxError') {\n            throw createNotSupportedError();\n          }\n          throw err;\n        }\n      };\n    };\n\n    var createDataCloneError = function createDataCloneError() {\n      return new DOMException('', 'DataCloneError');\n    };\n\n    var detachArrayBuffer = function detachArrayBuffer(arrayBuffer) {\n      var _MessageChannel = new MessageChannel(),\n        port1 = _MessageChannel.port1,\n        port2 = _MessageChannel.port2;\n      return new Promise(function (resolve) {\n        var closeAndResolve = function closeAndResolve() {\n          port2.onmessage = null;\n          port1.close();\n          port2.close();\n          resolve();\n        };\n        port2.onmessage = function () {\n          return closeAndResolve();\n        };\n        try {\n          port1.postMessage(arrayBuffer, [arrayBuffer]);\n        } catch (_unused) {\n          // Ignore errors.\n        } finally {\n          closeAndResolve();\n        }\n      });\n    };\n\n    var createDecodeAudioData = function createDecodeAudioData(audioBufferStore, cacheTestResult, createDataCloneError, createEncodingError, detachedArrayBuffers, getNativeContext, isNativeContext, testAudioBufferCopyChannelMethodsOutOfBoundsSupport, testPromiseSupport, wrapAudioBufferCopyChannelMethods, wrapAudioBufferCopyChannelMethodsOutOfBounds) {\n      return function (anyContext, audioData) {\n        var nativeContext = isNativeContext(anyContext) ? anyContext : getNativeContext(anyContext);\n        // Bug #43: Only Chrome and Edge do throw a DataCloneError.\n        if (detachedArrayBuffers.has(audioData)) {\n          var err = createDataCloneError();\n          return Promise.reject(err);\n        }\n        // The audioData parameter maybe of a type which can't be added to a WeakSet.\n        try {\n          detachedArrayBuffers.add(audioData);\n        } catch (_unused) {\n          // Ignore errors.\n        }\n        // Bug #21: Safari does not support promises yet.\n        if (cacheTestResult(testPromiseSupport, function () {\n          return testPromiseSupport(nativeContext);\n        })) {\n          return nativeContext.decodeAudioData(audioData).then(function (audioBuffer) {\n            // Bug #133: Safari does neuter the ArrayBuffer.\n            detachArrayBuffer(audioData)[\"catch\"](function () {\n              // Ignore errors.\n            });\n            // Bug #157: Firefox does not allow the bufferOffset to be out-of-bounds.\n            if (!cacheTestResult(testAudioBufferCopyChannelMethodsOutOfBoundsSupport, function () {\n              return testAudioBufferCopyChannelMethodsOutOfBoundsSupport(audioBuffer);\n            })) {\n              wrapAudioBufferCopyChannelMethodsOutOfBounds(audioBuffer);\n            }\n            audioBufferStore.add(audioBuffer);\n            return audioBuffer;\n          });\n        }\n        // Bug #21: Safari does not return a Promise yet.\n        return new Promise(function (resolve, reject) {\n          var complete = /*#__PURE__*/function () {\n            var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n              return _regeneratorRuntime.wrap(function _callee$(_context) {\n                while (1) switch (_context.prev = _context.next) {\n                  case 0:\n                    _context.prev = 0;\n                    _context.next = 3;\n                    return detachArrayBuffer(audioData);\n                  case 3:\n                    _context.next = 7;\n                    break;\n                  case 5:\n                    _context.prev = 5;\n                    _context.t0 = _context[\"catch\"](0);\n                  case 7:\n                  case \"end\":\n                    return _context.stop();\n                }\n              }, _callee, null, [[0, 5]]);\n            }));\n            return function complete() {\n              return _ref.apply(this, arguments);\n            };\n          }();\n          var fail = function fail(err) {\n            reject(err);\n            complete();\n          };\n          // Bug #26: Safari throws a synchronous error.\n          try {\n            // Bug #1: Safari requires a successCallback.\n            nativeContext.decodeAudioData(audioData, function (audioBuffer) {\n              // Bug #5: Safari does not support copyFromChannel() and copyToChannel().\n              // Bug #100: Safari does throw a wrong error when calling getChannelData() with an out-of-bounds value.\n              if (typeof audioBuffer.copyFromChannel !== 'function') {\n                wrapAudioBufferCopyChannelMethods(audioBuffer);\n                wrapAudioBufferGetChannelDataMethod(audioBuffer);\n              }\n              audioBufferStore.add(audioBuffer);\n              complete().then(function () {\n                return resolve(audioBuffer);\n              });\n            }, function (err) {\n              // Bug #4: Safari returns null instead of an error.\n              if (err === null) {\n                fail(createEncodingError());\n              } else {\n                fail(err);\n              }\n            });\n          } catch (err) {\n            fail(err);\n          }\n        });\n      };\n    };\n\n    function _createForOfIteratorHelper$3(r, e) { var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray$3(r)) || e) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t[\"return\"] || t[\"return\"](); } finally { if (u) throw o; } } }; }\n    function _unsupportedIterableToArray$3(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray$3(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$3(r, a) : void 0; } }\n    function _arrayLikeToArray$3(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\n    var createDecrementCycleCounter = function createDecrementCycleCounter(connectNativeAudioNodeToNativeAudioNode, cycleCounters, getAudioNodeConnections, getNativeAudioNode, getNativeAudioParam, getNativeContext, isActiveAudioNode, isNativeOfflineAudioContext) {\n      return function (audioNode, count) {\n        var cycleCounter = cycleCounters.get(audioNode);\n        if (cycleCounter === undefined) {\n          throw new Error('Missing the expected cycle count.');\n        }\n        var nativeContext = getNativeContext(audioNode.context);\n        var isOffline = isNativeOfflineAudioContext(nativeContext);\n        if (cycleCounter === count) {\n          cycleCounters[\"delete\"](audioNode);\n          if (!isOffline && isActiveAudioNode(audioNode)) {\n            var nativeSourceAudioNode = getNativeAudioNode(audioNode);\n            var _getAudioNodeConnecti = getAudioNodeConnections(audioNode),\n              outputs = _getAudioNodeConnecti.outputs;\n            var _iterator = _createForOfIteratorHelper$3(outputs),\n              _step;\n            try {\n              for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                var output = _step.value;\n                if (isAudioNodeOutputConnection(output)) {\n                  var nativeDestinationAudioNode = getNativeAudioNode(output[0]);\n                  connectNativeAudioNodeToNativeAudioNode(nativeSourceAudioNode, nativeDestinationAudioNode, output[1], output[2]);\n                } else {\n                  var nativeDestinationAudioParam = getNativeAudioParam(output[0]);\n                  nativeSourceAudioNode.connect(nativeDestinationAudioParam, output[1]);\n                }\n              }\n            } catch (err) {\n              _iterator.e(err);\n            } finally {\n              _iterator.f();\n            }\n          }\n        } else {\n          cycleCounters.set(audioNode, cycleCounter - count);\n        }\n      };\n    };\n\n    function ownKeys$l(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\n    function _objectSpread$l(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$l(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$l(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n    function _callSuper$f(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$f() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\n    function _isNativeReflectConstruct$f() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$f = function _isNativeReflectConstruct() { return !!t; })(); }\n    var DEFAULT_OPTIONS$b = {\n      channelCount: 2,\n      channelCountMode: 'max',\n      channelInterpretation: 'speakers',\n      delayTime: 0,\n      maxDelayTime: 1\n    };\n    var createDelayNodeConstructor = function createDelayNodeConstructor(audioNodeConstructor, createAudioParam, createDelayNodeRenderer, createNativeDelayNode, getNativeContext, isNativeOfflineAudioContext, setAudioNodeTailTime) {\n      return /*#__PURE__*/function (_audioNodeConstructor) {\n        function DelayNode(context, options) {\n          var _this;\n          _classCallCheck(this, DelayNode);\n          var nativeContext = getNativeContext(context);\n          var mergedOptions = _objectSpread$l(_objectSpread$l({}, DEFAULT_OPTIONS$b), options);\n          var nativeDelayNode = createNativeDelayNode(nativeContext, mergedOptions);\n          var isOffline = isNativeOfflineAudioContext(nativeContext);\n          var delayNodeRenderer = isOffline ? createDelayNodeRenderer(mergedOptions.maxDelayTime) : null;\n          _this = _callSuper$f(this, DelayNode, [context, false, nativeDelayNode, delayNodeRenderer]);\n          _this._delayTime = createAudioParam(_this, isOffline, nativeDelayNode.delayTime);\n          setAudioNodeTailTime(_this, mergedOptions.maxDelayTime);\n          return _this;\n        }\n        _inherits(DelayNode, _audioNodeConstructor);\n        return _createClass(DelayNode, [{\n          key: \"delayTime\",\n          get: function get() {\n            return this._delayTime;\n          }\n        }]);\n      }(audioNodeConstructor);\n    };\n\n    var createDelayNodeRendererFactory = function createDelayNodeRendererFactory(connectAudioParam, createNativeDelayNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode) {\n      return function (maxDelayTime) {\n        var renderedNativeDelayNodes = new WeakMap();\n        var createDelayNode = /*#__PURE__*/function () {\n          var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(proxy, nativeOfflineAudioContext) {\n            var nativeDelayNode, nativeDelayNodeIsOwnedByContext, options;\n            return _regeneratorRuntime.wrap(function _callee$(_context) {\n              while (1) switch (_context.prev = _context.next) {\n                case 0:\n                  nativeDelayNode = getNativeAudioNode(proxy); // If the initially used nativeDelayNode was not constructed on the same OfflineAudioContext it needs to be created again.\n                  nativeDelayNodeIsOwnedByContext = isOwnedByContext(nativeDelayNode, nativeOfflineAudioContext);\n                  if (!nativeDelayNodeIsOwnedByContext) {\n                    options = {\n                      channelCount: nativeDelayNode.channelCount,\n                      channelCountMode: nativeDelayNode.channelCountMode,\n                      channelInterpretation: nativeDelayNode.channelInterpretation,\n                      delayTime: nativeDelayNode.delayTime.value,\n                      maxDelayTime: maxDelayTime\n                    };\n                    nativeDelayNode = createNativeDelayNode(nativeOfflineAudioContext, options);\n                  }\n                  renderedNativeDelayNodes.set(nativeOfflineAudioContext, nativeDelayNode);\n                  if (nativeDelayNodeIsOwnedByContext) {\n                    _context.next = 9;\n                    break;\n                  }\n                  _context.next = 7;\n                  return renderAutomation(nativeOfflineAudioContext, proxy.delayTime, nativeDelayNode.delayTime);\n                case 7:\n                  _context.next = 11;\n                  break;\n                case 9:\n                  _context.next = 11;\n                  return connectAudioParam(nativeOfflineAudioContext, proxy.delayTime, nativeDelayNode.delayTime);\n                case 11:\n                  _context.next = 13;\n                  return renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeDelayNode);\n                case 13:\n                  return _context.abrupt(\"return\", nativeDelayNode);\n                case 14:\n                case \"end\":\n                  return _context.stop();\n              }\n            }, _callee);\n          }));\n          return function createDelayNode(_x, _x2) {\n            return _ref.apply(this, arguments);\n          };\n        }();\n        return {\n          render: function render(proxy, nativeOfflineAudioContext) {\n            var renderedNativeDelayNode = renderedNativeDelayNodes.get(nativeOfflineAudioContext);\n            if (renderedNativeDelayNode !== undefined) {\n              return Promise.resolve(renderedNativeDelayNode);\n            }\n            return createDelayNode(proxy, nativeOfflineAudioContext);\n          }\n        };\n      };\n    };\n\n    var createDeleteActiveInputConnectionToAudioNode = function createDeleteActiveInputConnectionToAudioNode(pickElementFromSet) {\n      return function (activeInputs, source, output, input) {\n        return pickElementFromSet(activeInputs[input], function (activeInputConnection) {\n          return activeInputConnection[0] === source && activeInputConnection[1] === output;\n        });\n      };\n    };\n\n    var createDeleteUnrenderedAudioWorkletNode = function createDeleteUnrenderedAudioWorkletNode(getUnrenderedAudioWorkletNodes) {\n      return function (nativeContext, audioWorkletNode) {\n        getUnrenderedAudioWorkletNodes(nativeContext)[\"delete\"](audioWorkletNode);\n      };\n    };\n\n    var isDelayNode = function isDelayNode(audioNode) {\n      return 'delayTime' in audioNode;\n    };\n\n    var createDetectCycles = function createDetectCycles(audioParamAudioNodeStore, getAudioNodeConnections, getValueForKey) {\n      return function detectCycles(chain, nextLink) {\n        var audioNode = isAudioNode(nextLink) ? nextLink : getValueForKey(audioParamAudioNodeStore, nextLink);\n        if (isDelayNode(audioNode)) {\n          return [];\n        }\n        if (chain[0] === audioNode) {\n          return [chain];\n        }\n        if (chain.includes(audioNode)) {\n          return [];\n        }\n        var _getAudioNodeConnecti = getAudioNodeConnections(audioNode),\n          outputs = _getAudioNodeConnecti.outputs;\n        return Array.from(outputs).map(function (outputConnection) {\n          return detectCycles([].concat(_toConsumableArray(chain), [audioNode]), outputConnection[0]);\n        }).reduce(function (mergedCycles, nestedCycles) {\n          return mergedCycles.concat(nestedCycles);\n        }, []);\n      };\n    };\n\n    var getOutputAudioNodeAtIndex = function getOutputAudioNodeAtIndex(createIndexSizeError, outputAudioNodes, output) {\n      var outputAudioNode = outputAudioNodes[output];\n      if (outputAudioNode === undefined) {\n        throw createIndexSizeError();\n      }\n      return outputAudioNode;\n    };\n    var createDisconnectMultipleOutputs = function createDisconnectMultipleOutputs(createIndexSizeError) {\n      return function (outputAudioNodes) {\n        var destinationOrOutput = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n        var output = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n        var input = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n        if (destinationOrOutput === undefined) {\n          return outputAudioNodes.forEach(function (outputAudioNode) {\n            return outputAudioNode.disconnect();\n          });\n        }\n        if (typeof destinationOrOutput === 'number') {\n          return getOutputAudioNodeAtIndex(createIndexSizeError, outputAudioNodes, destinationOrOutput).disconnect();\n        }\n        if (isNativeAudioNode$1(destinationOrOutput)) {\n          if (output === undefined) {\n            return outputAudioNodes.forEach(function (outputAudioNode) {\n              return outputAudioNode.disconnect(destinationOrOutput);\n            });\n          }\n          if (input === undefined) {\n            return getOutputAudioNodeAtIndex(createIndexSizeError, outputAudioNodes, output).disconnect(destinationOrOutput, 0);\n          }\n          return getOutputAudioNodeAtIndex(createIndexSizeError, outputAudioNodes, output).disconnect(destinationOrOutput, 0, input);\n        }\n        if (output === undefined) {\n          return outputAudioNodes.forEach(function (outputAudioNode) {\n            return outputAudioNode.disconnect(destinationOrOutput);\n          });\n        }\n        return getOutputAudioNodeAtIndex(createIndexSizeError, outputAudioNodes, output).disconnect(destinationOrOutput, 0);\n      };\n    };\n\n    function ownKeys$k(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\n    function _objectSpread$k(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$k(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$k(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n    function _callSuper$e(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$e() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\n    function _isNativeReflectConstruct$e() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$e = function _isNativeReflectConstruct() { return !!t; })(); }\n    var DEFAULT_OPTIONS$a = {\n      attack: 0.003,\n      channelCount: 2,\n      channelCountMode: 'clamped-max',\n      channelInterpretation: 'speakers',\n      knee: 30,\n      ratio: 12,\n      release: 0.25,\n      threshold: -24\n    };\n    var createDynamicsCompressorNodeConstructor = function createDynamicsCompressorNodeConstructor(audioNodeConstructor, createAudioParam, createDynamicsCompressorNodeRenderer, createNativeDynamicsCompressorNode, createNotSupportedError, getNativeContext, isNativeOfflineAudioContext, setAudioNodeTailTime) {\n      return /*#__PURE__*/function (_audioNodeConstructor) {\n        function DynamicsCompressorNode(context, options) {\n          var _this;\n          _classCallCheck(this, DynamicsCompressorNode);\n          var nativeContext = getNativeContext(context);\n          var mergedOptions = _objectSpread$k(_objectSpread$k({}, DEFAULT_OPTIONS$a), options);\n          var nativeDynamicsCompressorNode = createNativeDynamicsCompressorNode(nativeContext, mergedOptions);\n          var isOffline = isNativeOfflineAudioContext(nativeContext);\n          var dynamicsCompressorNodeRenderer = isOffline ? createDynamicsCompressorNodeRenderer() : null;\n          _this = _callSuper$e(this, DynamicsCompressorNode, [context, false, nativeDynamicsCompressorNode, dynamicsCompressorNodeRenderer]);\n          _this._attack = createAudioParam(_this, isOffline, nativeDynamicsCompressorNode.attack);\n          _this._knee = createAudioParam(_this, isOffline, nativeDynamicsCompressorNode.knee);\n          _this._nativeDynamicsCompressorNode = nativeDynamicsCompressorNode;\n          _this._ratio = createAudioParam(_this, isOffline, nativeDynamicsCompressorNode.ratio);\n          _this._release = createAudioParam(_this, isOffline, nativeDynamicsCompressorNode.release);\n          _this._threshold = createAudioParam(_this, isOffline, nativeDynamicsCompressorNode.threshold);\n          setAudioNodeTailTime(_this, 0.006);\n          return _this;\n        }\n        _inherits(DynamicsCompressorNode, _audioNodeConstructor);\n        return _createClass(DynamicsCompressorNode, [{\n          key: \"attack\",\n          get: function get() {\n            return this._attack;\n          }\n          // Bug #108: Safari allows a channelCount of three and above which is why the getter and setter needs to be overwritten here.\n        }, {\n          key: \"channelCount\",\n          get: function get() {\n            return this._nativeDynamicsCompressorNode.channelCount;\n          },\n          set: function set(value) {\n            var previousChannelCount = this._nativeDynamicsCompressorNode.channelCount;\n            this._nativeDynamicsCompressorNode.channelCount = value;\n            if (value > 2) {\n              this._nativeDynamicsCompressorNode.channelCount = previousChannelCount;\n              throw createNotSupportedError();\n            }\n          }\n          /*\n           * Bug #109: Only Chrome and Firefox disallow a channelCountMode of 'max' yet which is why the getter and setter needs to be\n           * overwritten here.\n           */\n        }, {\n          key: \"channelCountMode\",\n          get: function get() {\n            return this._nativeDynamicsCompressorNode.channelCountMode;\n          },\n          set: function set(value) {\n            var previousChannelCount = this._nativeDynamicsCompressorNode.channelCountMode;\n            this._nativeDynamicsCompressorNode.channelCountMode = value;\n            if (value === 'max') {\n              this._nativeDynamicsCompressorNode.channelCountMode = previousChannelCount;\n              throw createNotSupportedError();\n            }\n          }\n        }, {\n          key: \"knee\",\n          get: function get() {\n            return this._knee;\n          }\n        }, {\n          key: \"ratio\",\n          get: function get() {\n            return this._ratio;\n          }\n        }, {\n          key: \"reduction\",\n          get: function get() {\n            // Bug #111: Safari returns an AudioParam instead of a number.\n            if (typeof this._nativeDynamicsCompressorNode.reduction.value === 'number') {\n              return this._nativeDynamicsCompressorNode.reduction.value;\n            }\n            return this._nativeDynamicsCompressorNode.reduction;\n          }\n        }, {\n          key: \"release\",\n          get: function get() {\n            return this._release;\n          }\n        }, {\n          key: \"threshold\",\n          get: function get() {\n            return this._threshold;\n          }\n        }]);\n      }(audioNodeConstructor);\n    };\n\n    var createDynamicsCompressorNodeRendererFactory = function createDynamicsCompressorNodeRendererFactory(connectAudioParam, createNativeDynamicsCompressorNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode) {\n      return function () {\n        var renderedNativeDynamicsCompressorNodes = new WeakMap();\n        var createDynamicsCompressorNode = /*#__PURE__*/function () {\n          var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(proxy, nativeOfflineAudioContext) {\n            var nativeDynamicsCompressorNode, nativeDynamicsCompressorNodeIsOwnedByContext, options;\n            return _regeneratorRuntime.wrap(function _callee$(_context) {\n              while (1) switch (_context.prev = _context.next) {\n                case 0:\n                  nativeDynamicsCompressorNode = getNativeAudioNode(proxy);\n                  /*\n                   * If the initially used nativeDynamicsCompressorNode was not constructed on the same OfflineAudioContext it needs to be\n                   * created again.\n                   */\n                  nativeDynamicsCompressorNodeIsOwnedByContext = isOwnedByContext(nativeDynamicsCompressorNode, nativeOfflineAudioContext);\n                  if (!nativeDynamicsCompressorNodeIsOwnedByContext) {\n                    options = {\n                      attack: nativeDynamicsCompressorNode.attack.value,\n                      channelCount: nativeDynamicsCompressorNode.channelCount,\n                      channelCountMode: nativeDynamicsCompressorNode.channelCountMode,\n                      channelInterpretation: nativeDynamicsCompressorNode.channelInterpretation,\n                      knee: nativeDynamicsCompressorNode.knee.value,\n                      ratio: nativeDynamicsCompressorNode.ratio.value,\n                      release: nativeDynamicsCompressorNode.release.value,\n                      threshold: nativeDynamicsCompressorNode.threshold.value\n                    };\n                    nativeDynamicsCompressorNode = createNativeDynamicsCompressorNode(nativeOfflineAudioContext, options);\n                  }\n                  renderedNativeDynamicsCompressorNodes.set(nativeOfflineAudioContext, nativeDynamicsCompressorNode);\n                  if (nativeDynamicsCompressorNodeIsOwnedByContext) {\n                    _context.next = 17;\n                    break;\n                  }\n                  _context.next = 7;\n                  return renderAutomation(nativeOfflineAudioContext, proxy.attack, nativeDynamicsCompressorNode.attack);\n                case 7:\n                  _context.next = 9;\n                  return renderAutomation(nativeOfflineAudioContext, proxy.knee, nativeDynamicsCompressorNode.knee);\n                case 9:\n                  _context.next = 11;\n                  return renderAutomation(nativeOfflineAudioContext, proxy.ratio, nativeDynamicsCompressorNode.ratio);\n                case 11:\n                  _context.next = 13;\n                  return renderAutomation(nativeOfflineAudioContext, proxy.release, nativeDynamicsCompressorNode.release);\n                case 13:\n                  _context.next = 15;\n                  return renderAutomation(nativeOfflineAudioContext, proxy.threshold, nativeDynamicsCompressorNode.threshold);\n                case 15:\n                  _context.next = 27;\n                  break;\n                case 17:\n                  _context.next = 19;\n                  return connectAudioParam(nativeOfflineAudioContext, proxy.attack, nativeDynamicsCompressorNode.attack);\n                case 19:\n                  _context.next = 21;\n                  return connectAudioParam(nativeOfflineAudioContext, proxy.knee, nativeDynamicsCompressorNode.knee);\n                case 21:\n                  _context.next = 23;\n                  return connectAudioParam(nativeOfflineAudioContext, proxy.ratio, nativeDynamicsCompressorNode.ratio);\n                case 23:\n                  _context.next = 25;\n                  return connectAudioParam(nativeOfflineAudioContext, proxy.release, nativeDynamicsCompressorNode.release);\n                case 25:\n                  _context.next = 27;\n                  return connectAudioParam(nativeOfflineAudioContext, proxy.threshold, nativeDynamicsCompressorNode.threshold);\n                case 27:\n                  _context.next = 29;\n                  return renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeDynamicsCompressorNode);\n                case 29:\n                  return _context.abrupt(\"return\", nativeDynamicsCompressorNode);\n                case 30:\n                case \"end\":\n                  return _context.stop();\n              }\n            }, _callee);\n          }));\n          return function createDynamicsCompressorNode(_x, _x2) {\n            return _ref.apply(this, arguments);\n          };\n        }();\n        return {\n          render: function render(proxy, nativeOfflineAudioContext) {\n            var renderedNativeDynamicsCompressorNode = renderedNativeDynamicsCompressorNodes.get(nativeOfflineAudioContext);\n            if (renderedNativeDynamicsCompressorNode !== undefined) {\n              return Promise.resolve(renderedNativeDynamicsCompressorNode);\n            }\n            return createDynamicsCompressorNode(proxy, nativeOfflineAudioContext);\n          }\n        };\n      };\n    };\n\n    var createEncodingError = function createEncodingError() {\n      return new DOMException('', 'EncodingError');\n    };\n\n    var createEvaluateSource = function createEvaluateSource(window) {\n      return function (source) {\n        return new Promise(function (resolve, reject) {\n          if (window === null) {\n            // Bug #182 Chrome and Edge do throw an instance of a SyntaxError instead of a DOMException.\n            reject(new SyntaxError());\n            return;\n          }\n          var head = window.document.head;\n          if (head === null) {\n            // Bug #182 Chrome and Edge do throw an instance of a SyntaxError instead of a DOMException.\n            reject(new SyntaxError());\n          } else {\n            var script = window.document.createElement('script');\n            // @todo Safari doesn't like URLs with a type of 'application/javascript; charset=utf-8'.\n            var blob = new Blob([source], {\n              type: 'application/javascript'\n            });\n            var url = URL.createObjectURL(blob);\n            var originalOnErrorHandler = window.onerror;\n            var removeErrorEventListenerAndRevokeUrl = function removeErrorEventListenerAndRevokeUrl() {\n              window.onerror = originalOnErrorHandler;\n              URL.revokeObjectURL(url);\n            };\n            window.onerror = function (message, src, lineno, colno, error) {\n              // @todo Edge thinks the source is the one of the html document.\n              if (src === url || src === window.location.href && lineno === 1 && colno === 1) {\n                removeErrorEventListenerAndRevokeUrl();\n                reject(error);\n                return false;\n              }\n              if (originalOnErrorHandler !== null) {\n                return originalOnErrorHandler(message, src, lineno, colno, error);\n              }\n            };\n            script.onerror = function () {\n              removeErrorEventListenerAndRevokeUrl();\n              // Bug #182 Chrome and Edge do throw an instance of a SyntaxError instead of a DOMException.\n              reject(new SyntaxError());\n            };\n            script.onload = function () {\n              removeErrorEventListenerAndRevokeUrl();\n              resolve();\n            };\n            script.src = url;\n            script.type = 'module';\n            head.appendChild(script);\n          }\n        });\n      };\n    };\n\n    var createEventTargetConstructor = function createEventTargetConstructor(wrapEventListener) {\n      return /*#__PURE__*/function () {\n        function EventTarget(_nativeEventTarget) {\n          _classCallCheck(this, EventTarget);\n          this._nativeEventTarget = _nativeEventTarget;\n          this._listeners = new WeakMap();\n        }\n        return _createClass(EventTarget, [{\n          key: \"addEventListener\",\n          value: function addEventListener(type, listener, options) {\n            if (listener !== null) {\n              var wrappedEventListener = this._listeners.get(listener);\n              if (wrappedEventListener === undefined) {\n                wrappedEventListener = wrapEventListener(this, listener);\n                if (typeof listener === 'function') {\n                  this._listeners.set(listener, wrappedEventListener);\n                }\n              }\n              this._nativeEventTarget.addEventListener(type, wrappedEventListener, options);\n            }\n          }\n        }, {\n          key: \"dispatchEvent\",\n          value: function dispatchEvent(event) {\n            return this._nativeEventTarget.dispatchEvent(event);\n          }\n        }, {\n          key: \"removeEventListener\",\n          value: function removeEventListener(type, listener, options) {\n            var wrappedEventListener = listener === null ? undefined : this._listeners.get(listener);\n            this._nativeEventTarget.removeEventListener(type, wrappedEventListener === undefined ? null : wrappedEventListener, options);\n          }\n        }]);\n      }();\n    };\n\n    var createExposeCurrentFrameAndCurrentTime = function createExposeCurrentFrameAndCurrentTime(window) {\n      return function (currentTime, sampleRate, fn) {\n        Object.defineProperties(window, {\n          currentFrame: {\n            configurable: true,\n            get: function get() {\n              return Math.round(currentTime * sampleRate);\n            }\n          },\n          currentTime: {\n            configurable: true,\n            get: function get() {\n              return currentTime;\n            }\n          }\n        });\n        try {\n          return fn();\n        } finally {\n          if (window !== null) {\n            delete window.currentFrame;\n            delete window.currentTime;\n          }\n        }\n      };\n    };\n\n    var createFetchSource = function createFetchSource(createAbortError) {\n      return /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(url) {\n          var response;\n          return _regeneratorRuntime.wrap(function _callee$(_context) {\n            while (1) switch (_context.prev = _context.next) {\n              case 0:\n                _context.prev = 0;\n                _context.next = 3;\n                return fetch(url);\n              case 3:\n                response = _context.sent;\n                if (!response.ok) {\n                  _context.next = 10;\n                  break;\n                }\n                _context.next = 7;\n                return response.text();\n              case 7:\n                _context.t0 = _context.sent;\n                _context.t1 = response.url;\n                return _context.abrupt(\"return\", [_context.t0, _context.t1]);\n              case 10:\n                _context.next = 14;\n                break;\n              case 12:\n                _context.prev = 12;\n                _context.t2 = _context[\"catch\"](0);\n              case 14:\n                throw createAbortError();\n              case 15:\n              case \"end\":\n                return _context.stop();\n            }\n          }, _callee, null, [[0, 12]]);\n        }));\n        return function (_x) {\n          return _ref.apply(this, arguments);\n        };\n      }();\n    };\n\n    function ownKeys$j(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\n    function _objectSpread$j(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$j(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$j(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n    function _callSuper$d(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$d() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\n    function _isNativeReflectConstruct$d() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$d = function _isNativeReflectConstruct() { return !!t; })(); }\n    var DEFAULT_OPTIONS$9 = {\n      channelCount: 2,\n      channelCountMode: 'max',\n      channelInterpretation: 'speakers',\n      gain: 1\n    };\n    var createGainNodeConstructor = function createGainNodeConstructor(audioNodeConstructor, createAudioParam, createGainNodeRenderer, createNativeGainNode, getNativeContext, isNativeOfflineAudioContext) {\n      return /*#__PURE__*/function (_audioNodeConstructor) {\n        function GainNode(context, options) {\n          var _this;\n          _classCallCheck(this, GainNode);\n          var nativeContext = getNativeContext(context);\n          var mergedOptions = _objectSpread$j(_objectSpread$j({}, DEFAULT_OPTIONS$9), options);\n          var nativeGainNode = createNativeGainNode(nativeContext, mergedOptions);\n          var isOffline = isNativeOfflineAudioContext(nativeContext);\n          var gainNodeRenderer = isOffline ? createGainNodeRenderer() : null;\n          _this = _callSuper$d(this, GainNode, [context, false, nativeGainNode, gainNodeRenderer]);\n          // Bug #74: Safari does not export the correct values for maxValue and minValue.\n          _this._gain = createAudioParam(_this, isOffline, nativeGainNode.gain, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n          return _this;\n        }\n        _inherits(GainNode, _audioNodeConstructor);\n        return _createClass(GainNode, [{\n          key: \"gain\",\n          get: function get() {\n            return this._gain;\n          }\n        }]);\n      }(audioNodeConstructor);\n    };\n\n    var createGainNodeRendererFactory = function createGainNodeRendererFactory(connectAudioParam, createNativeGainNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode) {\n      return function () {\n        var renderedNativeGainNodes = new WeakMap();\n        var createGainNode = /*#__PURE__*/function () {\n          var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(proxy, nativeOfflineAudioContext) {\n            var nativeGainNode, nativeGainNodeIsOwnedByContext, options;\n            return _regeneratorRuntime.wrap(function _callee$(_context) {\n              while (1) switch (_context.prev = _context.next) {\n                case 0:\n                  nativeGainNode = getNativeAudioNode(proxy); // If the initially used nativeGainNode was not constructed on the same OfflineAudioContext it needs to be created again.\n                  nativeGainNodeIsOwnedByContext = isOwnedByContext(nativeGainNode, nativeOfflineAudioContext);\n                  if (!nativeGainNodeIsOwnedByContext) {\n                    options = {\n                      channelCount: nativeGainNode.channelCount,\n                      channelCountMode: nativeGainNode.channelCountMode,\n                      channelInterpretation: nativeGainNode.channelInterpretation,\n                      gain: nativeGainNode.gain.value\n                    };\n                    nativeGainNode = createNativeGainNode(nativeOfflineAudioContext, options);\n                  }\n                  renderedNativeGainNodes.set(nativeOfflineAudioContext, nativeGainNode);\n                  if (nativeGainNodeIsOwnedByContext) {\n                    _context.next = 9;\n                    break;\n                  }\n                  _context.next = 7;\n                  return renderAutomation(nativeOfflineAudioContext, proxy.gain, nativeGainNode.gain);\n                case 7:\n                  _context.next = 11;\n                  break;\n                case 9:\n                  _context.next = 11;\n                  return connectAudioParam(nativeOfflineAudioContext, proxy.gain, nativeGainNode.gain);\n                case 11:\n                  _context.next = 13;\n                  return renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeGainNode);\n                case 13:\n                  return _context.abrupt(\"return\", nativeGainNode);\n                case 14:\n                case \"end\":\n                  return _context.stop();\n              }\n            }, _callee);\n          }));\n          return function createGainNode(_x, _x2) {\n            return _ref.apply(this, arguments);\n          };\n        }();\n        return {\n          render: function render(proxy, nativeOfflineAudioContext) {\n            var renderedNativeGainNode = renderedNativeGainNodes.get(nativeOfflineAudioContext);\n            if (renderedNativeGainNode !== undefined) {\n              return Promise.resolve(renderedNativeGainNode);\n            }\n            return createGainNode(proxy, nativeOfflineAudioContext);\n          }\n        };\n      };\n    };\n\n    var createGetActiveAudioWorkletNodeInputs = function createGetActiveAudioWorkletNodeInputs(activeAudioWorkletNodeInputsStore, getValueForKey) {\n      return function (nativeAudioWorkletNode) {\n        return getValueForKey(activeAudioWorkletNodeInputsStore, nativeAudioWorkletNode);\n      };\n    };\n\n    var createGetAudioNodeRenderer = function createGetAudioNodeRenderer(getAudioNodeConnections) {\n      return function (audioNode) {\n        var audioNodeConnections = getAudioNodeConnections(audioNode);\n        if (audioNodeConnections.renderer === null) {\n          throw new Error('Missing the renderer of the given AudioNode in the audio graph.');\n        }\n        return audioNodeConnections.renderer;\n      };\n    };\n\n    var createGetAudioNodeTailTime = function createGetAudioNodeTailTime(audioNodeTailTimeStore) {\n      return function (audioNode) {\n        var _a;\n        return (_a = audioNodeTailTimeStore.get(audioNode)) !== null && _a !== void 0 ? _a : 0;\n      };\n    };\n\n    var createGetAudioParamRenderer = function createGetAudioParamRenderer(getAudioParamConnections) {\n      return function (audioParam) {\n        var audioParamConnections = getAudioParamConnections(audioParam);\n        if (audioParamConnections.renderer === null) {\n          throw new Error('Missing the renderer of the given AudioParam in the audio graph.');\n        }\n        return audioParamConnections.renderer;\n      };\n    };\n\n    var createGetBackupOfflineAudioContext = function createGetBackupOfflineAudioContext(backupOfflineAudioContextStore) {\n      return function (nativeContext) {\n        return backupOfflineAudioContextStore.get(nativeContext);\n      };\n    };\n\n    var createInvalidStateError = function createInvalidStateError() {\n      return new DOMException('', 'InvalidStateError');\n    };\n\n    var createGetNativeContext = function createGetNativeContext(contextStore) {\n      return function (context) {\n        var nativeContext = contextStore.get(context);\n        if (nativeContext === undefined) {\n          throw createInvalidStateError();\n        }\n        return nativeContext;\n      };\n    };\n\n    var createGetOrCreateBackupOfflineAudioContext = function createGetOrCreateBackupOfflineAudioContext(backupOfflineAudioContextStore, nativeOfflineAudioContextConstructor) {\n      return function (nativeContext) {\n        var backupOfflineAudioContext = backupOfflineAudioContextStore.get(nativeContext);\n        if (backupOfflineAudioContext !== undefined) {\n          return backupOfflineAudioContext;\n        }\n        if (nativeOfflineAudioContextConstructor === null) {\n          throw new Error('Missing the native OfflineAudioContext constructor.');\n        }\n        // Bug #141: Safari does not support creating an OfflineAudioContext with less than 44100 Hz.\n        backupOfflineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n        backupOfflineAudioContextStore.set(nativeContext, backupOfflineAudioContext);\n        return backupOfflineAudioContext;\n      };\n    };\n\n    var createGetUnrenderedAudioWorkletNodes = function createGetUnrenderedAudioWorkletNodes(unrenderedAudioWorkletNodeStore) {\n      return function (nativeContext) {\n        var unrenderedAudioWorkletNodes = unrenderedAudioWorkletNodeStore.get(nativeContext);\n        if (unrenderedAudioWorkletNodes === undefined) {\n          throw new Error('The context has no set of AudioWorkletNodes.');\n        }\n        return unrenderedAudioWorkletNodes;\n      };\n    };\n\n    var createInvalidAccessError = function createInvalidAccessError() {\n      return new DOMException('', 'InvalidAccessError');\n    };\n\n    var wrapIIRFilterNodeGetFrequencyResponseMethod = function wrapIIRFilterNodeGetFrequencyResponseMethod(nativeIIRFilterNode) {\n      nativeIIRFilterNode.getFrequencyResponse = function (getFrequencyResponse) {\n        return function (frequencyHz, magResponse, phaseResponse) {\n          if (frequencyHz.length !== magResponse.length || magResponse.length !== phaseResponse.length) {\n            throw createInvalidAccessError();\n          }\n          return getFrequencyResponse.call(nativeIIRFilterNode, frequencyHz, magResponse, phaseResponse);\n        };\n      }(nativeIIRFilterNode.getFrequencyResponse);\n    };\n\n    function ownKeys$i(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\n    function _objectSpread$i(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$i(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$i(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n    function _callSuper$c(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$c() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\n    function _isNativeReflectConstruct$c() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$c = function _isNativeReflectConstruct() { return !!t; })(); }\n    var DEFAULT_OPTIONS$8 = {\n      channelCount: 2,\n      channelCountMode: 'max',\n      channelInterpretation: 'speakers'\n    };\n    var createIIRFilterNodeConstructor = function createIIRFilterNodeConstructor(audioNodeConstructor, createNativeIIRFilterNode, createIIRFilterNodeRenderer, getNativeContext, isNativeOfflineAudioContext, setAudioNodeTailTime) {\n      return /*#__PURE__*/function (_audioNodeConstructor) {\n        function IIRFilterNode(context, options) {\n          var _this;\n          _classCallCheck(this, IIRFilterNode);\n          var nativeContext = getNativeContext(context);\n          var isOffline = isNativeOfflineAudioContext(nativeContext);\n          var mergedOptions = _objectSpread$i(_objectSpread$i({}, DEFAULT_OPTIONS$8), options);\n          var nativeIIRFilterNode = createNativeIIRFilterNode(nativeContext, isOffline ? null : context.baseLatency, mergedOptions);\n          var iirFilterNodeRenderer = isOffline ? createIIRFilterNodeRenderer(mergedOptions.feedback, mergedOptions.feedforward) : null;\n          _this = _callSuper$c(this, IIRFilterNode, [context, false, nativeIIRFilterNode, iirFilterNodeRenderer]);\n          // Bug #23 & #24: FirefoxDeveloper does not throw an InvalidAccessError.\n          // @todo Write a test which allows other browsers to remain unpatched.\n          wrapIIRFilterNodeGetFrequencyResponseMethod(nativeIIRFilterNode);\n          _this._nativeIIRFilterNode = nativeIIRFilterNode;\n          // @todo Determine a meaningful tail-time instead of just using one second.\n          setAudioNodeTailTime(_this, 1);\n          return _this;\n        }\n        _inherits(IIRFilterNode, _audioNodeConstructor);\n        return _createClass(IIRFilterNode, [{\n          key: \"getFrequencyResponse\",\n          value: function getFrequencyResponse(frequencyHz, magResponse, phaseResponse) {\n            return this._nativeIIRFilterNode.getFrequencyResponse(frequencyHz, magResponse, phaseResponse);\n          }\n        }]);\n      }(audioNodeConstructor);\n    };\n\n    // This implementation as shamelessly inspired by source code of\n    // tslint:disable-next-line:max-line-length\n    // {@link https://chromium.googlesource.com/chromium/src.git/+/master/third_party/WebKit/Source/platform/audio/IIRFilter.cpp|Chromium's IIRFilter}.\n    var filterBuffer = function filterBuffer(feedback, feedbackLength, feedforward, feedforwardLength, minLength, xBuffer, yBuffer, bufferIndex, bufferLength, input, output) {\n      var inputLength = input.length;\n      var i = bufferIndex;\n      for (var j = 0; j < inputLength; j += 1) {\n        var y = feedforward[0] * input[j];\n        for (var k = 1; k < minLength; k += 1) {\n          var x = i - k & bufferLength - 1; // tslint:disable-line:no-bitwise\n          y += feedforward[k] * xBuffer[x];\n          y -= feedback[k] * yBuffer[x];\n        }\n        for (var _k = minLength; _k < feedforwardLength; _k += 1) {\n          y += feedforward[_k] * xBuffer[i - _k & bufferLength - 1]; // tslint:disable-line:no-bitwise\n        }\n        for (var _k2 = minLength; _k2 < feedbackLength; _k2 += 1) {\n          y -= feedback[_k2] * yBuffer[i - _k2 & bufferLength - 1]; // tslint:disable-line:no-bitwise\n        }\n        xBuffer[i] = input[j];\n        yBuffer[i] = y;\n        i = i + 1 & bufferLength - 1; // tslint:disable-line:no-bitwise\n        output[j] = y;\n      }\n      return i;\n    };\n\n    var filterFullBuffer = function filterFullBuffer(renderedBuffer, nativeOfflineAudioContext, feedback, feedforward) {\n      var convertedFeedback = feedback instanceof Float64Array ? feedback : new Float64Array(feedback);\n      var convertedFeedforward = feedforward instanceof Float64Array ? feedforward : new Float64Array(feedforward);\n      var feedbackLength = convertedFeedback.length;\n      var feedforwardLength = convertedFeedforward.length;\n      var minLength = Math.min(feedbackLength, feedforwardLength);\n      if (convertedFeedback[0] !== 1) {\n        for (var i = 0; i < feedbackLength; i += 1) {\n          convertedFeedforward[i] /= convertedFeedback[0];\n        }\n        for (var _i = 1; _i < feedforwardLength; _i += 1) {\n          convertedFeedback[_i] /= convertedFeedback[0];\n        }\n      }\n      var bufferLength = 32;\n      var xBuffer = new Float32Array(bufferLength);\n      var yBuffer = new Float32Array(bufferLength);\n      var filteredBuffer = nativeOfflineAudioContext.createBuffer(renderedBuffer.numberOfChannels, renderedBuffer.length, renderedBuffer.sampleRate);\n      var numberOfChannels = renderedBuffer.numberOfChannels;\n      for (var _i2 = 0; _i2 < numberOfChannels; _i2 += 1) {\n        var input = renderedBuffer.getChannelData(_i2);\n        var output = filteredBuffer.getChannelData(_i2);\n        xBuffer.fill(0);\n        yBuffer.fill(0);\n        filterBuffer(convertedFeedback, feedbackLength, convertedFeedforward, feedforwardLength, minLength, xBuffer, yBuffer, 0, bufferLength, input, output);\n      }\n      return filteredBuffer;\n    };\n    var createIIRFilterNodeRendererFactory = function createIIRFilterNodeRendererFactory(createNativeAudioBufferSourceNode, getNativeAudioNode, nativeOfflineAudioContextConstructor, renderInputsOfAudioNode, renderNativeOfflineAudioContext) {\n      return function (feedback, feedforward) {\n        var renderedNativeAudioNodes = new WeakMap();\n        var filteredBufferPromise = null;\n        var createAudioNode = /*#__PURE__*/function () {\n          var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee2(proxy, nativeOfflineAudioContext) {\n            var nativeAudioBufferSourceNode, nativeIIRFilterNode, nativeIIRFilterNodeIsOwnedByContext, partialOfflineAudioContext, filteredBuffer;\n            return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n              while (1) switch (_context2.prev = _context2.next) {\n                case 0:\n                  nativeAudioBufferSourceNode = null;\n                  nativeIIRFilterNode = getNativeAudioNode(proxy); // If the initially used nativeIIRFilterNode was not constructed on the same OfflineAudioContext it needs to be created again.\n                  nativeIIRFilterNodeIsOwnedByContext = isOwnedByContext(nativeIIRFilterNode, nativeOfflineAudioContext); // Bug #9: Safari does not support IIRFilterNodes.\n                  if (nativeOfflineAudioContext.createIIRFilter === undefined) {\n                    nativeAudioBufferSourceNode = createNativeAudioBufferSourceNode(nativeOfflineAudioContext, {\n                      buffer: null,\n                      channelCount: 2,\n                      channelCountMode: 'max',\n                      channelInterpretation: 'speakers',\n                      loop: false,\n                      loopEnd: 0,\n                      loopStart: 0,\n                      playbackRate: 1\n                    });\n                  } else if (!nativeIIRFilterNodeIsOwnedByContext) {\n                    // @todo TypeScript defines the parameters of createIIRFilter() as arrays of numbers.\n                    nativeIIRFilterNode = nativeOfflineAudioContext.createIIRFilter(feedforward, feedback);\n                  }\n                  renderedNativeAudioNodes.set(nativeOfflineAudioContext, nativeAudioBufferSourceNode === null ? nativeIIRFilterNode : nativeAudioBufferSourceNode);\n                  if (!(nativeAudioBufferSourceNode !== null)) {\n                    _context2.next = 17;\n                    break;\n                  }\n                  if (!(filteredBufferPromise === null)) {\n                    _context2.next = 11;\n                    break;\n                  }\n                  if (!(nativeOfflineAudioContextConstructor === null)) {\n                    _context2.next = 9;\n                    break;\n                  }\n                  throw new Error('Missing the native OfflineAudioContext constructor.');\n                case 9:\n                  partialOfflineAudioContext = new nativeOfflineAudioContextConstructor(\n                  // Bug #47: The AudioDestinationNode in Safari gets not initialized correctly.\n                  proxy.context.destination.channelCount,\n                  // Bug #17: Safari does not yet expose the length.\n                  proxy.context.length, nativeOfflineAudioContext.sampleRate);\n                  filteredBufferPromise = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n                    var renderedBuffer;\n                    return _regeneratorRuntime.wrap(function _callee$(_context) {\n                      while (1) switch (_context.prev = _context.next) {\n                        case 0:\n                          _context.next = 2;\n                          return renderInputsOfAudioNode(proxy, partialOfflineAudioContext, partialOfflineAudioContext.destination);\n                        case 2:\n                          _context.next = 4;\n                          return renderNativeOfflineAudioContext(partialOfflineAudioContext);\n                        case 4:\n                          renderedBuffer = _context.sent;\n                          return _context.abrupt(\"return\", filterFullBuffer(renderedBuffer, nativeOfflineAudioContext, feedback, feedforward));\n                        case 6:\n                        case \"end\":\n                          return _context.stop();\n                      }\n                    }, _callee);\n                  }))();\n                case 11:\n                  _context2.next = 13;\n                  return filteredBufferPromise;\n                case 13:\n                  filteredBuffer = _context2.sent;\n                  nativeAudioBufferSourceNode.buffer = filteredBuffer;\n                  nativeAudioBufferSourceNode.start(0);\n                  return _context2.abrupt(\"return\", nativeAudioBufferSourceNode);\n                case 17:\n                  _context2.next = 19;\n                  return renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeIIRFilterNode);\n                case 19:\n                  return _context2.abrupt(\"return\", nativeIIRFilterNode);\n                case 20:\n                case \"end\":\n                  return _context2.stop();\n              }\n            }, _callee2);\n          }));\n          return function createAudioNode(_x, _x2) {\n            return _ref.apply(this, arguments);\n          };\n        }();\n        return {\n          render: function render(proxy, nativeOfflineAudioContext) {\n            var renderedNativeAudioNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);\n            if (renderedNativeAudioNode !== undefined) {\n              return Promise.resolve(renderedNativeAudioNode);\n            }\n            return createAudioNode(proxy, nativeOfflineAudioContext);\n          }\n        };\n      };\n    };\n\n    function _createForOfIteratorHelper$2(r, e) { var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray$2(r)) || e) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t[\"return\"] || t[\"return\"](); } finally { if (u) throw o; } } }; }\n    function _unsupportedIterableToArray$2(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray$2(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$2(r, a) : void 0; } }\n    function _arrayLikeToArray$2(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\n    var createIncrementCycleCounterFactory = function createIncrementCycleCounterFactory(cycleCounters, disconnectNativeAudioNodeFromNativeAudioNode, getAudioNodeConnections, getNativeAudioNode, getNativeAudioParam, isActiveAudioNode) {\n      return function (isOffline) {\n        return function (audioNode, count) {\n          var cycleCounter = cycleCounters.get(audioNode);\n          if (cycleCounter === undefined) {\n            if (!isOffline && isActiveAudioNode(audioNode)) {\n              var nativeSourceAudioNode = getNativeAudioNode(audioNode);\n              var _getAudioNodeConnecti = getAudioNodeConnections(audioNode),\n                outputs = _getAudioNodeConnecti.outputs;\n              var _iterator = _createForOfIteratorHelper$2(outputs),\n                _step;\n              try {\n                for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                  var output = _step.value;\n                  if (isAudioNodeOutputConnection(output)) {\n                    var nativeDestinationAudioNode = getNativeAudioNode(output[0]);\n                    disconnectNativeAudioNodeFromNativeAudioNode(nativeSourceAudioNode, nativeDestinationAudioNode, output[1], output[2]);\n                  } else {\n                    var nativeDestinationAudioParam = getNativeAudioParam(output[0]);\n                    nativeSourceAudioNode.disconnect(nativeDestinationAudioParam, output[1]);\n                  }\n                }\n              } catch (err) {\n                _iterator.e(err);\n              } finally {\n                _iterator.f();\n              }\n            }\n            cycleCounters.set(audioNode, count);\n          } else {\n            cycleCounters.set(audioNode, cycleCounter + count);\n          }\n        };\n      };\n    };\n\n    var createIsAnyAudioContext = function createIsAnyAudioContext(contextStore, isNativeAudioContext) {\n      return function (anything) {\n        var nativeContext = contextStore.get(anything);\n        return isNativeAudioContext(nativeContext) || isNativeAudioContext(anything);\n      };\n    };\n\n    var createIsAnyAudioNode = function createIsAnyAudioNode(audioNodeStore, isNativeAudioNode) {\n      return function (anything) {\n        return audioNodeStore.has(anything) || isNativeAudioNode(anything);\n      };\n    };\n\n    var createIsAnyAudioParam = function createIsAnyAudioParam(audioParamStore, isNativeAudioParam) {\n      return function (anything) {\n        return audioParamStore.has(anything) || isNativeAudioParam(anything);\n      };\n    };\n\n    var createIsAnyOfflineAudioContext = function createIsAnyOfflineAudioContext(contextStore, isNativeOfflineAudioContext) {\n      return function (anything) {\n        var nativeContext = contextStore.get(anything);\n        return isNativeOfflineAudioContext(nativeContext) || isNativeOfflineAudioContext(anything);\n      };\n    };\n\n    var createIsNativeAudioContext = function createIsNativeAudioContext(nativeAudioContextConstructor) {\n      return function (anything) {\n        return nativeAudioContextConstructor !== null && anything instanceof nativeAudioContextConstructor;\n      };\n    };\n\n    var createIsNativeAudioNode = function createIsNativeAudioNode(window) {\n      return function (anything) {\n        return window !== null && typeof window.AudioNode === 'function' && anything instanceof window.AudioNode;\n      };\n    };\n\n    var createIsNativeAudioParam = function createIsNativeAudioParam(window) {\n      return function (anything) {\n        return window !== null && typeof window.AudioParam === 'function' && anything instanceof window.AudioParam;\n      };\n    };\n\n    var createIsNativeContext = function createIsNativeContext(isNativeAudioContext, isNativeOfflineAudioContext) {\n      return function (anything) {\n        return isNativeAudioContext(anything) || isNativeOfflineAudioContext(anything);\n      };\n    };\n\n    var createIsNativeOfflineAudioContext = function createIsNativeOfflineAudioContext(nativeOfflineAudioContextConstructor) {\n      return function (anything) {\n        return nativeOfflineAudioContextConstructor !== null && anything instanceof nativeOfflineAudioContextConstructor;\n      };\n    };\n\n    var createIsSecureContext = function createIsSecureContext(window) {\n      return window !== null && window.isSecureContext;\n    };\n\n    var createIsSupportedPromise = /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(cacheTestResult, testAudioBufferCopyChannelMethodsSubarraySupport, testAudioContextCloseMethodSupport, testAudioContextDecodeAudioDataMethodTypeErrorSupport, testAudioContextOptionsSupport, testAudioNodeConnectMethodSupport, testAudioWorkletProcessorNoOutputsSupport, testChannelMergerNodeChannelCountSupport, testConstantSourceNodeAccurateSchedulingSupport, testConvolverNodeBufferReassignabilitySupport, testConvolverNodeChannelCountSupport, testDomExceptionContrucorSupport, testIsSecureContextSupport, testMediaStreamAudioSourceNodeMediaStreamWithoutAudioTrackSupport, testStereoPannerNodeDefaultValueSupport, testTransferablesSupport) {\n        var results;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              if (!(cacheTestResult(testAudioBufferCopyChannelMethodsSubarraySupport, testAudioBufferCopyChannelMethodsSubarraySupport) && cacheTestResult(testAudioContextCloseMethodSupport, testAudioContextCloseMethodSupport) && cacheTestResult(testAudioContextOptionsSupport, testAudioContextOptionsSupport) && cacheTestResult(testAudioNodeConnectMethodSupport, testAudioNodeConnectMethodSupport) && cacheTestResult(testChannelMergerNodeChannelCountSupport, testChannelMergerNodeChannelCountSupport) && cacheTestResult(testConstantSourceNodeAccurateSchedulingSupport, testConstantSourceNodeAccurateSchedulingSupport) && cacheTestResult(testConvolverNodeBufferReassignabilitySupport, testConvolverNodeBufferReassignabilitySupport) && cacheTestResult(testConvolverNodeChannelCountSupport, testConvolverNodeChannelCountSupport) && cacheTestResult(testDomExceptionContrucorSupport, testDomExceptionContrucorSupport) && cacheTestResult(testIsSecureContextSupport, testIsSecureContextSupport) && cacheTestResult(testMediaStreamAudioSourceNodeMediaStreamWithoutAudioTrackSupport, testMediaStreamAudioSourceNodeMediaStreamWithoutAudioTrackSupport))) {\n                _context.next = 5;\n                break;\n              }\n              _context.next = 3;\n              return Promise.all([cacheTestResult(testAudioContextDecodeAudioDataMethodTypeErrorSupport, testAudioContextDecodeAudioDataMethodTypeErrorSupport), cacheTestResult(testAudioWorkletProcessorNoOutputsSupport, testAudioWorkletProcessorNoOutputsSupport), cacheTestResult(testStereoPannerNodeDefaultValueSupport, testStereoPannerNodeDefaultValueSupport), cacheTestResult(testTransferablesSupport, testTransferablesSupport)]);\n            case 3:\n              results = _context.sent;\n              return _context.abrupt(\"return\", results.every(function (result) {\n                return result;\n              }));\n            case 5:\n              return _context.abrupt(\"return\", false);\n            case 6:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee);\n      }));\n      return function createIsSupportedPromise(_x, _x2, _x3, _x4, _x5, _x6, _x7, _x8, _x9, _x10, _x11, _x12, _x13, _x14, _x15, _x16) {\n        return _ref.apply(this, arguments);\n      };\n    }();\n\n    function _callSuper$b(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$b() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\n    function _isNativeReflectConstruct$b() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$b = function _isNativeReflectConstruct() { return !!t; })(); }\n    var createMediaElementAudioSourceNodeConstructor = function createMediaElementAudioSourceNodeConstructor(audioNodeConstructor, createNativeMediaElementAudioSourceNode, getNativeContext, isNativeOfflineAudioContext) {\n      return /*#__PURE__*/function (_audioNodeConstructor) {\n        function MediaElementAudioSourceNode(context, options) {\n          var _this;\n          _classCallCheck(this, MediaElementAudioSourceNode);\n          var nativeContext = getNativeContext(context);\n          var nativeMediaElementAudioSourceNode = createNativeMediaElementAudioSourceNode(nativeContext, options);\n          // Bug #171: Safari allows to create a MediaElementAudioSourceNode with an OfflineAudioContext.\n          if (isNativeOfflineAudioContext(nativeContext)) {\n            throw TypeError();\n          }\n          _this = _callSuper$b(this, MediaElementAudioSourceNode, [context, true, nativeMediaElementAudioSourceNode, null]);\n          _this._nativeMediaElementAudioSourceNode = nativeMediaElementAudioSourceNode;\n          return _this;\n        }\n        _inherits(MediaElementAudioSourceNode, _audioNodeConstructor);\n        return _createClass(MediaElementAudioSourceNode, [{\n          key: \"mediaElement\",\n          get: function get() {\n            return this._nativeMediaElementAudioSourceNode.mediaElement;\n          }\n        }]);\n      }(audioNodeConstructor);\n    };\n\n    function ownKeys$h(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\n    function _objectSpread$h(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$h(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$h(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n    function _callSuper$a(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$a() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\n    function _isNativeReflectConstruct$a() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$a = function _isNativeReflectConstruct() { return !!t; })(); }\n    var DEFAULT_OPTIONS$7 = {\n      channelCount: 2,\n      channelCountMode: 'explicit',\n      channelInterpretation: 'speakers'\n    };\n    var createMediaStreamAudioDestinationNodeConstructor = function createMediaStreamAudioDestinationNodeConstructor(audioNodeConstructor, createNativeMediaStreamAudioDestinationNode, getNativeContext, isNativeOfflineAudioContext) {\n      return /*#__PURE__*/function (_audioNodeConstructor) {\n        function MediaStreamAudioDestinationNode(context, options) {\n          var _this;\n          _classCallCheck(this, MediaStreamAudioDestinationNode);\n          var nativeContext = getNativeContext(context);\n          // Bug #173: Safari allows to create a MediaStreamAudioDestinationNode with an OfflineAudioContext.\n          if (isNativeOfflineAudioContext(nativeContext)) {\n            throw new TypeError();\n          }\n          var mergedOptions = _objectSpread$h(_objectSpread$h({}, DEFAULT_OPTIONS$7), options);\n          var nativeMediaStreamAudioDestinationNode = createNativeMediaStreamAudioDestinationNode(nativeContext, mergedOptions);\n          _this = _callSuper$a(this, MediaStreamAudioDestinationNode, [context, false, nativeMediaStreamAudioDestinationNode, null]);\n          _this._nativeMediaStreamAudioDestinationNode = nativeMediaStreamAudioDestinationNode;\n          return _this;\n        }\n        _inherits(MediaStreamAudioDestinationNode, _audioNodeConstructor);\n        return _createClass(MediaStreamAudioDestinationNode, [{\n          key: \"stream\",\n          get: function get() {\n            return this._nativeMediaStreamAudioDestinationNode.stream;\n          }\n        }]);\n      }(audioNodeConstructor);\n    };\n\n    function _callSuper$9(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$9() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\n    function _isNativeReflectConstruct$9() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$9 = function _isNativeReflectConstruct() { return !!t; })(); }\n    var createMediaStreamAudioSourceNodeConstructor = function createMediaStreamAudioSourceNodeConstructor(audioNodeConstructor, createNativeMediaStreamAudioSourceNode, getNativeContext, isNativeOfflineAudioContext) {\n      return /*#__PURE__*/function (_audioNodeConstructor) {\n        function MediaStreamAudioSourceNode(context, options) {\n          var _this;\n          _classCallCheck(this, MediaStreamAudioSourceNode);\n          var nativeContext = getNativeContext(context);\n          var nativeMediaStreamAudioSourceNode = createNativeMediaStreamAudioSourceNode(nativeContext, options);\n          // Bug #172: Safari allows to create a MediaStreamAudioSourceNode with an OfflineAudioContext.\n          if (isNativeOfflineAudioContext(nativeContext)) {\n            throw new TypeError();\n          }\n          _this = _callSuper$9(this, MediaStreamAudioSourceNode, [context, true, nativeMediaStreamAudioSourceNode, null]);\n          _this._nativeMediaStreamAudioSourceNode = nativeMediaStreamAudioSourceNode;\n          return _this;\n        }\n        _inherits(MediaStreamAudioSourceNode, _audioNodeConstructor);\n        return _createClass(MediaStreamAudioSourceNode, [{\n          key: \"mediaStream\",\n          get: function get() {\n            return this._nativeMediaStreamAudioSourceNode.mediaStream;\n          }\n        }]);\n      }(audioNodeConstructor);\n    };\n\n    function _callSuper$8(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$8() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\n    function _isNativeReflectConstruct$8() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$8 = function _isNativeReflectConstruct() { return !!t; })(); }\n    var createMediaStreamTrackAudioSourceNodeConstructor = function createMediaStreamTrackAudioSourceNodeConstructor(audioNodeConstructor, createNativeMediaStreamTrackAudioSourceNode, getNativeContext) {\n      return /*#__PURE__*/function (_audioNodeConstructor) {\n        function MediaStreamTrackAudioSourceNode(context, options) {\n          _classCallCheck(this, MediaStreamTrackAudioSourceNode);\n          var nativeContext = getNativeContext(context);\n          var nativeMediaStreamTrackAudioSourceNode = createNativeMediaStreamTrackAudioSourceNode(nativeContext, options);\n          return _callSuper$8(this, MediaStreamTrackAudioSourceNode, [context, true, nativeMediaStreamTrackAudioSourceNode, null]);\n        }\n        _inherits(MediaStreamTrackAudioSourceNode, _audioNodeConstructor);\n        return _createClass(MediaStreamTrackAudioSourceNode);\n      }(audioNodeConstructor);\n    };\n\n    function _callSuper$7(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$7() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\n    function _isNativeReflectConstruct$7() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$7 = function _isNativeReflectConstruct() { return !!t; })(); }\n    var createMinimalAudioContextConstructor = function createMinimalAudioContextConstructor(createInvalidStateError, createNotSupportedError, createUnknownError, minimalBaseAudioContextConstructor, nativeAudioContextConstructor) {\n      return /*#__PURE__*/function (_minimalBaseAudioCont) {\n        function MinimalAudioContext() {\n          var _this;\n          var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n          _classCallCheck(this, MinimalAudioContext);\n          if (nativeAudioContextConstructor === null) {\n            throw new Error('Missing the native AudioContext constructor.');\n          }\n          var nativeAudioContext;\n          try {\n            nativeAudioContext = new nativeAudioContextConstructor(options);\n          } catch (err) {\n            // Bug #192 Safari does throw a SyntaxError if the sampleRate is not supported.\n            if (err.code === 12 && err.message === 'sampleRate is not in range') {\n              throw createNotSupportedError();\n            }\n            throw err;\n          }\n          // Bug #131 Safari returns null when there are four other AudioContexts running already.\n          if (nativeAudioContext === null) {\n            throw createUnknownError();\n          }\n          // Bug #51 Only Chrome and Edge throw an error if the given latencyHint is invalid.\n          if (!isValidLatencyHint(options.latencyHint)) {\n            throw new TypeError(\"The provided value '\".concat(options.latencyHint, \"' is not a valid enum value of type AudioContextLatencyCategory.\"));\n          }\n          // Bug #150 Safari does not support setting the sampleRate.\n          if (options.sampleRate !== undefined && nativeAudioContext.sampleRate !== options.sampleRate) {\n            throw createNotSupportedError();\n          }\n          _this = _callSuper$7(this, MinimalAudioContext, [nativeAudioContext, 2]);\n          var latencyHint = options.latencyHint;\n          var _nativeAudioContext = nativeAudioContext,\n            sampleRate = _nativeAudioContext.sampleRate;\n          // @todo The values for 'balanced', 'interactive' and 'playback' are just copied from Chrome's implementation.\n          _this._baseLatency = typeof nativeAudioContext.baseLatency === 'number' ? nativeAudioContext.baseLatency : latencyHint === 'balanced' ? 512 / sampleRate : latencyHint === 'interactive' || latencyHint === undefined ? 256 / sampleRate : latencyHint === 'playback' ? 1024 / sampleRate :\n          /*\n           * @todo The min (256) and max (16384) values are taken from the allowed bufferSize values of a\n           * ScriptProcessorNode.\n           */\n          Math.max(2, Math.min(128, Math.round(latencyHint * sampleRate / 128))) * 128 / sampleRate;\n          _this._nativeAudioContext = nativeAudioContext;\n          // Bug #188: Safari will set the context's state to 'interrupted' in case the user switches tabs.\n          if (nativeAudioContextConstructor.name === 'webkitAudioContext') {\n            _this._nativeGainNode = nativeAudioContext.createGain();\n            _this._nativeOscillatorNode = nativeAudioContext.createOscillator();\n            _this._nativeGainNode.gain.value = 1e-37;\n            _this._nativeOscillatorNode.connect(_this._nativeGainNode).connect(nativeAudioContext.destination);\n            _this._nativeOscillatorNode.start();\n          } else {\n            _this._nativeGainNode = null;\n            _this._nativeOscillatorNode = null;\n          }\n          _this._state = null;\n          /*\n           * Bug #34: Chrome and Edge pretend to be running right away, but fire an onstatechange event when the state actually changes\n           * to 'running'.\n           */\n          if (nativeAudioContext.state === 'running') {\n            _this._state = 'suspended';\n            var _revokeState = function revokeState() {\n              if (_this._state === 'suspended') {\n                _this._state = null;\n              }\n              nativeAudioContext.removeEventListener('statechange', _revokeState);\n            };\n            nativeAudioContext.addEventListener('statechange', _revokeState);\n          }\n          return _this;\n        }\n        _inherits(MinimalAudioContext, _minimalBaseAudioCont);\n        return _createClass(MinimalAudioContext, [{\n          key: \"baseLatency\",\n          get: function get() {\n            return this._baseLatency;\n          }\n        }, {\n          key: \"state\",\n          get: function get() {\n            return this._state !== null ? this._state : this._nativeAudioContext.state;\n          }\n        }, {\n          key: \"close\",\n          value: function close() {\n            var _this2 = this;\n            // Bug #35: Firefox does not throw an error if the AudioContext was closed before.\n            if (this.state === 'closed') {\n              return this._nativeAudioContext.close().then(function () {\n                throw createInvalidStateError();\n              });\n            }\n            // Bug #34: If the state was set to suspended before it should be revoked now.\n            if (this._state === 'suspended') {\n              this._state = null;\n            }\n            return this._nativeAudioContext.close().then(function () {\n              if (_this2._nativeGainNode !== null && _this2._nativeOscillatorNode !== null) {\n                _this2._nativeOscillatorNode.stop();\n                _this2._nativeGainNode.disconnect();\n                _this2._nativeOscillatorNode.disconnect();\n              }\n              deactivateAudioGraph(_this2);\n            });\n          }\n        }, {\n          key: \"resume\",\n          value: function resume() {\n            var _this3 = this;\n            if (this._state === 'suspended') {\n              return new Promise(function (resolve, reject) {\n                var _resolvePromise = function resolvePromise() {\n                  _this3._nativeAudioContext.removeEventListener('statechange', _resolvePromise);\n                  if (_this3._nativeAudioContext.state === 'running') {\n                    resolve();\n                  } else {\n                    _this3.resume().then(resolve, reject);\n                  }\n                };\n                _this3._nativeAudioContext.addEventListener('statechange', _resolvePromise);\n              });\n            }\n            return this._nativeAudioContext.resume()[\"catch\"](function (err) {\n              // Bug #55: Chrome and Edge do throw an InvalidAccessError instead of an InvalidStateError.\n              // Bug #56: Safari invokes the catch handler but without an error.\n              if (err === undefined || err.code === 15) {\n                throw createInvalidStateError();\n              }\n              throw err;\n            });\n          }\n        }, {\n          key: \"suspend\",\n          value: function suspend() {\n            return this._nativeAudioContext.suspend()[\"catch\"](function (err) {\n              // Bug #56: Safari invokes the catch handler but without an error.\n              if (err === undefined) {\n                throw createInvalidStateError();\n              }\n              throw err;\n            });\n          }\n        }]);\n      }(minimalBaseAudioContextConstructor);\n    };\n\n    function _callSuper$6(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$6() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\n    function _isNativeReflectConstruct$6() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$6 = function _isNativeReflectConstruct() { return !!t; })(); }\n    var createMinimalBaseAudioContextConstructor = function createMinimalBaseAudioContextConstructor(audioDestinationNodeConstructor, createAudioListener, eventTargetConstructor, isNativeOfflineAudioContext, unrenderedAudioWorkletNodeStore, wrapEventListener) {\n      return /*#__PURE__*/function (_eventTargetConstruct) {\n        function MinimalBaseAudioContext(_nativeContext, numberOfChannels) {\n          var _this;\n          _classCallCheck(this, MinimalBaseAudioContext);\n          _this = _callSuper$6(this, MinimalBaseAudioContext, [_nativeContext]);\n          _this._nativeContext = _nativeContext;\n          CONTEXT_STORE.set(_this, _nativeContext);\n          if (isNativeOfflineAudioContext(_nativeContext)) {\n            unrenderedAudioWorkletNodeStore.set(_nativeContext, new Set());\n          }\n          _this._destination = new audioDestinationNodeConstructor(_this, numberOfChannels);\n          _this._listener = createAudioListener(_this, _nativeContext);\n          _this._onstatechange = null;\n          return _this;\n        }\n        _inherits(MinimalBaseAudioContext, _eventTargetConstruct);\n        return _createClass(MinimalBaseAudioContext, [{\n          key: \"currentTime\",\n          get: function get() {\n            return this._nativeContext.currentTime;\n          }\n        }, {\n          key: \"destination\",\n          get: function get() {\n            return this._destination;\n          }\n        }, {\n          key: \"listener\",\n          get: function get() {\n            return this._listener;\n          }\n        }, {\n          key: \"onstatechange\",\n          get: function get() {\n            return this._onstatechange;\n          },\n          set: function set(value) {\n            var wrappedListener = typeof value === 'function' ? wrapEventListener(this, value) : null;\n            this._nativeContext.onstatechange = wrappedListener;\n            var nativeOnStateChange = this._nativeContext.onstatechange;\n            this._onstatechange = nativeOnStateChange !== null && nativeOnStateChange === wrappedListener ? value : nativeOnStateChange;\n          }\n        }, {\n          key: \"sampleRate\",\n          get: function get() {\n            return this._nativeContext.sampleRate;\n          }\n        }, {\n          key: \"state\",\n          get: function get() {\n            return this._nativeContext.state;\n          }\n        }]);\n      }(eventTargetConstructor);\n    };\n\n    var testPromiseSupport = function testPromiseSupport(nativeContext) {\n      // This 12 numbers represent the 48 bytes of an empty WAVE file with a single sample.\n      var uint32Array = new Uint32Array([1179011410, 40, 1163280727, 544501094, 16, 131073, 44100, 176400, 1048580, 1635017060, 4, 0]);\n      try {\n        // Bug #1: Safari requires a successCallback.\n        var promise = nativeContext.decodeAudioData(uint32Array.buffer, function () {\n          // Ignore the success callback.\n        });\n        if (promise === undefined) {\n          return false;\n        }\n        promise[\"catch\"](function () {\n          // Ignore rejected errors.\n        });\n        return true;\n      } catch (_unused) {\n        // Ignore errors.\n      }\n      return false;\n    };\n\n    function ownKeys$g(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\n    function _objectSpread$g(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$g(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$g(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n    function _callSuper$5(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$5() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\n    function _isNativeReflectConstruct$5() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$5 = function _isNativeReflectConstruct() { return !!t; })(); }\n    var DEFAULT_OPTIONS$6 = {\n      numberOfChannels: 1\n    };\n    var createMinimalOfflineAudioContextConstructor = function createMinimalOfflineAudioContextConstructor(cacheTestResult, createInvalidStateError, createNativeOfflineAudioContext, minimalBaseAudioContextConstructor, _startRendering) {\n      return /*#__PURE__*/function (_minimalBaseAudioCont) {\n        function MinimalOfflineAudioContext(options) {\n          var _this;\n          _classCallCheck(this, MinimalOfflineAudioContext);\n          var _DEFAULT_OPTIONS$opti = _objectSpread$g(_objectSpread$g({}, DEFAULT_OPTIONS$6), options),\n            length = _DEFAULT_OPTIONS$opti.length,\n            numberOfChannels = _DEFAULT_OPTIONS$opti.numberOfChannels,\n            sampleRate = _DEFAULT_OPTIONS$opti.sampleRate;\n          var nativeOfflineAudioContext = createNativeOfflineAudioContext(numberOfChannels, length, sampleRate);\n          // #21 Safari does not support promises and therefore would fire the statechange event before the promise can be resolved.\n          if (!cacheTestResult(testPromiseSupport, function () {\n            return testPromiseSupport(nativeOfflineAudioContext);\n          })) {\n            nativeOfflineAudioContext.addEventListener('statechange', function () {\n              var i = 0;\n              var _delayStateChangeEvent = function delayStateChangeEvent(event) {\n                if (_this._state === 'running') {\n                  if (i > 0) {\n                    nativeOfflineAudioContext.removeEventListener('statechange', _delayStateChangeEvent);\n                    event.stopImmediatePropagation();\n                    _this._waitForThePromiseToSettle(event);\n                  } else {\n                    i += 1;\n                  }\n                }\n              };\n              return _delayStateChangeEvent;\n            }());\n          }\n          _this = _callSuper$5(this, MinimalOfflineAudioContext, [nativeOfflineAudioContext, numberOfChannels]);\n          _this._length = length;\n          _this._nativeOfflineAudioContext = nativeOfflineAudioContext;\n          _this._state = null;\n          return _this;\n        }\n        _inherits(MinimalOfflineAudioContext, _minimalBaseAudioCont);\n        return _createClass(MinimalOfflineAudioContext, [{\n          key: \"length\",\n          get: function get() {\n            // Bug #17: Safari does not yet expose the length.\n            if (this._nativeOfflineAudioContext.length === undefined) {\n              return this._length;\n            }\n            return this._nativeOfflineAudioContext.length;\n          }\n        }, {\n          key: \"state\",\n          get: function get() {\n            return this._state === null ? this._nativeOfflineAudioContext.state : this._state;\n          }\n        }, {\n          key: \"startRendering\",\n          value: function startRendering() {\n            var _this2 = this;\n            /*\n             * Bug #9 & #59: It is theoretically possible that startRendering() will first render a partialOfflineAudioContext. Therefore\n             * the state of the nativeOfflineAudioContext might no transition to running immediately.\n             */\n            if (this._state === 'running') {\n              return Promise.reject(createInvalidStateError());\n            }\n            this._state = 'running';\n            return _startRendering(this.destination, this._nativeOfflineAudioContext)[\"finally\"](function () {\n              _this2._state = null;\n              deactivateAudioGraph(_this2);\n            });\n          }\n        }, {\n          key: \"_waitForThePromiseToSettle\",\n          value: function _waitForThePromiseToSettle(event) {\n            var _this3 = this;\n            if (this._state === null) {\n              this._nativeOfflineAudioContext.dispatchEvent(event);\n            } else {\n              setTimeout(function () {\n                return _this3._waitForThePromiseToSettle(event);\n              });\n            }\n          }\n        }]);\n      }(minimalBaseAudioContextConstructor);\n    };\n\n    function _createForOfIteratorHelper$1(r, e) { var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray$1(r)) || e) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t[\"return\"] || t[\"return\"](); } finally { if (u) throw o; } } }; }\n    function _unsupportedIterableToArray$1(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray$1(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$1(r, a) : void 0; } }\n    function _arrayLikeToArray$1(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\n    var createMonitorConnections = function createMonitorConnections(insertElementInSet, isNativeAudioNode) {\n      return function (nativeAudioNode, whenConnected, whenDisconnected) {\n        var connections = new Set();\n        nativeAudioNode.connect = function (connect) {\n          // tslint:disable-next-line:invalid-void no-inferrable-types\n          return function (destination) {\n            var output = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n            var input = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n            var wasDisconnected = connections.size === 0;\n            if (isNativeAudioNode(destination)) {\n              // @todo TypeScript cannot infer the overloaded signature with 3 arguments yet.\n              connect.call(nativeAudioNode, destination, output, input);\n              insertElementInSet(connections, [destination, output, input], function (connection) {\n                return connection[0] === destination && connection[1] === output && connection[2] === input;\n              }, true);\n              if (wasDisconnected) {\n                whenConnected();\n              }\n              return destination;\n            }\n            connect.call(nativeAudioNode, destination, output);\n            insertElementInSet(connections, [destination, output], function (connection) {\n              return connection[0] === destination && connection[1] === output;\n            }, true);\n            if (wasDisconnected) {\n              whenConnected();\n            }\n            return;\n          };\n        }(nativeAudioNode.connect);\n        nativeAudioNode.disconnect = function (disconnect) {\n          return function (destinationOrOutput, output, input) {\n            var wasConnected = connections.size > 0;\n            if (destinationOrOutput === undefined) {\n              disconnect.apply(nativeAudioNode);\n              connections.clear();\n            } else if (typeof destinationOrOutput === 'number') {\n              // @todo TypeScript cannot infer the overloaded signature with 1 argument yet.\n              disconnect.call(nativeAudioNode, destinationOrOutput);\n              var _iterator = _createForOfIteratorHelper$1(connections),\n                _step;\n              try {\n                for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                  var connection = _step.value;\n                  if (connection[1] === destinationOrOutput) {\n                    connections[\"delete\"](connection);\n                  }\n                }\n              } catch (err) {\n                _iterator.e(err);\n              } finally {\n                _iterator.f();\n              }\n            } else {\n              if (isNativeAudioNode(destinationOrOutput)) {\n                // @todo TypeScript cannot infer the overloaded signature with 3 arguments yet.\n                disconnect.call(nativeAudioNode, destinationOrOutput, output, input);\n              } else {\n                // @todo TypeScript cannot infer the overloaded signature with 2 arguments yet.\n                disconnect.call(nativeAudioNode, destinationOrOutput, output);\n              }\n              var _iterator2 = _createForOfIteratorHelper$1(connections),\n                _step2;\n              try {\n                for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                  var _connection = _step2.value;\n                  if (_connection[0] === destinationOrOutput && (output === undefined || _connection[1] === output) && (input === undefined || _connection[2] === input)) {\n                    connections[\"delete\"](_connection);\n                  }\n                }\n              } catch (err) {\n                _iterator2.e(err);\n              } finally {\n                _iterator2.f();\n              }\n            }\n            var isDisconnected = connections.size === 0;\n            if (wasConnected && isDisconnected) {\n              whenDisconnected();\n            }\n          };\n        }(nativeAudioNode.disconnect);\n        return nativeAudioNode;\n      };\n    };\n\n    var assignNativeAudioNodeOption = function assignNativeAudioNodeOption(nativeAudioNode, options, option) {\n      var value = options[option];\n      if (value !== undefined && value !== nativeAudioNode[option]) {\n        nativeAudioNode[option] = value;\n      }\n    };\n\n    var assignNativeAudioNodeOptions = function assignNativeAudioNodeOptions(nativeAudioNode, options) {\n      assignNativeAudioNodeOption(nativeAudioNode, options, 'channelCount');\n      assignNativeAudioNodeOption(nativeAudioNode, options, 'channelCountMode');\n      assignNativeAudioNodeOption(nativeAudioNode, options, 'channelInterpretation');\n    };\n\n    var testAnalyserNodeGetFloatTimeDomainDataMethodSupport = function testAnalyserNodeGetFloatTimeDomainDataMethodSupport(nativeAnalyserNode) {\n      return typeof nativeAnalyserNode.getFloatTimeDomainData === 'function';\n    };\n\n    var wrapAnalyserNodeGetFloatTimeDomainDataMethod = function wrapAnalyserNodeGetFloatTimeDomainDataMethod(nativeAnalyserNode) {\n      nativeAnalyserNode.getFloatTimeDomainData = function (array) {\n        var byteTimeDomainData = new Uint8Array(array.length);\n        nativeAnalyserNode.getByteTimeDomainData(byteTimeDomainData);\n        var length = Math.max(byteTimeDomainData.length, nativeAnalyserNode.fftSize);\n        for (var i = 0; i < length; i += 1) {\n          array[i] = (byteTimeDomainData[i] - 128) * 0.0078125;\n        }\n        return array;\n      };\n    };\n\n    var createNativeAnalyserNodeFactory = function createNativeAnalyserNodeFactory(cacheTestResult, createIndexSizeError) {\n      return function (nativeContext, options) {\n        var nativeAnalyserNode = nativeContext.createAnalyser();\n        // Bug #37: Firefox does not create an AnalyserNode with the default properties.\n        assignNativeAudioNodeOptions(nativeAnalyserNode, options);\n        // Bug #118: Safari does not throw an error if maxDecibels is not more than minDecibels.\n        if (!(options.maxDecibels > options.minDecibels)) {\n          throw createIndexSizeError();\n        }\n        assignNativeAudioNodeOption(nativeAnalyserNode, options, 'fftSize');\n        assignNativeAudioNodeOption(nativeAnalyserNode, options, 'maxDecibels');\n        assignNativeAudioNodeOption(nativeAnalyserNode, options, 'minDecibels');\n        assignNativeAudioNodeOption(nativeAnalyserNode, options, 'smoothingTimeConstant');\n        // Bug #36: Safari does not support getFloatTimeDomainData() yet.\n        if (!cacheTestResult(testAnalyserNodeGetFloatTimeDomainDataMethodSupport, function () {\n          return testAnalyserNodeGetFloatTimeDomainDataMethodSupport(nativeAnalyserNode);\n        })) {\n          wrapAnalyserNodeGetFloatTimeDomainDataMethod(nativeAnalyserNode);\n        }\n        return nativeAnalyserNode;\n      };\n    };\n\n    var createNativeAudioBufferConstructor = function createNativeAudioBufferConstructor(window) {\n      if (window === null) {\n        return null;\n      }\n      if (window.hasOwnProperty('AudioBuffer')) {\n        return window.AudioBuffer;\n      }\n      return null;\n    };\n\n    var assignNativeAudioNodeAudioParamValue = function assignNativeAudioNodeAudioParamValue(nativeAudioNode, options, audioParam) {\n      var value = options[audioParam];\n      if (value !== undefined && value !== nativeAudioNode[audioParam].value) {\n        nativeAudioNode[audioParam].value = value;\n      }\n    };\n\n    var wrapAudioBufferSourceNodeStartMethodConsecutiveCalls = function wrapAudioBufferSourceNodeStartMethodConsecutiveCalls(nativeAudioBufferSourceNode) {\n      nativeAudioBufferSourceNode.start = function (start) {\n        var isScheduled = false;\n        return function () {\n          var when = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n          var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n          var duration = arguments.length > 2 ? arguments[2] : undefined;\n          if (isScheduled) {\n            throw createInvalidStateError();\n          }\n          start.call(nativeAudioBufferSourceNode, when, offset, duration);\n          isScheduled = true;\n        };\n      }(nativeAudioBufferSourceNode.start);\n    };\n\n    var wrapAudioScheduledSourceNodeStartMethodNegativeParameters = function wrapAudioScheduledSourceNodeStartMethodNegativeParameters(nativeAudioScheduledSourceNode) {\n      nativeAudioScheduledSourceNode.start = function (start) {\n        return function () {\n          var when = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n          var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n          var duration = arguments.length > 2 ? arguments[2] : undefined;\n          if (typeof duration === 'number' && duration < 0 || offset < 0 || when < 0) {\n            throw new RangeError(\"The parameters can't be negative.\");\n          }\n          // @todo TypeScript cannot infer the overloaded signature with 3 arguments yet.\n          start.call(nativeAudioScheduledSourceNode, when, offset, duration);\n        };\n      }(nativeAudioScheduledSourceNode.start);\n    };\n\n    var wrapAudioScheduledSourceNodeStopMethodNegativeParameters = function wrapAudioScheduledSourceNodeStopMethodNegativeParameters(nativeAudioScheduledSourceNode) {\n      nativeAudioScheduledSourceNode.stop = function (stop) {\n        return function () {\n          var when = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n          if (when < 0) {\n            throw new RangeError(\"The parameter can't be negative.\");\n          }\n          stop.call(nativeAudioScheduledSourceNode, when);\n        };\n      }(nativeAudioScheduledSourceNode.stop);\n    };\n\n    var createNativeAudioBufferSourceNodeFactory = function createNativeAudioBufferSourceNodeFactory(addSilentConnection, cacheTestResult, testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport, testAudioBufferSourceNodeStartMethodOffsetClampingSupport, testAudioBufferSourceNodeStopMethodNullifiedBufferSupport, testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport, testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, wrapAudioBufferSourceNodeStartMethodOffsetClampling, wrapAudioBufferSourceNodeStopMethodNullifiedBuffer, wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls) {\n      return function (nativeContext, options) {\n        var nativeAudioBufferSourceNode = nativeContext.createBufferSource();\n        assignNativeAudioNodeOptions(nativeAudioBufferSourceNode, options);\n        assignNativeAudioNodeAudioParamValue(nativeAudioBufferSourceNode, options, 'playbackRate');\n        assignNativeAudioNodeOption(nativeAudioBufferSourceNode, options, 'buffer');\n        // Bug #149: Safari does not yet support the detune AudioParam.\n        assignNativeAudioNodeOption(nativeAudioBufferSourceNode, options, 'loop');\n        assignNativeAudioNodeOption(nativeAudioBufferSourceNode, options, 'loopEnd');\n        assignNativeAudioNodeOption(nativeAudioBufferSourceNode, options, 'loopStart');\n        // Bug #69: Safari does allow calls to start() of an already scheduled AudioBufferSourceNode.\n        if (!cacheTestResult(testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport, function () {\n          return testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport(nativeContext);\n        })) {\n          wrapAudioBufferSourceNodeStartMethodConsecutiveCalls(nativeAudioBufferSourceNode);\n        }\n        // Bug #154 & #155: Safari does not handle offsets which are equal to or greater than the duration of the buffer.\n        if (!cacheTestResult(testAudioBufferSourceNodeStartMethodOffsetClampingSupport, function () {\n          return testAudioBufferSourceNodeStartMethodOffsetClampingSupport(nativeContext);\n        })) {\n          wrapAudioBufferSourceNodeStartMethodOffsetClampling(nativeAudioBufferSourceNode);\n        }\n        // Bug #162: Safari does throw an error when stop() is called on an AudioBufferSourceNode which has no buffer assigned to it.\n        if (!cacheTestResult(testAudioBufferSourceNodeStopMethodNullifiedBufferSupport, function () {\n          return testAudioBufferSourceNodeStopMethodNullifiedBufferSupport(nativeContext);\n        })) {\n          wrapAudioBufferSourceNodeStopMethodNullifiedBuffer(nativeAudioBufferSourceNode, nativeContext);\n        }\n        // Bug #44: Safari does not throw a RangeError yet.\n        if (!cacheTestResult(testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, function () {\n          return testAudioScheduledSourceNodeStartMethodNegativeParametersSupport(nativeContext);\n        })) {\n          wrapAudioScheduledSourceNodeStartMethodNegativeParameters(nativeAudioBufferSourceNode);\n        }\n        // Bug #19: Safari does not ignore calls to stop() of an already stopped AudioBufferSourceNode.\n        if (!cacheTestResult(testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport, function () {\n          return testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport(nativeContext);\n        })) {\n          wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls(nativeAudioBufferSourceNode, nativeContext);\n        }\n        // Bug #44: Only Firefox does not throw a RangeError yet.\n        if (!cacheTestResult(testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, function () {\n          return testAudioScheduledSourceNodeStopMethodNegativeParametersSupport(nativeContext);\n        })) {\n          wrapAudioScheduledSourceNodeStopMethodNegativeParameters(nativeAudioBufferSourceNode);\n        }\n        // Bug #175: Safari will not fire an ended event if the AudioBufferSourceNode is unconnected.\n        addSilentConnection(nativeContext, nativeAudioBufferSourceNode);\n        return nativeAudioBufferSourceNode;\n      };\n    };\n\n    var createNativeAudioContextConstructor = function createNativeAudioContextConstructor(window) {\n      if (window === null) {\n        return null;\n      }\n      if (window.hasOwnProperty('AudioContext')) {\n        return window.AudioContext;\n      }\n      return window.hasOwnProperty('webkitAudioContext') ? window.webkitAudioContext : null;\n    };\n\n    var createNativeAudioDestinationNodeFactory = function createNativeAudioDestinationNodeFactory(createNativeGainNode, overwriteAccessors) {\n      return function (nativeContext, channelCount, isNodeOfNativeOfflineAudioContext) {\n        var nativeAudioDestinationNode = nativeContext.destination;\n        // Bug #132: Safari does not have the correct channelCount.\n        if (nativeAudioDestinationNode.channelCount !== channelCount) {\n          try {\n            nativeAudioDestinationNode.channelCount = channelCount;\n          } catch (_unused) {\n            // Bug #169: Safari throws an error on each attempt to change the channelCount.\n          }\n        }\n        // Bug #83: Safari does not have the correct channelCountMode.\n        if (isNodeOfNativeOfflineAudioContext && nativeAudioDestinationNode.channelCountMode !== 'explicit') {\n          nativeAudioDestinationNode.channelCountMode = 'explicit';\n        }\n        // Bug #47: The AudioDestinationNode in Safari does not initialize the maxChannelCount property correctly.\n        if (nativeAudioDestinationNode.maxChannelCount === 0) {\n          Object.defineProperty(nativeAudioDestinationNode, 'maxChannelCount', {\n            value: channelCount\n          });\n        }\n        // Bug #168: No browser does yet have an AudioDestinationNode with an output.\n        var gainNode = createNativeGainNode(nativeContext, {\n          channelCount: channelCount,\n          channelCountMode: nativeAudioDestinationNode.channelCountMode,\n          channelInterpretation: nativeAudioDestinationNode.channelInterpretation,\n          gain: 1\n        });\n        overwriteAccessors(gainNode, 'channelCount', function (get) {\n          return function () {\n            return get.call(gainNode);\n          };\n        }, function (set) {\n          return function (value) {\n            set.call(gainNode, value);\n            try {\n              nativeAudioDestinationNode.channelCount = value;\n            } catch (err) {\n              // Bug #169: Safari throws an error on each attempt to change the channelCount.\n              if (value > nativeAudioDestinationNode.maxChannelCount) {\n                throw err;\n              }\n            }\n          };\n        });\n        overwriteAccessors(gainNode, 'channelCountMode', function (get) {\n          return function () {\n            return get.call(gainNode);\n          };\n        }, function (set) {\n          return function (value) {\n            set.call(gainNode, value);\n            nativeAudioDestinationNode.channelCountMode = value;\n          };\n        });\n        overwriteAccessors(gainNode, 'channelInterpretation', function (get) {\n          return function () {\n            return get.call(gainNode);\n          };\n        }, function (set) {\n          return function (value) {\n            set.call(gainNode, value);\n            nativeAudioDestinationNode.channelInterpretation = value;\n          };\n        });\n        Object.defineProperty(gainNode, 'maxChannelCount', {\n          get: function get() {\n            return nativeAudioDestinationNode.maxChannelCount;\n          }\n        });\n        // @todo This should be disconnected when the context is closed.\n        gainNode.connect(nativeAudioDestinationNode);\n        return gainNode;\n      };\n    };\n\n    var createNativeAudioWorkletNodeConstructor = function createNativeAudioWorkletNodeConstructor(window) {\n      if (window === null) {\n        return null;\n      }\n      return window.hasOwnProperty('AudioWorkletNode') ? window.AudioWorkletNode : null;\n    };\n\n    var testClonabilityOfAudioWorkletNodeOptions = function testClonabilityOfAudioWorkletNodeOptions(audioWorkletNodeOptions) {\n      var _MessageChannel = new MessageChannel(),\n        port1 = _MessageChannel.port1;\n      try {\n        // This will throw an error if the audioWorkletNodeOptions are not clonable.\n        port1.postMessage(audioWorkletNodeOptions);\n      } finally {\n        port1.close();\n      }\n    };\n\n    function ownKeys$f(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\n    function _objectSpread$f(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$f(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$f(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n    var createNativeAudioWorkletNodeFactory = function createNativeAudioWorkletNodeFactory(createInvalidStateError, createNativeAudioWorkletNodeFaker, createNativeGainNode, createNotSupportedError, monitorConnections) {\n      return function (nativeContext, baseLatency, nativeAudioWorkletNodeConstructor, name, processorConstructor, options) {\n        if (nativeAudioWorkletNodeConstructor !== null) {\n          try {\n            var nativeAudioWorkletNode = new nativeAudioWorkletNodeConstructor(nativeContext, name, options);\n            var patchedEventListeners = new Map();\n            var onprocessorerror = null;\n            Object.defineProperties(nativeAudioWorkletNode, {\n              /*\n               * Bug #61: Overwriting the property accessors for channelCount and channelCountMode is necessary as long as some\n               * browsers have no native implementation to achieve a consistent behavior.\n               */\n              channelCount: {\n                get: function get() {\n                  return options.channelCount;\n                },\n                set: function set() {\n                  throw createInvalidStateError();\n                }\n              },\n              channelCountMode: {\n                get: function get() {\n                  return 'explicit';\n                },\n                set: function set() {\n                  throw createInvalidStateError();\n                }\n              },\n              // Bug #156: Chrome and Edge do not yet fire an ErrorEvent.\n              onprocessorerror: {\n                get: function get() {\n                  return onprocessorerror;\n                },\n                set: function set(value) {\n                  if (typeof onprocessorerror === 'function') {\n                    nativeAudioWorkletNode.removeEventListener('processorerror', onprocessorerror);\n                  }\n                  onprocessorerror = typeof value === 'function' ? value : null;\n                  if (typeof onprocessorerror === 'function') {\n                    nativeAudioWorkletNode.addEventListener('processorerror', onprocessorerror);\n                  }\n                }\n              }\n            });\n            nativeAudioWorkletNode.addEventListener = function (addEventListener) {\n              return function () {\n                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n                  args[_key] = arguments[_key];\n                }\n                if (args[0] === 'processorerror') {\n                  var unpatchedEventListener = typeof args[1] === 'function' ? args[1] : _typeof(args[1]) === 'object' && args[1] !== null && typeof args[1].handleEvent === 'function' ? args[1].handleEvent : null;\n                  if (unpatchedEventListener !== null) {\n                    var patchedEventListener = patchedEventListeners.get(args[1]);\n                    if (patchedEventListener !== undefined) {\n                      args[1] = patchedEventListener;\n                    } else {\n                      args[1] = function (event) {\n                        // Bug #178: Chrome and Edge do fire an event of type error.\n                        if (event.type === 'error') {\n                          Object.defineProperties(event, {\n                            type: {\n                              value: 'processorerror'\n                            }\n                          });\n                          unpatchedEventListener(event);\n                        } else {\n                          unpatchedEventListener(new ErrorEvent(args[0], _objectSpread$f({}, event)));\n                        }\n                      };\n                      patchedEventListeners.set(unpatchedEventListener, args[1]);\n                    }\n                  }\n                }\n                // Bug #178: Chrome and Edge do fire an event of type error.\n                addEventListener.call(nativeAudioWorkletNode, 'error', args[1], args[2]);\n                return addEventListener.call.apply(addEventListener, [nativeAudioWorkletNode].concat(args));\n              };\n            }(nativeAudioWorkletNode.addEventListener);\n            nativeAudioWorkletNode.removeEventListener = function (removeEventListener) {\n              return function () {\n                for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n                  args[_key2] = arguments[_key2];\n                }\n                if (args[0] === 'processorerror') {\n                  var patchedEventListener = patchedEventListeners.get(args[1]);\n                  if (patchedEventListener !== undefined) {\n                    patchedEventListeners[\"delete\"](args[1]);\n                    args[1] = patchedEventListener;\n                  }\n                }\n                // Bug #178: Chrome and Edge do fire an event of type error.\n                removeEventListener.call(nativeAudioWorkletNode, 'error', args[1], args[2]);\n                return removeEventListener.call(nativeAudioWorkletNode, args[0], args[1], args[2]);\n              };\n            }(nativeAudioWorkletNode.removeEventListener);\n            /*\n             * Bug #86: Chrome and Edge do not invoke the process() function if the corresponding AudioWorkletNode is unconnected but\n             * has an output.\n             */\n            if (options.numberOfOutputs !== 0) {\n              var nativeGainNode = createNativeGainNode(nativeContext, {\n                channelCount: 1,\n                channelCountMode: 'explicit',\n                channelInterpretation: 'discrete',\n                gain: 0\n              });\n              nativeAudioWorkletNode.connect(nativeGainNode).connect(nativeContext.destination);\n              var whenConnected = function whenConnected() {\n                return nativeGainNode.disconnect();\n              };\n              var whenDisconnected = function whenDisconnected() {\n                return nativeGainNode.connect(nativeContext.destination);\n              };\n              // @todo Disconnect the connection when the process() function of the AudioWorkletNode returns false.\n              return monitorConnections(nativeAudioWorkletNode, whenConnected, whenDisconnected);\n            }\n            return nativeAudioWorkletNode;\n          } catch (err) {\n            // Bug #60: Chrome & Edge throw an InvalidStateError instead of a NotSupportedError.\n            if (err.code === 11) {\n              throw createNotSupportedError();\n            }\n            throw err;\n          }\n        }\n        // Bug #61: Only Chrome & Edge have an implementation of the AudioWorkletNode yet.\n        if (processorConstructor === undefined) {\n          throw createNotSupportedError();\n        }\n        testClonabilityOfAudioWorkletNodeOptions(options);\n        return createNativeAudioWorkletNodeFaker(nativeContext, baseLatency, processorConstructor, options);\n      };\n    };\n\n    var computeBufferSize = function computeBufferSize(baseLatency, sampleRate) {\n      if (baseLatency === null) {\n        return 512;\n      }\n      return Math.max(512, Math.min(16384, Math.pow(2, Math.round(Math.log2(baseLatency * sampleRate)))));\n    };\n\n    var cloneAudioWorkletNodeOptions = function cloneAudioWorkletNodeOptions(audioWorkletNodeOptions) {\n      return new Promise(function (resolve, reject) {\n        var _MessageChannel = new MessageChannel(),\n          port1 = _MessageChannel.port1,\n          port2 = _MessageChannel.port2;\n        port1.onmessage = function (_ref) {\n          var data = _ref.data;\n          port1.close();\n          port2.close();\n          resolve(data);\n        };\n        port1.onmessageerror = function (_ref2) {\n          var data = _ref2.data;\n          port1.close();\n          port2.close();\n          reject(data);\n        };\n        // This will throw an error if the audioWorkletNodeOptions are not clonable.\n        port2.postMessage(audioWorkletNodeOptions);\n      });\n    };\n\n    var createAudioWorkletProcessorPromise = /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(processorConstructor, audioWorkletNodeOptions) {\n        var clonedAudioWorkletNodeOptions;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              _context.next = 2;\n              return cloneAudioWorkletNodeOptions(audioWorkletNodeOptions);\n            case 2:\n              clonedAudioWorkletNodeOptions = _context.sent;\n              return _context.abrupt(\"return\", new processorConstructor(clonedAudioWorkletNodeOptions));\n            case 4:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee);\n      }));\n      return function createAudioWorkletProcessorPromise(_x, _x2) {\n        return _ref.apply(this, arguments);\n      };\n    }();\n\n    var createAudioWorkletProcessor = function createAudioWorkletProcessor(nativeContext, nativeAudioWorkletNode, processorConstructor, audioWorkletNodeOptions) {\n      var nodeToProcessorMap = NODE_TO_PROCESSOR_MAPS.get(nativeContext);\n      if (nodeToProcessorMap === undefined) {\n        nodeToProcessorMap = new WeakMap();\n        NODE_TO_PROCESSOR_MAPS.set(nativeContext, nodeToProcessorMap);\n      }\n      var audioWorkletProcessorPromise = createAudioWorkletProcessorPromise(processorConstructor, audioWorkletNodeOptions);\n      nodeToProcessorMap.set(nativeAudioWorkletNode, audioWorkletProcessorPromise);\n      return audioWorkletProcessorPromise;\n    };\n\n    function ownKeys$e(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\n    function _objectSpread$e(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$e(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$e(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n    function _createForOfIteratorHelper(r, e) { var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t[\"return\"] || t[\"return\"](); } finally { if (u) throw o; } } }; }\n    function _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\n    function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\n    var createNativeAudioWorkletNodeFakerFactory = function createNativeAudioWorkletNodeFakerFactory(connectMultipleOutputs, createIndexSizeError, createInvalidStateError, createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeConstantSourceNode, createNativeGainNode, createNativeScriptProcessorNode, createNotSupportedError, disconnectMultipleOutputs, exposeCurrentFrameAndCurrentTime, getActiveAudioWorkletNodeInputs, monitorConnections) {\n      return function (nativeContext, baseLatency, processorConstructor, options) {\n        if (options.numberOfInputs === 0 && options.numberOfOutputs === 0) {\n          throw createNotSupportedError();\n        }\n        var outputChannelCount = Array.isArray(options.outputChannelCount) ? options.outputChannelCount : Array.from(options.outputChannelCount);\n        // @todo Check if any of the channelCount values is greater than the implementation's maximum number of channels.\n        if (outputChannelCount.some(function (channelCount) {\n          return channelCount < 1;\n        })) {\n          throw createNotSupportedError();\n        }\n        if (outputChannelCount.length !== options.numberOfOutputs) {\n          throw createIndexSizeError();\n        }\n        // Bug #61: This is not part of the standard but required for the faker to work.\n        if (options.channelCountMode !== 'explicit') {\n          throw createNotSupportedError();\n        }\n        var numberOfInputChannels = options.channelCount * options.numberOfInputs;\n        var numberOfOutputChannels = outputChannelCount.reduce(function (sum, value) {\n          return sum + value;\n        }, 0);\n        var numberOfParameters = processorConstructor.parameterDescriptors === undefined ? 0 : processorConstructor.parameterDescriptors.length;\n        // Bug #61: This is not part of the standard but required for the faker to work.\n        if (numberOfInputChannels + numberOfParameters > 6 || numberOfOutputChannels > 6) {\n          throw createNotSupportedError();\n        }\n        var messageChannel = new MessageChannel();\n        var gainNodes = [];\n        var inputChannelSplitterNodes = [];\n        for (var i = 0; i < options.numberOfInputs; i += 1) {\n          gainNodes.push(createNativeGainNode(nativeContext, {\n            channelCount: options.channelCount,\n            channelCountMode: options.channelCountMode,\n            channelInterpretation: options.channelInterpretation,\n            gain: 1\n          }));\n          inputChannelSplitterNodes.push(createNativeChannelSplitterNode(nativeContext, {\n            channelCount: options.channelCount,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'discrete',\n            numberOfOutputs: options.channelCount\n          }));\n        }\n        var constantSourceNodes = [];\n        if (processorConstructor.parameterDescriptors !== undefined) {\n          var _iterator = _createForOfIteratorHelper(processorConstructor.parameterDescriptors),\n            _step;\n          try {\n            var _loop = function _loop() {\n              var _step$value = _step.value,\n                defaultValue = _step$value.defaultValue,\n                maxValue = _step$value.maxValue,\n                minValue = _step$value.minValue,\n                name = _step$value.name;\n              var constantSourceNode = createNativeConstantSourceNode(nativeContext, {\n                channelCount: 1,\n                channelCountMode: 'explicit',\n                channelInterpretation: 'discrete',\n                offset: options.parameterData[name] !== undefined ? options.parameterData[name] : defaultValue === undefined ? 0 : defaultValue\n              });\n              Object.defineProperties(constantSourceNode.offset, {\n                defaultValue: {\n                  get: function get() {\n                    return defaultValue === undefined ? 0 : defaultValue;\n                  }\n                },\n                maxValue: {\n                  get: function get() {\n                    return maxValue === undefined ? MOST_POSITIVE_SINGLE_FLOAT : maxValue;\n                  }\n                },\n                minValue: {\n                  get: function get() {\n                    return minValue === undefined ? MOST_NEGATIVE_SINGLE_FLOAT : minValue;\n                  }\n                }\n              });\n              constantSourceNodes.push(constantSourceNode);\n            };\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              _loop();\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n        }\n        var inputChannelMergerNode = createNativeChannelMergerNode(nativeContext, {\n          channelCount: 1,\n          channelCountMode: 'explicit',\n          channelInterpretation: 'speakers',\n          numberOfInputs: Math.max(1, numberOfInputChannels + numberOfParameters)\n        });\n        var bufferSize = computeBufferSize(baseLatency, nativeContext.sampleRate);\n        var scriptProcessorNode = createNativeScriptProcessorNode(nativeContext, bufferSize, numberOfInputChannels + numberOfParameters,\n        // Bug #87: Only Firefox will fire an AudioProcessingEvent if there is no connected output.\n        Math.max(1, numberOfOutputChannels));\n        var outputChannelSplitterNode = createNativeChannelSplitterNode(nativeContext, {\n          channelCount: Math.max(1, numberOfOutputChannels),\n          channelCountMode: 'explicit',\n          channelInterpretation: 'discrete',\n          numberOfOutputs: Math.max(1, numberOfOutputChannels)\n        });\n        var outputChannelMergerNodes = [];\n        for (var _i = 0; _i < options.numberOfOutputs; _i += 1) {\n          outputChannelMergerNodes.push(createNativeChannelMergerNode(nativeContext, {\n            channelCount: 1,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'speakers',\n            numberOfInputs: outputChannelCount[_i]\n          }));\n        }\n        for (var _i2 = 0; _i2 < options.numberOfInputs; _i2 += 1) {\n          gainNodes[_i2].connect(inputChannelSplitterNodes[_i2]);\n          for (var j = 0; j < options.channelCount; j += 1) {\n            inputChannelSplitterNodes[_i2].connect(inputChannelMergerNode, j, _i2 * options.channelCount + j);\n          }\n        }\n        var parameterMap = new ReadOnlyMap(processorConstructor.parameterDescriptors === undefined ? [] : processorConstructor.parameterDescriptors.map(function (_ref, index) {\n          var name = _ref.name;\n          var constantSourceNode = constantSourceNodes[index];\n          constantSourceNode.connect(inputChannelMergerNode, 0, numberOfInputChannels + index);\n          constantSourceNode.start(0);\n          return [name, constantSourceNode.offset];\n        }));\n        inputChannelMergerNode.connect(scriptProcessorNode);\n        var channelInterpretation = options.channelInterpretation;\n        var onprocessorerror = null;\n        // Bug #87: Expose at least one output to make this node connectable.\n        var outputAudioNodes = options.numberOfOutputs === 0 ? [scriptProcessorNode] : outputChannelMergerNodes;\n        var nativeAudioWorkletNodeFaker = {\n          get bufferSize() {\n            return bufferSize;\n          },\n          get channelCount() {\n            return options.channelCount;\n          },\n          set channelCount(_) {\n            // Bug #61: This is not part of the standard but required for the faker to work.\n            throw createInvalidStateError();\n          },\n          get channelCountMode() {\n            return options.channelCountMode;\n          },\n          set channelCountMode(_) {\n            // Bug #61: This is not part of the standard but required for the faker to work.\n            throw createInvalidStateError();\n          },\n          get channelInterpretation() {\n            return channelInterpretation;\n          },\n          set channelInterpretation(value) {\n            for (var _i3 = 0, _gainNodes = gainNodes; _i3 < _gainNodes.length; _i3++) {\n              var gainNode = _gainNodes[_i3];\n              gainNode.channelInterpretation = value;\n            }\n            channelInterpretation = value;\n          },\n          get context() {\n            return scriptProcessorNode.context;\n          },\n          get inputs() {\n            return gainNodes;\n          },\n          get numberOfInputs() {\n            return options.numberOfInputs;\n          },\n          get numberOfOutputs() {\n            return options.numberOfOutputs;\n          },\n          get onprocessorerror() {\n            return onprocessorerror;\n          },\n          set onprocessorerror(value) {\n            if (typeof onprocessorerror === 'function') {\n              nativeAudioWorkletNodeFaker.removeEventListener('processorerror', onprocessorerror);\n            }\n            onprocessorerror = typeof value === 'function' ? value : null;\n            if (typeof onprocessorerror === 'function') {\n              nativeAudioWorkletNodeFaker.addEventListener('processorerror', onprocessorerror);\n            }\n          },\n          get parameters() {\n            return parameterMap;\n          },\n          get port() {\n            return messageChannel.port2;\n          },\n          addEventListener: function addEventListener() {\n            return scriptProcessorNode.addEventListener(arguments.length <= 0 ? undefined : arguments[0], arguments.length <= 1 ? undefined : arguments[1], arguments.length <= 2 ? undefined : arguments[2]);\n          },\n          connect: connectMultipleOutputs.bind(null, outputAudioNodes),\n          disconnect: disconnectMultipleOutputs.bind(null, outputAudioNodes),\n          dispatchEvent: function dispatchEvent() {\n            return scriptProcessorNode.dispatchEvent(arguments.length <= 0 ? undefined : arguments[0]);\n          },\n          removeEventListener: function removeEventListener() {\n            return scriptProcessorNode.removeEventListener(arguments.length <= 0 ? undefined : arguments[0], arguments.length <= 1 ? undefined : arguments[1], arguments.length <= 2 ? undefined : arguments[2]);\n          }\n        };\n        var patchedEventListeners = new Map();\n        messageChannel.port1.addEventListener = function (addEventListener) {\n          return function () {\n            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n              args[_key] = arguments[_key];\n            }\n            if (args[0] === 'message') {\n              var unpatchedEventListener = typeof args[1] === 'function' ? args[1] : _typeof(args[1]) === 'object' && args[1] !== null && typeof args[1].handleEvent === 'function' ? args[1].handleEvent : null;\n              if (unpatchedEventListener !== null) {\n                var patchedEventListener = patchedEventListeners.get(args[1]);\n                if (patchedEventListener !== undefined) {\n                  args[1] = patchedEventListener;\n                } else {\n                  args[1] = function (event) {\n                    exposeCurrentFrameAndCurrentTime(nativeContext.currentTime, nativeContext.sampleRate, function () {\n                      return unpatchedEventListener(event);\n                    });\n                  };\n                  patchedEventListeners.set(unpatchedEventListener, args[1]);\n                }\n              }\n            }\n            return addEventListener.call(messageChannel.port1, args[0], args[1], args[2]);\n          };\n        }(messageChannel.port1.addEventListener);\n        messageChannel.port1.removeEventListener = function (removeEventListener) {\n          return function () {\n            for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n              args[_key2] = arguments[_key2];\n            }\n            if (args[0] === 'message') {\n              var patchedEventListener = patchedEventListeners.get(args[1]);\n              if (patchedEventListener !== undefined) {\n                patchedEventListeners[\"delete\"](args[1]);\n                args[1] = patchedEventListener;\n              }\n            }\n            return removeEventListener.call(messageChannel.port1, args[0], args[1], args[2]);\n          };\n        }(messageChannel.port1.removeEventListener);\n        var onmessage = null;\n        Object.defineProperty(messageChannel.port1, 'onmessage', {\n          get: function get() {\n            return onmessage;\n          },\n          set: function set(value) {\n            if (typeof onmessage === 'function') {\n              messageChannel.port1.removeEventListener('message', onmessage);\n            }\n            onmessage = typeof value === 'function' ? value : null;\n            if (typeof onmessage === 'function') {\n              messageChannel.port1.addEventListener('message', onmessage);\n              messageChannel.port1.start();\n            }\n          }\n        });\n        processorConstructor.prototype.port = messageChannel.port1;\n        var audioWorkletProcessor = null;\n        var audioWorkletProcessorPromise = createAudioWorkletProcessor(nativeContext, nativeAudioWorkletNodeFaker, processorConstructor, options);\n        audioWorkletProcessorPromise.then(function (dWrkltPrcssr) {\n          return audioWorkletProcessor = dWrkltPrcssr;\n        });\n        var inputs = createNestedArrays(options.numberOfInputs, options.channelCount);\n        var outputs = createNestedArrays(options.numberOfOutputs, outputChannelCount);\n        var parameters = processorConstructor.parameterDescriptors === undefined ? [] : processorConstructor.parameterDescriptors.reduce(function (prmtrs, _ref2) {\n          var name = _ref2.name;\n          return _objectSpread$e(_objectSpread$e({}, prmtrs), {}, _defineProperty({}, name, new Float32Array(128)));\n        }, {});\n        var isActive = true;\n        var disconnectOutputsGraph = function disconnectOutputsGraph() {\n          if (options.numberOfOutputs > 0) {\n            scriptProcessorNode.disconnect(outputChannelSplitterNode);\n          }\n          for (var _i4 = 0, outputChannelSplitterNodeOutput = 0; _i4 < options.numberOfOutputs; _i4 += 1) {\n            var outputChannelMergerNode = outputChannelMergerNodes[_i4];\n            for (var _j = 0; _j < outputChannelCount[_i4]; _j += 1) {\n              outputChannelSplitterNode.disconnect(outputChannelMergerNode, outputChannelSplitterNodeOutput + _j, _j);\n            }\n            outputChannelSplitterNodeOutput += outputChannelCount[_i4];\n          }\n        };\n        var activeInputIndexes = new Map();\n        // tslint:disable-next-line:deprecation\n        scriptProcessorNode.onaudioprocess = function (_ref3) {\n          var inputBuffer = _ref3.inputBuffer,\n            outputBuffer = _ref3.outputBuffer;\n          if (audioWorkletProcessor !== null) {\n            var activeInputs = getActiveAudioWorkletNodeInputs(nativeAudioWorkletNodeFaker);\n            var _loop2 = function _loop2(_i5) {\n              for (var _j2 = 0; _j2 < options.numberOfInputs; _j2 += 1) {\n                for (var k = 0; k < options.channelCount; k += 1) {\n                  copyFromChannel(inputBuffer, inputs[_j2], k, k, _i5);\n                }\n              }\n              if (processorConstructor.parameterDescriptors !== undefined) {\n                processorConstructor.parameterDescriptors.forEach(function (_ref4, index) {\n                  var name = _ref4.name;\n                  copyFromChannel(inputBuffer, parameters, name, numberOfInputChannels + index, _i5);\n                });\n              }\n              for (var _j3 = 0; _j3 < options.numberOfInputs; _j3 += 1) {\n                for (var _k = 0; _k < outputChannelCount[_j3]; _k += 1) {\n                  // The byteLength will be 0 when the ArrayBuffer was transferred.\n                  if (outputs[_j3][_k].byteLength === 0) {\n                    outputs[_j3][_k] = new Float32Array(128);\n                  }\n                }\n              }\n              try {\n                var potentiallyEmptyInputs = inputs.map(function (input, index) {\n                  var activeInput = activeInputs[index];\n                  if (activeInput.size > 0) {\n                    activeInputIndexes.set(index, bufferSize / 128);\n                    return input;\n                  }\n                  var count = activeInputIndexes.get(index);\n                  if (count === undefined) {\n                    return [];\n                  }\n                  if (input.every(function (channelData) {\n                    return channelData.every(function (sample) {\n                      return sample === 0;\n                    });\n                  })) {\n                    if (count === 1) {\n                      activeInputIndexes[\"delete\"](index);\n                    } else {\n                      activeInputIndexes.set(index, count - 1);\n                    }\n                  }\n                  return input;\n                });\n                var activeSourceFlag = exposeCurrentFrameAndCurrentTime(nativeContext.currentTime + _i5 / nativeContext.sampleRate, nativeContext.sampleRate, function () {\n                  return audioWorkletProcessor.process(potentiallyEmptyInputs, outputs, parameters);\n                });\n                isActive = activeSourceFlag;\n                for (var _j4 = 0, outputChannelSplitterNodeOutput = 0; _j4 < options.numberOfOutputs; _j4 += 1) {\n                  for (var _k2 = 0; _k2 < outputChannelCount[_j4]; _k2 += 1) {\n                    copyToChannel(outputBuffer, outputs[_j4], _k2, outputChannelSplitterNodeOutput + _k2, _i5);\n                  }\n                  outputChannelSplitterNodeOutput += outputChannelCount[_j4];\n                }\n              } catch (error) {\n                isActive = false;\n                nativeAudioWorkletNodeFaker.dispatchEvent(new ErrorEvent('processorerror', {\n                  colno: error.colno,\n                  filename: error.filename,\n                  lineno: error.lineno,\n                  message: error.message\n                }));\n              }\n              if (!isActive) {\n                for (var _j5 = 0; _j5 < options.numberOfInputs; _j5 += 1) {\n                  gainNodes[_j5].disconnect(inputChannelSplitterNodes[_j5]);\n                  for (var _k3 = 0; _k3 < options.channelCount; _k3 += 1) {\n                    inputChannelSplitterNodes[_i5].disconnect(inputChannelMergerNode, _k3, _j5 * options.channelCount + _k3);\n                  }\n                }\n                if (processorConstructor.parameterDescriptors !== undefined) {\n                  var length = processorConstructor.parameterDescriptors.length;\n                  for (var _j6 = 0; _j6 < length; _j6 += 1) {\n                    var constantSourceNode = constantSourceNodes[_j6];\n                    constantSourceNode.disconnect(inputChannelMergerNode, 0, numberOfInputChannels + _j6);\n                    constantSourceNode.stop();\n                  }\n                }\n                inputChannelMergerNode.disconnect(scriptProcessorNode);\n                scriptProcessorNode.onaudioprocess = null; // tslint:disable-line:deprecation\n                if (isConnected) {\n                  disconnectOutputsGraph();\n                } else {\n                  disconnectFakeGraph();\n                }\n                return 1; // break\n              }\n            };\n            for (var _i5 = 0; _i5 < bufferSize; _i5 += 128) {\n              if (_loop2(_i5)) break;\n            }\n          }\n        };\n        var isConnected = false;\n        // Bug #87: Only Firefox will fire an AudioProcessingEvent if there is no connected output.\n        var nativeGainNode = createNativeGainNode(nativeContext, {\n          channelCount: 1,\n          channelCountMode: 'explicit',\n          channelInterpretation: 'discrete',\n          gain: 0\n        });\n        var connectFakeGraph = function connectFakeGraph() {\n          return scriptProcessorNode.connect(nativeGainNode).connect(nativeContext.destination);\n        };\n        var disconnectFakeGraph = function disconnectFakeGraph() {\n          scriptProcessorNode.disconnect(nativeGainNode);\n          nativeGainNode.disconnect();\n        };\n        var whenConnected = function whenConnected() {\n          if (isActive) {\n            disconnectFakeGraph();\n            if (options.numberOfOutputs > 0) {\n              scriptProcessorNode.connect(outputChannelSplitterNode);\n            }\n            for (var _i6 = 0, outputChannelSplitterNodeOutput = 0; _i6 < options.numberOfOutputs; _i6 += 1) {\n              var outputChannelMergerNode = outputChannelMergerNodes[_i6];\n              for (var _j7 = 0; _j7 < outputChannelCount[_i6]; _j7 += 1) {\n                outputChannelSplitterNode.connect(outputChannelMergerNode, outputChannelSplitterNodeOutput + _j7, _j7);\n              }\n              outputChannelSplitterNodeOutput += outputChannelCount[_i6];\n            }\n          }\n          isConnected = true;\n        };\n        var whenDisconnected = function whenDisconnected() {\n          if (isActive) {\n            connectFakeGraph();\n            disconnectOutputsGraph();\n          }\n          isConnected = false;\n        };\n        connectFakeGraph();\n        return monitorConnections(nativeAudioWorkletNodeFaker, whenConnected, whenDisconnected);\n      };\n    };\n\n    var createNativeBiquadFilterNode = function createNativeBiquadFilterNode(nativeContext, options) {\n      var nativeBiquadFilterNode = nativeContext.createBiquadFilter();\n      assignNativeAudioNodeOptions(nativeBiquadFilterNode, options);\n      assignNativeAudioNodeAudioParamValue(nativeBiquadFilterNode, options, 'Q');\n      assignNativeAudioNodeAudioParamValue(nativeBiquadFilterNode, options, 'detune');\n      assignNativeAudioNodeAudioParamValue(nativeBiquadFilterNode, options, 'frequency');\n      assignNativeAudioNodeAudioParamValue(nativeBiquadFilterNode, options, 'gain');\n      assignNativeAudioNodeOption(nativeBiquadFilterNode, options, 'type');\n      return nativeBiquadFilterNode;\n    };\n\n    var createNativeChannelMergerNodeFactory = function createNativeChannelMergerNodeFactory(nativeAudioContextConstructor, wrapChannelMergerNode) {\n      return function (nativeContext, options) {\n        var nativeChannelMergerNode = nativeContext.createChannelMerger(options.numberOfInputs);\n        /*\n         * Bug #20: Safari requires a connection of any kind to treat the input signal correctly.\n         * @todo Unfortunately there is no way to test for this behavior in a synchronous fashion which is why testing for the existence of\n         * the webkitAudioContext is used as a workaround here.\n         */\n        if (nativeAudioContextConstructor !== null && nativeAudioContextConstructor.name === 'webkitAudioContext') {\n          wrapChannelMergerNode(nativeContext, nativeChannelMergerNode);\n        }\n        assignNativeAudioNodeOptions(nativeChannelMergerNode, options);\n        return nativeChannelMergerNode;\n      };\n    };\n\n    var wrapChannelSplitterNode = function wrapChannelSplitterNode(channelSplitterNode) {\n      var channelCount = channelSplitterNode.numberOfOutputs;\n      // Bug #97: Safari does not throw an error when attempting to change the channelCount to something other than its initial value.\n      Object.defineProperty(channelSplitterNode, 'channelCount', {\n        get: function get() {\n          return channelCount;\n        },\n        set: function set(value) {\n          if (value !== channelCount) {\n            throw createInvalidStateError();\n          }\n        }\n      });\n      // Bug #30: Safari does not throw an error when attempting to change the channelCountMode to something other than explicit.\n      Object.defineProperty(channelSplitterNode, 'channelCountMode', {\n        get: function get() {\n          return 'explicit';\n        },\n        set: function set(value) {\n          if (value !== 'explicit') {\n            throw createInvalidStateError();\n          }\n        }\n      });\n      // Bug #32: Safari does not throw an error when attempting to change the channelInterpretation to something other than discrete.\n      Object.defineProperty(channelSplitterNode, 'channelInterpretation', {\n        get: function get() {\n          return 'discrete';\n        },\n        set: function set(value) {\n          if (value !== 'discrete') {\n            throw createInvalidStateError();\n          }\n        }\n      });\n    };\n\n    var createNativeChannelSplitterNode = function createNativeChannelSplitterNode(nativeContext, options) {\n      var nativeChannelSplitterNode = nativeContext.createChannelSplitter(options.numberOfOutputs);\n      // Bug #96: Safari does not have the correct channelCount.\n      // Bug #29: Safari does not have the correct channelCountMode.\n      // Bug #31: Safari does not have the correct channelInterpretation.\n      assignNativeAudioNodeOptions(nativeChannelSplitterNode, options);\n      // Bug #29, #30, #31, #32, #96 & #97: Only Chrome, Edge & Firefox partially support the spec yet.\n      wrapChannelSplitterNode(nativeChannelSplitterNode);\n      return nativeChannelSplitterNode;\n    };\n\n    var createNativeConstantSourceNodeFactory = function createNativeConstantSourceNodeFactory(addSilentConnection, cacheTestResult, createNativeConstantSourceNodeFaker, testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, testAudioScheduledSourceNodeStopMethodNegativeParametersSupport) {\n      return function (nativeContext, options) {\n        // Bug #62: Safari does not support ConstantSourceNodes.\n        if (nativeContext.createConstantSource === undefined) {\n          return createNativeConstantSourceNodeFaker(nativeContext, options);\n        }\n        var nativeConstantSourceNode = nativeContext.createConstantSource();\n        assignNativeAudioNodeOptions(nativeConstantSourceNode, options);\n        assignNativeAudioNodeAudioParamValue(nativeConstantSourceNode, options, 'offset');\n        // Bug #44: Safari does not throw a RangeError yet.\n        if (!cacheTestResult(testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, function () {\n          return testAudioScheduledSourceNodeStartMethodNegativeParametersSupport(nativeContext);\n        })) {\n          wrapAudioScheduledSourceNodeStartMethodNegativeParameters(nativeConstantSourceNode);\n        }\n        // Bug #44: Only Firefox does not throw a RangeError yet.\n        if (!cacheTestResult(testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, function () {\n          return testAudioScheduledSourceNodeStopMethodNegativeParametersSupport(nativeContext);\n        })) {\n          wrapAudioScheduledSourceNodeStopMethodNegativeParameters(nativeConstantSourceNode);\n        }\n        // Bug #175: Safari will not fire an ended event if the ConstantSourceNode is unconnected.\n        addSilentConnection(nativeContext, nativeConstantSourceNode);\n        return nativeConstantSourceNode;\n      };\n    };\n\n    var interceptConnections = function interceptConnections(original, interceptor) {\n      original.connect = interceptor.connect.bind(interceptor);\n      original.disconnect = interceptor.disconnect.bind(interceptor);\n      return original;\n    };\n\n    var _excluded$3 = [\"offset\"];\n    function ownKeys$d(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\n    function _objectSpread$d(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$d(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$d(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n    var createNativeConstantSourceNodeFakerFactory = function createNativeConstantSourceNodeFakerFactory(addSilentConnection, createNativeAudioBufferSourceNode, createNativeGainNode, monitorConnections) {\n      return function (nativeContext, _ref) {\n        var offset = _ref.offset,\n          audioNodeOptions = _objectWithoutProperties(_ref, _excluded$3);\n        var audioBuffer = nativeContext.createBuffer(1, 2, 44100);\n        var audioBufferSourceNode = createNativeAudioBufferSourceNode(nativeContext, {\n          buffer: null,\n          channelCount: 2,\n          channelCountMode: 'max',\n          channelInterpretation: 'speakers',\n          loop: false,\n          loopEnd: 0,\n          loopStart: 0,\n          playbackRate: 1\n        });\n        var gainNode = createNativeGainNode(nativeContext, _objectSpread$d(_objectSpread$d({}, audioNodeOptions), {}, {\n          gain: offset\n        }));\n        // Bug #5: Safari does not support copyFromChannel() and copyToChannel().\n        var channelData = audioBuffer.getChannelData(0);\n        // Bug #95: Safari does not play or loop one sample buffers.\n        channelData[0] = 1;\n        channelData[1] = 1;\n        audioBufferSourceNode.buffer = audioBuffer;\n        audioBufferSourceNode.loop = true;\n        var nativeConstantSourceNodeFaker = {\n          get bufferSize() {\n            return undefined;\n          },\n          get channelCount() {\n            return gainNode.channelCount;\n          },\n          set channelCount(value) {\n            gainNode.channelCount = value;\n          },\n          get channelCountMode() {\n            return gainNode.channelCountMode;\n          },\n          set channelCountMode(value) {\n            gainNode.channelCountMode = value;\n          },\n          get channelInterpretation() {\n            return gainNode.channelInterpretation;\n          },\n          set channelInterpretation(value) {\n            gainNode.channelInterpretation = value;\n          },\n          get context() {\n            return gainNode.context;\n          },\n          get inputs() {\n            return [];\n          },\n          get numberOfInputs() {\n            return audioBufferSourceNode.numberOfInputs;\n          },\n          get numberOfOutputs() {\n            return gainNode.numberOfOutputs;\n          },\n          get offset() {\n            return gainNode.gain;\n          },\n          get onended() {\n            return audioBufferSourceNode.onended;\n          },\n          set onended(value) {\n            audioBufferSourceNode.onended = value;\n          },\n          addEventListener: function addEventListener() {\n            return audioBufferSourceNode.addEventListener(arguments.length <= 0 ? undefined : arguments[0], arguments.length <= 1 ? undefined : arguments[1], arguments.length <= 2 ? undefined : arguments[2]);\n          },\n          dispatchEvent: function dispatchEvent() {\n            return audioBufferSourceNode.dispatchEvent(arguments.length <= 0 ? undefined : arguments[0]);\n          },\n          removeEventListener: function removeEventListener() {\n            return audioBufferSourceNode.removeEventListener(arguments.length <= 0 ? undefined : arguments[0], arguments.length <= 1 ? undefined : arguments[1], arguments.length <= 2 ? undefined : arguments[2]);\n          },\n          start: function start() {\n            var when = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n            audioBufferSourceNode.start.call(audioBufferSourceNode, when);\n          },\n          stop: function stop() {\n            var when = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n            audioBufferSourceNode.stop.call(audioBufferSourceNode, when);\n          }\n        };\n        var whenConnected = function whenConnected() {\n          return audioBufferSourceNode.connect(gainNode);\n        };\n        var whenDisconnected = function whenDisconnected() {\n          return audioBufferSourceNode.disconnect(gainNode);\n        };\n        // Bug #175: Safari will not fire an ended event if the AudioBufferSourceNode is unconnected.\n        addSilentConnection(nativeContext, audioBufferSourceNode);\n        return monitorConnections(interceptConnections(nativeConstantSourceNodeFaker, gainNode), whenConnected, whenDisconnected);\n      };\n    };\n\n    var createNativeConvolverNodeFactory = function createNativeConvolverNodeFactory(createNotSupportedError, overwriteAccessors) {\n      return function (nativeContext, options) {\n        var nativeConvolverNode = nativeContext.createConvolver();\n        assignNativeAudioNodeOptions(nativeConvolverNode, options);\n        // The normalize property needs to be set before setting the buffer.\n        if (options.disableNormalization === nativeConvolverNode.normalize) {\n          nativeConvolverNode.normalize = !options.disableNormalization;\n        }\n        assignNativeAudioNodeOption(nativeConvolverNode, options, 'buffer');\n        // Bug #113: Safari does allow to set the channelCount to a value larger than 2.\n        if (options.channelCount > 2) {\n          throw createNotSupportedError();\n        }\n        overwriteAccessors(nativeConvolverNode, 'channelCount', function (get) {\n          return function () {\n            return get.call(nativeConvolverNode);\n          };\n        }, function (set) {\n          return function (value) {\n            if (value > 2) {\n              throw createNotSupportedError();\n            }\n            return set.call(nativeConvolverNode, value);\n          };\n        });\n        // Bug #114: Safari allows to set the channelCountMode to 'max'.\n        if (options.channelCountMode === 'max') {\n          throw createNotSupportedError();\n        }\n        overwriteAccessors(nativeConvolverNode, 'channelCountMode', function (get) {\n          return function () {\n            return get.call(nativeConvolverNode);\n          };\n        }, function (set) {\n          return function (value) {\n            if (value === 'max') {\n              throw createNotSupportedError();\n            }\n            return set.call(nativeConvolverNode, value);\n          };\n        });\n        return nativeConvolverNode;\n      };\n    };\n\n    var createNativeDelayNode = function createNativeDelayNode(nativeContext, options) {\n      var nativeDelayNode = nativeContext.createDelay(options.maxDelayTime);\n      assignNativeAudioNodeOptions(nativeDelayNode, options);\n      assignNativeAudioNodeAudioParamValue(nativeDelayNode, options, 'delayTime');\n      return nativeDelayNode;\n    };\n\n    var createNativeDynamicsCompressorNodeFactory = function createNativeDynamicsCompressorNodeFactory(createNotSupportedError) {\n      return function (nativeContext, options) {\n        var nativeDynamicsCompressorNode = nativeContext.createDynamicsCompressor();\n        assignNativeAudioNodeOptions(nativeDynamicsCompressorNode, options);\n        // Bug #108: Safari allows a channelCount of three and above.\n        if (options.channelCount > 2) {\n          throw createNotSupportedError();\n        }\n        // Bug #109: Only Chrome and Firefox disallow a channelCountMode of 'max'.\n        if (options.channelCountMode === 'max') {\n          throw createNotSupportedError();\n        }\n        assignNativeAudioNodeAudioParamValue(nativeDynamicsCompressorNode, options, 'attack');\n        assignNativeAudioNodeAudioParamValue(nativeDynamicsCompressorNode, options, 'knee');\n        assignNativeAudioNodeAudioParamValue(nativeDynamicsCompressorNode, options, 'ratio');\n        assignNativeAudioNodeAudioParamValue(nativeDynamicsCompressorNode, options, 'release');\n        assignNativeAudioNodeAudioParamValue(nativeDynamicsCompressorNode, options, 'threshold');\n        return nativeDynamicsCompressorNode;\n      };\n    };\n\n    var createNativeGainNode = function createNativeGainNode(nativeContext, options) {\n      var nativeGainNode = nativeContext.createGain();\n      assignNativeAudioNodeOptions(nativeGainNode, options);\n      assignNativeAudioNodeAudioParamValue(nativeGainNode, options, 'gain');\n      return nativeGainNode;\n    };\n\n    var createNativeIIRFilterNodeFactory = function createNativeIIRFilterNodeFactory(createNativeIIRFilterNodeFaker) {\n      return function (nativeContext, baseLatency, options) {\n        // Bug #9: Safari does not support IIRFilterNodes.\n        if (nativeContext.createIIRFilter === undefined) {\n          return createNativeIIRFilterNodeFaker(nativeContext, baseLatency, options);\n        }\n        // @todo TypeScript defines the parameters of createIIRFilter() as arrays of numbers.\n        var nativeIIRFilterNode = nativeContext.createIIRFilter(options.feedforward, options.feedback);\n        assignNativeAudioNodeOptions(nativeIIRFilterNode, options);\n        return nativeIIRFilterNode;\n      };\n    };\n\n    function divide(a, b) {\n      var denominator = b[0] * b[0] + b[1] * b[1];\n      return [(a[0] * b[0] + a[1] * b[1]) / denominator, (a[1] * b[0] - a[0] * b[1]) / denominator];\n    }\n    function multiply(a, b) {\n      return [a[0] * b[0] - a[1] * b[1], a[0] * b[1] + a[1] * b[0]];\n    }\n    function evaluatePolynomial(coefficient, z) {\n      var result = [0, 0];\n      for (var i = coefficient.length - 1; i >= 0; i -= 1) {\n        result = multiply(result, z);\n        result[0] += coefficient[i];\n      }\n      return result;\n    }\n    var createNativeIIRFilterNodeFakerFactory = function createNativeIIRFilterNodeFakerFactory(createInvalidAccessError, createInvalidStateError, createNativeScriptProcessorNode, createNotSupportedError) {\n      return function (nativeContext, baseLatency, _ref) {\n        var channelCount = _ref.channelCount,\n          channelCountMode = _ref.channelCountMode,\n          channelInterpretation = _ref.channelInterpretation,\n          feedback = _ref.feedback,\n          feedforward = _ref.feedforward;\n        var bufferSize = computeBufferSize(baseLatency, nativeContext.sampleRate);\n        var convertedFeedback = feedback instanceof Float64Array ? feedback : new Float64Array(feedback);\n        var convertedFeedforward = feedforward instanceof Float64Array ? feedforward : new Float64Array(feedforward);\n        var feedbackLength = convertedFeedback.length;\n        var feedforwardLength = convertedFeedforward.length;\n        var minLength = Math.min(feedbackLength, feedforwardLength);\n        if (feedbackLength === 0 || feedbackLength > 20) {\n          throw createNotSupportedError();\n        }\n        if (convertedFeedback[0] === 0) {\n          throw createInvalidStateError();\n        }\n        if (feedforwardLength === 0 || feedforwardLength > 20) {\n          throw createNotSupportedError();\n        }\n        if (convertedFeedforward[0] === 0) {\n          throw createInvalidStateError();\n        }\n        if (convertedFeedback[0] !== 1) {\n          for (var i = 0; i < feedforwardLength; i += 1) {\n            convertedFeedforward[i] /= convertedFeedback[0];\n          }\n          for (var _i = 1; _i < feedbackLength; _i += 1) {\n            convertedFeedback[_i] /= convertedFeedback[0];\n          }\n        }\n        var scriptProcessorNode = createNativeScriptProcessorNode(nativeContext, bufferSize, channelCount, channelCount);\n        scriptProcessorNode.channelCount = channelCount;\n        scriptProcessorNode.channelCountMode = channelCountMode;\n        scriptProcessorNode.channelInterpretation = channelInterpretation;\n        var bufferLength = 32;\n        var bufferIndexes = [];\n        var xBuffers = [];\n        var yBuffers = [];\n        for (var _i2 = 0; _i2 < channelCount; _i2 += 1) {\n          bufferIndexes.push(0);\n          var xBuffer = new Float32Array(bufferLength);\n          var yBuffer = new Float32Array(bufferLength);\n          xBuffer.fill(0);\n          yBuffer.fill(0);\n          xBuffers.push(xBuffer);\n          yBuffers.push(yBuffer);\n        }\n        // tslint:disable-next-line:deprecation\n        scriptProcessorNode.onaudioprocess = function (event) {\n          var inputBuffer = event.inputBuffer;\n          var outputBuffer = event.outputBuffer;\n          var numberOfChannels = inputBuffer.numberOfChannels;\n          for (var _i3 = 0; _i3 < numberOfChannels; _i3 += 1) {\n            var input = inputBuffer.getChannelData(_i3);\n            var output = outputBuffer.getChannelData(_i3);\n            bufferIndexes[_i3] = filterBuffer(convertedFeedback, feedbackLength, convertedFeedforward, feedforwardLength, minLength, xBuffers[_i3], yBuffers[_i3], bufferIndexes[_i3], bufferLength, input, output);\n          }\n        };\n        var nyquist = nativeContext.sampleRate / 2;\n        var nativeIIRFilterNodeFaker = {\n          get bufferSize() {\n            return bufferSize;\n          },\n          get channelCount() {\n            return scriptProcessorNode.channelCount;\n          },\n          set channelCount(value) {\n            scriptProcessorNode.channelCount = value;\n          },\n          get channelCountMode() {\n            return scriptProcessorNode.channelCountMode;\n          },\n          set channelCountMode(value) {\n            scriptProcessorNode.channelCountMode = value;\n          },\n          get channelInterpretation() {\n            return scriptProcessorNode.channelInterpretation;\n          },\n          set channelInterpretation(value) {\n            scriptProcessorNode.channelInterpretation = value;\n          },\n          get context() {\n            return scriptProcessorNode.context;\n          },\n          get inputs() {\n            return [scriptProcessorNode];\n          },\n          get numberOfInputs() {\n            return scriptProcessorNode.numberOfInputs;\n          },\n          get numberOfOutputs() {\n            return scriptProcessorNode.numberOfOutputs;\n          },\n          addEventListener: function addEventListener() {\n            // @todo Dissallow adding an audioprocess listener.\n            return scriptProcessorNode.addEventListener(arguments.length <= 0 ? undefined : arguments[0], arguments.length <= 1 ? undefined : arguments[1], arguments.length <= 2 ? undefined : arguments[2]);\n          },\n          dispatchEvent: function dispatchEvent() {\n            return scriptProcessorNode.dispatchEvent(arguments.length <= 0 ? undefined : arguments[0]);\n          },\n          getFrequencyResponse: function getFrequencyResponse(frequencyHz, magResponse, phaseResponse) {\n            if (frequencyHz.length !== magResponse.length || magResponse.length !== phaseResponse.length) {\n              throw createInvalidAccessError();\n            }\n            var length = frequencyHz.length;\n            for (var _i4 = 0; _i4 < length; _i4 += 1) {\n              var omega = -Math.PI * (frequencyHz[_i4] / nyquist);\n              var z = [Math.cos(omega), Math.sin(omega)];\n              var numerator = evaluatePolynomial(convertedFeedforward, z);\n              var denominator = evaluatePolynomial(convertedFeedback, z);\n              var response = divide(numerator, denominator);\n              magResponse[_i4] = Math.sqrt(response[0] * response[0] + response[1] * response[1]);\n              phaseResponse[_i4] = Math.atan2(response[1], response[0]);\n            }\n          },\n          removeEventListener: function removeEventListener() {\n            return scriptProcessorNode.removeEventListener(arguments.length <= 0 ? undefined : arguments[0], arguments.length <= 1 ? undefined : arguments[1], arguments.length <= 2 ? undefined : arguments[2]);\n          }\n        };\n        return interceptConnections(nativeIIRFilterNodeFaker, scriptProcessorNode);\n      };\n    };\n\n    var createNativeMediaElementAudioSourceNode = function createNativeMediaElementAudioSourceNode(nativeAudioContext, options) {\n      return nativeAudioContext.createMediaElementSource(options.mediaElement);\n    };\n\n    var createNativeMediaStreamAudioDestinationNode = function createNativeMediaStreamAudioDestinationNode(nativeAudioContext, options) {\n      var nativeMediaStreamAudioDestinationNode = nativeAudioContext.createMediaStreamDestination();\n      assignNativeAudioNodeOptions(nativeMediaStreamAudioDestinationNode, options);\n      // Bug #174: Safari does expose a wrong numberOfOutputs.\n      if (nativeMediaStreamAudioDestinationNode.numberOfOutputs === 1) {\n        Object.defineProperty(nativeMediaStreamAudioDestinationNode, 'numberOfOutputs', {\n          get: function get() {\n            return 0;\n          }\n        });\n      }\n      return nativeMediaStreamAudioDestinationNode;\n    };\n\n    var createNativeMediaStreamAudioSourceNode = function createNativeMediaStreamAudioSourceNode(nativeAudioContext, _ref) {\n      var mediaStream = _ref.mediaStream;\n      var audioStreamTracks = mediaStream.getAudioTracks();\n      /*\n       * Bug #151: Safari does not use the audio track as input anymore if it gets removed from the mediaStream after construction.\n       * Bug #159: Safari picks the first audio track if the MediaStream has more than one audio track.\n       */\n      audioStreamTracks.sort(function (a, b) {\n        return a.id < b.id ? -1 : a.id > b.id ? 1 : 0;\n      });\n      var filteredAudioStreamTracks = audioStreamTracks.slice(0, 1);\n      var nativeMediaStreamAudioSourceNode = nativeAudioContext.createMediaStreamSource(new MediaStream(filteredAudioStreamTracks));\n      /*\n       * Bug #151 & #159: The given mediaStream gets reconstructed before it gets passed to the native node which is why the accessor needs\n       * to be overwritten as it would otherwise expose the reconstructed version.\n       */\n      Object.defineProperty(nativeMediaStreamAudioSourceNode, 'mediaStream', {\n        value: mediaStream\n      });\n      return nativeMediaStreamAudioSourceNode;\n    };\n\n    var createNativeMediaStreamTrackAudioSourceNodeFactory = function createNativeMediaStreamTrackAudioSourceNodeFactory(createInvalidStateError, isNativeOfflineAudioContext) {\n      return function (nativeAudioContext, _ref) {\n        var mediaStreamTrack = _ref.mediaStreamTrack;\n        // Bug #121: Only Firefox does yet support the MediaStreamTrackAudioSourceNode.\n        if (typeof nativeAudioContext.createMediaStreamTrackSource === 'function') {\n          return nativeAudioContext.createMediaStreamTrackSource(mediaStreamTrack);\n        }\n        var mediaStream = new MediaStream([mediaStreamTrack]);\n        var nativeMediaStreamAudioSourceNode = nativeAudioContext.createMediaStreamSource(mediaStream);\n        // Bug #120: Firefox does not throw an error if the mediaStream has no audio track.\n        if (mediaStreamTrack.kind !== 'audio') {\n          throw createInvalidStateError();\n        }\n        // Bug #172: Safari allows to create a MediaStreamAudioSourceNode with an OfflineAudioContext.\n        if (isNativeOfflineAudioContext(nativeAudioContext)) {\n          throw new TypeError();\n        }\n        return nativeMediaStreamAudioSourceNode;\n      };\n    };\n\n    var createNativeOfflineAudioContextConstructor = function createNativeOfflineAudioContextConstructor(window) {\n      if (window === null) {\n        return null;\n      }\n      if (window.hasOwnProperty('OfflineAudioContext')) {\n        return window.OfflineAudioContext;\n      }\n      return window.hasOwnProperty('webkitOfflineAudioContext') ? window.webkitOfflineAudioContext : null;\n    };\n\n    var createNativeOscillatorNodeFactory = function createNativeOscillatorNodeFactory(addSilentConnection, cacheTestResult, testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport, testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls) {\n      return function (nativeContext, options) {\n        var nativeOscillatorNode = nativeContext.createOscillator();\n        assignNativeAudioNodeOptions(nativeOscillatorNode, options);\n        assignNativeAudioNodeAudioParamValue(nativeOscillatorNode, options, 'detune');\n        assignNativeAudioNodeAudioParamValue(nativeOscillatorNode, options, 'frequency');\n        if (options.periodicWave !== undefined) {\n          nativeOscillatorNode.setPeriodicWave(options.periodicWave);\n        } else {\n          assignNativeAudioNodeOption(nativeOscillatorNode, options, 'type');\n        }\n        // Bug #44: Only Chrome & Edge throw a RangeError yet.\n        if (!cacheTestResult(testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, function () {\n          return testAudioScheduledSourceNodeStartMethodNegativeParametersSupport(nativeContext);\n        })) {\n          wrapAudioScheduledSourceNodeStartMethodNegativeParameters(nativeOscillatorNode);\n        }\n        // Bug #19: Safari does not ignore calls to stop() of an already stopped AudioBufferSourceNode.\n        if (!cacheTestResult(testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport, function () {\n          return testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport(nativeContext);\n        })) {\n          wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls(nativeOscillatorNode, nativeContext);\n        }\n        // Bug #44: Only Firefox does not throw a RangeError yet.\n        if (!cacheTestResult(testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, function () {\n          return testAudioScheduledSourceNodeStopMethodNegativeParametersSupport(nativeContext);\n        })) {\n          wrapAudioScheduledSourceNodeStopMethodNegativeParameters(nativeOscillatorNode);\n        }\n        // Bug #175: Safari will not fire an ended event if the OscillatorNode is unconnected.\n        addSilentConnection(nativeContext, nativeOscillatorNode);\n        return nativeOscillatorNode;\n      };\n    };\n\n    var createNativePannerNodeFactory = function createNativePannerNodeFactory(createNativePannerNodeFaker) {\n      return function (nativeContext, options) {\n        var nativePannerNode = nativeContext.createPanner();\n        // Bug #124: Safari does not support modifying the orientation and the position with AudioParams.\n        if (nativePannerNode.orientationX === undefined) {\n          return createNativePannerNodeFaker(nativeContext, options);\n        }\n        assignNativeAudioNodeOptions(nativePannerNode, options);\n        assignNativeAudioNodeAudioParamValue(nativePannerNode, options, 'orientationX');\n        assignNativeAudioNodeAudioParamValue(nativePannerNode, options, 'orientationY');\n        assignNativeAudioNodeAudioParamValue(nativePannerNode, options, 'orientationZ');\n        assignNativeAudioNodeAudioParamValue(nativePannerNode, options, 'positionX');\n        assignNativeAudioNodeAudioParamValue(nativePannerNode, options, 'positionY');\n        assignNativeAudioNodeAudioParamValue(nativePannerNode, options, 'positionZ');\n        assignNativeAudioNodeOption(nativePannerNode, options, 'coneInnerAngle');\n        assignNativeAudioNodeOption(nativePannerNode, options, 'coneOuterAngle');\n        assignNativeAudioNodeOption(nativePannerNode, options, 'coneOuterGain');\n        assignNativeAudioNodeOption(nativePannerNode, options, 'distanceModel');\n        assignNativeAudioNodeOption(nativePannerNode, options, 'maxDistance');\n        assignNativeAudioNodeOption(nativePannerNode, options, 'panningModel');\n        assignNativeAudioNodeOption(nativePannerNode, options, 'refDistance');\n        assignNativeAudioNodeOption(nativePannerNode, options, 'rolloffFactor');\n        return nativePannerNode;\n      };\n    };\n\n    var _excluded$2 = [\"coneInnerAngle\", \"coneOuterAngle\", \"coneOuterGain\", \"distanceModel\", \"maxDistance\", \"orientationX\", \"orientationY\", \"orientationZ\", \"panningModel\", \"positionX\", \"positionY\", \"positionZ\", \"refDistance\", \"rolloffFactor\"];\n    function ownKeys$c(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\n    function _objectSpread$c(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$c(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$c(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n    var createNativePannerNodeFakerFactory = function createNativePannerNodeFakerFactory(connectNativeAudioNodeToNativeAudioNode, createInvalidStateError, createNativeChannelMergerNode, createNativeGainNode, createNativeScriptProcessorNode, createNativeWaveShaperNode, createNotSupportedError, disconnectNativeAudioNodeFromNativeAudioNode, getFirstSample, monitorConnections) {\n      return function (nativeContext, _ref) {\n        var coneInnerAngle = _ref.coneInnerAngle,\n          coneOuterAngle = _ref.coneOuterAngle,\n          coneOuterGain = _ref.coneOuterGain,\n          distanceModel = _ref.distanceModel,\n          maxDistance = _ref.maxDistance,\n          orientationX = _ref.orientationX,\n          orientationY = _ref.orientationY,\n          orientationZ = _ref.orientationZ,\n          panningModel = _ref.panningModel,\n          positionX = _ref.positionX,\n          positionY = _ref.positionY,\n          positionZ = _ref.positionZ,\n          refDistance = _ref.refDistance,\n          rolloffFactor = _ref.rolloffFactor,\n          audioNodeOptions = _objectWithoutProperties(_ref, _excluded$2);\n        var pannerNode = nativeContext.createPanner();\n        // Bug #125: Safari does not throw an error yet.\n        if (audioNodeOptions.channelCount > 2) {\n          throw createNotSupportedError();\n        }\n        // Bug #126: Safari does not throw an error yet.\n        if (audioNodeOptions.channelCountMode === 'max') {\n          throw createNotSupportedError();\n        }\n        assignNativeAudioNodeOptions(pannerNode, audioNodeOptions);\n        var SINGLE_CHANNEL_OPTIONS = {\n          channelCount: 1,\n          channelCountMode: 'explicit',\n          channelInterpretation: 'discrete'\n        };\n        var channelMergerNode = createNativeChannelMergerNode(nativeContext, _objectSpread$c(_objectSpread$c({}, SINGLE_CHANNEL_OPTIONS), {}, {\n          channelInterpretation: 'speakers',\n          numberOfInputs: 6\n        }));\n        var inputGainNode = createNativeGainNode(nativeContext, _objectSpread$c(_objectSpread$c({}, audioNodeOptions), {}, {\n          gain: 1\n        }));\n        var orientationXGainNode = createNativeGainNode(nativeContext, _objectSpread$c(_objectSpread$c({}, SINGLE_CHANNEL_OPTIONS), {}, {\n          gain: 1\n        }));\n        var orientationYGainNode = createNativeGainNode(nativeContext, _objectSpread$c(_objectSpread$c({}, SINGLE_CHANNEL_OPTIONS), {}, {\n          gain: 0\n        }));\n        var orientationZGainNode = createNativeGainNode(nativeContext, _objectSpread$c(_objectSpread$c({}, SINGLE_CHANNEL_OPTIONS), {}, {\n          gain: 0\n        }));\n        var positionXGainNode = createNativeGainNode(nativeContext, _objectSpread$c(_objectSpread$c({}, SINGLE_CHANNEL_OPTIONS), {}, {\n          gain: 0\n        }));\n        var positionYGainNode = createNativeGainNode(nativeContext, _objectSpread$c(_objectSpread$c({}, SINGLE_CHANNEL_OPTIONS), {}, {\n          gain: 0\n        }));\n        var positionZGainNode = createNativeGainNode(nativeContext, _objectSpread$c(_objectSpread$c({}, SINGLE_CHANNEL_OPTIONS), {}, {\n          gain: 0\n        }));\n        var scriptProcessorNode = createNativeScriptProcessorNode(nativeContext, 256, 6, 1);\n        var waveShaperNode = createNativeWaveShaperNode(nativeContext, _objectSpread$c(_objectSpread$c({}, SINGLE_CHANNEL_OPTIONS), {}, {\n          curve: new Float32Array([1, 1]),\n          oversample: 'none'\n        }));\n        var lastOrientation = [orientationX, orientationY, orientationZ];\n        var lastPosition = [positionX, positionY, positionZ];\n        var buffer = new Float32Array(1);\n        // tslint:disable-next-line:deprecation\n        scriptProcessorNode.onaudioprocess = function (_ref2) {\n          var inputBuffer = _ref2.inputBuffer;\n          var orientation = [getFirstSample(inputBuffer, buffer, 0), getFirstSample(inputBuffer, buffer, 1), getFirstSample(inputBuffer, buffer, 2)];\n          if (orientation.some(function (value, index) {\n            return value !== lastOrientation[index];\n          })) {\n            pannerNode.setOrientation.apply(pannerNode, orientation); // tslint:disable-line:deprecation\n            lastOrientation = orientation;\n          }\n          var positon = [getFirstSample(inputBuffer, buffer, 3), getFirstSample(inputBuffer, buffer, 4), getFirstSample(inputBuffer, buffer, 5)];\n          if (positon.some(function (value, index) {\n            return value !== lastPosition[index];\n          })) {\n            pannerNode.setPosition.apply(pannerNode, positon); // tslint:disable-line:deprecation\n            lastPosition = positon;\n          }\n        };\n        Object.defineProperty(orientationYGainNode.gain, 'defaultValue', {\n          get: function get() {\n            return 0;\n          }\n        });\n        Object.defineProperty(orientationZGainNode.gain, 'defaultValue', {\n          get: function get() {\n            return 0;\n          }\n        });\n        Object.defineProperty(positionXGainNode.gain, 'defaultValue', {\n          get: function get() {\n            return 0;\n          }\n        });\n        Object.defineProperty(positionYGainNode.gain, 'defaultValue', {\n          get: function get() {\n            return 0;\n          }\n        });\n        Object.defineProperty(positionZGainNode.gain, 'defaultValue', {\n          get: function get() {\n            return 0;\n          }\n        });\n        var nativePannerNodeFaker = {\n          get bufferSize() {\n            return undefined;\n          },\n          get channelCount() {\n            return pannerNode.channelCount;\n          },\n          set channelCount(value) {\n            // Bug #125: Safari does not throw an error yet.\n            if (value > 2) {\n              throw createNotSupportedError();\n            }\n            inputGainNode.channelCount = value;\n            pannerNode.channelCount = value;\n          },\n          get channelCountMode() {\n            return pannerNode.channelCountMode;\n          },\n          set channelCountMode(value) {\n            // Bug #126: Safari does not throw an error yet.\n            if (value === 'max') {\n              throw createNotSupportedError();\n            }\n            inputGainNode.channelCountMode = value;\n            pannerNode.channelCountMode = value;\n          },\n          get channelInterpretation() {\n            return pannerNode.channelInterpretation;\n          },\n          set channelInterpretation(value) {\n            inputGainNode.channelInterpretation = value;\n            pannerNode.channelInterpretation = value;\n          },\n          get coneInnerAngle() {\n            return pannerNode.coneInnerAngle;\n          },\n          set coneInnerAngle(value) {\n            pannerNode.coneInnerAngle = value;\n          },\n          get coneOuterAngle() {\n            return pannerNode.coneOuterAngle;\n          },\n          set coneOuterAngle(value) {\n            pannerNode.coneOuterAngle = value;\n          },\n          get coneOuterGain() {\n            return pannerNode.coneOuterGain;\n          },\n          set coneOuterGain(value) {\n            // Bug #127: Safari does not throw an InvalidStateError yet.\n            if (value < 0 || value > 1) {\n              throw createInvalidStateError();\n            }\n            pannerNode.coneOuterGain = value;\n          },\n          get context() {\n            return pannerNode.context;\n          },\n          get distanceModel() {\n            return pannerNode.distanceModel;\n          },\n          set distanceModel(value) {\n            pannerNode.distanceModel = value;\n          },\n          get inputs() {\n            return [inputGainNode];\n          },\n          get maxDistance() {\n            return pannerNode.maxDistance;\n          },\n          set maxDistance(value) {\n            // Bug #128: Safari does not throw an error yet.\n            if (value < 0) {\n              throw new RangeError();\n            }\n            pannerNode.maxDistance = value;\n          },\n          get numberOfInputs() {\n            return pannerNode.numberOfInputs;\n          },\n          get numberOfOutputs() {\n            return pannerNode.numberOfOutputs;\n          },\n          get orientationX() {\n            return orientationXGainNode.gain;\n          },\n          get orientationY() {\n            return orientationYGainNode.gain;\n          },\n          get orientationZ() {\n            return orientationZGainNode.gain;\n          },\n          get panningModel() {\n            return pannerNode.panningModel;\n          },\n          set panningModel(value) {\n            pannerNode.panningModel = value;\n          },\n          get positionX() {\n            return positionXGainNode.gain;\n          },\n          get positionY() {\n            return positionYGainNode.gain;\n          },\n          get positionZ() {\n            return positionZGainNode.gain;\n          },\n          get refDistance() {\n            return pannerNode.refDistance;\n          },\n          set refDistance(value) {\n            // Bug #129: Safari does not throw an error yet.\n            if (value < 0) {\n              throw new RangeError();\n            }\n            pannerNode.refDistance = value;\n          },\n          get rolloffFactor() {\n            return pannerNode.rolloffFactor;\n          },\n          set rolloffFactor(value) {\n            // Bug #130: Safari does not throw an error yet.\n            if (value < 0) {\n              throw new RangeError();\n            }\n            pannerNode.rolloffFactor = value;\n          },\n          addEventListener: function addEventListener() {\n            return inputGainNode.addEventListener(arguments.length <= 0 ? undefined : arguments[0], arguments.length <= 1 ? undefined : arguments[1], arguments.length <= 2 ? undefined : arguments[2]);\n          },\n          dispatchEvent: function dispatchEvent() {\n            return inputGainNode.dispatchEvent(arguments.length <= 0 ? undefined : arguments[0]);\n          },\n          removeEventListener: function removeEventListener() {\n            return inputGainNode.removeEventListener(arguments.length <= 0 ? undefined : arguments[0], arguments.length <= 1 ? undefined : arguments[1], arguments.length <= 2 ? undefined : arguments[2]);\n          }\n        };\n        if (coneInnerAngle !== nativePannerNodeFaker.coneInnerAngle) {\n          nativePannerNodeFaker.coneInnerAngle = coneInnerAngle;\n        }\n        if (coneOuterAngle !== nativePannerNodeFaker.coneOuterAngle) {\n          nativePannerNodeFaker.coneOuterAngle = coneOuterAngle;\n        }\n        if (coneOuterGain !== nativePannerNodeFaker.coneOuterGain) {\n          nativePannerNodeFaker.coneOuterGain = coneOuterGain;\n        }\n        if (distanceModel !== nativePannerNodeFaker.distanceModel) {\n          nativePannerNodeFaker.distanceModel = distanceModel;\n        }\n        if (maxDistance !== nativePannerNodeFaker.maxDistance) {\n          nativePannerNodeFaker.maxDistance = maxDistance;\n        }\n        if (orientationX !== nativePannerNodeFaker.orientationX.value) {\n          nativePannerNodeFaker.orientationX.value = orientationX;\n        }\n        if (orientationY !== nativePannerNodeFaker.orientationY.value) {\n          nativePannerNodeFaker.orientationY.value = orientationY;\n        }\n        if (orientationZ !== nativePannerNodeFaker.orientationZ.value) {\n          nativePannerNodeFaker.orientationZ.value = orientationZ;\n        }\n        if (panningModel !== nativePannerNodeFaker.panningModel) {\n          nativePannerNodeFaker.panningModel = panningModel;\n        }\n        if (positionX !== nativePannerNodeFaker.positionX.value) {\n          nativePannerNodeFaker.positionX.value = positionX;\n        }\n        if (positionY !== nativePannerNodeFaker.positionY.value) {\n          nativePannerNodeFaker.positionY.value = positionY;\n        }\n        if (positionZ !== nativePannerNodeFaker.positionZ.value) {\n          nativePannerNodeFaker.positionZ.value = positionZ;\n        }\n        if (refDistance !== nativePannerNodeFaker.refDistance) {\n          nativePannerNodeFaker.refDistance = refDistance;\n        }\n        if (rolloffFactor !== nativePannerNodeFaker.rolloffFactor) {\n          nativePannerNodeFaker.rolloffFactor = rolloffFactor;\n        }\n        if (lastOrientation[0] !== 1 || lastOrientation[1] !== 0 || lastOrientation[2] !== 0) {\n          pannerNode.setOrientation.apply(pannerNode, _toConsumableArray(lastOrientation)); // tslint:disable-line:deprecation\n        }\n        if (lastPosition[0] !== 0 || lastPosition[1] !== 0 || lastPosition[2] !== 0) {\n          pannerNode.setPosition.apply(pannerNode, _toConsumableArray(lastPosition)); // tslint:disable-line:deprecation\n        }\n        var whenConnected = function whenConnected() {\n          inputGainNode.connect(pannerNode);\n          // Bug #119: Safari does not fully support the WaveShaperNode.\n          connectNativeAudioNodeToNativeAudioNode(inputGainNode, waveShaperNode, 0, 0);\n          waveShaperNode.connect(orientationXGainNode).connect(channelMergerNode, 0, 0);\n          waveShaperNode.connect(orientationYGainNode).connect(channelMergerNode, 0, 1);\n          waveShaperNode.connect(orientationZGainNode).connect(channelMergerNode, 0, 2);\n          waveShaperNode.connect(positionXGainNode).connect(channelMergerNode, 0, 3);\n          waveShaperNode.connect(positionYGainNode).connect(channelMergerNode, 0, 4);\n          waveShaperNode.connect(positionZGainNode).connect(channelMergerNode, 0, 5);\n          channelMergerNode.connect(scriptProcessorNode).connect(nativeContext.destination);\n        };\n        var whenDisconnected = function whenDisconnected() {\n          inputGainNode.disconnect(pannerNode);\n          // Bug #119: Safari does not fully support the WaveShaperNode.\n          disconnectNativeAudioNodeFromNativeAudioNode(inputGainNode, waveShaperNode, 0, 0);\n          waveShaperNode.disconnect(orientationXGainNode);\n          orientationXGainNode.disconnect(channelMergerNode);\n          waveShaperNode.disconnect(orientationYGainNode);\n          orientationYGainNode.disconnect(channelMergerNode);\n          waveShaperNode.disconnect(orientationZGainNode);\n          orientationZGainNode.disconnect(channelMergerNode);\n          waveShaperNode.disconnect(positionXGainNode);\n          positionXGainNode.disconnect(channelMergerNode);\n          waveShaperNode.disconnect(positionYGainNode);\n          positionYGainNode.disconnect(channelMergerNode);\n          waveShaperNode.disconnect(positionZGainNode);\n          positionZGainNode.disconnect(channelMergerNode);\n          channelMergerNode.disconnect(scriptProcessorNode);\n          scriptProcessorNode.disconnect(nativeContext.destination);\n        };\n        return monitorConnections(interceptConnections(nativePannerNodeFaker, pannerNode), whenConnected, whenDisconnected);\n      };\n    };\n\n    var createNativePeriodicWaveFactory = function createNativePeriodicWaveFactory(createIndexSizeError) {\n      return function (nativeContext, _ref) {\n        var disableNormalization = _ref.disableNormalization,\n          imag = _ref.imag,\n          real = _ref.real;\n        // Bug #180: Safari does not allow to use ordinary arrays.\n        var convertedImag = imag instanceof Float32Array ? imag : new Float32Array(imag);\n        var convertedReal = real instanceof Float32Array ? real : new Float32Array(real);\n        var nativePeriodicWave = nativeContext.createPeriodicWave(convertedReal, convertedImag, {\n          disableNormalization: disableNormalization\n        });\n        // Bug #181: Safari does not throw an IndexSizeError so far if the given arrays have less than two values.\n        if (Array.from(imag).length < 2) {\n          throw createIndexSizeError();\n        }\n        return nativePeriodicWave;\n      };\n    };\n\n    var createNativeScriptProcessorNode = function createNativeScriptProcessorNode(nativeContext, bufferSize, numberOfInputChannels, numberOfOutputChannels) {\n      return nativeContext.createScriptProcessor(bufferSize, numberOfInputChannels, numberOfOutputChannels); // tslint:disable-line deprecation\n    };\n\n    var createNativeStereoPannerNodeFactory = function createNativeStereoPannerNodeFactory(createNativeStereoPannerNodeFaker, createNotSupportedError) {\n      return function (nativeContext, options) {\n        var channelCountMode = options.channelCountMode;\n        /*\n         * Bug #105: The channelCountMode of 'clamped-max' should be supported. However it is not possible to write a polyfill for Safari\n         * which supports it and therefore it can't be supported at all.\n         */\n        if (channelCountMode === 'clamped-max') {\n          throw createNotSupportedError();\n        }\n        // Bug #105: Safari does not support the StereoPannerNode.\n        if (nativeContext.createStereoPanner === undefined) {\n          return createNativeStereoPannerNodeFaker(nativeContext, options);\n        }\n        var nativeStereoPannerNode = nativeContext.createStereoPanner();\n        assignNativeAudioNodeOptions(nativeStereoPannerNode, options);\n        assignNativeAudioNodeAudioParamValue(nativeStereoPannerNode, options, 'pan');\n        /*\n         * Bug #105: The channelCountMode of 'clamped-max' should be supported. However it is not possible to write a polyfill for Safari\n         * which supports it and therefore it can't be supported at all.\n         */\n        Object.defineProperty(nativeStereoPannerNode, 'channelCountMode', {\n          get: function get() {\n            return channelCountMode;\n          },\n          set: function set(value) {\n            if (value !== channelCountMode) {\n              throw createNotSupportedError();\n            }\n          }\n        });\n        return nativeStereoPannerNode;\n      };\n    };\n\n    var _excluded$1 = [\"channelCount\", \"channelCountMode\", \"pan\"];\n    function ownKeys$b(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\n    function _objectSpread$b(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$b(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$b(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n    var createNativeStereoPannerNodeFakerFactory = function createNativeStereoPannerNodeFakerFactory(createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeGainNode, createNativeWaveShaperNode, createNotSupportedError, monitorConnections) {\n      // The curve has a size of 14bit plus 1 value to have an exact representation for zero. This value has been determined experimentally.\n      var CURVE_SIZE = 16385;\n      var DC_CURVE = new Float32Array([1, 1]);\n      var HALF_PI = Math.PI / 2;\n      var SINGLE_CHANNEL_OPTIONS = {\n        channelCount: 1,\n        channelCountMode: 'explicit',\n        channelInterpretation: 'discrete'\n      };\n      var SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS = _objectSpread$b(_objectSpread$b({}, SINGLE_CHANNEL_OPTIONS), {}, {\n        oversample: 'none'\n      });\n      var buildInternalGraphForMono = function buildInternalGraphForMono(nativeContext, inputGainNode, panGainNode, channelMergerNode) {\n        var leftWaveShaperCurve = new Float32Array(CURVE_SIZE);\n        var rightWaveShaperCurve = new Float32Array(CURVE_SIZE);\n        for (var i = 0; i < CURVE_SIZE; i += 1) {\n          var x = i / (CURVE_SIZE - 1) * HALF_PI;\n          leftWaveShaperCurve[i] = Math.cos(x);\n          rightWaveShaperCurve[i] = Math.sin(x);\n        }\n        var leftGainNode = createNativeGainNode(nativeContext, _objectSpread$b(_objectSpread$b({}, SINGLE_CHANNEL_OPTIONS), {}, {\n          gain: 0\n        }));\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        var leftWaveShaperNode = createNativeWaveShaperNode(nativeContext, _objectSpread$b(_objectSpread$b({}, SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS), {}, {\n          curve: leftWaveShaperCurve\n        }));\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        var panWaveShaperNode = createNativeWaveShaperNode(nativeContext, _objectSpread$b(_objectSpread$b({}, SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS), {}, {\n          curve: DC_CURVE\n        }));\n        var rightGainNode = createNativeGainNode(nativeContext, _objectSpread$b(_objectSpread$b({}, SINGLE_CHANNEL_OPTIONS), {}, {\n          gain: 0\n        }));\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        var rightWaveShaperNode = createNativeWaveShaperNode(nativeContext, _objectSpread$b(_objectSpread$b({}, SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS), {}, {\n          curve: rightWaveShaperCurve\n        }));\n        return {\n          connectGraph: function connectGraph() {\n            inputGainNode.connect(leftGainNode);\n            inputGainNode.connect(panWaveShaperNode.inputs === undefined ? panWaveShaperNode : panWaveShaperNode.inputs[0]);\n            inputGainNode.connect(rightGainNode);\n            panWaveShaperNode.connect(panGainNode);\n            panGainNode.connect(leftWaveShaperNode.inputs === undefined ? leftWaveShaperNode : leftWaveShaperNode.inputs[0]);\n            panGainNode.connect(rightWaveShaperNode.inputs === undefined ? rightWaveShaperNode : rightWaveShaperNode.inputs[0]);\n            leftWaveShaperNode.connect(leftGainNode.gain);\n            rightWaveShaperNode.connect(rightGainNode.gain);\n            leftGainNode.connect(channelMergerNode, 0, 0);\n            rightGainNode.connect(channelMergerNode, 0, 1);\n          },\n          disconnectGraph: function disconnectGraph() {\n            inputGainNode.disconnect(leftGainNode);\n            inputGainNode.disconnect(panWaveShaperNode.inputs === undefined ? panWaveShaperNode : panWaveShaperNode.inputs[0]);\n            inputGainNode.disconnect(rightGainNode);\n            panWaveShaperNode.disconnect(panGainNode);\n            panGainNode.disconnect(leftWaveShaperNode.inputs === undefined ? leftWaveShaperNode : leftWaveShaperNode.inputs[0]);\n            panGainNode.disconnect(rightWaveShaperNode.inputs === undefined ? rightWaveShaperNode : rightWaveShaperNode.inputs[0]);\n            leftWaveShaperNode.disconnect(leftGainNode.gain);\n            rightWaveShaperNode.disconnect(rightGainNode.gain);\n            leftGainNode.disconnect(channelMergerNode, 0, 0);\n            rightGainNode.disconnect(channelMergerNode, 0, 1);\n          }\n        };\n      };\n      var buildInternalGraphForStereo = function buildInternalGraphForStereo(nativeContext, inputGainNode, panGainNode, channelMergerNode) {\n        var leftInputForLeftOutputWaveShaperCurve = new Float32Array(CURVE_SIZE);\n        var leftInputForRightOutputWaveShaperCurve = new Float32Array(CURVE_SIZE);\n        var rightInputForLeftOutputWaveShaperCurve = new Float32Array(CURVE_SIZE);\n        var rightInputForRightOutputWaveShaperCurve = new Float32Array(CURVE_SIZE);\n        var centerIndex = Math.floor(CURVE_SIZE / 2);\n        for (var i = 0; i < CURVE_SIZE; i += 1) {\n          if (i > centerIndex) {\n            var x = (i - centerIndex) / (CURVE_SIZE - 1 - centerIndex) * HALF_PI;\n            leftInputForLeftOutputWaveShaperCurve[i] = Math.cos(x);\n            leftInputForRightOutputWaveShaperCurve[i] = Math.sin(x);\n            rightInputForLeftOutputWaveShaperCurve[i] = 0;\n            rightInputForRightOutputWaveShaperCurve[i] = 1;\n          } else {\n            var _x = i / (CURVE_SIZE - 1 - centerIndex) * HALF_PI;\n            leftInputForLeftOutputWaveShaperCurve[i] = 1;\n            leftInputForRightOutputWaveShaperCurve[i] = 0;\n            rightInputForLeftOutputWaveShaperCurve[i] = Math.cos(_x);\n            rightInputForRightOutputWaveShaperCurve[i] = Math.sin(_x);\n          }\n        }\n        var channelSplitterNode = createNativeChannelSplitterNode(nativeContext, {\n          channelCount: 2,\n          channelCountMode: 'explicit',\n          channelInterpretation: 'discrete',\n          numberOfOutputs: 2\n        });\n        var leftInputForLeftOutputGainNode = createNativeGainNode(nativeContext, _objectSpread$b(_objectSpread$b({}, SINGLE_CHANNEL_OPTIONS), {}, {\n          gain: 0\n        }));\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        var leftInputForLeftOutputWaveShaperNode = createNativeWaveShaperNode(nativeContext, _objectSpread$b(_objectSpread$b({}, SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS), {}, {\n          curve: leftInputForLeftOutputWaveShaperCurve\n        }));\n        var leftInputForRightOutputGainNode = createNativeGainNode(nativeContext, _objectSpread$b(_objectSpread$b({}, SINGLE_CHANNEL_OPTIONS), {}, {\n          gain: 0\n        }));\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        var leftInputForRightOutputWaveShaperNode = createNativeWaveShaperNode(nativeContext, _objectSpread$b(_objectSpread$b({}, SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS), {}, {\n          curve: leftInputForRightOutputWaveShaperCurve\n        }));\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        var panWaveShaperNode = createNativeWaveShaperNode(nativeContext, _objectSpread$b(_objectSpread$b({}, SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS), {}, {\n          curve: DC_CURVE\n        }));\n        var rightInputForLeftOutputGainNode = createNativeGainNode(nativeContext, _objectSpread$b(_objectSpread$b({}, SINGLE_CHANNEL_OPTIONS), {}, {\n          gain: 0\n        }));\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        var rightInputForLeftOutputWaveShaperNode = createNativeWaveShaperNode(nativeContext, _objectSpread$b(_objectSpread$b({}, SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS), {}, {\n          curve: rightInputForLeftOutputWaveShaperCurve\n        }));\n        var rightInputForRightOutputGainNode = createNativeGainNode(nativeContext, _objectSpread$b(_objectSpread$b({}, SINGLE_CHANNEL_OPTIONS), {}, {\n          gain: 0\n        }));\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        var rightInputForRightOutputWaveShaperNode = createNativeWaveShaperNode(nativeContext, _objectSpread$b(_objectSpread$b({}, SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS), {}, {\n          curve: rightInputForRightOutputWaveShaperCurve\n        }));\n        return {\n          connectGraph: function connectGraph() {\n            inputGainNode.connect(channelSplitterNode);\n            inputGainNode.connect(panWaveShaperNode.inputs === undefined ? panWaveShaperNode : panWaveShaperNode.inputs[0]);\n            channelSplitterNode.connect(leftInputForLeftOutputGainNode, 0);\n            channelSplitterNode.connect(leftInputForRightOutputGainNode, 0);\n            channelSplitterNode.connect(rightInputForLeftOutputGainNode, 1);\n            channelSplitterNode.connect(rightInputForRightOutputGainNode, 1);\n            panWaveShaperNode.connect(panGainNode);\n            panGainNode.connect(leftInputForLeftOutputWaveShaperNode.inputs === undefined ? leftInputForLeftOutputWaveShaperNode : leftInputForLeftOutputWaveShaperNode.inputs[0]);\n            panGainNode.connect(leftInputForRightOutputWaveShaperNode.inputs === undefined ? leftInputForRightOutputWaveShaperNode : leftInputForRightOutputWaveShaperNode.inputs[0]);\n            panGainNode.connect(rightInputForLeftOutputWaveShaperNode.inputs === undefined ? rightInputForLeftOutputWaveShaperNode : rightInputForLeftOutputWaveShaperNode.inputs[0]);\n            panGainNode.connect(rightInputForRightOutputWaveShaperNode.inputs === undefined ? rightInputForRightOutputWaveShaperNode : rightInputForRightOutputWaveShaperNode.inputs[0]);\n            leftInputForLeftOutputWaveShaperNode.connect(leftInputForLeftOutputGainNode.gain);\n            leftInputForRightOutputWaveShaperNode.connect(leftInputForRightOutputGainNode.gain);\n            rightInputForLeftOutputWaveShaperNode.connect(rightInputForLeftOutputGainNode.gain);\n            rightInputForRightOutputWaveShaperNode.connect(rightInputForRightOutputGainNode.gain);\n            leftInputForLeftOutputGainNode.connect(channelMergerNode, 0, 0);\n            rightInputForLeftOutputGainNode.connect(channelMergerNode, 0, 0);\n            leftInputForRightOutputGainNode.connect(channelMergerNode, 0, 1);\n            rightInputForRightOutputGainNode.connect(channelMergerNode, 0, 1);\n          },\n          disconnectGraph: function disconnectGraph() {\n            inputGainNode.disconnect(channelSplitterNode);\n            inputGainNode.disconnect(panWaveShaperNode.inputs === undefined ? panWaveShaperNode : panWaveShaperNode.inputs[0]);\n            channelSplitterNode.disconnect(leftInputForLeftOutputGainNode, 0);\n            channelSplitterNode.disconnect(leftInputForRightOutputGainNode, 0);\n            channelSplitterNode.disconnect(rightInputForLeftOutputGainNode, 1);\n            channelSplitterNode.disconnect(rightInputForRightOutputGainNode, 1);\n            panWaveShaperNode.disconnect(panGainNode);\n            panGainNode.disconnect(leftInputForLeftOutputWaveShaperNode.inputs === undefined ? leftInputForLeftOutputWaveShaperNode : leftInputForLeftOutputWaveShaperNode.inputs[0]);\n            panGainNode.disconnect(leftInputForRightOutputWaveShaperNode.inputs === undefined ? leftInputForRightOutputWaveShaperNode : leftInputForRightOutputWaveShaperNode.inputs[0]);\n            panGainNode.disconnect(rightInputForLeftOutputWaveShaperNode.inputs === undefined ? rightInputForLeftOutputWaveShaperNode : rightInputForLeftOutputWaveShaperNode.inputs[0]);\n            panGainNode.disconnect(rightInputForRightOutputWaveShaperNode.inputs === undefined ? rightInputForRightOutputWaveShaperNode : rightInputForRightOutputWaveShaperNode.inputs[0]);\n            leftInputForLeftOutputWaveShaperNode.disconnect(leftInputForLeftOutputGainNode.gain);\n            leftInputForRightOutputWaveShaperNode.disconnect(leftInputForRightOutputGainNode.gain);\n            rightInputForLeftOutputWaveShaperNode.disconnect(rightInputForLeftOutputGainNode.gain);\n            rightInputForRightOutputWaveShaperNode.disconnect(rightInputForRightOutputGainNode.gain);\n            leftInputForLeftOutputGainNode.disconnect(channelMergerNode, 0, 0);\n            rightInputForLeftOutputGainNode.disconnect(channelMergerNode, 0, 0);\n            leftInputForRightOutputGainNode.disconnect(channelMergerNode, 0, 1);\n            rightInputForRightOutputGainNode.disconnect(channelMergerNode, 0, 1);\n          }\n        };\n      };\n      var buildInternalGraph = function buildInternalGraph(nativeContext, channelCount, inputGainNode, panGainNode, channelMergerNode) {\n        if (channelCount === 1) {\n          return buildInternalGraphForMono(nativeContext, inputGainNode, panGainNode, channelMergerNode);\n        }\n        if (channelCount === 2) {\n          return buildInternalGraphForStereo(nativeContext, inputGainNode, panGainNode, channelMergerNode);\n        }\n        throw createNotSupportedError();\n      };\n      return function (nativeContext, _ref) {\n        var channelCount = _ref.channelCount,\n          channelCountMode = _ref.channelCountMode,\n          pan = _ref.pan,\n          audioNodeOptions = _objectWithoutProperties(_ref, _excluded$1);\n        if (channelCountMode === 'max') {\n          throw createNotSupportedError();\n        }\n        var channelMergerNode = createNativeChannelMergerNode(nativeContext, _objectSpread$b(_objectSpread$b({}, audioNodeOptions), {}, {\n          channelCount: 1,\n          channelCountMode: channelCountMode,\n          numberOfInputs: 2\n        }));\n        var inputGainNode = createNativeGainNode(nativeContext, _objectSpread$b(_objectSpread$b({}, audioNodeOptions), {}, {\n          channelCount: channelCount,\n          channelCountMode: channelCountMode,\n          gain: 1\n        }));\n        var panGainNode = createNativeGainNode(nativeContext, {\n          channelCount: 1,\n          channelCountMode: 'explicit',\n          channelInterpretation: 'discrete',\n          gain: pan\n        });\n        var _buildInternalGraph = buildInternalGraph(nativeContext, channelCount, inputGainNode, panGainNode, channelMergerNode),\n          connectGraph = _buildInternalGraph.connectGraph,\n          disconnectGraph = _buildInternalGraph.disconnectGraph;\n        Object.defineProperty(panGainNode.gain, 'defaultValue', {\n          get: function get() {\n            return 0;\n          }\n        });\n        Object.defineProperty(panGainNode.gain, 'maxValue', {\n          get: function get() {\n            return 1;\n          }\n        });\n        Object.defineProperty(panGainNode.gain, 'minValue', {\n          get: function get() {\n            return -1;\n          }\n        });\n        var nativeStereoPannerNodeFakerFactory = {\n          get bufferSize() {\n            return undefined;\n          },\n          get channelCount() {\n            return inputGainNode.channelCount;\n          },\n          set channelCount(value) {\n            if (inputGainNode.channelCount !== value) {\n              if (isConnected) {\n                disconnectGraph();\n              }\n              var _buildInternalGraph2 = buildInternalGraph(nativeContext, value, inputGainNode, panGainNode, channelMergerNode);\n              connectGraph = _buildInternalGraph2.connectGraph;\n              disconnectGraph = _buildInternalGraph2.disconnectGraph;\n              if (isConnected) {\n                connectGraph();\n              }\n            }\n            inputGainNode.channelCount = value;\n          },\n          get channelCountMode() {\n            return inputGainNode.channelCountMode;\n          },\n          set channelCountMode(value) {\n            if (value === 'clamped-max' || value === 'max') {\n              throw createNotSupportedError();\n            }\n            inputGainNode.channelCountMode = value;\n          },\n          get channelInterpretation() {\n            return inputGainNode.channelInterpretation;\n          },\n          set channelInterpretation(value) {\n            inputGainNode.channelInterpretation = value;\n          },\n          get context() {\n            return inputGainNode.context;\n          },\n          get inputs() {\n            return [inputGainNode];\n          },\n          get numberOfInputs() {\n            return inputGainNode.numberOfInputs;\n          },\n          get numberOfOutputs() {\n            return inputGainNode.numberOfOutputs;\n          },\n          get pan() {\n            return panGainNode.gain;\n          },\n          addEventListener: function addEventListener() {\n            return inputGainNode.addEventListener(arguments.length <= 0 ? undefined : arguments[0], arguments.length <= 1 ? undefined : arguments[1], arguments.length <= 2 ? undefined : arguments[2]);\n          },\n          dispatchEvent: function dispatchEvent() {\n            return inputGainNode.dispatchEvent(arguments.length <= 0 ? undefined : arguments[0]);\n          },\n          removeEventListener: function removeEventListener() {\n            return inputGainNode.removeEventListener(arguments.length <= 0 ? undefined : arguments[0], arguments.length <= 1 ? undefined : arguments[1], arguments.length <= 2 ? undefined : arguments[2]);\n          }\n        };\n        var isConnected = false;\n        var whenConnected = function whenConnected() {\n          connectGraph();\n          isConnected = true;\n        };\n        var whenDisconnected = function whenDisconnected() {\n          disconnectGraph();\n          isConnected = false;\n        };\n        return monitorConnections(interceptConnections(nativeStereoPannerNodeFakerFactory, channelMergerNode), whenConnected, whenDisconnected);\n      };\n    };\n\n    var createNativeWaveShaperNodeFactory = function createNativeWaveShaperNodeFactory(createConnectedNativeAudioBufferSourceNode, createInvalidStateError, createNativeWaveShaperNodeFaker, isDCCurve, monitorConnections, nativeAudioContextConstructor, overwriteAccessors) {\n      return function (nativeContext, options) {\n        var nativeWaveShaperNode = nativeContext.createWaveShaper();\n        /*\n         * Bug #119: Safari does not correctly map the values.\n         * @todo Unfortunately there is no way to test for this behavior in a synchronous fashion which is why testing for the existence of\n         * the webkitAudioContext is used as a workaround here. Testing for the automationRate property is necessary because this workaround\n         * isn't necessary anymore since v14.0.2 of Safari.\n         */\n        if (nativeAudioContextConstructor !== null && nativeAudioContextConstructor.name === 'webkitAudioContext' && nativeContext.createGain().gain.automationRate === undefined) {\n          return createNativeWaveShaperNodeFaker(nativeContext, options);\n        }\n        assignNativeAudioNodeOptions(nativeWaveShaperNode, options);\n        var curve = options.curve === null || options.curve instanceof Float32Array ? options.curve : new Float32Array(options.curve);\n        // Bug #104: Chrome and Edge will throw an InvalidAccessError when the curve has less than two samples.\n        if (curve !== null && curve.length < 2) {\n          throw createInvalidStateError();\n        }\n        // Only values of type Float32Array can be assigned to the curve property.\n        assignNativeAudioNodeOption(nativeWaveShaperNode, {\n          curve: curve\n        }, 'curve');\n        assignNativeAudioNodeOption(nativeWaveShaperNode, options, 'oversample');\n        var disconnectNativeAudioBufferSourceNode = null;\n        var isConnected = false;\n        overwriteAccessors(nativeWaveShaperNode, 'curve', function (get) {\n          return function () {\n            return get.call(nativeWaveShaperNode);\n          };\n        }, function (set) {\n          return function (value) {\n            set.call(nativeWaveShaperNode, value);\n            if (isConnected) {\n              if (isDCCurve(value) && disconnectNativeAudioBufferSourceNode === null) {\n                disconnectNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNode(nativeContext, nativeWaveShaperNode);\n              } else if (!isDCCurve(value) && disconnectNativeAudioBufferSourceNode !== null) {\n                disconnectNativeAudioBufferSourceNode();\n                disconnectNativeAudioBufferSourceNode = null;\n              }\n            }\n            return value;\n          };\n        });\n        var whenConnected = function whenConnected() {\n          isConnected = true;\n          if (isDCCurve(nativeWaveShaperNode.curve)) {\n            disconnectNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNode(nativeContext, nativeWaveShaperNode);\n          }\n        };\n        var whenDisconnected = function whenDisconnected() {\n          isConnected = false;\n          if (disconnectNativeAudioBufferSourceNode !== null) {\n            disconnectNativeAudioBufferSourceNode();\n            disconnectNativeAudioBufferSourceNode = null;\n          }\n        };\n        return monitorConnections(nativeWaveShaperNode, whenConnected, whenDisconnected);\n      };\n    };\n\n    var _excluded = [\"curve\", \"oversample\"];\n    function ownKeys$a(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\n    function _objectSpread$a(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$a(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$a(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n    var createNativeWaveShaperNodeFakerFactory = function createNativeWaveShaperNodeFakerFactory(createConnectedNativeAudioBufferSourceNode, createInvalidStateError, createNativeGainNode, isDCCurve, monitorConnections) {\n      return function (nativeContext, _ref) {\n        var curve = _ref.curve,\n          oversample = _ref.oversample,\n          audioNodeOptions = _objectWithoutProperties(_ref, _excluded);\n        var negativeWaveShaperNode = nativeContext.createWaveShaper();\n        var positiveWaveShaperNode = nativeContext.createWaveShaper();\n        assignNativeAudioNodeOptions(negativeWaveShaperNode, audioNodeOptions);\n        assignNativeAudioNodeOptions(positiveWaveShaperNode, audioNodeOptions);\n        var inputGainNode = createNativeGainNode(nativeContext, _objectSpread$a(_objectSpread$a({}, audioNodeOptions), {}, {\n          gain: 1\n        }));\n        var invertGainNode = createNativeGainNode(nativeContext, _objectSpread$a(_objectSpread$a({}, audioNodeOptions), {}, {\n          gain: -1\n        }));\n        var outputGainNode = createNativeGainNode(nativeContext, _objectSpread$a(_objectSpread$a({}, audioNodeOptions), {}, {\n          gain: 1\n        }));\n        var revertGainNode = createNativeGainNode(nativeContext, _objectSpread$a(_objectSpread$a({}, audioNodeOptions), {}, {\n          gain: -1\n        }));\n        var disconnectNativeAudioBufferSourceNode = null;\n        var isConnected = false;\n        var unmodifiedCurve = null;\n        var nativeWaveShaperNodeFaker = {\n          get bufferSize() {\n            return undefined;\n          },\n          get channelCount() {\n            return negativeWaveShaperNode.channelCount;\n          },\n          set channelCount(value) {\n            inputGainNode.channelCount = value;\n            invertGainNode.channelCount = value;\n            negativeWaveShaperNode.channelCount = value;\n            outputGainNode.channelCount = value;\n            positiveWaveShaperNode.channelCount = value;\n            revertGainNode.channelCount = value;\n          },\n          get channelCountMode() {\n            return negativeWaveShaperNode.channelCountMode;\n          },\n          set channelCountMode(value) {\n            inputGainNode.channelCountMode = value;\n            invertGainNode.channelCountMode = value;\n            negativeWaveShaperNode.channelCountMode = value;\n            outputGainNode.channelCountMode = value;\n            positiveWaveShaperNode.channelCountMode = value;\n            revertGainNode.channelCountMode = value;\n          },\n          get channelInterpretation() {\n            return negativeWaveShaperNode.channelInterpretation;\n          },\n          set channelInterpretation(value) {\n            inputGainNode.channelInterpretation = value;\n            invertGainNode.channelInterpretation = value;\n            negativeWaveShaperNode.channelInterpretation = value;\n            outputGainNode.channelInterpretation = value;\n            positiveWaveShaperNode.channelInterpretation = value;\n            revertGainNode.channelInterpretation = value;\n          },\n          get context() {\n            return negativeWaveShaperNode.context;\n          },\n          get curve() {\n            return unmodifiedCurve;\n          },\n          set curve(value) {\n            // Bug #102: Safari does not throw an InvalidStateError when the curve has less than two samples.\n            if (value !== null && value.length < 2) {\n              throw createInvalidStateError();\n            }\n            if (value === null) {\n              negativeWaveShaperNode.curve = value;\n              positiveWaveShaperNode.curve = value;\n            } else {\n              var curveLength = value.length;\n              var negativeCurve = new Float32Array(curveLength + 2 - curveLength % 2);\n              var positiveCurve = new Float32Array(curveLength + 2 - curveLength % 2);\n              negativeCurve[0] = value[0];\n              positiveCurve[0] = -value[curveLength - 1];\n              var length = Math.ceil((curveLength + 1) / 2);\n              var centerIndex = (curveLength + 1) / 2 - 1;\n              for (var i = 1; i < length; i += 1) {\n                var theoreticIndex = i / length * centerIndex;\n                var lowerIndex = Math.floor(theoreticIndex);\n                var upperIndex = Math.ceil(theoreticIndex);\n                negativeCurve[i] = lowerIndex === upperIndex ? value[lowerIndex] : (1 - (theoreticIndex - lowerIndex)) * value[lowerIndex] + (1 - (upperIndex - theoreticIndex)) * value[upperIndex];\n                positiveCurve[i] = lowerIndex === upperIndex ? -value[curveLength - 1 - lowerIndex] : -((1 - (theoreticIndex - lowerIndex)) * value[curveLength - 1 - lowerIndex]) - (1 - (upperIndex - theoreticIndex)) * value[curveLength - 1 - upperIndex];\n              }\n              negativeCurve[length] = curveLength % 2 === 1 ? value[length - 1] : (value[length - 2] + value[length - 1]) / 2;\n              negativeWaveShaperNode.curve = negativeCurve;\n              positiveWaveShaperNode.curve = positiveCurve;\n            }\n            unmodifiedCurve = value;\n            if (isConnected) {\n              if (isDCCurve(unmodifiedCurve) && disconnectNativeAudioBufferSourceNode === null) {\n                disconnectNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNode(nativeContext, inputGainNode);\n              } else if (disconnectNativeAudioBufferSourceNode !== null) {\n                disconnectNativeAudioBufferSourceNode();\n                disconnectNativeAudioBufferSourceNode = null;\n              }\n            }\n          },\n          get inputs() {\n            return [inputGainNode];\n          },\n          get numberOfInputs() {\n            return negativeWaveShaperNode.numberOfInputs;\n          },\n          get numberOfOutputs() {\n            return negativeWaveShaperNode.numberOfOutputs;\n          },\n          get oversample() {\n            return negativeWaveShaperNode.oversample;\n          },\n          set oversample(value) {\n            negativeWaveShaperNode.oversample = value;\n            positiveWaveShaperNode.oversample = value;\n          },\n          addEventListener: function addEventListener() {\n            return inputGainNode.addEventListener(arguments.length <= 0 ? undefined : arguments[0], arguments.length <= 1 ? undefined : arguments[1], arguments.length <= 2 ? undefined : arguments[2]);\n          },\n          dispatchEvent: function dispatchEvent() {\n            return inputGainNode.dispatchEvent(arguments.length <= 0 ? undefined : arguments[0]);\n          },\n          removeEventListener: function removeEventListener() {\n            return inputGainNode.removeEventListener(arguments.length <= 0 ? undefined : arguments[0], arguments.length <= 1 ? undefined : arguments[1], arguments.length <= 2 ? undefined : arguments[2]);\n          }\n        };\n        if (curve !== null) {\n          // Only values of type Float32Array can be assigned to the curve property.\n          nativeWaveShaperNodeFaker.curve = curve instanceof Float32Array ? curve : new Float32Array(curve);\n        }\n        if (oversample !== nativeWaveShaperNodeFaker.oversample) {\n          nativeWaveShaperNodeFaker.oversample = oversample;\n        }\n        var whenConnected = function whenConnected() {\n          inputGainNode.connect(negativeWaveShaperNode).connect(outputGainNode);\n          inputGainNode.connect(invertGainNode).connect(positiveWaveShaperNode).connect(revertGainNode).connect(outputGainNode);\n          isConnected = true;\n          if (isDCCurve(unmodifiedCurve)) {\n            disconnectNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNode(nativeContext, inputGainNode);\n          }\n        };\n        var whenDisconnected = function whenDisconnected() {\n          inputGainNode.disconnect(negativeWaveShaperNode);\n          negativeWaveShaperNode.disconnect(outputGainNode);\n          inputGainNode.disconnect(invertGainNode);\n          invertGainNode.disconnect(positiveWaveShaperNode);\n          positiveWaveShaperNode.disconnect(revertGainNode);\n          revertGainNode.disconnect(outputGainNode);\n          isConnected = false;\n          if (disconnectNativeAudioBufferSourceNode !== null) {\n            disconnectNativeAudioBufferSourceNode();\n            disconnectNativeAudioBufferSourceNode = null;\n          }\n        };\n        return monitorConnections(interceptConnections(nativeWaveShaperNodeFaker, outputGainNode), whenConnected, whenDisconnected);\n      };\n    };\n\n    var createNotSupportedError = function createNotSupportedError() {\n      return new DOMException('', 'NotSupportedError');\n    };\n\n    function ownKeys$9(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\n    function _objectSpread$9(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$9(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$9(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n    function _callSuper$4(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$4() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\n    function _isNativeReflectConstruct$4() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$4 = function _isNativeReflectConstruct() { return !!t; })(); }\n    var DEFAULT_OPTIONS$5 = {\n      numberOfChannels: 1\n    };\n    var createOfflineAudioContextConstructor = function createOfflineAudioContextConstructor(baseAudioContextConstructor, cacheTestResult, createInvalidStateError, createNativeOfflineAudioContext, _startRendering) {\n      return /*#__PURE__*/function (_baseAudioContextCons) {\n        function OfflineAudioContext(a, b, c) {\n          var _this;\n          _classCallCheck(this, OfflineAudioContext);\n          var options;\n          if (typeof a === 'number' && b !== undefined && c !== undefined) {\n            options = {\n              length: b,\n              numberOfChannels: a,\n              sampleRate: c\n            };\n          } else if (_typeof(a) === 'object') {\n            options = a;\n          } else {\n            throw new Error('The given parameters are not valid.');\n          }\n          var _DEFAULT_OPTIONS$opti = _objectSpread$9(_objectSpread$9({}, DEFAULT_OPTIONS$5), options),\n            length = _DEFAULT_OPTIONS$opti.length,\n            numberOfChannels = _DEFAULT_OPTIONS$opti.numberOfChannels,\n            sampleRate = _DEFAULT_OPTIONS$opti.sampleRate;\n          var nativeOfflineAudioContext = createNativeOfflineAudioContext(numberOfChannels, length, sampleRate);\n          // #21 Safari does not support promises and therefore would fire the statechange event before the promise can be resolved.\n          if (!cacheTestResult(testPromiseSupport, function () {\n            return testPromiseSupport(nativeOfflineAudioContext);\n          })) {\n            nativeOfflineAudioContext.addEventListener('statechange', function () {\n              var i = 0;\n              var _delayStateChangeEvent = function delayStateChangeEvent(event) {\n                if (_this._state === 'running') {\n                  if (i > 0) {\n                    nativeOfflineAudioContext.removeEventListener('statechange', _delayStateChangeEvent);\n                    event.stopImmediatePropagation();\n                    _this._waitForThePromiseToSettle(event);\n                  } else {\n                    i += 1;\n                  }\n                }\n              };\n              return _delayStateChangeEvent;\n            }());\n          }\n          _this = _callSuper$4(this, OfflineAudioContext, [nativeOfflineAudioContext, numberOfChannels]);\n          _this._length = length;\n          _this._nativeOfflineAudioContext = nativeOfflineAudioContext;\n          _this._state = null;\n          return _this;\n        }\n        _inherits(OfflineAudioContext, _baseAudioContextCons);\n        return _createClass(OfflineAudioContext, [{\n          key: \"length\",\n          get: function get() {\n            // Bug #17: Safari does not yet expose the length.\n            if (this._nativeOfflineAudioContext.length === undefined) {\n              return this._length;\n            }\n            return this._nativeOfflineAudioContext.length;\n          }\n        }, {\n          key: \"state\",\n          get: function get() {\n            return this._state === null ? this._nativeOfflineAudioContext.state : this._state;\n          }\n        }, {\n          key: \"startRendering\",\n          value: function startRendering() {\n            var _this2 = this;\n            /*\n             * Bug #9 & #59: It is theoretically possible that startRendering() will first render a partialOfflineAudioContext. Therefore\n             * the state of the nativeOfflineAudioContext might no transition to running immediately.\n             */\n            if (this._state === 'running') {\n              return Promise.reject(createInvalidStateError());\n            }\n            this._state = 'running';\n            return _startRendering(this.destination, this._nativeOfflineAudioContext)[\"finally\"](function () {\n              _this2._state = null;\n              deactivateAudioGraph(_this2);\n            });\n          }\n        }, {\n          key: \"_waitForThePromiseToSettle\",\n          value: function _waitForThePromiseToSettle(event) {\n            var _this3 = this;\n            if (this._state === null) {\n              this._nativeOfflineAudioContext.dispatchEvent(event);\n            } else {\n              setTimeout(function () {\n                return _this3._waitForThePromiseToSettle(event);\n              });\n            }\n          }\n        }]);\n      }(baseAudioContextConstructor);\n    };\n\n    function ownKeys$8(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\n    function _objectSpread$8(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$8(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$8(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n    function _callSuper$3(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$3() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\n    function _isNativeReflectConstruct$3() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$3 = function _isNativeReflectConstruct() { return !!t; })(); }\n    var DEFAULT_OPTIONS$4 = {\n      channelCount: 2,\n      channelCountMode: 'max',\n      // This attribute has no effect for nodes with no inputs.\n      channelInterpretation: 'speakers',\n      // This attribute has no effect for nodes with no inputs.\n      detune: 0,\n      frequency: 440,\n      periodicWave: undefined,\n      type: 'sine'\n    };\n    var createOscillatorNodeConstructor = function createOscillatorNodeConstructor(audioNodeConstructor, createAudioParam, createNativeOscillatorNode, createOscillatorNodeRenderer, getNativeContext, isNativeOfflineAudioContext, wrapEventListener) {\n      return /*#__PURE__*/function (_audioNodeConstructor) {\n        function OscillatorNode(context, options) {\n          var _this;\n          _classCallCheck(this, OscillatorNode);\n          var nativeContext = getNativeContext(context);\n          var mergedOptions = _objectSpread$8(_objectSpread$8({}, DEFAULT_OPTIONS$4), options);\n          var nativeOscillatorNode = createNativeOscillatorNode(nativeContext, mergedOptions);\n          var isOffline = isNativeOfflineAudioContext(nativeContext);\n          var oscillatorNodeRenderer = isOffline ? createOscillatorNodeRenderer() : null;\n          var nyquist = context.sampleRate / 2;\n          _this = _callSuper$3(this, OscillatorNode, [context, false, nativeOscillatorNode, oscillatorNodeRenderer]);\n          // Bug #81: Firefox & Safari do not export the correct values for maxValue and minValue.\n          _this._detune = createAudioParam(_this, isOffline, nativeOscillatorNode.detune, 153600, -153600);\n          // Bug #76: Safari does not export the correct values for maxValue and minValue.\n          _this._frequency = createAudioParam(_this, isOffline, nativeOscillatorNode.frequency, nyquist, -nyquist);\n          _this._nativeOscillatorNode = nativeOscillatorNode;\n          _this._onended = null;\n          _this._oscillatorNodeRenderer = oscillatorNodeRenderer;\n          if (_this._oscillatorNodeRenderer !== null && mergedOptions.periodicWave !== undefined) {\n            _this._oscillatorNodeRenderer.periodicWave = mergedOptions.periodicWave;\n          }\n          return _this;\n        }\n        _inherits(OscillatorNode, _audioNodeConstructor);\n        return _createClass(OscillatorNode, [{\n          key: \"detune\",\n          get: function get() {\n            return this._detune;\n          }\n        }, {\n          key: \"frequency\",\n          get: function get() {\n            return this._frequency;\n          }\n        }, {\n          key: \"onended\",\n          get: function get() {\n            return this._onended;\n          },\n          set: function set(value) {\n            var wrappedListener = typeof value === 'function' ? wrapEventListener(this, value) : null;\n            this._nativeOscillatorNode.onended = wrappedListener;\n            var nativeOnEnded = this._nativeOscillatorNode.onended;\n            this._onended = nativeOnEnded !== null && nativeOnEnded === wrappedListener ? value : nativeOnEnded;\n          }\n        }, {\n          key: \"type\",\n          get: function get() {\n            return this._nativeOscillatorNode.type;\n          },\n          set: function set(value) {\n            this._nativeOscillatorNode.type = value;\n            if (this._oscillatorNodeRenderer !== null) {\n              this._oscillatorNodeRenderer.periodicWave = null;\n            }\n          }\n        }, {\n          key: \"setPeriodicWave\",\n          value: function setPeriodicWave(periodicWave) {\n            this._nativeOscillatorNode.setPeriodicWave(periodicWave);\n            if (this._oscillatorNodeRenderer !== null) {\n              this._oscillatorNodeRenderer.periodicWave = periodicWave;\n            }\n          }\n        }, {\n          key: \"start\",\n          value: function start() {\n            var _this2 = this;\n            var when = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n            this._nativeOscillatorNode.start(when);\n            if (this._oscillatorNodeRenderer !== null) {\n              this._oscillatorNodeRenderer.start = when;\n            }\n            if (this.context.state !== 'closed') {\n              setInternalStateToActive(this);\n              var _resetInternalStateToPassive = function resetInternalStateToPassive() {\n                _this2._nativeOscillatorNode.removeEventListener('ended', _resetInternalStateToPassive);\n                if (isActiveAudioNode(_this2)) {\n                  setInternalStateToPassive(_this2);\n                }\n              };\n              this._nativeOscillatorNode.addEventListener('ended', _resetInternalStateToPassive);\n            }\n          }\n        }, {\n          key: \"stop\",\n          value: function stop() {\n            var when = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n            this._nativeOscillatorNode.stop(when);\n            if (this._oscillatorNodeRenderer !== null) {\n              this._oscillatorNodeRenderer.stop = when;\n            }\n          }\n        }]);\n      }(audioNodeConstructor);\n    };\n\n    var createOscillatorNodeRendererFactory = function createOscillatorNodeRendererFactory(connectAudioParam, createNativeOscillatorNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode) {\n      return function () {\n        var renderedNativeOscillatorNodes = new WeakMap();\n        var periodicWave = null;\n        var start = null;\n        var stop = null;\n        var createOscillatorNode = /*#__PURE__*/function () {\n          var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(proxy, nativeOfflineAudioContext) {\n            var nativeOscillatorNode, nativeOscillatorNodeIsOwnedByContext, options;\n            return _regeneratorRuntime.wrap(function _callee$(_context) {\n              while (1) switch (_context.prev = _context.next) {\n                case 0:\n                  nativeOscillatorNode = getNativeAudioNode(proxy); // If the initially used nativeOscillatorNode was not constructed on the same OfflineAudioContext it needs to be created again.\n                  nativeOscillatorNodeIsOwnedByContext = isOwnedByContext(nativeOscillatorNode, nativeOfflineAudioContext);\n                  if (!nativeOscillatorNodeIsOwnedByContext) {\n                    options = {\n                      channelCount: nativeOscillatorNode.channelCount,\n                      channelCountMode: nativeOscillatorNode.channelCountMode,\n                      channelInterpretation: nativeOscillatorNode.channelInterpretation,\n                      detune: nativeOscillatorNode.detune.value,\n                      frequency: nativeOscillatorNode.frequency.value,\n                      periodicWave: periodicWave === null ? undefined : periodicWave,\n                      type: nativeOscillatorNode.type\n                    };\n                    nativeOscillatorNode = createNativeOscillatorNode(nativeOfflineAudioContext, options);\n                    if (start !== null) {\n                      nativeOscillatorNode.start(start);\n                    }\n                    if (stop !== null) {\n                      nativeOscillatorNode.stop(stop);\n                    }\n                  }\n                  renderedNativeOscillatorNodes.set(nativeOfflineAudioContext, nativeOscillatorNode);\n                  if (nativeOscillatorNodeIsOwnedByContext) {\n                    _context.next = 11;\n                    break;\n                  }\n                  _context.next = 7;\n                  return renderAutomation(nativeOfflineAudioContext, proxy.detune, nativeOscillatorNode.detune);\n                case 7:\n                  _context.next = 9;\n                  return renderAutomation(nativeOfflineAudioContext, proxy.frequency, nativeOscillatorNode.frequency);\n                case 9:\n                  _context.next = 15;\n                  break;\n                case 11:\n                  _context.next = 13;\n                  return connectAudioParam(nativeOfflineAudioContext, proxy.detune, nativeOscillatorNode.detune);\n                case 13:\n                  _context.next = 15;\n                  return connectAudioParam(nativeOfflineAudioContext, proxy.frequency, nativeOscillatorNode.frequency);\n                case 15:\n                  _context.next = 17;\n                  return renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeOscillatorNode);\n                case 17:\n                  return _context.abrupt(\"return\", nativeOscillatorNode);\n                case 18:\n                case \"end\":\n                  return _context.stop();\n              }\n            }, _callee);\n          }));\n          return function createOscillatorNode(_x, _x2) {\n            return _ref.apply(this, arguments);\n          };\n        }();\n        return {\n          set periodicWave(value) {\n            periodicWave = value;\n          },\n          set start(value) {\n            start = value;\n          },\n          set stop(value) {\n            stop = value;\n          },\n          render: function render(proxy, nativeOfflineAudioContext) {\n            var renderedNativeOscillatorNode = renderedNativeOscillatorNodes.get(nativeOfflineAudioContext);\n            if (renderedNativeOscillatorNode !== undefined) {\n              return Promise.resolve(renderedNativeOscillatorNode);\n            }\n            return createOscillatorNode(proxy, nativeOfflineAudioContext);\n          }\n        };\n      };\n    };\n\n    function ownKeys$7(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\n    function _objectSpread$7(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$7(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$7(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n    function _callSuper$2(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$2() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\n    function _isNativeReflectConstruct$2() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$2 = function _isNativeReflectConstruct() { return !!t; })(); }\n    var DEFAULT_OPTIONS$3 = {\n      channelCount: 2,\n      channelCountMode: 'clamped-max',\n      channelInterpretation: 'speakers',\n      coneInnerAngle: 360,\n      coneOuterAngle: 360,\n      coneOuterGain: 0,\n      distanceModel: 'inverse',\n      maxDistance: 10000,\n      orientationX: 1,\n      orientationY: 0,\n      orientationZ: 0,\n      panningModel: 'equalpower',\n      positionX: 0,\n      positionY: 0,\n      positionZ: 0,\n      refDistance: 1,\n      rolloffFactor: 1\n    };\n    var createPannerNodeConstructor = function createPannerNodeConstructor(audioNodeConstructor, createAudioParam, createNativePannerNode, createPannerNodeRenderer, getNativeContext, isNativeOfflineAudioContext, setAudioNodeTailTime) {\n      return /*#__PURE__*/function (_audioNodeConstructor) {\n        function PannerNode(context, options) {\n          var _this;\n          _classCallCheck(this, PannerNode);\n          var nativeContext = getNativeContext(context);\n          var mergedOptions = _objectSpread$7(_objectSpread$7({}, DEFAULT_OPTIONS$3), options);\n          var nativePannerNode = createNativePannerNode(nativeContext, mergedOptions);\n          var isOffline = isNativeOfflineAudioContext(nativeContext);\n          var pannerNodeRenderer = isOffline ? createPannerNodeRenderer() : null;\n          _this = _callSuper$2(this, PannerNode, [context, false, nativePannerNode, pannerNodeRenderer]);\n          _this._nativePannerNode = nativePannerNode;\n          // Bug #74: Safari does not export the correct values for maxValue and minValue.\n          _this._orientationX = createAudioParam(_this, isOffline, nativePannerNode.orientationX, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n          _this._orientationY = createAudioParam(_this, isOffline, nativePannerNode.orientationY, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n          _this._orientationZ = createAudioParam(_this, isOffline, nativePannerNode.orientationZ, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n          _this._positionX = createAudioParam(_this, isOffline, nativePannerNode.positionX, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n          _this._positionY = createAudioParam(_this, isOffline, nativePannerNode.positionY, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n          _this._positionZ = createAudioParam(_this, isOffline, nativePannerNode.positionZ, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n          // @todo Determine a meaningful tail-time instead of just using one second.\n          setAudioNodeTailTime(_this, 1);\n          return _this;\n        }\n        _inherits(PannerNode, _audioNodeConstructor);\n        return _createClass(PannerNode, [{\n          key: \"coneInnerAngle\",\n          get: function get() {\n            return this._nativePannerNode.coneInnerAngle;\n          },\n          set: function set(value) {\n            this._nativePannerNode.coneInnerAngle = value;\n          }\n        }, {\n          key: \"coneOuterAngle\",\n          get: function get() {\n            return this._nativePannerNode.coneOuterAngle;\n          },\n          set: function set(value) {\n            this._nativePannerNode.coneOuterAngle = value;\n          }\n        }, {\n          key: \"coneOuterGain\",\n          get: function get() {\n            return this._nativePannerNode.coneOuterGain;\n          },\n          set: function set(value) {\n            this._nativePannerNode.coneOuterGain = value;\n          }\n        }, {\n          key: \"distanceModel\",\n          get: function get() {\n            return this._nativePannerNode.distanceModel;\n          },\n          set: function set(value) {\n            this._nativePannerNode.distanceModel = value;\n          }\n        }, {\n          key: \"maxDistance\",\n          get: function get() {\n            return this._nativePannerNode.maxDistance;\n          },\n          set: function set(value) {\n            this._nativePannerNode.maxDistance = value;\n          }\n        }, {\n          key: \"orientationX\",\n          get: function get() {\n            return this._orientationX;\n          }\n        }, {\n          key: \"orientationY\",\n          get: function get() {\n            return this._orientationY;\n          }\n        }, {\n          key: \"orientationZ\",\n          get: function get() {\n            return this._orientationZ;\n          }\n        }, {\n          key: \"panningModel\",\n          get: function get() {\n            return this._nativePannerNode.panningModel;\n          },\n          set: function set(value) {\n            this._nativePannerNode.panningModel = value;\n          }\n        }, {\n          key: \"positionX\",\n          get: function get() {\n            return this._positionX;\n          }\n        }, {\n          key: \"positionY\",\n          get: function get() {\n            return this._positionY;\n          }\n        }, {\n          key: \"positionZ\",\n          get: function get() {\n            return this._positionZ;\n          }\n        }, {\n          key: \"refDistance\",\n          get: function get() {\n            return this._nativePannerNode.refDistance;\n          },\n          set: function set(value) {\n            this._nativePannerNode.refDistance = value;\n          }\n        }, {\n          key: \"rolloffFactor\",\n          get: function get() {\n            return this._nativePannerNode.rolloffFactor;\n          },\n          set: function set(value) {\n            this._nativePannerNode.rolloffFactor = value;\n          }\n        }]);\n      }(audioNodeConstructor);\n    };\n\n    function ownKeys$6(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\n    function _objectSpread$6(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$6(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$6(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n    var createPannerNodeRendererFactory = function createPannerNodeRendererFactory(connectAudioParam, createNativeChannelMergerNode, createNativeConstantSourceNode, createNativeGainNode, createNativePannerNode, getNativeAudioNode, nativeOfflineAudioContextConstructor, renderAutomation, renderInputsOfAudioNode, renderNativeOfflineAudioContext) {\n      return function () {\n        var renderedNativeAudioNodes = new WeakMap();\n        var renderedBufferPromise = null;\n        var createAudioNode = /*#__PURE__*/function () {\n          var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee3(proxy, nativeOfflineAudioContext) {\n            var nativeGainNode, nativePannerNode, commonAudioNodeOptions, commonNativePannerNodeOptions, nativePannerNodeIsOwnedByContext, options, partialOfflineAudioContext, nativeChannelMergerNode, renderedBuffer, inputGainNode, channelDatas, i, lastOrientation, lastPosition, gateGainNode, partialPannerNode, _i, orientation, positon, currentTime;\n            return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n              while (1) switch (_context3.prev = _context3.next) {\n                case 0:\n                  nativeGainNode = null;\n                  nativePannerNode = getNativeAudioNode(proxy);\n                  commonAudioNodeOptions = {\n                    channelCount: nativePannerNode.channelCount,\n                    channelCountMode: nativePannerNode.channelCountMode,\n                    channelInterpretation: nativePannerNode.channelInterpretation\n                  };\n                  commonNativePannerNodeOptions = _objectSpread$6(_objectSpread$6({}, commonAudioNodeOptions), {}, {\n                    coneInnerAngle: nativePannerNode.coneInnerAngle,\n                    coneOuterAngle: nativePannerNode.coneOuterAngle,\n                    coneOuterGain: nativePannerNode.coneOuterGain,\n                    distanceModel: nativePannerNode.distanceModel,\n                    maxDistance: nativePannerNode.maxDistance,\n                    panningModel: nativePannerNode.panningModel,\n                    refDistance: nativePannerNode.refDistance,\n                    rolloffFactor: nativePannerNode.rolloffFactor\n                  }); // If the initially used nativePannerNode was not constructed on the same OfflineAudioContext it needs to be created again.\n                  nativePannerNodeIsOwnedByContext = isOwnedByContext(nativePannerNode, nativeOfflineAudioContext); // Bug #124: Safari does not support modifying the orientation and the position with AudioParams.\n                  if ('bufferSize' in nativePannerNode) {\n                    nativeGainNode = createNativeGainNode(nativeOfflineAudioContext, _objectSpread$6(_objectSpread$6({}, commonAudioNodeOptions), {}, {\n                      gain: 1\n                    }));\n                  } else if (!nativePannerNodeIsOwnedByContext) {\n                    options = _objectSpread$6(_objectSpread$6({}, commonNativePannerNodeOptions), {}, {\n                      orientationX: nativePannerNode.orientationX.value,\n                      orientationY: nativePannerNode.orientationY.value,\n                      orientationZ: nativePannerNode.orientationZ.value,\n                      positionX: nativePannerNode.positionX.value,\n                      positionY: nativePannerNode.positionY.value,\n                      positionZ: nativePannerNode.positionZ.value\n                    });\n                    nativePannerNode = createNativePannerNode(nativeOfflineAudioContext, options);\n                  }\n                  renderedNativeAudioNodes.set(nativeOfflineAudioContext, nativeGainNode === null ? nativePannerNode : nativeGainNode);\n                  if (!(nativeGainNode !== null)) {\n                    _context3.next = 31;\n                    break;\n                  }\n                  if (!(renderedBufferPromise === null)) {\n                    _context3.next = 15;\n                    break;\n                  }\n                  if (!(nativeOfflineAudioContextConstructor === null)) {\n                    _context3.next = 11;\n                    break;\n                  }\n                  throw new Error('Missing the native OfflineAudioContext constructor.');\n                case 11:\n                  partialOfflineAudioContext = new nativeOfflineAudioContextConstructor(6,\n                  // Bug #17: Safari does not yet expose the length.\n                  proxy.context.length, nativeOfflineAudioContext.sampleRate);\n                  nativeChannelMergerNode = createNativeChannelMergerNode(partialOfflineAudioContext, {\n                    channelCount: 1,\n                    channelCountMode: 'explicit',\n                    channelInterpretation: 'speakers',\n                    numberOfInputs: 6\n                  });\n                  nativeChannelMergerNode.connect(partialOfflineAudioContext.destination);\n                  renderedBufferPromise = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n                    var nativeConstantSourceNodes, i;\n                    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n                      while (1) switch (_context2.prev = _context2.next) {\n                        case 0:\n                          _context2.next = 2;\n                          return Promise.all([proxy.orientationX, proxy.orientationY, proxy.orientationZ, proxy.positionX, proxy.positionY, proxy.positionZ].map(/*#__PURE__*/function () {\n                            var _ref3 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(audioParam, index) {\n                              var nativeConstantSourceNode;\n                              return _regeneratorRuntime.wrap(function _callee$(_context) {\n                                while (1) switch (_context.prev = _context.next) {\n                                  case 0:\n                                    nativeConstantSourceNode = createNativeConstantSourceNode(partialOfflineAudioContext, {\n                                      channelCount: 1,\n                                      channelCountMode: 'explicit',\n                                      channelInterpretation: 'discrete',\n                                      offset: index === 0 ? 1 : 0\n                                    });\n                                    _context.next = 3;\n                                    return renderAutomation(partialOfflineAudioContext, audioParam, nativeConstantSourceNode.offset);\n                                  case 3:\n                                    return _context.abrupt(\"return\", nativeConstantSourceNode);\n                                  case 4:\n                                  case \"end\":\n                                    return _context.stop();\n                                }\n                              }, _callee);\n                            }));\n                            return function (_x3, _x4) {\n                              return _ref3.apply(this, arguments);\n                            };\n                          }()));\n                        case 2:\n                          nativeConstantSourceNodes = _context2.sent;\n                          for (i = 0; i < 6; i += 1) {\n                            nativeConstantSourceNodes[i].connect(nativeChannelMergerNode, 0, i);\n                            nativeConstantSourceNodes[i].start(0);\n                          }\n                          return _context2.abrupt(\"return\", renderNativeOfflineAudioContext(partialOfflineAudioContext));\n                        case 5:\n                        case \"end\":\n                          return _context2.stop();\n                      }\n                    }, _callee2);\n                  }))();\n                case 15:\n                  _context3.next = 17;\n                  return renderedBufferPromise;\n                case 17:\n                  renderedBuffer = _context3.sent;\n                  inputGainNode = createNativeGainNode(nativeOfflineAudioContext, _objectSpread$6(_objectSpread$6({}, commonAudioNodeOptions), {}, {\n                    gain: 1\n                  }));\n                  _context3.next = 21;\n                  return renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, inputGainNode);\n                case 21:\n                  channelDatas = [];\n                  for (i = 0; i < renderedBuffer.numberOfChannels; i += 1) {\n                    channelDatas.push(renderedBuffer.getChannelData(i));\n                  }\n                  lastOrientation = [channelDatas[0][0], channelDatas[1][0], channelDatas[2][0]];\n                  lastPosition = [channelDatas[3][0], channelDatas[4][0], channelDatas[5][0]];\n                  gateGainNode = createNativeGainNode(nativeOfflineAudioContext, _objectSpread$6(_objectSpread$6({}, commonAudioNodeOptions), {}, {\n                    gain: 1\n                  }));\n                  partialPannerNode = createNativePannerNode(nativeOfflineAudioContext, _objectSpread$6(_objectSpread$6({}, commonNativePannerNodeOptions), {}, {\n                    orientationX: lastOrientation[0],\n                    orientationY: lastOrientation[1],\n                    orientationZ: lastOrientation[2],\n                    positionX: lastPosition[0],\n                    positionY: lastPosition[1],\n                    positionZ: lastPosition[2]\n                  }));\n                  inputGainNode.connect(gateGainNode).connect(partialPannerNode.inputs[0]);\n                  partialPannerNode.connect(nativeGainNode);\n                  for (_i = 128; _i < renderedBuffer.length; _i += 128) {\n                    orientation = [channelDatas[0][_i], channelDatas[1][_i], channelDatas[2][_i]];\n                    positon = [channelDatas[3][_i], channelDatas[4][_i], channelDatas[5][_i]];\n                    if (orientation.some(function (value, index) {\n                      return value !== lastOrientation[index];\n                    }) || positon.some(function (value, index) {\n                      return value !== lastPosition[index];\n                    })) {\n                      lastOrientation = orientation;\n                      lastPosition = positon;\n                      currentTime = _i / nativeOfflineAudioContext.sampleRate;\n                      gateGainNode.gain.setValueAtTime(0, currentTime);\n                      gateGainNode = createNativeGainNode(nativeOfflineAudioContext, _objectSpread$6(_objectSpread$6({}, commonAudioNodeOptions), {}, {\n                        gain: 0\n                      }));\n                      partialPannerNode = createNativePannerNode(nativeOfflineAudioContext, _objectSpread$6(_objectSpread$6({}, commonNativePannerNodeOptions), {}, {\n                        orientationX: lastOrientation[0],\n                        orientationY: lastOrientation[1],\n                        orientationZ: lastOrientation[2],\n                        positionX: lastPosition[0],\n                        positionY: lastPosition[1],\n                        positionZ: lastPosition[2]\n                      }));\n                      gateGainNode.gain.setValueAtTime(1, currentTime);\n                      inputGainNode.connect(gateGainNode).connect(partialPannerNode.inputs[0]);\n                      partialPannerNode.connect(nativeGainNode);\n                    }\n                  }\n                  return _context3.abrupt(\"return\", nativeGainNode);\n                case 31:\n                  if (nativePannerNodeIsOwnedByContext) {\n                    _context3.next = 46;\n                    break;\n                  }\n                  _context3.next = 34;\n                  return renderAutomation(nativeOfflineAudioContext, proxy.orientationX, nativePannerNode.orientationX);\n                case 34:\n                  _context3.next = 36;\n                  return renderAutomation(nativeOfflineAudioContext, proxy.orientationY, nativePannerNode.orientationY);\n                case 36:\n                  _context3.next = 38;\n                  return renderAutomation(nativeOfflineAudioContext, proxy.orientationZ, nativePannerNode.orientationZ);\n                case 38:\n                  _context3.next = 40;\n                  return renderAutomation(nativeOfflineAudioContext, proxy.positionX, nativePannerNode.positionX);\n                case 40:\n                  _context3.next = 42;\n                  return renderAutomation(nativeOfflineAudioContext, proxy.positionY, nativePannerNode.positionY);\n                case 42:\n                  _context3.next = 44;\n                  return renderAutomation(nativeOfflineAudioContext, proxy.positionZ, nativePannerNode.positionZ);\n                case 44:\n                  _context3.next = 58;\n                  break;\n                case 46:\n                  _context3.next = 48;\n                  return connectAudioParam(nativeOfflineAudioContext, proxy.orientationX, nativePannerNode.orientationX);\n                case 48:\n                  _context3.next = 50;\n                  return connectAudioParam(nativeOfflineAudioContext, proxy.orientationY, nativePannerNode.orientationY);\n                case 50:\n                  _context3.next = 52;\n                  return connectAudioParam(nativeOfflineAudioContext, proxy.orientationZ, nativePannerNode.orientationZ);\n                case 52:\n                  _context3.next = 54;\n                  return connectAudioParam(nativeOfflineAudioContext, proxy.positionX, nativePannerNode.positionX);\n                case 54:\n                  _context3.next = 56;\n                  return connectAudioParam(nativeOfflineAudioContext, proxy.positionY, nativePannerNode.positionY);\n                case 56:\n                  _context3.next = 58;\n                  return connectAudioParam(nativeOfflineAudioContext, proxy.positionZ, nativePannerNode.positionZ);\n                case 58:\n                  if (!isNativeAudioNodeFaker(nativePannerNode)) {\n                    _context3.next = 63;\n                    break;\n                  }\n                  _context3.next = 61;\n                  return renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativePannerNode.inputs[0]);\n                case 61:\n                  _context3.next = 65;\n                  break;\n                case 63:\n                  _context3.next = 65;\n                  return renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativePannerNode);\n                case 65:\n                  return _context3.abrupt(\"return\", nativePannerNode);\n                case 66:\n                case \"end\":\n                  return _context3.stop();\n              }\n            }, _callee3);\n          }));\n          return function createAudioNode(_x, _x2) {\n            return _ref.apply(this, arguments);\n          };\n        }();\n        return {\n          render: function render(proxy, nativeOfflineAudioContext) {\n            var renderedNativeGainNodeOrNativePannerNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);\n            if (renderedNativeGainNodeOrNativePannerNode !== undefined) {\n              return Promise.resolve(renderedNativeGainNodeOrNativePannerNode);\n            }\n            return createAudioNode(proxy, nativeOfflineAudioContext);\n          }\n        };\n      };\n    };\n\n    function ownKeys$5(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\n    function _objectSpread$5(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$5(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$5(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n    var DEFAULT_OPTIONS$2 = {\n      disableNormalization: false\n    };\n    var createPeriodicWaveConstructor = function createPeriodicWaveConstructor(createNativePeriodicWave, getNativeContext, periodicWaveStore, sanitizePeriodicWaveOptions) {\n      return /*#__PURE__*/function () {\n        function PeriodicWave(context, options) {\n          _classCallCheck(this, PeriodicWave);\n          var nativeContext = getNativeContext(context);\n          var mergedOptions = sanitizePeriodicWaveOptions(_objectSpread$5(_objectSpread$5({}, DEFAULT_OPTIONS$2), options));\n          var periodicWave = createNativePeriodicWave(nativeContext, mergedOptions);\n          periodicWaveStore.add(periodicWave);\n          // This does violate all good pratices but it is used here to simplify the handling of periodic waves.\n          return periodicWave;\n        }\n        return _createClass(PeriodicWave, null, [{\n          key: Symbol.hasInstance,\n          value: function value(instance) {\n            return instance !== null && _typeof(instance) === 'object' && Object.getPrototypeOf(instance) === PeriodicWave.prototype || periodicWaveStore.has(instance);\n          }\n        }]);\n      }();\n    };\n\n    var createRenderAutomation = function createRenderAutomation(getAudioParamRenderer, renderInputsOfAudioParam) {\n      return function (nativeOfflineAudioContext, audioParam, nativeAudioParam) {\n        var audioParamRenderer = getAudioParamRenderer(audioParam);\n        audioParamRenderer.replay(nativeAudioParam);\n        return renderInputsOfAudioParam(audioParam, nativeOfflineAudioContext, nativeAudioParam);\n      };\n    };\n\n    var createRenderInputsOfAudioNode = function createRenderInputsOfAudioNode(getAudioNodeConnections, getAudioNodeRenderer, isPartOfACycle) {\n      return /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee2(audioNode, nativeOfflineAudioContext, nativeAudioNode) {\n          var audioNodeConnections;\n          return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n            while (1) switch (_context2.prev = _context2.next) {\n              case 0:\n                audioNodeConnections = getAudioNodeConnections(audioNode);\n                _context2.next = 3;\n                return Promise.all(audioNodeConnections.activeInputs.map(function (connections, input) {\n                  return Array.from(connections).map(/*#__PURE__*/function () {\n                    var _ref3 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(_ref2) {\n                      var _ref4, source, output, audioNodeRenderer, renderedNativeAudioNode, destination;\n                      return _regeneratorRuntime.wrap(function _callee$(_context) {\n                        while (1) switch (_context.prev = _context.next) {\n                          case 0:\n                            _ref4 = _slicedToArray(_ref2, 2), source = _ref4[0], output = _ref4[1];\n                            audioNodeRenderer = getAudioNodeRenderer(source);\n                            _context.next = 4;\n                            return audioNodeRenderer.render(source, nativeOfflineAudioContext);\n                          case 4:\n                            renderedNativeAudioNode = _context.sent;\n                            destination = audioNode.context.destination;\n                            if (!isPartOfACycle(source) && (audioNode !== destination || !isPartOfACycle(audioNode))) {\n                              renderedNativeAudioNode.connect(nativeAudioNode, output, input);\n                            }\n                          case 7:\n                          case \"end\":\n                            return _context.stop();\n                        }\n                      }, _callee);\n                    }));\n                    return function (_x4) {\n                      return _ref3.apply(this, arguments);\n                    };\n                  }());\n                }).reduce(function (allRenderingPromises, renderingPromises) {\n                  return [].concat(_toConsumableArray(allRenderingPromises), _toConsumableArray(renderingPromises));\n                }, []));\n              case 3:\n              case \"end\":\n                return _context2.stop();\n            }\n          }, _callee2);\n        }));\n        return function (_x, _x2, _x3) {\n          return _ref.apply(this, arguments);\n        };\n      }();\n    };\n\n    var createRenderInputsOfAudioParam = function createRenderInputsOfAudioParam(getAudioNodeRenderer, getAudioParamConnections, isPartOfACycle) {\n      return /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee2(audioParam, nativeOfflineAudioContext, nativeAudioParam) {\n          var audioParamConnections;\n          return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n            while (1) switch (_context2.prev = _context2.next) {\n              case 0:\n                audioParamConnections = getAudioParamConnections(audioParam);\n                _context2.next = 3;\n                return Promise.all(Array.from(audioParamConnections.activeInputs).map(/*#__PURE__*/function () {\n                  var _ref3 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(_ref2) {\n                    var _ref4, source, output, audioNodeRenderer, renderedNativeAudioNode;\n                    return _regeneratorRuntime.wrap(function _callee$(_context) {\n                      while (1) switch (_context.prev = _context.next) {\n                        case 0:\n                          _ref4 = _slicedToArray(_ref2, 2), source = _ref4[0], output = _ref4[1];\n                          audioNodeRenderer = getAudioNodeRenderer(source);\n                          _context.next = 4;\n                          return audioNodeRenderer.render(source, nativeOfflineAudioContext);\n                        case 4:\n                          renderedNativeAudioNode = _context.sent;\n                          if (!isPartOfACycle(source)) {\n                            renderedNativeAudioNode.connect(nativeAudioParam, output);\n                          }\n                        case 6:\n                        case \"end\":\n                          return _context.stop();\n                      }\n                    }, _callee);\n                  }));\n                  return function (_x4) {\n                    return _ref3.apply(this, arguments);\n                  };\n                }()));\n              case 3:\n              case \"end\":\n                return _context2.stop();\n            }\n          }, _callee2);\n        }));\n        return function (_x, _x2, _x3) {\n          return _ref.apply(this, arguments);\n        };\n      }();\n    };\n\n    var createRenderNativeOfflineAudioContext = function createRenderNativeOfflineAudioContext(cacheTestResult, createNativeGainNode, createNativeScriptProcessorNode, testOfflineAudioContextCurrentTimeSupport) {\n      return function (nativeOfflineAudioContext) {\n        // Bug #21: Safari does not support promises yet.\n        if (cacheTestResult(testPromiseSupport, function () {\n          return testPromiseSupport(nativeOfflineAudioContext);\n        })) {\n          // Bug #158: Chrome and Edge do not advance currentTime if it is not accessed while rendering the audio.\n          return Promise.resolve(cacheTestResult(testOfflineAudioContextCurrentTimeSupport, testOfflineAudioContextCurrentTimeSupport)).then(function (isOfflineAudioContextCurrentTimeSupported) {\n            if (!isOfflineAudioContextCurrentTimeSupported) {\n              var scriptProcessorNode = createNativeScriptProcessorNode(nativeOfflineAudioContext, 512, 0, 1);\n              nativeOfflineAudioContext.oncomplete = function () {\n                scriptProcessorNode.onaudioprocess = null; // tslint:disable-line:deprecation\n                scriptProcessorNode.disconnect();\n              };\n              scriptProcessorNode.onaudioprocess = function () {\n                return nativeOfflineAudioContext.currentTime;\n              }; // tslint:disable-line:deprecation\n              scriptProcessorNode.connect(nativeOfflineAudioContext.destination);\n            }\n            return nativeOfflineAudioContext.startRendering();\n          });\n        }\n        return new Promise(function (resolve) {\n          // Bug #48: Safari does not render an OfflineAudioContext without any connected node.\n          var gainNode = createNativeGainNode(nativeOfflineAudioContext, {\n            channelCount: 1,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'discrete',\n            gain: 0\n          });\n          nativeOfflineAudioContext.oncomplete = function (event) {\n            gainNode.disconnect();\n            resolve(event.renderedBuffer);\n          };\n          gainNode.connect(nativeOfflineAudioContext.destination);\n          nativeOfflineAudioContext.startRendering();\n        });\n      };\n    };\n\n    var createSetActiveAudioWorkletNodeInputs = function createSetActiveAudioWorkletNodeInputs(activeAudioWorkletNodeInputsStore) {\n      return function (nativeAudioWorkletNode, activeInputs) {\n        activeAudioWorkletNodeInputsStore.set(nativeAudioWorkletNode, activeInputs);\n      };\n    };\n\n    var createSetAudioNodeTailTime = function createSetAudioNodeTailTime(audioNodeTailTimeStore) {\n      return function (audioNode, tailTime) {\n        return audioNodeTailTimeStore.set(audioNode, tailTime);\n      };\n    };\n\n    var createStartRendering = function createStartRendering(audioBufferStore, cacheTestResult, getAudioNodeRenderer, getUnrenderedAudioWorkletNodes, renderNativeOfflineAudioContext, testAudioBufferCopyChannelMethodsOutOfBoundsSupport, wrapAudioBufferCopyChannelMethods, wrapAudioBufferCopyChannelMethodsOutOfBounds) {\n      return function (destination, nativeOfflineAudioContext) {\n        return getAudioNodeRenderer(destination).render(destination, nativeOfflineAudioContext)\n        /*\n         * Bug #86 & #87: Invoking the renderer of an AudioWorkletNode might be necessary if it has no direct or indirect connection to the\n         * destination.\n         */.then(function () {\n          return Promise.all(Array.from(getUnrenderedAudioWorkletNodes(nativeOfflineAudioContext)).map(function (audioWorkletNode) {\n            return getAudioNodeRenderer(audioWorkletNode).render(audioWorkletNode, nativeOfflineAudioContext);\n          }));\n        }).then(function () {\n          return renderNativeOfflineAudioContext(nativeOfflineAudioContext);\n        }).then(function (audioBuffer) {\n          // Bug #5: Safari does not support copyFromChannel() and copyToChannel().\n          // Bug #100: Safari does throw a wrong error when calling getChannelData() with an out-of-bounds value.\n          if (typeof audioBuffer.copyFromChannel !== 'function') {\n            wrapAudioBufferCopyChannelMethods(audioBuffer);\n            wrapAudioBufferGetChannelDataMethod(audioBuffer);\n            // Bug #157: Firefox does not allow the bufferOffset to be out-of-bounds.\n          } else if (!cacheTestResult(testAudioBufferCopyChannelMethodsOutOfBoundsSupport, function () {\n            return testAudioBufferCopyChannelMethodsOutOfBoundsSupport(audioBuffer);\n          })) {\n            wrapAudioBufferCopyChannelMethodsOutOfBounds(audioBuffer);\n          }\n          audioBufferStore.add(audioBuffer);\n          return audioBuffer;\n        });\n      };\n    };\n\n    function ownKeys$4(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\n    function _objectSpread$4(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$4(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$4(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n    function _callSuper$1(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$1() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\n    function _isNativeReflectConstruct$1() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$1 = function _isNativeReflectConstruct() { return !!t; })(); }\n    var DEFAULT_OPTIONS$1 = {\n      channelCount: 2,\n      /*\n       * Bug #105: The channelCountMode should be 'clamped-max' according to the spec but is set to 'explicit' to achieve consistent\n       * behavior.\n       */\n      channelCountMode: 'explicit',\n      channelInterpretation: 'speakers',\n      pan: 0\n    };\n    var createStereoPannerNodeConstructor = function createStereoPannerNodeConstructor(audioNodeConstructor, createAudioParam, createNativeStereoPannerNode, createStereoPannerNodeRenderer, getNativeContext, isNativeOfflineAudioContext) {\n      return /*#__PURE__*/function (_audioNodeConstructor) {\n        function StereoPannerNode(context, options) {\n          var _this;\n          _classCallCheck(this, StereoPannerNode);\n          var nativeContext = getNativeContext(context);\n          var mergedOptions = _objectSpread$4(_objectSpread$4({}, DEFAULT_OPTIONS$1), options);\n          var nativeStereoPannerNode = createNativeStereoPannerNode(nativeContext, mergedOptions);\n          var isOffline = isNativeOfflineAudioContext(nativeContext);\n          var stereoPannerNodeRenderer = isOffline ? createStereoPannerNodeRenderer() : null;\n          _this = _callSuper$1(this, StereoPannerNode, [context, false, nativeStereoPannerNode, stereoPannerNodeRenderer]);\n          _this._pan = createAudioParam(_this, isOffline, nativeStereoPannerNode.pan);\n          return _this;\n        }\n        _inherits(StereoPannerNode, _audioNodeConstructor);\n        return _createClass(StereoPannerNode, [{\n          key: \"pan\",\n          get: function get() {\n            return this._pan;\n          }\n        }]);\n      }(audioNodeConstructor);\n    };\n\n    var createStereoPannerNodeRendererFactory = function createStereoPannerNodeRendererFactory(connectAudioParam, createNativeStereoPannerNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode) {\n      return function () {\n        var renderedNativeStereoPannerNodes = new WeakMap();\n        var createStereoPannerNode = /*#__PURE__*/function () {\n          var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(proxy, nativeOfflineAudioContext) {\n            var nativeStereoPannerNode, nativeStereoPannerNodeIsOwnedByContext, options;\n            return _regeneratorRuntime.wrap(function _callee$(_context) {\n              while (1) switch (_context.prev = _context.next) {\n                case 0:\n                  nativeStereoPannerNode = getNativeAudioNode(proxy);\n                  /*\n                   * If the initially used nativeStereoPannerNode was not constructed on the same OfflineAudioContext it needs to be created\n                   * again.\n                   */\n                  nativeStereoPannerNodeIsOwnedByContext = isOwnedByContext(nativeStereoPannerNode, nativeOfflineAudioContext);\n                  if (!nativeStereoPannerNodeIsOwnedByContext) {\n                    options = {\n                      channelCount: nativeStereoPannerNode.channelCount,\n                      channelCountMode: nativeStereoPannerNode.channelCountMode,\n                      channelInterpretation: nativeStereoPannerNode.channelInterpretation,\n                      pan: nativeStereoPannerNode.pan.value\n                    };\n                    nativeStereoPannerNode = createNativeStereoPannerNode(nativeOfflineAudioContext, options);\n                  }\n                  renderedNativeStereoPannerNodes.set(nativeOfflineAudioContext, nativeStereoPannerNode);\n                  if (nativeStereoPannerNodeIsOwnedByContext) {\n                    _context.next = 9;\n                    break;\n                  }\n                  _context.next = 7;\n                  return renderAutomation(nativeOfflineAudioContext, proxy.pan, nativeStereoPannerNode.pan);\n                case 7:\n                  _context.next = 11;\n                  break;\n                case 9:\n                  _context.next = 11;\n                  return connectAudioParam(nativeOfflineAudioContext, proxy.pan, nativeStereoPannerNode.pan);\n                case 11:\n                  if (!isNativeAudioNodeFaker(nativeStereoPannerNode)) {\n                    _context.next = 16;\n                    break;\n                  }\n                  _context.next = 14;\n                  return renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeStereoPannerNode.inputs[0]);\n                case 14:\n                  _context.next = 18;\n                  break;\n                case 16:\n                  _context.next = 18;\n                  return renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeStereoPannerNode);\n                case 18:\n                  return _context.abrupt(\"return\", nativeStereoPannerNode);\n                case 19:\n                case \"end\":\n                  return _context.stop();\n              }\n            }, _callee);\n          }));\n          return function createStereoPannerNode(_x, _x2) {\n            return _ref.apply(this, arguments);\n          };\n        }();\n        return {\n          render: function render(proxy, nativeOfflineAudioContext) {\n            var renderedNativeStereoPannerNode = renderedNativeStereoPannerNodes.get(nativeOfflineAudioContext);\n            if (renderedNativeStereoPannerNode !== undefined) {\n              return Promise.resolve(renderedNativeStereoPannerNode);\n            }\n            return createStereoPannerNode(proxy, nativeOfflineAudioContext);\n          }\n        };\n      };\n    };\n\n    // Bug #33: Safari exposes an AudioBuffer but it can't be used as a constructor.\n    var createTestAudioBufferConstructorSupport = function createTestAudioBufferConstructorSupport(nativeAudioBufferConstructor) {\n      return function () {\n        if (nativeAudioBufferConstructor === null) {\n          return false;\n        }\n        try {\n          new nativeAudioBufferConstructor({\n            length: 1,\n            sampleRate: 44100\n          }); // tslint:disable-line:no-unused-expression\n        } catch (_unused) {\n          return false;\n        }\n        return true;\n      };\n    };\n\n    /*\n     * Firefox up to version 67 didn't fully support the copyFromChannel() and copyToChannel() methods. Therefore testing one of those methods\n     * is enough to know if the other one is supported as well.\n     */\n    var createTestAudioBufferCopyChannelMethodsSubarraySupport = function createTestAudioBufferCopyChannelMethodsSubarraySupport(nativeOfflineAudioContextConstructor) {\n      return function () {\n        if (nativeOfflineAudioContextConstructor === null) {\n          return false;\n        }\n        var nativeOfflineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n        var nativeAudioBuffer = nativeOfflineAudioContext.createBuffer(1, 1, 44100);\n        // Bug #5: Safari does not support copyFromChannel() and copyToChannel().\n        if (nativeAudioBuffer.copyToChannel === undefined) {\n          return true;\n        }\n        var source = new Float32Array(2);\n        try {\n          nativeAudioBuffer.copyFromChannel(source, 0, 0);\n        } catch (_unused) {\n          return false;\n        }\n        return true;\n      };\n    };\n\n    var createTestAudioContextCloseMethodSupport = function createTestAudioContextCloseMethodSupport(nativeAudioContextConstructor) {\n      return function () {\n        if (nativeAudioContextConstructor === null) {\n          return false;\n        }\n        // Try to check the prototype before constructing the AudioContext.\n        if (nativeAudioContextConstructor.prototype !== undefined && nativeAudioContextConstructor.prototype.close !== undefined) {\n          return true;\n        }\n        var audioContext = new nativeAudioContextConstructor();\n        var isAudioContextClosable = audioContext.close !== undefined;\n        try {\n          audioContext.close();\n        } catch (_unused) {\n          // Ignore errors.\n        }\n        return isAudioContextClosable;\n      };\n    };\n\n    /**\n     * Edge up to version 14, Firefox up to version 52, Safari up to version 9 and maybe other browsers\n     * did not refuse to decode invalid parameters with a TypeError.\n     */\n    var createTestAudioContextDecodeAudioDataMethodTypeErrorSupport = function createTestAudioContextDecodeAudioDataMethodTypeErrorSupport(nativeOfflineAudioContextConstructor) {\n      return function () {\n        if (nativeOfflineAudioContextConstructor === null) {\n          return Promise.resolve(false);\n        }\n        var offlineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n        // Bug #21: Safari does not support promises yet.\n        return new Promise(function (resolve) {\n          var isPending = true;\n          var resolvePromise = function resolvePromise(err) {\n            if (isPending) {\n              isPending = false;\n              offlineAudioContext.startRendering();\n              resolve(err instanceof TypeError);\n            }\n          };\n          var promise;\n          // Bug #26: Safari throws a synchronous error.\n          try {\n            promise = offlineAudioContext\n            // Bug #1: Safari requires a successCallback.\n            .decodeAudioData(null, function () {\n              // Ignore the success callback.\n            }, resolvePromise);\n          } catch (err) {\n            resolvePromise(err);\n          }\n          // Bug #21: Safari does not support promises yet.\n          if (promise !== undefined) {\n            // Bug #6: Chrome, Edge and Firefox do not call the errorCallback.\n            promise[\"catch\"](resolvePromise);\n          }\n        });\n      };\n    };\n\n    var createTestAudioContextOptionsSupport = function createTestAudioContextOptionsSupport(nativeAudioContextConstructor) {\n      return function () {\n        if (nativeAudioContextConstructor === null) {\n          return false;\n        }\n        var audioContext;\n        try {\n          audioContext = new nativeAudioContextConstructor({\n            latencyHint: 'balanced'\n          });\n        } catch (_unused) {\n          return false;\n        }\n        audioContext.close();\n        return true;\n      };\n    };\n\n    // Safari up to version 12.0 (but not v12.1) didn't return the destination in case it was an AudioNode.\n    var createTestAudioNodeConnectMethodSupport = function createTestAudioNodeConnectMethodSupport(nativeOfflineAudioContextConstructor) {\n      return function () {\n        if (nativeOfflineAudioContextConstructor === null) {\n          return false;\n        }\n        var nativeOfflineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n        var nativeGainNode = nativeOfflineAudioContext.createGain();\n        var isSupported = nativeGainNode.connect(nativeGainNode) === nativeGainNode;\n        nativeGainNode.disconnect(nativeGainNode);\n        return isSupported;\n      };\n    };\n\n    /**\n     * Chrome version 66 and 67 did not call the process() function of an AudioWorkletProcessor if it had no outputs. AudioWorklet support was\n     * enabled by default in version 66.\n     */\n    var createTestAudioWorkletProcessorNoOutputsSupport = function createTestAudioWorkletProcessorNoOutputsSupport(nativeAudioWorkletNodeConstructor, nativeOfflineAudioContextConstructor) {\n      return /*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var blob, messageChannel, offlineAudioContext, url, isCallingProcess, audioWorkletNode, oscillator;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              if (!(nativeAudioWorkletNodeConstructor === null)) {\n                _context.next = 2;\n                break;\n              }\n              return _context.abrupt(\"return\", true);\n            case 2:\n              if (!(nativeOfflineAudioContextConstructor === null)) {\n                _context.next = 4;\n                break;\n              }\n              return _context.abrupt(\"return\", false);\n            case 4:\n              blob = new Blob(['let c,p;class A extends AudioWorkletProcessor{constructor(){super();this.port.onmessage=(e)=>{p=e.data;p.onmessage=()=>{p.postMessage(c);p.close()};this.port.postMessage(0)}}process(){c=1}}registerProcessor(\"a\",A)'], {\n                type: 'application/javascript; charset=utf-8'\n              });\n              messageChannel = new MessageChannel(); // Bug #141: Safari does not support creating an OfflineAudioContext with less than 44100 Hz.\n              offlineAudioContext = new nativeOfflineAudioContextConstructor(1, 128, 44100);\n              url = URL.createObjectURL(blob);\n              isCallingProcess = false;\n              _context.prev = 9;\n              _context.next = 12;\n              return offlineAudioContext.audioWorklet.addModule(url);\n            case 12:\n              audioWorkletNode = new nativeAudioWorkletNodeConstructor(offlineAudioContext, 'a', {\n                numberOfOutputs: 0\n              });\n              oscillator = offlineAudioContext.createOscillator();\n              _context.next = 16;\n              return new Promise(function (resolve) {\n                audioWorkletNode.port.onmessage = function () {\n                  return resolve();\n                };\n                audioWorkletNode.port.postMessage(messageChannel.port2, [messageChannel.port2]);\n              });\n            case 16:\n              audioWorkletNode.port.onmessage = function () {\n                return isCallingProcess = true;\n              };\n              oscillator.connect(audioWorkletNode);\n              oscillator.start(0);\n              _context.next = 21;\n              return offlineAudioContext.startRendering();\n            case 21:\n              _context.next = 23;\n              return new Promise(function (resolve) {\n                messageChannel.port1.onmessage = function (_ref2) {\n                  var data = _ref2.data;\n                  return resolve(data === 1);\n                };\n                messageChannel.port1.postMessage(0);\n              });\n            case 23:\n              isCallingProcess = _context.sent;\n              _context.next = 28;\n              break;\n            case 26:\n              _context.prev = 26;\n              _context.t0 = _context[\"catch\"](9);\n            case 28:\n              _context.prev = 28;\n              messageChannel.port1.close();\n              URL.revokeObjectURL(url);\n              return _context.finish(28);\n            case 32:\n              return _context.abrupt(\"return\", isCallingProcess);\n            case 33:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, null, [[9, 26, 28, 32]]);\n      }));\n    };\n\n    // Bug #179: Firefox does not allow to transfer any buffer which has been passed to the process() method as an argument.\n    var createTestAudioWorkletProcessorPostMessageSupport = function createTestAudioWorkletProcessorPostMessageSupport(nativeAudioWorkletNodeConstructor, nativeOfflineAudioContextConstructor) {\n      return /*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var blob, offlineAudioContext, url, isEmittingMessageEvents, isEmittingProcessorErrorEvents, audioWorkletNode, oscillator;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              if (!(nativeAudioWorkletNodeConstructor === null)) {\n                _context.next = 2;\n                break;\n              }\n              return _context.abrupt(\"return\", true);\n            case 2:\n              if (!(nativeOfflineAudioContextConstructor === null)) {\n                _context.next = 4;\n                break;\n              }\n              return _context.abrupt(\"return\", false);\n            case 4:\n              blob = new Blob(['class A extends AudioWorkletProcessor{process(i){this.port.postMessage(i,[i[0][0].buffer])}}registerProcessor(\"a\",A)'], {\n                type: 'application/javascript; charset=utf-8'\n              }); // Bug #141: Safari does not support creating an OfflineAudioContext with less than 44100 Hz.\n              offlineAudioContext = new nativeOfflineAudioContextConstructor(1, 128, 44100);\n              url = URL.createObjectURL(blob);\n              isEmittingMessageEvents = false;\n              isEmittingProcessorErrorEvents = false;\n              _context.prev = 9;\n              _context.next = 12;\n              return offlineAudioContext.audioWorklet.addModule(url);\n            case 12:\n              audioWorkletNode = new nativeAudioWorkletNodeConstructor(offlineAudioContext, 'a', {\n                numberOfOutputs: 0\n              });\n              oscillator = offlineAudioContext.createOscillator();\n              audioWorkletNode.port.onmessage = function () {\n                return isEmittingMessageEvents = true;\n              };\n              audioWorkletNode.onprocessorerror = function () {\n                return isEmittingProcessorErrorEvents = true;\n              };\n              oscillator.connect(audioWorkletNode);\n              oscillator.start(0);\n              _context.next = 20;\n              return offlineAudioContext.startRendering();\n            case 20:\n              _context.next = 22;\n              return new Promise(function (resolve) {\n                return setTimeout(resolve);\n              });\n            case 22:\n              _context.next = 26;\n              break;\n            case 24:\n              _context.prev = 24;\n              _context.t0 = _context[\"catch\"](9);\n            case 26:\n              _context.prev = 26;\n              URL.revokeObjectURL(url);\n              return _context.finish(26);\n            case 29:\n              return _context.abrupt(\"return\", isEmittingMessageEvents && !isEmittingProcessorErrorEvents);\n            case 30:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, null, [[9, 24, 26, 29]]);\n      }));\n    };\n\n    /**\n     * Firefox up to version 69 did not throw an error when setting a different channelCount or channelCountMode.\n     */\n    var createTestChannelMergerNodeChannelCountSupport = function createTestChannelMergerNodeChannelCountSupport(nativeOfflineAudioContextConstructor) {\n      return function () {\n        if (nativeOfflineAudioContextConstructor === null) {\n          return false;\n        }\n        var offlineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n        var nativeChannelMergerNode = offlineAudioContext.createChannelMerger();\n        /**\n         * Bug #15: Safari does not return the default properties. It still needs to be patched. This test is supposed to test the support\n         * in other browsers.\n         */\n        if (nativeChannelMergerNode.channelCountMode === 'max') {\n          return true;\n        }\n        try {\n          nativeChannelMergerNode.channelCount = 2;\n        } catch (_unused) {\n          return true;\n        }\n        return false;\n      };\n    };\n\n    var createTestConstantSourceNodeAccurateSchedulingSupport = function createTestConstantSourceNodeAccurateSchedulingSupport(nativeOfflineAudioContextConstructor) {\n      return function () {\n        if (nativeOfflineAudioContextConstructor === null) {\n          return false;\n        }\n        var nativeOfflineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n        // Bug #62: Safari does not support ConstantSourceNodes.\n        if (nativeOfflineAudioContext.createConstantSource === undefined) {\n          return true;\n        }\n        var nativeConstantSourceNode = nativeOfflineAudioContext.createConstantSource();\n        /*\n         * @todo This is using bug #75 to detect bug #70. That works because both bugs were unique to\n         * the implementation of Firefox right now, but it could probably be done in a better way.\n         */\n        return nativeConstantSourceNode.offset.maxValue !== Number.POSITIVE_INFINITY;\n      };\n    };\n\n    // Opera up to version 57 did not allow to reassign the buffer of a ConvolverNode.\n    var createTestConvolverNodeBufferReassignabilitySupport = function createTestConvolverNodeBufferReassignabilitySupport(nativeOfflineAudioContextConstructor) {\n      return function () {\n        if (nativeOfflineAudioContextConstructor === null) {\n          return false;\n        }\n        var offlineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n        var nativeConvolverNode = offlineAudioContext.createConvolver();\n        nativeConvolverNode.buffer = offlineAudioContext.createBuffer(1, 1, offlineAudioContext.sampleRate);\n        try {\n          nativeConvolverNode.buffer = offlineAudioContext.createBuffer(1, 1, offlineAudioContext.sampleRate);\n        } catch (_unused) {\n          return false;\n        }\n        return true;\n      };\n    };\n\n    // Chrome up to version v80, Edge up to version v80 and Opera up to version v67 did not allow to set the channelCount property of a ConvolverNode to 1. They also did not allow to set the channelCountMode to 'explicit'.\n    var createTestConvolverNodeChannelCountSupport = function createTestConvolverNodeChannelCountSupport(nativeOfflineAudioContextConstructor) {\n      return function () {\n        if (nativeOfflineAudioContextConstructor === null) {\n          return false;\n        }\n        var offlineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n        var nativeConvolverNode = offlineAudioContext.createConvolver();\n        try {\n          nativeConvolverNode.channelCount = 1;\n        } catch (_unused) {\n          return false;\n        }\n        return true;\n      };\n    };\n\n    var createTestIsSecureContextSupport = function createTestIsSecureContextSupport(window) {\n      return function () {\n        return window !== null && window.hasOwnProperty('isSecureContext');\n      };\n    };\n\n    // Firefox up to version 68 did not throw an error when creating a MediaStreamAudioSourceNode with a mediaStream that had no audio track.\n    var createTestMediaStreamAudioSourceNodeMediaStreamWithoutAudioTrackSupport = function createTestMediaStreamAudioSourceNodeMediaStreamWithoutAudioTrackSupport(nativeAudioContextConstructor) {\n      return function () {\n        if (nativeAudioContextConstructor === null) {\n          return false;\n        }\n        var audioContext = new nativeAudioContextConstructor();\n        try {\n          audioContext.createMediaStreamSource(new MediaStream());\n          return false;\n        } catch (err) {\n          return true;\n        } finally {\n          audioContext.close();\n        }\n      };\n    };\n\n    var createTestOfflineAudioContextCurrentTimeSupport = function createTestOfflineAudioContextCurrentTimeSupport(createNativeGainNode, nativeOfflineAudioContextConstructor) {\n      return function () {\n        if (nativeOfflineAudioContextConstructor === null) {\n          return Promise.resolve(false);\n        }\n        var nativeOfflineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n        // Bug #48: Safari does not render an OfflineAudioContext without any connected node.\n        var gainNode = createNativeGainNode(nativeOfflineAudioContext, {\n          channelCount: 1,\n          channelCountMode: 'explicit',\n          channelInterpretation: 'discrete',\n          gain: 0\n        });\n        // Bug #21: Safari does not support promises yet.\n        return new Promise(function (resolve) {\n          nativeOfflineAudioContext.oncomplete = function () {\n            gainNode.disconnect();\n            resolve(nativeOfflineAudioContext.currentTime !== 0);\n          };\n          nativeOfflineAudioContext.startRendering();\n        });\n      };\n    };\n\n    /**\n     * Firefox up to version 62 did not kick off the processing of the StereoPannerNode if the value of pan was zero.\n     */\n    var createTestStereoPannerNodeDefaultValueSupport = function createTestStereoPannerNodeDefaultValueSupport(nativeOfflineAudioContextConstructor) {\n      return function () {\n        if (nativeOfflineAudioContextConstructor === null) {\n          return Promise.resolve(false);\n        }\n        var nativeOfflineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n        /*\n         * Bug #105: Safari does not support the StereoPannerNode. Therefore the returned value should normally be false but the faker does\n         * support the tested behaviour.\n         */\n        if (nativeOfflineAudioContext.createStereoPanner === undefined) {\n          return Promise.resolve(true);\n        }\n        // Bug #62: Safari does not support ConstantSourceNodes.\n        if (nativeOfflineAudioContext.createConstantSource === undefined) {\n          return Promise.resolve(true);\n        }\n        var constantSourceNode = nativeOfflineAudioContext.createConstantSource();\n        var stereoPanner = nativeOfflineAudioContext.createStereoPanner();\n        constantSourceNode.channelCount = 1;\n        constantSourceNode.offset.value = 1;\n        stereoPanner.channelCount = 1;\n        constantSourceNode.start();\n        constantSourceNode.connect(stereoPanner).connect(nativeOfflineAudioContext.destination);\n        return nativeOfflineAudioContext.startRendering().then(function (buffer) {\n          return buffer.getChannelData(0)[0] !== 1;\n        });\n      };\n    };\n\n    var createUnknownError = function createUnknownError() {\n      return new DOMException('', 'UnknownError');\n    };\n\n    function ownKeys$3(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\n    function _objectSpread$3(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$3(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$3(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n    function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\n    function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\n    var DEFAULT_OPTIONS = {\n      channelCount: 2,\n      channelCountMode: 'max',\n      channelInterpretation: 'speakers',\n      curve: null,\n      oversample: 'none'\n    };\n    var createWaveShaperNodeConstructor = function createWaveShaperNodeConstructor(audioNodeConstructor, createInvalidStateError, createNativeWaveShaperNode, createWaveShaperNodeRenderer, getNativeContext, isNativeOfflineAudioContext, setAudioNodeTailTime) {\n      return /*#__PURE__*/function (_audioNodeConstructor) {\n        function WaveShaperNode(context, options) {\n          var _this;\n          _classCallCheck(this, WaveShaperNode);\n          var nativeContext = getNativeContext(context);\n          var mergedOptions = _objectSpread$3(_objectSpread$3({}, DEFAULT_OPTIONS), options);\n          var nativeWaveShaperNode = createNativeWaveShaperNode(nativeContext, mergedOptions);\n          var isOffline = isNativeOfflineAudioContext(nativeContext);\n          var waveShaperNodeRenderer = isOffline ? createWaveShaperNodeRenderer() : null;\n          // @todo Add a mechanism to only switch a WaveShaperNode to active while it is connected.\n          _this = _callSuper(this, WaveShaperNode, [context, true, nativeWaveShaperNode, waveShaperNodeRenderer]);\n          _this._isCurveNullified = false;\n          _this._nativeWaveShaperNode = nativeWaveShaperNode;\n          // @todo Determine a meaningful tail-time instead of just using one second.\n          setAudioNodeTailTime(_this, 1);\n          return _this;\n        }\n        _inherits(WaveShaperNode, _audioNodeConstructor);\n        return _createClass(WaveShaperNode, [{\n          key: \"curve\",\n          get: function get() {\n            if (this._isCurveNullified) {\n              return null;\n            }\n            return this._nativeWaveShaperNode.curve;\n          },\n          set: function set(value) {\n            // Bug #103: Safari does not allow to set the curve to null.\n            if (value === null) {\n              this._isCurveNullified = true;\n              this._nativeWaveShaperNode.curve = new Float32Array([0, 0]);\n            } else {\n              // Bug #102: Safari does not throw an InvalidStateError when the curve has less than two samples.\n              // Bug #104: Chrome and Edge will throw an InvalidAccessError when the curve has less than two samples.\n              if (value.length < 2) {\n                throw createInvalidStateError();\n              }\n              this._isCurveNullified = false;\n              this._nativeWaveShaperNode.curve = value;\n            }\n          }\n        }, {\n          key: \"oversample\",\n          get: function get() {\n            return this._nativeWaveShaperNode.oversample;\n          },\n          set: function set(value) {\n            this._nativeWaveShaperNode.oversample = value;\n          }\n        }]);\n      }(audioNodeConstructor);\n    };\n\n    var createWaveShaperNodeRendererFactory = function createWaveShaperNodeRendererFactory(createNativeWaveShaperNode, getNativeAudioNode, renderInputsOfAudioNode) {\n      return function () {\n        var renderedNativeWaveShaperNodes = new WeakMap();\n        var createWaveShaperNode = /*#__PURE__*/function () {\n          var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(proxy, nativeOfflineAudioContext) {\n            var nativeWaveShaperNode, nativeWaveShaperNodeIsOwnedByContext, options;\n            return _regeneratorRuntime.wrap(function _callee$(_context) {\n              while (1) switch (_context.prev = _context.next) {\n                case 0:\n                  nativeWaveShaperNode = getNativeAudioNode(proxy); // If the initially used nativeWaveShaperNode was not constructed on the same OfflineAudioContext it needs to be created again.\n                  nativeWaveShaperNodeIsOwnedByContext = isOwnedByContext(nativeWaveShaperNode, nativeOfflineAudioContext);\n                  if (!nativeWaveShaperNodeIsOwnedByContext) {\n                    options = {\n                      channelCount: nativeWaveShaperNode.channelCount,\n                      channelCountMode: nativeWaveShaperNode.channelCountMode,\n                      channelInterpretation: nativeWaveShaperNode.channelInterpretation,\n                      curve: nativeWaveShaperNode.curve,\n                      oversample: nativeWaveShaperNode.oversample\n                    };\n                    nativeWaveShaperNode = createNativeWaveShaperNode(nativeOfflineAudioContext, options);\n                  }\n                  renderedNativeWaveShaperNodes.set(nativeOfflineAudioContext, nativeWaveShaperNode);\n                  if (!isNativeAudioNodeFaker(nativeWaveShaperNode)) {\n                    _context.next = 9;\n                    break;\n                  }\n                  _context.next = 7;\n                  return renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeWaveShaperNode.inputs[0]);\n                case 7:\n                  _context.next = 11;\n                  break;\n                case 9:\n                  _context.next = 11;\n                  return renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeWaveShaperNode);\n                case 11:\n                  return _context.abrupt(\"return\", nativeWaveShaperNode);\n                case 12:\n                case \"end\":\n                  return _context.stop();\n              }\n            }, _callee);\n          }));\n          return function createWaveShaperNode(_x, _x2) {\n            return _ref.apply(this, arguments);\n          };\n        }();\n        return {\n          render: function render(proxy, nativeOfflineAudioContext) {\n            var renderedNativeWaveShaperNode = renderedNativeWaveShaperNodes.get(nativeOfflineAudioContext);\n            if (renderedNativeWaveShaperNode !== undefined) {\n              return Promise.resolve(renderedNativeWaveShaperNode);\n            }\n            return createWaveShaperNode(proxy, nativeOfflineAudioContext);\n          }\n        };\n      };\n    };\n\n    var createWindow = function createWindow() {\n      return typeof window === 'undefined' ? null : window;\n    };\n\n    var createWrapAudioBufferCopyChannelMethods = function createWrapAudioBufferCopyChannelMethods(convertNumberToUnsignedLong, createIndexSizeError) {\n      return function (audioBuffer) {\n        audioBuffer.copyFromChannel = function (destination, channelNumberAsNumber) {\n          var bufferOffsetAsNumber = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n          var bufferOffset = convertNumberToUnsignedLong(bufferOffsetAsNumber);\n          var channelNumber = convertNumberToUnsignedLong(channelNumberAsNumber);\n          if (channelNumber >= audioBuffer.numberOfChannels) {\n            throw createIndexSizeError();\n          }\n          var audioBufferLength = audioBuffer.length;\n          var channelData = audioBuffer.getChannelData(channelNumber);\n          var destinationLength = destination.length;\n          for (var i = bufferOffset < 0 ? -bufferOffset : 0; i + bufferOffset < audioBufferLength && i < destinationLength; i += 1) {\n            destination[i] = channelData[i + bufferOffset];\n          }\n        };\n        audioBuffer.copyToChannel = function (source, channelNumberAsNumber) {\n          var bufferOffsetAsNumber = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n          var bufferOffset = convertNumberToUnsignedLong(bufferOffsetAsNumber);\n          var channelNumber = convertNumberToUnsignedLong(channelNumberAsNumber);\n          if (channelNumber >= audioBuffer.numberOfChannels) {\n            throw createIndexSizeError();\n          }\n          var audioBufferLength = audioBuffer.length;\n          var channelData = audioBuffer.getChannelData(channelNumber);\n          var sourceLength = source.length;\n          for (var i = bufferOffset < 0 ? -bufferOffset : 0; i + bufferOffset < audioBufferLength && i < sourceLength; i += 1) {\n            channelData[i + bufferOffset] = source[i];\n          }\n        };\n      };\n    };\n\n    var createWrapAudioBufferCopyChannelMethodsOutOfBounds = function createWrapAudioBufferCopyChannelMethodsOutOfBounds(convertNumberToUnsignedLong) {\n      return function (audioBuffer) {\n        audioBuffer.copyFromChannel = function (copyFromChannel) {\n          return function (destination, channelNumberAsNumber) {\n            var bufferOffsetAsNumber = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n            var bufferOffset = convertNumberToUnsignedLong(bufferOffsetAsNumber);\n            var channelNumber = convertNumberToUnsignedLong(channelNumberAsNumber);\n            if (bufferOffset < audioBuffer.length) {\n              return copyFromChannel.call(audioBuffer, destination, channelNumber, bufferOffset);\n            }\n          };\n        }(audioBuffer.copyFromChannel);\n        audioBuffer.copyToChannel = function (copyToChannel) {\n          return function (source, channelNumberAsNumber) {\n            var bufferOffsetAsNumber = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n            var bufferOffset = convertNumberToUnsignedLong(bufferOffsetAsNumber);\n            var channelNumber = convertNumberToUnsignedLong(channelNumberAsNumber);\n            if (bufferOffset < audioBuffer.length) {\n              return copyToChannel.call(audioBuffer, source, channelNumber, bufferOffset);\n            }\n          };\n        }(audioBuffer.copyToChannel);\n      };\n    };\n\n    var createWrapAudioBufferSourceNodeStopMethodNullifiedBuffer = function createWrapAudioBufferSourceNodeStopMethodNullifiedBuffer(overwriteAccessors) {\n      return function (nativeAudioBufferSourceNode, nativeContext) {\n        var nullifiedBuffer = nativeContext.createBuffer(1, 1, 44100);\n        if (nativeAudioBufferSourceNode.buffer === null) {\n          nativeAudioBufferSourceNode.buffer = nullifiedBuffer;\n        }\n        overwriteAccessors(nativeAudioBufferSourceNode, 'buffer', function (get) {\n          return function () {\n            var value = get.call(nativeAudioBufferSourceNode);\n            return value === nullifiedBuffer ? null : value;\n          };\n        }, function (set) {\n          return function (value) {\n            return set.call(nativeAudioBufferSourceNode, value === null ? nullifiedBuffer : value);\n          };\n        });\n      };\n    };\n\n    var createWrapChannelMergerNode = function createWrapChannelMergerNode(createInvalidStateError, monitorConnections) {\n      return function (nativeContext, channelMergerNode) {\n        // Bug #15: Safari does not return the default properties.\n        channelMergerNode.channelCount = 1;\n        channelMergerNode.channelCountMode = 'explicit';\n        // Bug #16: Safari does not throw an error when setting a different channelCount or channelCountMode.\n        Object.defineProperty(channelMergerNode, 'channelCount', {\n          get: function get() {\n            return 1;\n          },\n          set: function set() {\n            throw createInvalidStateError();\n          }\n        });\n        Object.defineProperty(channelMergerNode, 'channelCountMode', {\n          get: function get() {\n            return 'explicit';\n          },\n          set: function set() {\n            throw createInvalidStateError();\n          }\n        });\n        // Bug #20: Safari requires a connection of any kind to treat the input signal correctly.\n        var audioBufferSourceNode = nativeContext.createBufferSource();\n        var whenConnected = function whenConnected() {\n          var length = channelMergerNode.numberOfInputs;\n          for (var i = 0; i < length; i += 1) {\n            audioBufferSourceNode.connect(channelMergerNode, 0, i);\n          }\n        };\n        var whenDisconnected = function whenDisconnected() {\n          return audioBufferSourceNode.disconnect(channelMergerNode);\n        };\n        monitorConnections(channelMergerNode, whenConnected, whenDisconnected);\n      };\n    };\n\n    var getFirstSample = function getFirstSample(audioBuffer, buffer, channelNumber) {\n      // Bug #5: Safari does not support copyFromChannel() and copyToChannel().\n      if (audioBuffer.copyFromChannel === undefined) {\n        return audioBuffer.getChannelData(channelNumber)[0];\n      }\n      audioBuffer.copyFromChannel(buffer, channelNumber);\n      return buffer[0];\n    };\n\n    var isDCCurve = function isDCCurve(curve) {\n      if (curve === null) {\n        return false;\n      }\n      var length = curve.length;\n      if (length % 2 !== 0) {\n        return curve[Math.floor(length / 2)] !== 0;\n      }\n      return curve[length / 2 - 1] + curve[length / 2] !== 0;\n    };\n\n    var overwriteAccessors = function overwriteAccessors(object, property, createGetter, createSetter) {\n      var prototype = object;\n      while (!prototype.hasOwnProperty(property)) {\n        prototype = Object.getPrototypeOf(prototype);\n      }\n      var _Object$getOwnPropert = Object.getOwnPropertyDescriptor(prototype, property),\n        get = _Object$getOwnPropert.get,\n        set = _Object$getOwnPropert.set;\n      Object.defineProperty(object, property, {\n        get: createGetter(get),\n        set: createSetter(set)\n      });\n    };\n\n    function ownKeys$2(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\n    function _objectSpread$2(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$2(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$2(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n    var sanitizeAudioWorkletNodeOptions = function sanitizeAudioWorkletNodeOptions(options) {\n      return _objectSpread$2(_objectSpread$2({}, options), {}, {\n        outputChannelCount: options.outputChannelCount !== undefined ? options.outputChannelCount : options.numberOfInputs === 1 && options.numberOfOutputs === 1 ?\n        /*\n         * Bug #61: This should be the computedNumberOfChannels, but unfortunately that is almost impossible to fake. That's why\n         * the channelCountMode is required to be 'explicit' as long as there is not a native implementation in every browser. That\n         * makes sure the computedNumberOfChannels is equivilant to the channelCount which makes it much easier to compute.\n         */\n        [options.channelCount] : Array.from({\n          length: options.numberOfOutputs\n        }, function () {\n          return 1;\n        })\n      });\n    };\n\n    function ownKeys$1(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\n    function _objectSpread$1(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$1(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$1(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n    var sanitizeChannelSplitterOptions = function sanitizeChannelSplitterOptions(options) {\n      return _objectSpread$1(_objectSpread$1({}, options), {}, {\n        channelCount: options.numberOfOutputs\n      });\n    };\n\n    function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\n    function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n    var sanitizePeriodicWaveOptions = function sanitizePeriodicWaveOptions(options) {\n      var imag = options.imag,\n        real = options.real;\n      if (imag === undefined) {\n        if (real === undefined) {\n          return _objectSpread(_objectSpread({}, options), {}, {\n            imag: [0, 0],\n            real: [0, 0]\n          });\n        }\n        return _objectSpread(_objectSpread({}, options), {}, {\n          imag: Array.from(real, function () {\n            return 0;\n          }),\n          real: real\n        });\n      }\n      if (real === undefined) {\n        return _objectSpread(_objectSpread({}, options), {}, {\n          imag: imag,\n          real: Array.from(imag, function () {\n            return 0;\n          })\n        });\n      }\n      return _objectSpread(_objectSpread({}, options), {}, {\n        imag: imag,\n        real: real\n      });\n    };\n\n    var _setValueAtTimeUntilPossible = function setValueAtTimeUntilPossible(audioParam, value, startTime) {\n      try {\n        audioParam.setValueAtTime(value, startTime);\n      } catch (err) {\n        if (err.code !== 9) {\n          throw err;\n        }\n        _setValueAtTimeUntilPossible(audioParam, value, startTime + 1e-7);\n      }\n    };\n\n    var testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport = function testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport(nativeContext) {\n      var nativeAudioBufferSourceNode = nativeContext.createBufferSource();\n      nativeAudioBufferSourceNode.start();\n      try {\n        nativeAudioBufferSourceNode.start();\n      } catch (_unused) {\n        return true;\n      }\n      return false;\n    };\n\n    var testAudioBufferSourceNodeStartMethodOffsetClampingSupport = function testAudioBufferSourceNodeStartMethodOffsetClampingSupport(nativeContext) {\n      var nativeAudioBufferSourceNode = nativeContext.createBufferSource();\n      var nativeAudioBuffer = nativeContext.createBuffer(1, 1, 44100);\n      nativeAudioBufferSourceNode.buffer = nativeAudioBuffer;\n      try {\n        nativeAudioBufferSourceNode.start(0, 1);\n      } catch (_unused) {\n        return false;\n      }\n      return true;\n    };\n\n    var testAudioBufferSourceNodeStopMethodNullifiedBufferSupport = function testAudioBufferSourceNodeStopMethodNullifiedBufferSupport(nativeContext) {\n      var nativeAudioBufferSourceNode = nativeContext.createBufferSource();\n      nativeAudioBufferSourceNode.start();\n      try {\n        nativeAudioBufferSourceNode.stop();\n      } catch (_unused) {\n        return false;\n      }\n      return true;\n    };\n\n    var testAudioScheduledSourceNodeStartMethodNegativeParametersSupport = function testAudioScheduledSourceNodeStartMethodNegativeParametersSupport(nativeContext) {\n      var nativeAudioBufferSourceNode = nativeContext.createOscillator();\n      try {\n        nativeAudioBufferSourceNode.start(-1);\n      } catch (err) {\n        return err instanceof RangeError;\n      }\n      return false;\n    };\n\n    var testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport = function testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport(nativeContext) {\n      var nativeAudioBuffer = nativeContext.createBuffer(1, 1, 44100);\n      var nativeAudioBufferSourceNode = nativeContext.createBufferSource();\n      nativeAudioBufferSourceNode.buffer = nativeAudioBuffer;\n      nativeAudioBufferSourceNode.start();\n      nativeAudioBufferSourceNode.stop();\n      try {\n        nativeAudioBufferSourceNode.stop();\n        return true;\n      } catch (_unused) {\n        return false;\n      }\n    };\n\n    var testAudioScheduledSourceNodeStopMethodNegativeParametersSupport = function testAudioScheduledSourceNodeStopMethodNegativeParametersSupport(nativeContext) {\n      var nativeAudioBufferSourceNode = nativeContext.createOscillator();\n      try {\n        nativeAudioBufferSourceNode.stop(-1);\n      } catch (err) {\n        return err instanceof RangeError;\n      }\n      return false;\n    };\n\n    var testAudioWorkletNodeOptionsClonability = function testAudioWorkletNodeOptionsClonability(audioWorkletNodeOptions) {\n      var _MessageChannel = new MessageChannel(),\n        port1 = _MessageChannel.port1,\n        port2 = _MessageChannel.port2;\n      try {\n        // This will throw an error if the audioWorkletNodeOptions are not clonable.\n        port1.postMessage(audioWorkletNodeOptions);\n      } finally {\n        port1.close();\n        port2.close();\n      }\n    };\n\n    /*\n     * Bug #122: Edge up to version v18 did not allow to construct a DOMException'. It also had a couple more bugs but since this is easy to\n     * test it's used here as a placeholder.\n     *\n     * Bug #27: Edge up to version v18 did reject an invalid arrayBuffer passed to decodeAudioData() with a DOMException.\n     *\n     * Bug #50: Edge up to version v18 did not allow to create AudioNodes on a closed context.\n     *\n     * Bug #57: Edge up to version v18 did not throw an error when assigning the type of an OscillatorNode to 'custom'.\n     *\n     * Bug #63: Edge up to version v18 did not expose the mediaElement property of a MediaElementAudioSourceNode.\n     *\n     * Bug #64: Edge up to version v18 did not support the MediaStreamAudioDestinationNode.\n     *\n     * Bug #71: Edge up to version v18 did not allow to set the buffer of an AudioBufferSourceNode to null.\n     *\n     * Bug #93: Edge up to version v18 did set the sampleRate of an AudioContext to zero when it was closed.\n     *\n     * Bug #101: Edge up to version v18 refused to execute decodeAudioData() on a closed context.\n     *\n     * Bug #106: Edge up to version v18 did not expose the maxValue and minValue properties of the pan AudioParam of a StereoPannerNode.\n     *\n     * Bug #110: Edge up to version v18 did not expose the maxValue and minValue properties of the attack, knee, ratio, release and threshold AudioParams of a DynamicsCompressorNode.\n     *\n     * Bug #123: Edge up to version v18 did not support HRTF as the panningModel for a PannerNode.\n     *\n     * Bug #145: Edge up to version v18 did throw an IndexSizeError when an OfflineAudioContext was created with a sampleRate of zero.\n     *\n     * Bug #161: Edge up to version v18 did not expose the maxValue and minValue properties of the delayTime AudioParam of a DelayNode.\n     */\n    var testDomExceptionConstructorSupport = function testDomExceptionConstructorSupport() {\n      try {\n        new DOMException(); // tslint:disable-line:no-unused-expression\n      } catch (_unused) {\n        return false;\n      }\n      return true;\n    };\n\n    // Safari at version 11 did not support transferables.\n    var testTransferablesSupport = function testTransferablesSupport() {\n      return new Promise(function (resolve) {\n        var arrayBuffer = new ArrayBuffer(0);\n        var _MessageChannel = new MessageChannel(),\n          port1 = _MessageChannel.port1,\n          port2 = _MessageChannel.port2;\n        port1.onmessage = function (_ref) {\n          var data = _ref.data;\n          return resolve(data !== null);\n        };\n        port2.postMessage(arrayBuffer, [arrayBuffer]);\n      });\n    };\n\n    var wrapAudioBufferSourceNodeStartMethodOffsetClamping = function wrapAudioBufferSourceNodeStartMethodOffsetClamping(nativeAudioBufferSourceNode) {\n      nativeAudioBufferSourceNode.start = function (start) {\n        return function () {\n          var when = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n          var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n          var duration = arguments.length > 2 ? arguments[2] : undefined;\n          var buffer = nativeAudioBufferSourceNode.buffer;\n          // Bug #154: Safari does not clamp the offset if it is equal to or greater than the duration of the buffer.\n          var clampedOffset = buffer === null ? offset : Math.min(buffer.duration, offset);\n          // Bug #155: Safari does not handle the offset correctly if it would cause the buffer to be not be played at all.\n          if (buffer !== null && clampedOffset > buffer.duration - 0.5 / nativeAudioBufferSourceNode.context.sampleRate) {\n            start.call(nativeAudioBufferSourceNode, when, 0, 0);\n          } else {\n            start.call(nativeAudioBufferSourceNode, when, clampedOffset, duration);\n          }\n        };\n      }(nativeAudioBufferSourceNode.start);\n    };\n\n    var wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls = function wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls(nativeAudioScheduledSourceNode, nativeContext) {\n      var nativeGainNode = nativeContext.createGain();\n      nativeAudioScheduledSourceNode.connect(nativeGainNode);\n      var disconnectGainNode = function (disconnect) {\n        return function () {\n          // @todo TypeScript cannot infer the overloaded signature with 1 argument yet.\n          disconnect.call(nativeAudioScheduledSourceNode, nativeGainNode);\n          nativeAudioScheduledSourceNode.removeEventListener('ended', disconnectGainNode);\n        };\n      }(nativeAudioScheduledSourceNode.disconnect);\n      nativeAudioScheduledSourceNode.addEventListener('ended', disconnectGainNode);\n      interceptConnections(nativeAudioScheduledSourceNode, nativeGainNode);\n      nativeAudioScheduledSourceNode.stop = function (stop) {\n        var isStopped = false;\n        return function () {\n          var when = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n          if (isStopped) {\n            try {\n              stop.call(nativeAudioScheduledSourceNode, when);\n            } catch (_unused) {\n              nativeGainNode.gain.setValueAtTime(0, when);\n            }\n          } else {\n            stop.call(nativeAudioScheduledSourceNode, when);\n            isStopped = true;\n          }\n        };\n      }(nativeAudioScheduledSourceNode.stop);\n    };\n\n    var wrapEventListener = function wrapEventListener(target, eventListener) {\n      return function (event) {\n        var descriptor = {\n          value: target\n        };\n        Object.defineProperties(event, {\n          currentTarget: descriptor,\n          target: descriptor\n        });\n        if (typeof eventListener === 'function') {\n          return eventListener.call(target, event);\n        }\n        return eventListener.handleEvent.call(target, event);\n      };\n    };\n\n    var addActiveInputConnectionToAudioNode = createAddActiveInputConnectionToAudioNode(insertElementInSet);\n    var addPassiveInputConnectionToAudioNode = createAddPassiveInputConnectionToAudioNode(insertElementInSet);\n    var deleteActiveInputConnectionToAudioNode = createDeleteActiveInputConnectionToAudioNode(pickElementFromSet);\n    var audioNodeTailTimeStore = new WeakMap();\n    var getAudioNodeTailTime = createGetAudioNodeTailTime(audioNodeTailTimeStore);\n    var cacheTestResult = createCacheTestResult(new Map(), new WeakMap());\n    var window$1 = createWindow();\n    var createNativeAnalyserNode = createNativeAnalyserNodeFactory(cacheTestResult, createIndexSizeError);\n    var getAudioNodeRenderer = createGetAudioNodeRenderer(getAudioNodeConnections);\n    var renderInputsOfAudioNode = createRenderInputsOfAudioNode(getAudioNodeConnections, getAudioNodeRenderer, isPartOfACycle);\n    var createAnalyserNodeRenderer = createAnalyserNodeRendererFactory(createNativeAnalyserNode, getNativeAudioNode, renderInputsOfAudioNode);\n    var getNativeContext = createGetNativeContext(CONTEXT_STORE);\n    var nativeOfflineAudioContextConstructor = createNativeOfflineAudioContextConstructor(window$1);\n    var isNativeOfflineAudioContext = createIsNativeOfflineAudioContext(nativeOfflineAudioContextConstructor);\n    var audioParamAudioNodeStore = new WeakMap();\n    var eventTargetConstructor = createEventTargetConstructor(wrapEventListener);\n    var nativeAudioContextConstructor = createNativeAudioContextConstructor(window$1);\n    var isNativeAudioContext = createIsNativeAudioContext(nativeAudioContextConstructor);\n    var isNativeAudioNode = createIsNativeAudioNode(window$1);\n    var isNativeAudioParam = createIsNativeAudioParam(window$1);\n    var nativeAudioWorkletNodeConstructor = createNativeAudioWorkletNodeConstructor(window$1);\n    var audioNodeConstructor = createAudioNodeConstructor(createAddAudioNodeConnections(AUDIO_NODE_CONNECTIONS_STORE), createAddConnectionToAudioNode(addActiveInputConnectionToAudioNode, addPassiveInputConnectionToAudioNode, connectNativeAudioNodeToNativeAudioNode, deleteActiveInputConnectionToAudioNode, disconnectNativeAudioNodeFromNativeAudioNode, getAudioNodeConnections, getAudioNodeTailTime, getEventListenersOfAudioNode, getNativeAudioNode, insertElementInSet, isActiveAudioNode, isPartOfACycle, isPassiveAudioNode), cacheTestResult, createIncrementCycleCounterFactory(CYCLE_COUNTERS, disconnectNativeAudioNodeFromNativeAudioNode, getAudioNodeConnections, getNativeAudioNode, getNativeAudioParam, isActiveAudioNode), createIndexSizeError, createInvalidAccessError, createNotSupportedError, createDecrementCycleCounter(connectNativeAudioNodeToNativeAudioNode, CYCLE_COUNTERS, getAudioNodeConnections, getNativeAudioNode, getNativeAudioParam, getNativeContext, isActiveAudioNode, isNativeOfflineAudioContext), createDetectCycles(audioParamAudioNodeStore, getAudioNodeConnections, getValueForKey), eventTargetConstructor, getNativeContext, isNativeAudioContext, isNativeAudioNode, isNativeAudioParam, isNativeOfflineAudioContext, nativeAudioWorkletNodeConstructor);\n    var analyserNodeConstructor = createAnalyserNodeConstructor(audioNodeConstructor, createAnalyserNodeRenderer, createIndexSizeError, createNativeAnalyserNode, getNativeContext, isNativeOfflineAudioContext);\n    var audioBufferStore = new WeakSet();\n    var nativeAudioBufferConstructor = createNativeAudioBufferConstructor(window$1);\n    var convertNumberToUnsignedLong = createConvertNumberToUnsignedLong(new Uint32Array(1));\n    var wrapAudioBufferCopyChannelMethods = createWrapAudioBufferCopyChannelMethods(convertNumberToUnsignedLong, createIndexSizeError);\n    var wrapAudioBufferCopyChannelMethodsOutOfBounds = createWrapAudioBufferCopyChannelMethodsOutOfBounds(convertNumberToUnsignedLong);\n    var audioBufferConstructor = createAudioBufferConstructor(audioBufferStore, cacheTestResult, createNotSupportedError, nativeAudioBufferConstructor, nativeOfflineAudioContextConstructor, createTestAudioBufferConstructorSupport(nativeAudioBufferConstructor), wrapAudioBufferCopyChannelMethods, wrapAudioBufferCopyChannelMethodsOutOfBounds);\n    var addSilentConnection = createAddSilentConnection(createNativeGainNode);\n    var renderInputsOfAudioParam = createRenderInputsOfAudioParam(getAudioNodeRenderer, getAudioParamConnections, isPartOfACycle);\n    var connectAudioParam = createConnectAudioParam(renderInputsOfAudioParam);\n    var createNativeAudioBufferSourceNode = createNativeAudioBufferSourceNodeFactory(addSilentConnection, cacheTestResult, testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport, testAudioBufferSourceNodeStartMethodOffsetClampingSupport, testAudioBufferSourceNodeStopMethodNullifiedBufferSupport, testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport, testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, wrapAudioBufferSourceNodeStartMethodOffsetClamping, createWrapAudioBufferSourceNodeStopMethodNullifiedBuffer(overwriteAccessors), wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls);\n    var renderAutomation = createRenderAutomation(createGetAudioParamRenderer(getAudioParamConnections), renderInputsOfAudioParam);\n    var createAudioBufferSourceNodeRenderer = createAudioBufferSourceNodeRendererFactory(connectAudioParam, createNativeAudioBufferSourceNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);\n    var createAudioParam = createAudioParamFactory(createAddAudioParamConnections(AUDIO_PARAM_CONNECTIONS_STORE), audioParamAudioNodeStore, AUDIO_PARAM_STORE, createAudioParamRenderer, automationEvents.createCancelAndHoldAutomationEvent, automationEvents.createCancelScheduledValuesAutomationEvent, automationEvents.createExponentialRampToValueAutomationEvent, automationEvents.createLinearRampToValueAutomationEvent, automationEvents.createSetTargetAutomationEvent, automationEvents.createSetValueAutomationEvent, automationEvents.createSetValueCurveAutomationEvent, nativeAudioContextConstructor, _setValueAtTimeUntilPossible);\n    var audioBufferSourceNodeConstructor = createAudioBufferSourceNodeConstructor(audioNodeConstructor, createAudioBufferSourceNodeRenderer, createAudioParam, createInvalidStateError, createNativeAudioBufferSourceNode, getNativeContext, isNativeOfflineAudioContext, wrapEventListener);\n    var audioDestinationNodeConstructor = createAudioDestinationNodeConstructor(audioNodeConstructor, createAudioDestinationNodeRenderer, createIndexSizeError, createInvalidStateError, createNativeAudioDestinationNodeFactory(createNativeGainNode, overwriteAccessors), getNativeContext, isNativeOfflineAudioContext, renderInputsOfAudioNode);\n    var createBiquadFilterNodeRenderer = createBiquadFilterNodeRendererFactory(connectAudioParam, createNativeBiquadFilterNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);\n    var setAudioNodeTailTime = createSetAudioNodeTailTime(audioNodeTailTimeStore);\n    var biquadFilterNodeConstructor = createBiquadFilterNodeConstructor(audioNodeConstructor, createAudioParam, createBiquadFilterNodeRenderer, createInvalidAccessError, createNativeBiquadFilterNode, getNativeContext, isNativeOfflineAudioContext, setAudioNodeTailTime);\n    var monitorConnections = createMonitorConnections(insertElementInSet, isNativeAudioNode);\n    var wrapChannelMergerNode = createWrapChannelMergerNode(createInvalidStateError, monitorConnections);\n    var createNativeChannelMergerNode = createNativeChannelMergerNodeFactory(nativeAudioContextConstructor, wrapChannelMergerNode);\n    var createChannelMergerNodeRenderer = createChannelMergerNodeRendererFactory(createNativeChannelMergerNode, getNativeAudioNode, renderInputsOfAudioNode);\n    var channelMergerNodeConstructor = createChannelMergerNodeConstructor(audioNodeConstructor, createChannelMergerNodeRenderer, createNativeChannelMergerNode, getNativeContext, isNativeOfflineAudioContext);\n    var createChannelSplitterNodeRenderer = createChannelSplitterNodeRendererFactory(createNativeChannelSplitterNode, getNativeAudioNode, renderInputsOfAudioNode);\n    var channelSplitterNodeConstructor = createChannelSplitterNodeConstructor(audioNodeConstructor, createChannelSplitterNodeRenderer, createNativeChannelSplitterNode, getNativeContext, isNativeOfflineAudioContext, sanitizeChannelSplitterOptions);\n    var createNativeConstantSourceNodeFaker = createNativeConstantSourceNodeFakerFactory(addSilentConnection, createNativeAudioBufferSourceNode, createNativeGainNode, monitorConnections);\n    var createNativeConstantSourceNode = createNativeConstantSourceNodeFactory(addSilentConnection, cacheTestResult, createNativeConstantSourceNodeFaker, testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, testAudioScheduledSourceNodeStopMethodNegativeParametersSupport);\n    var createConstantSourceNodeRenderer = createConstantSourceNodeRendererFactory(connectAudioParam, createNativeConstantSourceNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);\n    var constantSourceNodeConstructor = createConstantSourceNodeConstructor(audioNodeConstructor, createAudioParam, createConstantSourceNodeRenderer, createNativeConstantSourceNode, getNativeContext, isNativeOfflineAudioContext, wrapEventListener);\n    var createNativeConvolverNode = createNativeConvolverNodeFactory(createNotSupportedError, overwriteAccessors);\n    var createConvolverNodeRenderer = createConvolverNodeRendererFactory(createNativeConvolverNode, getNativeAudioNode, renderInputsOfAudioNode);\n    var convolverNodeConstructor = createConvolverNodeConstructor(audioNodeConstructor, createConvolverNodeRenderer, createNativeConvolverNode, getNativeContext, isNativeOfflineAudioContext, setAudioNodeTailTime);\n    var createDelayNodeRenderer = createDelayNodeRendererFactory(connectAudioParam, createNativeDelayNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);\n    var delayNodeConstructor = createDelayNodeConstructor(audioNodeConstructor, createAudioParam, createDelayNodeRenderer, createNativeDelayNode, getNativeContext, isNativeOfflineAudioContext, setAudioNodeTailTime);\n    var createNativeDynamicsCompressorNode = createNativeDynamicsCompressorNodeFactory(createNotSupportedError);\n    var createDynamicsCompressorNodeRenderer = createDynamicsCompressorNodeRendererFactory(connectAudioParam, createNativeDynamicsCompressorNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);\n    var dynamicsCompressorNodeConstructor = createDynamicsCompressorNodeConstructor(audioNodeConstructor, createAudioParam, createDynamicsCompressorNodeRenderer, createNativeDynamicsCompressorNode, createNotSupportedError, getNativeContext, isNativeOfflineAudioContext, setAudioNodeTailTime);\n    var createGainNodeRenderer = createGainNodeRendererFactory(connectAudioParam, createNativeGainNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);\n    var gainNodeConstructor = createGainNodeConstructor(audioNodeConstructor, createAudioParam, createGainNodeRenderer, createNativeGainNode, getNativeContext, isNativeOfflineAudioContext);\n    var createNativeIIRFilterNodeFaker = createNativeIIRFilterNodeFakerFactory(createInvalidAccessError, createInvalidStateError, createNativeScriptProcessorNode, createNotSupportedError);\n    var renderNativeOfflineAudioContext = createRenderNativeOfflineAudioContext(cacheTestResult, createNativeGainNode, createNativeScriptProcessorNode, createTestOfflineAudioContextCurrentTimeSupport(createNativeGainNode, nativeOfflineAudioContextConstructor));\n    var createIIRFilterNodeRenderer = createIIRFilterNodeRendererFactory(createNativeAudioBufferSourceNode, getNativeAudioNode, nativeOfflineAudioContextConstructor, renderInputsOfAudioNode, renderNativeOfflineAudioContext);\n    var createNativeIIRFilterNode = createNativeIIRFilterNodeFactory(createNativeIIRFilterNodeFaker);\n    var iIRFilterNodeConstructor = createIIRFilterNodeConstructor(audioNodeConstructor, createNativeIIRFilterNode, createIIRFilterNodeRenderer, getNativeContext, isNativeOfflineAudioContext, setAudioNodeTailTime);\n    var createAudioListener = createAudioListenerFactory(createAudioParam, createNativeChannelMergerNode, createNativeConstantSourceNode, createNativeScriptProcessorNode, createNotSupportedError, getFirstSample, isNativeOfflineAudioContext, overwriteAccessors);\n    var unrenderedAudioWorkletNodeStore = new WeakMap();\n    var minimalBaseAudioContextConstructor = createMinimalBaseAudioContextConstructor(audioDestinationNodeConstructor, createAudioListener, eventTargetConstructor, isNativeOfflineAudioContext, unrenderedAudioWorkletNodeStore, wrapEventListener);\n    var createNativeOscillatorNode = createNativeOscillatorNodeFactory(addSilentConnection, cacheTestResult, testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport, testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls);\n    var createOscillatorNodeRenderer = createOscillatorNodeRendererFactory(connectAudioParam, createNativeOscillatorNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);\n    var oscillatorNodeConstructor = createOscillatorNodeConstructor(audioNodeConstructor, createAudioParam, createNativeOscillatorNode, createOscillatorNodeRenderer, getNativeContext, isNativeOfflineAudioContext, wrapEventListener);\n    var createConnectedNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNodeFactory(createNativeAudioBufferSourceNode);\n    var createNativeWaveShaperNodeFaker = createNativeWaveShaperNodeFakerFactory(createConnectedNativeAudioBufferSourceNode, createInvalidStateError, createNativeGainNode, isDCCurve, monitorConnections);\n    var createNativeWaveShaperNode = createNativeWaveShaperNodeFactory(createConnectedNativeAudioBufferSourceNode, createInvalidStateError, createNativeWaveShaperNodeFaker, isDCCurve, monitorConnections, nativeAudioContextConstructor, overwriteAccessors);\n    var createNativePannerNodeFaker = createNativePannerNodeFakerFactory(connectNativeAudioNodeToNativeAudioNode, createInvalidStateError, createNativeChannelMergerNode, createNativeGainNode, createNativeScriptProcessorNode, createNativeWaveShaperNode, createNotSupportedError, disconnectNativeAudioNodeFromNativeAudioNode, getFirstSample, monitorConnections);\n    var createNativePannerNode = createNativePannerNodeFactory(createNativePannerNodeFaker);\n    var createPannerNodeRenderer = createPannerNodeRendererFactory(connectAudioParam, createNativeChannelMergerNode, createNativeConstantSourceNode, createNativeGainNode, createNativePannerNode, getNativeAudioNode, nativeOfflineAudioContextConstructor, renderAutomation, renderInputsOfAudioNode, renderNativeOfflineAudioContext);\n    var pannerNodeConstructor = createPannerNodeConstructor(audioNodeConstructor, createAudioParam, createNativePannerNode, createPannerNodeRenderer, getNativeContext, isNativeOfflineAudioContext, setAudioNodeTailTime);\n    var createNativePeriodicWave = createNativePeriodicWaveFactory(createIndexSizeError);\n    var periodicWaveConstructor = createPeriodicWaveConstructor(createNativePeriodicWave, getNativeContext, new WeakSet(), sanitizePeriodicWaveOptions);\n    var nativeStereoPannerNodeFakerFactory = createNativeStereoPannerNodeFakerFactory(createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeGainNode, createNativeWaveShaperNode, createNotSupportedError, monitorConnections);\n    var createNativeStereoPannerNode = createNativeStereoPannerNodeFactory(nativeStereoPannerNodeFakerFactory, createNotSupportedError);\n    var createStereoPannerNodeRenderer = createStereoPannerNodeRendererFactory(connectAudioParam, createNativeStereoPannerNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);\n    var stereoPannerNodeConstructor = createStereoPannerNodeConstructor(audioNodeConstructor, createAudioParam, createNativeStereoPannerNode, createStereoPannerNodeRenderer, getNativeContext, isNativeOfflineAudioContext);\n    var createWaveShaperNodeRenderer = createWaveShaperNodeRendererFactory(createNativeWaveShaperNode, getNativeAudioNode, renderInputsOfAudioNode);\n    var waveShaperNodeConstructor = createWaveShaperNodeConstructor(audioNodeConstructor, createInvalidStateError, createNativeWaveShaperNode, createWaveShaperNodeRenderer, getNativeContext, isNativeOfflineAudioContext, setAudioNodeTailTime);\n    var isSecureContext = createIsSecureContext(window$1);\n    var exposeCurrentFrameAndCurrentTime = createExposeCurrentFrameAndCurrentTime(window$1);\n    var backupOfflineAudioContextStore = new WeakMap();\n    var getOrCreateBackupOfflineAudioContext = createGetOrCreateBackupOfflineAudioContext(backupOfflineAudioContextStore, nativeOfflineAudioContextConstructor);\n    // The addAudioWorkletModule() function is only available in a SecureContext.\n    var addAudioWorkletModule = isSecureContext ? createAddAudioWorkletModule(cacheTestResult, createNotSupportedError, createEvaluateSource(window$1), exposeCurrentFrameAndCurrentTime, createFetchSource(createAbortError), getNativeContext, getOrCreateBackupOfflineAudioContext, isNativeOfflineAudioContext, nativeAudioWorkletNodeConstructor, new WeakMap(), new WeakMap(), createTestAudioWorkletProcessorPostMessageSupport(nativeAudioWorkletNodeConstructor, nativeOfflineAudioContextConstructor),\n    // @todo window is guaranteed to be defined because isSecureContext checks that as well.\n    window$1) : undefined;\n    var isNativeContext = createIsNativeContext(isNativeAudioContext, isNativeOfflineAudioContext);\n    var decodeAudioData = createDecodeAudioData(audioBufferStore, cacheTestResult, createDataCloneError, createEncodingError, new WeakSet(), getNativeContext, isNativeContext, testAudioBufferCopyChannelMethodsOutOfBoundsSupport, testPromiseSupport, wrapAudioBufferCopyChannelMethods, wrapAudioBufferCopyChannelMethodsOutOfBounds);\n    var baseAudioContextConstructor = createBaseAudioContextConstructor(addAudioWorkletModule, analyserNodeConstructor, audioBufferConstructor, audioBufferSourceNodeConstructor, biquadFilterNodeConstructor, channelMergerNodeConstructor, channelSplitterNodeConstructor, constantSourceNodeConstructor, convolverNodeConstructor, decodeAudioData, delayNodeConstructor, dynamicsCompressorNodeConstructor, gainNodeConstructor, iIRFilterNodeConstructor, minimalBaseAudioContextConstructor, oscillatorNodeConstructor, pannerNodeConstructor, periodicWaveConstructor, stereoPannerNodeConstructor, waveShaperNodeConstructor);\n    var mediaElementAudioSourceNodeConstructor = createMediaElementAudioSourceNodeConstructor(audioNodeConstructor, createNativeMediaElementAudioSourceNode, getNativeContext, isNativeOfflineAudioContext);\n    var mediaStreamAudioDestinationNodeConstructor = createMediaStreamAudioDestinationNodeConstructor(audioNodeConstructor, createNativeMediaStreamAudioDestinationNode, getNativeContext, isNativeOfflineAudioContext);\n    var mediaStreamAudioSourceNodeConstructor = createMediaStreamAudioSourceNodeConstructor(audioNodeConstructor, createNativeMediaStreamAudioSourceNode, getNativeContext, isNativeOfflineAudioContext);\n    var createNativeMediaStreamTrackAudioSourceNode = createNativeMediaStreamTrackAudioSourceNodeFactory(createInvalidStateError, isNativeOfflineAudioContext);\n    var mediaStreamTrackAudioSourceNodeConstructor = createMediaStreamTrackAudioSourceNodeConstructor(audioNodeConstructor, createNativeMediaStreamTrackAudioSourceNode, getNativeContext);\n    var audioContextConstructor = createAudioContextConstructor(baseAudioContextConstructor, createInvalidStateError, createNotSupportedError, createUnknownError, mediaElementAudioSourceNodeConstructor, mediaStreamAudioDestinationNodeConstructor, mediaStreamAudioSourceNodeConstructor, mediaStreamTrackAudioSourceNodeConstructor, nativeAudioContextConstructor);\n    var getUnrenderedAudioWorkletNodes = createGetUnrenderedAudioWorkletNodes(unrenderedAudioWorkletNodeStore);\n    var addUnrenderedAudioWorkletNode = createAddUnrenderedAudioWorkletNode(getUnrenderedAudioWorkletNodes);\n    var connectMultipleOutputs = createConnectMultipleOutputs(createIndexSizeError);\n    var deleteUnrenderedAudioWorkletNode = createDeleteUnrenderedAudioWorkletNode(getUnrenderedAudioWorkletNodes);\n    var disconnectMultipleOutputs = createDisconnectMultipleOutputs(createIndexSizeError);\n    var activeAudioWorkletNodeInputsStore = new WeakMap();\n    var getActiveAudioWorkletNodeInputs = createGetActiveAudioWorkletNodeInputs(activeAudioWorkletNodeInputsStore, getValueForKey);\n    var createNativeAudioWorkletNodeFaker = createNativeAudioWorkletNodeFakerFactory(connectMultipleOutputs, createIndexSizeError, createInvalidStateError, createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeConstantSourceNode, createNativeGainNode, createNativeScriptProcessorNode, createNotSupportedError, disconnectMultipleOutputs, exposeCurrentFrameAndCurrentTime, getActiveAudioWorkletNodeInputs, monitorConnections);\n    var createNativeAudioWorkletNode = createNativeAudioWorkletNodeFactory(createInvalidStateError, createNativeAudioWorkletNodeFaker, createNativeGainNode, createNotSupportedError, monitorConnections);\n    var createAudioWorkletNodeRenderer = createAudioWorkletNodeRendererFactory(connectAudioParam, connectMultipleOutputs, createNativeAudioBufferSourceNode, createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeConstantSourceNode, createNativeGainNode, deleteUnrenderedAudioWorkletNode, disconnectMultipleOutputs, exposeCurrentFrameAndCurrentTime, getNativeAudioNode, nativeAudioWorkletNodeConstructor, nativeOfflineAudioContextConstructor, renderAutomation, renderInputsOfAudioNode, renderNativeOfflineAudioContext);\n    var getBackupOfflineAudioContext = createGetBackupOfflineAudioContext(backupOfflineAudioContextStore);\n    var setActiveAudioWorkletNodeInputs = createSetActiveAudioWorkletNodeInputs(activeAudioWorkletNodeInputsStore);\n    // The AudioWorkletNode constructor is only available in a SecureContext.\n    var audioWorkletNodeConstructor = isSecureContext ? createAudioWorkletNodeConstructor(addUnrenderedAudioWorkletNode, audioNodeConstructor, createAudioParam, createAudioWorkletNodeRenderer, createNativeAudioWorkletNode, getAudioNodeConnections, getBackupOfflineAudioContext, getNativeContext, isNativeOfflineAudioContext, nativeAudioWorkletNodeConstructor, sanitizeAudioWorkletNodeOptions, setActiveAudioWorkletNodeInputs, testAudioWorkletNodeOptionsClonability, wrapEventListener) : undefined;\n    var minimalAudioContextConstructor = createMinimalAudioContextConstructor(createInvalidStateError, createNotSupportedError, createUnknownError, minimalBaseAudioContextConstructor, nativeAudioContextConstructor);\n    var createNativeOfflineAudioContext = createCreateNativeOfflineAudioContext(createNotSupportedError, nativeOfflineAudioContextConstructor);\n    var startRendering = createStartRendering(audioBufferStore, cacheTestResult, getAudioNodeRenderer, getUnrenderedAudioWorkletNodes, renderNativeOfflineAudioContext, testAudioBufferCopyChannelMethodsOutOfBoundsSupport, wrapAudioBufferCopyChannelMethods, wrapAudioBufferCopyChannelMethodsOutOfBounds);\n    var minimalOfflineAudioContextConstructor = createMinimalOfflineAudioContextConstructor(cacheTestResult, createInvalidStateError, createNativeOfflineAudioContext, minimalBaseAudioContextConstructor, startRendering);\n    var offlineAudioContextConstructor = createOfflineAudioContextConstructor(baseAudioContextConstructor, cacheTestResult, createInvalidStateError, createNativeOfflineAudioContext, startRendering);\n    var isAnyAudioContext = createIsAnyAudioContext(CONTEXT_STORE, isNativeAudioContext);\n    var isAnyAudioNode = createIsAnyAudioNode(AUDIO_NODE_STORE, isNativeAudioNode);\n    var isAnyAudioParam = createIsAnyAudioParam(AUDIO_PARAM_STORE, isNativeAudioParam);\n    var isAnyOfflineAudioContext = createIsAnyOfflineAudioContext(CONTEXT_STORE, isNativeOfflineAudioContext);\n    var isSupported = function isSupported() {\n      return createIsSupportedPromise(cacheTestResult, createTestAudioBufferCopyChannelMethodsSubarraySupport(nativeOfflineAudioContextConstructor), createTestAudioContextCloseMethodSupport(nativeAudioContextConstructor), createTestAudioContextDecodeAudioDataMethodTypeErrorSupport(nativeOfflineAudioContextConstructor), createTestAudioContextOptionsSupport(nativeAudioContextConstructor), createTestAudioNodeConnectMethodSupport(nativeOfflineAudioContextConstructor), createTestAudioWorkletProcessorNoOutputsSupport(nativeAudioWorkletNodeConstructor, nativeOfflineAudioContextConstructor), createTestChannelMergerNodeChannelCountSupport(nativeOfflineAudioContextConstructor), createTestConstantSourceNodeAccurateSchedulingSupport(nativeOfflineAudioContextConstructor), createTestConvolverNodeBufferReassignabilitySupport(nativeOfflineAudioContextConstructor), createTestConvolverNodeChannelCountSupport(nativeOfflineAudioContextConstructor), testDomExceptionConstructorSupport, createTestIsSecureContextSupport(window$1), createTestMediaStreamAudioSourceNodeMediaStreamWithoutAudioTrackSupport(nativeAudioContextConstructor), createTestStereoPannerNodeDefaultValueSupport(nativeOfflineAudioContextConstructor), testTransferablesSupport);\n    };\n\n    exports.AnalyserNode = analyserNodeConstructor;\n    exports.AudioBuffer = audioBufferConstructor;\n    exports.AudioBufferSourceNode = audioBufferSourceNodeConstructor;\n    exports.AudioContext = audioContextConstructor;\n    exports.AudioWorkletNode = audioWorkletNodeConstructor;\n    exports.BiquadFilterNode = biquadFilterNodeConstructor;\n    exports.ChannelMergerNode = channelMergerNodeConstructor;\n    exports.ChannelSplitterNode = channelSplitterNodeConstructor;\n    exports.ConstantSourceNode = constantSourceNodeConstructor;\n    exports.ConvolverNode = convolverNodeConstructor;\n    exports.DelayNode = delayNodeConstructor;\n    exports.DynamicsCompressorNode = dynamicsCompressorNodeConstructor;\n    exports.GainNode = gainNodeConstructor;\n    exports.IIRFilterNode = iIRFilterNodeConstructor;\n    exports.MediaElementAudioSourceNode = mediaElementAudioSourceNodeConstructor;\n    exports.MediaStreamAudioDestinationNode = mediaStreamAudioDestinationNodeConstructor;\n    exports.MediaStreamAudioSourceNode = mediaStreamAudioSourceNodeConstructor;\n    exports.MediaStreamTrackAudioSourceNode = mediaStreamTrackAudioSourceNodeConstructor;\n    exports.MinimalAudioContext = minimalAudioContextConstructor;\n    exports.MinimalOfflineAudioContext = minimalOfflineAudioContextConstructor;\n    exports.OfflineAudioContext = offlineAudioContextConstructor;\n    exports.OscillatorNode = oscillatorNodeConstructor;\n    exports.PannerNode = pannerNodeConstructor;\n    exports.PeriodicWave = periodicWaveConstructor;\n    exports.StereoPannerNode = stereoPannerNodeConstructor;\n    exports.WaveShaperNode = waveShaperNodeConstructor;\n    exports.addAudioWorkletModule = addAudioWorkletModule;\n    exports.decodeAudioData = decodeAudioData;\n    exports.isAnyAudioContext = isAnyAudioContext;\n    exports.isAnyAudioNode = isAnyAudioNode;\n    exports.isAnyAudioParam = isAnyAudioParam;\n    exports.isAnyOfflineAudioContext = isAnyOfflineAudioContext;\n    exports.isSupported = isSupported;\n\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3RhbmRhcmRpemVkLWF1ZGlvLWNvbnRleHQvYnVpbGQvZXM1L2J1bmRsZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLElBQUksS0FBNEQsb0JBQW9CLG1CQUFPLENBQUMsc0ZBQW1CLEdBQUcsbUJBQU8sQ0FBQywwR0FBc0MsR0FBRyxtQkFBTyxDQUFDLHNHQUFvQyxHQUFHLG1CQUFPLENBQUMsNEdBQXVDLEdBQUcsbUJBQU8sQ0FBQyw0RkFBK0IsR0FBRyxtQkFBTyxDQUFDLDRHQUF1QyxHQUFHLG1CQUFPLENBQUMsa0lBQWtELEdBQUcsbUJBQU8sQ0FBQyw0R0FBdUMsR0FBRyxtQkFBTyxDQUFDLGdHQUFpQyxHQUFHLG1CQUFPLENBQUMsZ0hBQXlDLEdBQUcsbUJBQU8sQ0FBQyw0RkFBNEIsR0FBRyxtQkFBTyxDQUFDLGtIQUEwQyxHQUFHLG1CQUFPLENBQUMsOEhBQWdEO0FBQ25zQixJQUFJLENBQzZiO0FBQ2pjLENBQUMsdVFBQXVROztBQUV4UTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixvQ0FBb0M7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsY0FBYztBQUM5QixnQkFBZ0IsZ0NBQWdDO0FBQ2hEO0FBQ0EsK0JBQStC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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBLCtCQUErQix3QkFBd0Isb0NBQW9DLHlDQUF5QyxrQ0FBa0MsMERBQTBELDBCQUEwQjtBQUMxUCxrQ0FBa0MsZ0JBQWdCLHNCQUFzQixPQUFPLGtEQUFrRCx3REFBd0QsOEJBQThCLHFKQUFxSixxRUFBcUUsS0FBSztBQUN0YjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsK0JBQStCLHdCQUF3QixvQ0FBb0MseUNBQXlDLGtDQUFrQywwREFBMEQsMEJBQTBCO0FBQzFQLGtDQUFrQyxnQkFBZ0Isc0JBQXNCLE9BQU8sa0RBQWtELHdEQUF3RCw4QkFBOEIscUpBQXFKLHFFQUFxRSxLQUFLO0FBQ3RiLHFDQUFxQztBQUNyQyw2Q0FBNkMsTUFBTSxxRkFBcUYsTUFBTSxhQUFhLDZFQUE2RSxhQUFhO0FBQ3JQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNB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QTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0ZBQW9GLGFBQWE7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUZBQXVGLGVBQWU7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUZBQXVGLGVBQWU7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUZBQXVGLGVBQWU7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUZBQXVGLGVBQWU7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUZBQXVGLGVBQWU7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUZBQXVGLGVBQWU7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGdDQUFnQztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxzRkFBc0Y7QUFDdEY7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBLCtCQUErQix3QkFBd0Isb0NBQW9DLHlDQUF5QyxrQ0FBa0MsMERBQTBELDBCQUEwQjtBQUMxUCxrQ0FBa0MsZ0JBQWdCLHNCQUFzQixPQUFPLGtEQUFrRCx3REFBd0QsOEJBQThCLHFKQUFxSixxRUFBcUUsS0FBSztBQUN0YixxQ0FBcUM7QUFDckMsNkNBQTZDLE1BQU0scUZBQXFGLE1BQU0sYUFBYSw2RUFBNkUsYUFBYTtBQUNyUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUEsK0JBQStCLHdCQUF3QixvQ0FBb0MseUNBQXlDLGtDQUFrQywwREFBMEQsMEJBQTBCO0FBQzFQLGtDQUFrQyxnQkFBZ0Isc0JBQXNCLE9BQU8sa0RBQWtELHdEQUF3RCw4QkFBOEIscUpBQXFKLHFFQUFxRSxLQUFLO0FBQ3RiLHFDQUFxQztBQUNyQyw2Q0FBNkMsTUFBTSxxRkFBcUYsTUFBTSxhQUFhLDZFQUE2RSxhQUFhO0FBQ3JQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0EsUUFBUSw4SUFBOEk7QUFDdEo7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGlCQUFpQjtBQUN2QztBQUNBLHdCQUF3QixlQUFlO0FBQ3ZDLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsd0JBQXdCO0FBQ3pELHFFQUFxRTtBQUNyRTtBQUNBLGtDQUFrQyxzQkFBc0I7QUFDeEQsb0VBQW9FO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixvQkFBb0I7QUFDNUM7QUFDQTtBQUNBLHlCQUF5Qix3QkFBd0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix3QkFBd0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUU7QUFDbkUsMEhBQTBIO0FBQzFIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0RBQWtELCtFQUErRSxVQUFVLHVFQUF1RSxjQUFjLGlDQUFpQyxTQUFTLHdCQUF3QiwwQkFBMEIsV0FBVyxJQUFJLDZCQUE2QixxQkFBcUIsVUFBVSxZQUFZLGdLQUFnSyx1QkFBdUIsU0FBUyxrQkFBa0IsZ0JBQWdCLG9CQUFvQixrQkFBa0IsdUJBQXVCLHFCQUFxQixnQkFBZ0Isb0JBQW9CLE1BQU0sNkNBQTZDLFVBQVU7QUFDeHlCLG1EQUFtRCxTQUFTLDREQUE0RCxVQUFVLGdDQUFnQztBQUNsSyx5Q0FBeUMsK0NBQStDLDhCQUE4QixPQUFPLGtCQUFrQjtBQUMvSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsOEJBQThCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUwscUNBQXFDO0FBQ3JDLDZDQUE2QyxNQUFNLHFGQUFxRixNQUFNLGFBQWEsNkVBQTZFLGFBQWE7QUFDclA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDs7QUFFQSwrQkFBK0Isd0JBQXdCLG9DQUFvQyx5Q0FBeUMsa0NBQWtDLDBEQUEwRCwwQkFBMEI7QUFDMVAsa0NBQWtDLGdCQUFnQixzQkFBc0IsT0FBTyxrREFBa0Qsd0RBQXdELDhCQUE4QixxSkFBcUoscUVBQXFFLEtBQUs7QUFDdGIscUNBQXFDO0FBQ3JDLDZDQUE2QyxNQUFNLHFGQUFxRixNQUFNLGFBQWEsNkVBQTZFLGFBQWE7QUFDclA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQOztBQUVBLHFDQUFxQztBQUNyQyw2Q0FBNkMsTUFBTSxxRkFBcUYsTUFBTSxhQUFhLDZFQUE2RSxhQUFhO0FBQ3JQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7O0FBRUEscUNBQXFDO0FBQ3JDLDZDQUE2QyxNQUFNLHFGQUFxRixNQUFNLGFBQWEsNkVBQTZFLGFBQWE7QUFDclA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUEscUNBQXFDO0FBQ3JDLDZDQUE2QyxNQUFNLHFGQUFxRixNQUFNLGFBQWEsNkVBQTZFLGFBQWE7QUFDclA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQOztBQUVBLHFDQUFxQztBQUNyQyw2Q0FBNkMsTUFBTSxxRkFBcUYsTUFBTSxhQUFhLDZFQUE2RSxhQUFhO0FBQ3JQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0JBQStCLHdCQUF3QixvQ0FBb0MseUNBQXlDLGtDQUFrQywwREFBMEQsMEJBQTBCO0FBQzFQLGtDQUFrQyxnQkFBZ0Isc0JBQXNCLE9BQU8sa0RBQWtELHdEQUF3RCw4QkFBOEIscUpBQXFKLHFFQUFxRSxLQUFLO0FBQ3RiLHFDQUFxQztBQUNyQyw2Q0FBNkMsTUFBTSxxRkFBcUYsTUFBTSxhQUFhLDZFQUE2RSxhQUFhO0FBQ3JQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0U7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7O0FBRUEsa0RBQWtELCtFQUErRSxVQUFVLHVFQUF1RSxjQUFjLGlDQUFpQyxTQUFTLHdCQUF3QiwwQkFBMEIsV0FBVyxJQUFJLDZCQUE2QixxQkFBcUIsVUFBVSxZQUFZLGdLQUFnSyx1QkFBdUIsU0FBUyxrQkFBa0IsZ0JBQWdCLG9CQUFvQixrQkFBa0IsdUJBQXVCLHFCQUFxQixnQkFBZ0Isb0JBQW9CLE1BQU0sNkNBQTZDLFVBQVU7QUFDeHlCLG1EQUFtRCxTQUFTLDREQUE0RCxVQUFVLGdDQUFnQztBQUNsSyx5Q0FBeUMsK0NBQStDLDhCQUE4QixPQUFPLGtCQUFrQjtBQUMvSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyw4QkFBOEI7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsZ0NBQWdDO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGNBQWM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrQkFBK0Isd0JBQXdCLG9DQUFvQyx5Q0FBeUMsa0NBQWtDLDBEQUEwRCwwQkFBMEI7QUFDMVAsa0NBQWtDLGdCQUFnQixzQkFBc0IsT0FBTyxrREFBa0Qsd0RBQXdELDhCQUE4QixxSkFBcUoscUVBQXFFLEtBQUs7QUFDdGI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtHQUErRyw2QkFBNkI7QUFDNUk7QUFDQTtBQUNBLFNBQVM7QUFDVCxrR0FBa0csdUJBQXVCO0FBQ3pIO0FBQ0EsU0FBUztBQUNULHlHQUF5Ryw2QkFBNkI7QUFDdEk7QUFDQSxTQUFTO0FBQ1QseUdBQXlHLDZCQUE2QjtBQUN0STtBQUNBLFNBQVM7QUFDVCx5R0FBeUcsNkJBQTZCO0FBQ3RJO0FBQ0EsU0FBUztBQUNULHNHQUFzRyw2QkFBNkI7QUFDbkk7QUFDQSxTQUFTO0FBQ1Qsc0dBQXNHLDZCQUE2QjtBQUNuSTtBQUNBLFNBQVM7QUFDVCxzR0FBc0csNkJBQTZCO0FBQ25JO0FBQ0EsU0FBUztBQUNUO0FBQ0EseUdBQXlHLDZCQUE2QjtBQUN0STtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxzRUFBc0U7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCwrREFBK0Q7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNB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QUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLHNDQUFzQyxjQUFjLFFBQVEsMEJBQTBCLFNBQVMsaUJBQWlCLGlCQUFpQixXQUFXLDBCQUEwQixVQUFVLEtBQUs7QUFDN04sK0NBQStDO0FBQy9DLGVBQWU7QUFDZixxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0UsV0FBVywyQ0FBMkM7QUFDNUgsK0NBQStDO0FBQy9DLGVBQWUsR0FBRztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwrQkFBK0Isd0JBQXdCLG9DQUFvQyx5Q0FBeUMsa0NBQWtDLDBEQUEwRCwwQkFBMEI7QUFDMVAsa0NBQWtDLGdCQUFnQixzQkFBc0IsT0FBTyxrREFBa0Qsd0RBQXdELDhCQUE4QixxSkFBcUoscUVBQXFFLEtBQUs7QUFDdGIsbUNBQW1DO0FBQ25DLDJDQUEyQyxNQUFNLHFGQUFxRixNQUFNLGFBQWEsMkVBQTJFLGFBQWE7QUFDalA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCwrREFBK0Q7QUFDNUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsMERBQTBEO0FBQ3ZIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixZQUFZO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUEsK0JBQStCLHdCQUF3QixvQ0FBb0MseUNBQXlDLGtDQUFrQywwREFBMEQsMEJBQTBCO0FBQzFQLGtDQUFrQyxnQkFBZ0Isc0JBQXNCLE9BQU8sa0RBQWtELHdEQUF3RCw4QkFBOEIscUpBQXFKLHFFQUFxRSxLQUFLO0FBQ3RiO0FBQ0EsK0NBQStDLGNBQWM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7O0FBRUEsK0JBQStCLHdCQUF3QixvQ0FBb0MseUNBQXlDLGtDQUFrQywwREFBMEQsMEJBQTBCO0FBQzFQLGtDQUFrQyxnQkFBZ0Isc0JBQXNCLE9BQU8sa0RBQWtELHdEQUF3RCw4QkFBOEIscUpBQXFKLHFFQUFxRSxLQUFLO0FBQ3RiO0FBQ0EsK0NBQStDLGNBQWM7QUFDN0Q7QUFDQSxPQUFPO0FBQ1A7O0FBRUEsNkJBQTZCLHdCQUF3QixvQ0FBb0MseUNBQXlDLGtDQUFrQywwREFBMEQsMEJBQTBCO0FBQ3hQLGdDQUFnQyxnQkFBZ0Isc0JBQXNCLE9BQU8sa0RBQWtELHNEQUFzRCw4QkFBOEIsbUpBQW1KLHFFQUFxRSxLQUFLO0FBQ2hiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsY0FBYztBQUM3RDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsNkNBQTZDLGNBQWM7QUFDM0Q7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsNkNBQTZDLGNBQWM7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBLDJDQUEyQyxjQUFjO0FBQ3pEO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QixRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi9ub2RlX21vZHVsZXMvc3RhbmRhcmRpemVkLWF1ZGlvLWNvbnRleHQvYnVpbGQvZXM1L2J1bmRsZS5qcz81ZTliIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzLCByZXF1aXJlKCdhdXRvbWF0aW9uLWV2ZW50cycpLCByZXF1aXJlKCdAYmFiZWwvcnVudGltZS9oZWxwZXJzL3NsaWNlZFRvQXJyYXknKSwgcmVxdWlyZSgnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzcycpLCByZXF1aXJlKCdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrJyksIHJlcXVpcmUoJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvdHlwZW9mJyksIHJlcXVpcmUoJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHknKSwgcmVxdWlyZSgnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuJyksIHJlcXVpcmUoJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZ2V0UHJvdG90eXBlT2YnKSwgcmVxdWlyZSgnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbmhlcml0cycpLCByZXF1aXJlKCdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2FzeW5jVG9HZW5lcmF0b3InKSwgcmVxdWlyZSgnQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3InKSwgcmVxdWlyZSgnQGJhYmVsL3J1bnRpbWUvaGVscGVycy90b0NvbnN1bWFibGVBcnJheScpLCByZXF1aXJlKCdAYmFiZWwvcnVudGltZS9oZWxwZXJzL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzJykpIDpcbiAgICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJywgJ2F1dG9tYXRpb24tZXZlbnRzJywgJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvc2xpY2VkVG9BcnJheScsICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzJywgJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2snLCAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy90eXBlb2YnLCAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eScsICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4nLCAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9nZXRQcm90b3R5cGVPZicsICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2luaGVyaXRzJywgJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXN5bmNUb0dlbmVyYXRvcicsICdAYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvcicsICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL3RvQ29uc3VtYWJsZUFycmF5JywgJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvb2JqZWN0V2l0aG91dFByb3BlcnRpZXMnXSwgZmFjdG9yeSkgOlxuICAgIChnbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogZ2xvYmFsIHx8IHNlbGYsIGZhY3RvcnkoZ2xvYmFsLnN0YW5kYXJkaXplZEF1ZGlvQ29udGV4dCA9IHt9LCBnbG9iYWwuYXV0b21hdGlvbkV2ZW50cywgZ2xvYmFsLl9zbGljZWRUb0FycmF5LCBnbG9iYWwuX2NyZWF0ZUNsYXNzLCBnbG9iYWwuX2NsYXNzQ2FsbENoZWNrLCBnbG9iYWwuX3R5cGVvZiwgZ2xvYmFsLl9kZWZpbmVQcm9wZXJ0eSwgZ2xvYmFsLl9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuLCBnbG9iYWwuX2dldFByb3RvdHlwZU9mLCBnbG9iYWwuX2luaGVyaXRzLCBnbG9iYWwuX2FzeW5jVG9HZW5lcmF0b3IsIGdsb2JhbC5fcmVnZW5lcmF0b3JSdW50aW1lLCBnbG9iYWwuX3RvQ29uc3VtYWJsZUFycmF5LCBnbG9iYWwuX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKSk7XG59KSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMsIGF1dG9tYXRpb25FdmVudHMsIF9zbGljZWRUb0FycmF5LCBfY3JlYXRlQ2xhc3MsIF9jbGFzc0NhbGxDaGVjaywgX3R5cGVvZiwgX2RlZmluZVByb3BlcnR5LCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiwgX2dldFByb3RvdHlwZU9mLCBfaW5oZXJpdHMsIF9hc3luY1RvR2VuZXJhdG9yLCBfcmVnZW5lcmF0b3JSdW50aW1lLCBfdG9Db25zdW1hYmxlQXJyYXksIF9vYmplY3RXaXRob3V0UHJvcGVydGllcykgeyAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgY3JlYXRlQWJvcnRFcnJvciA9IGZ1bmN0aW9uIGNyZWF0ZUFib3J0RXJyb3IoKSB7XG4gICAgICByZXR1cm4gbmV3IERPTUV4Y2VwdGlvbignJywgJ0Fib3J0RXJyb3InKTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZUFkZEFjdGl2ZUlucHV0Q29ubmVjdGlvblRvQXVkaW9Ob2RlID0gZnVuY3Rpb24gY3JlYXRlQWRkQWN0aXZlSW5wdXRDb25uZWN0aW9uVG9BdWRpb05vZGUoaW5zZXJ0RWxlbWVudEluU2V0KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGFjdGl2ZUlucHV0cywgc291cmNlLCBfcmVmLCBpZ25vcmVEdXBsaWNhdGVzKSB7XG4gICAgICAgIHZhciBfcmVmMiA9IF9zbGljZWRUb0FycmF5KF9yZWYsIDMpLFxuICAgICAgICAgIG91dHB1dCA9IF9yZWYyWzBdLFxuICAgICAgICAgIGlucHV0ID0gX3JlZjJbMV0sXG4gICAgICAgICAgZXZlbnRMaXN0ZW5lciA9IF9yZWYyWzJdO1xuICAgICAgICBpbnNlcnRFbGVtZW50SW5TZXQoYWN0aXZlSW5wdXRzW2lucHV0XSwgW3NvdXJjZSwgb3V0cHV0LCBldmVudExpc3RlbmVyXSwgZnVuY3Rpb24gKGFjdGl2ZUlucHV0Q29ubmVjdGlvbikge1xuICAgICAgICAgIHJldHVybiBhY3RpdmVJbnB1dENvbm5lY3Rpb25bMF0gPT09IHNvdXJjZSAmJiBhY3RpdmVJbnB1dENvbm5lY3Rpb25bMV0gPT09IG91dHB1dDtcbiAgICAgICAgfSwgaWdub3JlRHVwbGljYXRlcyk7XG4gICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlQWRkQXVkaW9Ob2RlQ29ubmVjdGlvbnMgPSBmdW5jdGlvbiBjcmVhdGVBZGRBdWRpb05vZGVDb25uZWN0aW9ucyhhdWRpb05vZGVDb25uZWN0aW9uc1N0b3JlKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGF1ZGlvTm9kZSwgYXVkaW9Ob2RlUmVuZGVyZXIsIG5hdGl2ZUF1ZGlvTm9kZSkge1xuICAgICAgICB2YXIgYWN0aXZlSW5wdXRzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmF0aXZlQXVkaW9Ob2RlLm51bWJlck9mSW5wdXRzOyBpICs9IDEpIHtcbiAgICAgICAgICBhY3RpdmVJbnB1dHMucHVzaChuZXcgU2V0KCkpO1xuICAgICAgICB9XG4gICAgICAgIGF1ZGlvTm9kZUNvbm5lY3Rpb25zU3RvcmUuc2V0KGF1ZGlvTm9kZSwge1xuICAgICAgICAgIGFjdGl2ZUlucHV0czogYWN0aXZlSW5wdXRzLFxuICAgICAgICAgIG91dHB1dHM6IG5ldyBTZXQoKSxcbiAgICAgICAgICBwYXNzaXZlSW5wdXRzOiBuZXcgV2Vha01hcCgpLFxuICAgICAgICAgIHJlbmRlcmVyOiBhdWRpb05vZGVSZW5kZXJlclxuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVBZGRBdWRpb1BhcmFtQ29ubmVjdGlvbnMgPSBmdW5jdGlvbiBjcmVhdGVBZGRBdWRpb1BhcmFtQ29ubmVjdGlvbnMoYXVkaW9QYXJhbUNvbm5lY3Rpb25zU3RvcmUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoYXVkaW9QYXJhbSwgYXVkaW9QYXJhbVJlbmRlcmVyKSB7XG4gICAgICAgIGF1ZGlvUGFyYW1Db25uZWN0aW9uc1N0b3JlLnNldChhdWRpb1BhcmFtLCB7XG4gICAgICAgICAgYWN0aXZlSW5wdXRzOiBuZXcgU2V0KCksXG4gICAgICAgICAgcGFzc2l2ZUlucHV0czogbmV3IFdlYWtNYXAoKSxcbiAgICAgICAgICByZW5kZXJlcjogYXVkaW9QYXJhbVJlbmRlcmVyXG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIEFDVElWRV9BVURJT19OT0RFX1NUT1JFID0gbmV3IFdlYWtTZXQoKTtcbiAgICB2YXIgQVVESU9fTk9ERV9DT05ORUNUSU9OU19TVE9SRSA9IG5ldyBXZWFrTWFwKCk7XG4gICAgdmFyIEFVRElPX05PREVfU1RPUkUgPSBuZXcgV2Vha01hcCgpO1xuICAgIHZhciBBVURJT19QQVJBTV9DT05ORUNUSU9OU19TVE9SRSA9IG5ldyBXZWFrTWFwKCk7XG4gICAgdmFyIEFVRElPX1BBUkFNX1NUT1JFID0gbmV3IFdlYWtNYXAoKTtcbiAgICB2YXIgQ09OVEVYVF9TVE9SRSA9IG5ldyBXZWFrTWFwKCk7XG4gICAgdmFyIEVWRU5UX0xJU1RFTkVSUyA9IG5ldyBXZWFrTWFwKCk7XG4gICAgdmFyIENZQ0xFX0NPVU5URVJTID0gbmV3IFdlYWtNYXAoKTtcbiAgICAvLyBUaGlzIGNsdW5reSBuYW1lIGlzIGJvcnJvd2VkIGZyb20gdGhlIHNwZWMuIDotKVxuICAgIHZhciBOT0RFX05BTUVfVE9fUFJPQ0VTU09SX0NPTlNUUlVDVE9SX01BUFMgPSBuZXcgV2Vha01hcCgpO1xuICAgIHZhciBOT0RFX1RPX1BST0NFU1NPUl9NQVBTID0gbmV3IFdlYWtNYXAoKTtcblxuICAgIHZhciBoYW5kbGVyID0ge1xuICAgICAgY29uc3RydWN0OiBmdW5jdGlvbiBjb25zdHJ1Y3QoKSB7XG4gICAgICAgIHJldHVybiBoYW5kbGVyO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIGlzQ29uc3RydWN0aWJsZSA9IGZ1bmN0aW9uIGlzQ29uc3RydWN0aWJsZShjb25zdHJ1Y3RpYmxlKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgcHJveHkgPSBuZXcgUHJveHkoY29uc3RydWN0aWJsZSwgaGFuZGxlcik7XG4gICAgICAgIG5ldyBwcm94eSgpOyAvLyB0c2xpbnQ6ZGlzYWJsZS1saW5lOm5vLXVudXNlZC1leHByZXNzaW9uXG4gICAgICB9IGNhdGNoIChfdW51c2VkKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICAvKlxuICAgICAqIFRoaXMgbWFzc2l2ZSByZWdleCB0cmllcyB0byBjb3ZlciBhbGwgdGhlIGZvbGxvd2luZyBjYXNlcy5cbiAgICAgKlxuICAgICAqIGltcG9ydCAnLi9wYXRoJztcbiAgICAgKiBpbXBvcnQgZGVmYXVsdEltcG9ydCBmcm9tICcuL3BhdGgnO1xuICAgICAqIGltcG9ydCB7IG5hbWVkSW1wb3J0IH0gZnJvbSAnLi9wYXRoJztcbiAgICAgKiBpbXBvcnQgeyBuYW1lZEltcG9ydCBhcyByZW5hbWVuZEltcG9ydCB9IGZyb20gJy4vcGF0aCc7XG4gICAgICogaW1wb3J0ICogYXMgbmFtZXNwYWNlSW1wb3J0IGZyb20gJy4vcGF0aCc7XG4gICAgICogaW1wb3J0IGRlZmF1bHRJbXBvcnQsIHsgbmFtZWRJbXBvcnQgfSBmcm9tICcuL3BhdGgnO1xuICAgICAqIGltcG9ydCBkZWZhdWx0SW1wb3J0LCB7IG5hbWVkSW1wb3J0IGFzIHJlbmFtZW5kSW1wb3J0IH0gZnJvbSAnLi9wYXRoJztcbiAgICAgKiBpbXBvcnQgZGVmYXVsdEltcG9ydCwgKiBhcyBuYW1lc3BhY2VJbXBvcnQgZnJvbSAnLi9wYXRoJztcbiAgICAgKi9cbiAgICB2YXIgSU1QT1JUX1NUQVRFTUVOVF9SRUdFWCA9IC9eaW1wb3J0KD86KD86W1xcc10rW1xcd10rfCg/OltcXHNdK1tcXHddK1tcXHNdKiwpP1tcXHNdKlxce1tcXHNdKltcXHddKyg/OltcXHNdK2FzW1xcc10rW1xcd10rKT8oPzpbXFxzXSosW1xcc10qW1xcd10rKD86W1xcc10rYXNbXFxzXStbXFx3XSspPykqW1xcc10qfXwoPzpbXFxzXStbXFx3XStbXFxzXSosKT9bXFxzXSpcXCpbXFxzXSthc1tcXHNdK1tcXHddKylbXFxzXStmcm9tKT8oPzpbXFxzXSopKFwiKFteXCJcXFxcXXxcXFxcLikrXCJ8JyhbXidcXFxcXXxcXFxcLikrJykoPzpbXFxzXSopOz8vOyAvLyB0c2xpbnQ6ZGlzYWJsZS1saW5lOm1heC1saW5lLWxlbmd0aFxuICAgIHZhciBzcGxpdEltcG9ydFN0YXRlbWVudHMgPSBmdW5jdGlvbiBzcGxpdEltcG9ydFN0YXRlbWVudHMoc291cmNlLCB1cmwpIHtcbiAgICAgIHZhciBpbXBvcnRTdGF0ZW1lbnRzID0gW107XG4gICAgICB2YXIgc291cmNlV2l0aG91dEltcG9ydFN0YXRlbWVudHMgPSBzb3VyY2UucmVwbGFjZSgvXltcXHNdKy8sICcnKTtcbiAgICAgIHZhciByZXN1bHQgPSBzb3VyY2VXaXRob3V0SW1wb3J0U3RhdGVtZW50cy5tYXRjaChJTVBPUlRfU1RBVEVNRU5UX1JFR0VYKTtcbiAgICAgIHdoaWxlIChyZXN1bHQgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIHVucmVzb2x2ZWRVcmwgPSByZXN1bHRbMV0uc2xpY2UoMSwgLTEpO1xuICAgICAgICB2YXIgaW1wb3J0U3RhdGVtZW50V2l0aFJlc29sdmVkVXJsID0gcmVzdWx0WzBdLnJlcGxhY2UoLyhbXFxzXSspPzs/JC8sICcnKS5yZXBsYWNlKHVucmVzb2x2ZWRVcmwsIG5ldyBVUkwodW5yZXNvbHZlZFVybCwgdXJsKS50b1N0cmluZygpKTtcbiAgICAgICAgaW1wb3J0U3RhdGVtZW50cy5wdXNoKGltcG9ydFN0YXRlbWVudFdpdGhSZXNvbHZlZFVybCk7XG4gICAgICAgIHNvdXJjZVdpdGhvdXRJbXBvcnRTdGF0ZW1lbnRzID0gc291cmNlV2l0aG91dEltcG9ydFN0YXRlbWVudHMuc2xpY2UocmVzdWx0WzBdLmxlbmd0aCkucmVwbGFjZSgvXltcXHNdKy8sICcnKTtcbiAgICAgICAgcmVzdWx0ID0gc291cmNlV2l0aG91dEltcG9ydFN0YXRlbWVudHMubWF0Y2goSU1QT1JUX1NUQVRFTUVOVF9SRUdFWCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gW2ltcG9ydFN0YXRlbWVudHMuam9pbignOycpLCBzb3VyY2VXaXRob3V0SW1wb3J0U3RhdGVtZW50c107XG4gICAgfTtcblxuICAgIHZhciB2ZXJpZnlQYXJhbWV0ZXJEZXNjcmlwdG9ycyA9IGZ1bmN0aW9uIHZlcmlmeVBhcmFtZXRlckRlc2NyaXB0b3JzKHBhcmFtZXRlckRlc2NyaXB0b3JzKSB7XG4gICAgICBpZiAocGFyYW1ldGVyRGVzY3JpcHRvcnMgIT09IHVuZGVmaW5lZCAmJiAhQXJyYXkuaXNBcnJheShwYXJhbWV0ZXJEZXNjcmlwdG9ycykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIHBhcmFtZXRlckRlc2NyaXB0b3JzIHByb3BlcnR5IG9mIGdpdmVuIHZhbHVlIGZvciBwcm9jZXNzb3JDdG9yIGlzIG5vdCBhbiBhcnJheS4nKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciB2ZXJpZnlQcm9jZXNzb3JDdG9yID0gZnVuY3Rpb24gdmVyaWZ5UHJvY2Vzc29yQ3Rvcihwcm9jZXNzb3JDdG9yKSB7XG4gICAgICBpZiAoIWlzQ29uc3RydWN0aWJsZShwcm9jZXNzb3JDdG9yKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgZ2l2ZW4gdmFsdWUgZm9yIHByb2Nlc3NvckN0b3Igc2hvdWxkIGJlIGEgY29uc3RydWN0b3IuJyk7XG4gICAgICB9XG4gICAgICBpZiAocHJvY2Vzc29yQ3Rvci5wcm90b3R5cGUgPT09IG51bGwgfHwgX3R5cGVvZihwcm9jZXNzb3JDdG9yLnByb3RvdHlwZSkgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBnaXZlbiB2YWx1ZSBmb3IgcHJvY2Vzc29yQ3RvciBzaG91bGQgaGF2ZSBhIHByb3RvdHlwZS4nKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBjcmVhdGVBZGRBdWRpb1dvcmtsZXRNb2R1bGUgPSBmdW5jdGlvbiBjcmVhdGVBZGRBdWRpb1dvcmtsZXRNb2R1bGUoY2FjaGVUZXN0UmVzdWx0LCBjcmVhdGVOb3RTdXBwb3J0ZWRFcnJvciwgZXZhbHVhdGVTb3VyY2UsIGV4cG9zZUN1cnJlbnRGcmFtZUFuZEN1cnJlbnRUaW1lLCBmZXRjaFNvdXJjZSwgZ2V0TmF0aXZlQ29udGV4dCwgZ2V0T3JDcmVhdGVCYWNrdXBPZmZsaW5lQXVkaW9Db250ZXh0LCBpc05hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQsIG5hdGl2ZUF1ZGlvV29ya2xldE5vZGVDb25zdHJ1Y3Rvciwgb25nb2luZ1JlcXVlc3RzLCByZXNvbHZlZFJlcXVlc3RzLCB0ZXN0QXVkaW9Xb3JrbGV0UHJvY2Vzc29yUG9zdE1lc3NhZ2VTdXBwb3J0LCB3aW5kb3cpIHtcbiAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGNvbnRleHQsIG1vZHVsZVVSTCkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge1xuICAgICAgICAgIGNyZWRlbnRpYWxzOiAnb21pdCdcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHJlc29sdmVkUmVxdWVzdHNPZkNvbnRleHQgPSByZXNvbHZlZFJlcXVlc3RzLmdldChjb250ZXh0KTtcbiAgICAgICAgaWYgKHJlc29sdmVkUmVxdWVzdHNPZkNvbnRleHQgIT09IHVuZGVmaW5lZCAmJiByZXNvbHZlZFJlcXVlc3RzT2ZDb250ZXh0Lmhhcyhtb2R1bGVVUkwpKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvbmdvaW5nUmVxdWVzdHNPZkNvbnRleHQgPSBvbmdvaW5nUmVxdWVzdHMuZ2V0KGNvbnRleHQpO1xuICAgICAgICBpZiAob25nb2luZ1JlcXVlc3RzT2ZDb250ZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YXIgcHJvbWlzZU9mT25nb2luZ1JlcXVlc3QgPSBvbmdvaW5nUmVxdWVzdHNPZkNvbnRleHQuZ2V0KG1vZHVsZVVSTCk7XG4gICAgICAgICAgaWYgKHByb21pc2VPZk9uZ29pbmdSZXF1ZXN0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlT2ZPbmdvaW5nUmVxdWVzdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5hdGl2ZUNvbnRleHQgPSBnZXROYXRpdmVDb250ZXh0KGNvbnRleHQpO1xuICAgICAgICAvLyBCdWcgIzU5OiBTYWZhcmkgZG9lcyBub3QgaW1wbGVtZW50IHRoZSBhdWRpb1dvcmtsZXQgcHJvcGVydHkuXG4gICAgICAgIHZhciBwcm9taXNlID0gbmF0aXZlQ29udGV4dC5hdWRpb1dvcmtsZXQgPT09IHVuZGVmaW5lZCA/IGZldGNoU291cmNlKG1vZHVsZVVSTCkudGhlbihmdW5jdGlvbiAoX3JlZikge1xuICAgICAgICAgIHZhciBfcmVmMiA9IF9zbGljZWRUb0FycmF5KF9yZWYsIDIpLFxuICAgICAgICAgICAgc291cmNlID0gX3JlZjJbMF0sXG4gICAgICAgICAgICBhYnNvbHV0ZVVybCA9IF9yZWYyWzFdO1xuICAgICAgICAgIHZhciBfc3BsaXRJbXBvcnRTdGF0ZW1lbnQgPSBzcGxpdEltcG9ydFN0YXRlbWVudHMoc291cmNlLCBhYnNvbHV0ZVVybCksXG4gICAgICAgICAgICBfc3BsaXRJbXBvcnRTdGF0ZW1lbnQyID0gX3NsaWNlZFRvQXJyYXkoX3NwbGl0SW1wb3J0U3RhdGVtZW50LCAyKSxcbiAgICAgICAgICAgIGltcG9ydFN0YXRlbWVudHMgPSBfc3BsaXRJbXBvcnRTdGF0ZW1lbnQyWzBdLFxuICAgICAgICAgICAgc291cmNlV2l0aG91dEltcG9ydFN0YXRlbWVudHMgPSBfc3BsaXRJbXBvcnRTdGF0ZW1lbnQyWzFdO1xuICAgICAgICAgIC8qXG4gICAgICAgICAgICogVGhpcyBpcyB0aGUgdW5taW5pZmllZCB2ZXJzaW9uIG9mIHRoZSBjb2RlIHVzZWQgYmVsb3c6XG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiBgYGBqc1xuICAgICAgICAgICAqICR7IGltcG9ydFN0YXRlbWVudHMgfTtcbiAgICAgICAgICAgKiAoKGEsIGIpID0+IHtcbiAgICAgICAgICAgKiAgICAgKGFbYl0gPSBhW2JdIHx8IFsgXSkucHVzaChcbiAgICAgICAgICAgKiAgICAgICAgIChBdWRpb1dvcmtsZXRQcm9jZXNzb3IsIGdsb2JhbCwgcmVnaXN0ZXJQcm9jZXNzb3IsIHNhbXBsZVJhdGUsIHNlbGYsIHdpbmRvdykgPT4ge1xuICAgICAgICAgICAqICAgICAgICAgICAgICR7IHNvdXJjZVdpdGhvdXRJbXBvcnRTdGF0ZW1lbnRzIH1cbiAgICAgICAgICAgKiAgICAgICAgIH1cbiAgICAgICAgICAgKiAgICAgKTtcbiAgICAgICAgICAgKiB9KSh3aW5kb3csICdfQVdHUycpO1xuICAgICAgICAgICAqIGBgYFxuICAgICAgICAgICAqL1xuICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTptYXgtbGluZS1sZW5ndGhcbiAgICAgICAgICB2YXIgd3JhcHBlZFNvdXJjZSA9IFwiXCIuY29uY2F0KGltcG9ydFN0YXRlbWVudHMsIFwiOygoYSxiKT0+eyhhW2JdPWFbYl18fFtdKS5wdXNoKChBdWRpb1dvcmtsZXRQcm9jZXNzb3IsZ2xvYmFsLHJlZ2lzdGVyUHJvY2Vzc29yLHNhbXBsZVJhdGUsc2VsZix3aW5kb3cpPT57XCIpLmNvbmNhdChzb3VyY2VXaXRob3V0SW1wb3J0U3RhdGVtZW50cywgXCJcXG59KX0pKHdpbmRvdywnX0FXR1MnKVwiKTtcbiAgICAgICAgICAvLyBAdG9kbyBFdmFsdWF0aW5nIHRoZSBnaXZlbiBzb3VyY2UgY29kZSBpcyBhIHBvc3NpYmxlIHNlY3VyaXR5IHByb2JsZW0uXG4gICAgICAgICAgcmV0dXJuIGV2YWx1YXRlU291cmNlKHdyYXBwZWRTb3VyY2UpO1xuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgZXZhbHVhdGVBdWRpb1dvcmtsZXRHbG9iYWxTY29wZSA9IHdpbmRvdy5fQVdHUy5wb3AoKTtcbiAgICAgICAgICBpZiAoZXZhbHVhdGVBdWRpb1dvcmtsZXRHbG9iYWxTY29wZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBCdWcgIzE4MiBDaHJvbWUgYW5kIEVkZ2UgZG8gdGhyb3cgYW4gaW5zdGFuY2Ugb2YgYSBTeW50YXhFcnJvciBpbnN0ZWFkIG9mIGEgRE9NRXhjZXB0aW9uLlxuICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGV4cG9zZUN1cnJlbnRGcmFtZUFuZEN1cnJlbnRUaW1lKG5hdGl2ZUNvbnRleHQuY3VycmVudFRpbWUsIG5hdGl2ZUNvbnRleHQuc2FtcGxlUmF0ZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGV2YWx1YXRlQXVkaW9Xb3JrbGV0R2xvYmFsU2NvcGUoLyojX19QVVJFX18qL19jcmVhdGVDbGFzcyhmdW5jdGlvbiBBdWRpb1dvcmtsZXRQcm9jZXNzb3IoKSB7XG4gICAgICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBdWRpb1dvcmtsZXRQcm9jZXNzb3IpO1xuICAgICAgICAgICAgfSksIHVuZGVmaW5lZCwgZnVuY3Rpb24gKG5hbWUsIHByb2Nlc3NvckN0b3IpIHtcbiAgICAgICAgICAgICAgaWYgKG5hbWUudHJpbSgpID09PSAnJykge1xuICAgICAgICAgICAgICAgIHRocm93IGNyZWF0ZU5vdFN1cHBvcnRlZEVycm9yKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFyIG5vZGVOYW1lVG9Qcm9jZXNzb3JDb25zdHJ1Y3Rvck1hcCA9IE5PREVfTkFNRV9UT19QUk9DRVNTT1JfQ09OU1RSVUNUT1JfTUFQUy5nZXQobmF0aXZlQ29udGV4dCk7XG4gICAgICAgICAgICAgIGlmIChub2RlTmFtZVRvUHJvY2Vzc29yQ29uc3RydWN0b3JNYXAgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmIChub2RlTmFtZVRvUHJvY2Vzc29yQ29uc3RydWN0b3JNYXAuaGFzKG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBjcmVhdGVOb3RTdXBwb3J0ZWRFcnJvcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2ZXJpZnlQcm9jZXNzb3JDdG9yKHByb2Nlc3NvckN0b3IpO1xuICAgICAgICAgICAgICAgIHZlcmlmeVBhcmFtZXRlckRlc2NyaXB0b3JzKHByb2Nlc3NvckN0b3IucGFyYW1ldGVyRGVzY3JpcHRvcnMpO1xuICAgICAgICAgICAgICAgIG5vZGVOYW1lVG9Qcm9jZXNzb3JDb25zdHJ1Y3Rvck1hcC5zZXQobmFtZSwgcHJvY2Vzc29yQ3Rvcik7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmVyaWZ5UHJvY2Vzc29yQ3Rvcihwcm9jZXNzb3JDdG9yKTtcbiAgICAgICAgICAgICAgICB2ZXJpZnlQYXJhbWV0ZXJEZXNjcmlwdG9ycyhwcm9jZXNzb3JDdG9yLnBhcmFtZXRlckRlc2NyaXB0b3JzKTtcbiAgICAgICAgICAgICAgICBOT0RFX05BTUVfVE9fUFJPQ0VTU09SX0NPTlNUUlVDVE9SX01BUFMuc2V0KG5hdGl2ZUNvbnRleHQsIG5ldyBNYXAoW1tuYW1lLCBwcm9jZXNzb3JDdG9yXV0pKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgbmF0aXZlQ29udGV4dC5zYW1wbGVSYXRlLCB1bmRlZmluZWQsIHVuZGVmaW5lZCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pIDogUHJvbWlzZS5hbGwoW2ZldGNoU291cmNlKG1vZHVsZVVSTCksIFByb21pc2UucmVzb2x2ZShjYWNoZVRlc3RSZXN1bHQodGVzdEF1ZGlvV29ya2xldFByb2Nlc3NvclBvc3RNZXNzYWdlU3VwcG9ydCwgdGVzdEF1ZGlvV29ya2xldFByb2Nlc3NvclBvc3RNZXNzYWdlU3VwcG9ydCkpXSkudGhlbihmdW5jdGlvbiAoX3JlZjMpIHtcbiAgICAgICAgICB2YXIgX3JlZjQgPSBfc2xpY2VkVG9BcnJheShfcmVmMywgMiksXG4gICAgICAgICAgICBfcmVmNCQgPSBfc2xpY2VkVG9BcnJheShfcmVmNFswXSwgMiksXG4gICAgICAgICAgICBzb3VyY2UgPSBfcmVmNCRbMF0sXG4gICAgICAgICAgICBhYnNvbHV0ZVVybCA9IF9yZWY0JFsxXSxcbiAgICAgICAgICAgIGlzU3VwcG9ydGluZ1Bvc3RNZXNzYWdlID0gX3JlZjRbMV07XG4gICAgICAgICAgdmFyIGN1cnJlbnRJbmRleCA9IGluZGV4ICsgMTtcbiAgICAgICAgICBpbmRleCA9IGN1cnJlbnRJbmRleDtcbiAgICAgICAgICB2YXIgX3NwbGl0SW1wb3J0U3RhdGVtZW50MyA9IHNwbGl0SW1wb3J0U3RhdGVtZW50cyhzb3VyY2UsIGFic29sdXRlVXJsKSxcbiAgICAgICAgICAgIF9zcGxpdEltcG9ydFN0YXRlbWVudDQgPSBfc2xpY2VkVG9BcnJheShfc3BsaXRJbXBvcnRTdGF0ZW1lbnQzLCAyKSxcbiAgICAgICAgICAgIGltcG9ydFN0YXRlbWVudHMgPSBfc3BsaXRJbXBvcnRTdGF0ZW1lbnQ0WzBdLFxuICAgICAgICAgICAgc291cmNlV2l0aG91dEltcG9ydFN0YXRlbWVudHMgPSBfc3BsaXRJbXBvcnRTdGF0ZW1lbnQ0WzFdO1xuICAgICAgICAgIC8qXG4gICAgICAgICAgICogQnVnICMxNzk6IEZpcmVmb3ggZG9lcyBub3QgYWxsb3cgdG8gdHJhbnNmZXIgYW55IGJ1ZmZlciB3aGljaCBoYXMgYmVlbiBwYXNzZWQgdG8gdGhlIHByb2Nlc3MoKSBtZXRob2QgYXMgYW4gYXJndW1lbnQuXG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiBUaGlzIGlzIHRoZSB1bm1pbmlmaWVkIHZlcnNpb24gb2YgdGhlIGNvZGUgdXNlZCBiZWxvdy5cbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIGBgYGpzXG4gICAgICAgICAgICogY2xhc3MgZXh0ZW5kcyBBdWRpb1dvcmtsZXRQcm9jZXNzb3Ige1xuICAgICAgICAgICAqXG4gICAgICAgICAgICogICAgIF9fYnVmZmVycyA9IG5ldyBXZWFrU2V0KCk7XG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiAgICAgY29uc3RydWN0b3IgKCkge1xuICAgICAgICAgICAqICAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgICAgKlxuICAgICAgICAgICAqICAgICAgICAgdGhpcy5wb3J0LnBvc3RNZXNzYWdlID0gKChwb3N0TWVzc2FnZSkgPT4ge1xuICAgICAgICAgICAqICAgICAgICAgICAgIHJldHVybiAobWVzc2FnZSwgdHJhbnNmZXJhYmxlcykgPT4ge1xuICAgICAgICAgICAqICAgICAgICAgICAgICAgICBjb25zdCBmaWx0ZXJlZFRyYW5zZmVyYWJsZXMgPSAodHJhbnNmZXJhYmxlcylcbiAgICAgICAgICAgKiAgICAgICAgICAgICAgICAgICAgID8gdHJhbnNmZXJhYmxlcy5maWx0ZXIoKHRyYW5zZmVyYWJsZSkgPT4gIXRoaXMuX19idWZmZXJzLmhhcyh0cmFuc2ZlcmFibGUpKVxuICAgICAgICAgICAqICAgICAgICAgICAgICAgICAgICAgOiB0cmFuc2ZlcmFibGVzO1xuICAgICAgICAgICAqXG4gICAgICAgICAgICogICAgICAgICAgICAgICAgIHJldHVybiBwb3N0TWVzc2FnZS5jYWxsKHRoaXMucG9ydCwgbWVzc2FnZSwgZmlsdGVyZWRUcmFuc2ZlcmFibGVzKTtcbiAgICAgICAgICAgKiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgKiAgICAgICAgIH0pKHRoaXMucG9ydC5wb3N0TWVzc2FnZSk7XG4gICAgICAgICAgICogICAgIH1cbiAgICAgICAgICAgKiB9XG4gICAgICAgICAgICogYGBgXG4gICAgICAgICAgICovXG4gICAgICAgICAgdmFyIHBhdGNoZWRBdWRpb1dvcmtsZXRQcm9jZXNzb3IgPSBpc1N1cHBvcnRpbmdQb3N0TWVzc2FnZSA/ICdBdWRpb1dvcmtsZXRQcm9jZXNzb3InIDogJ2NsYXNzIGV4dGVuZHMgQXVkaW9Xb3JrbGV0UHJvY2Vzc29yIHtfX2I9bmV3IFdlYWtTZXQoKTtjb25zdHJ1Y3Rvcigpe3N1cGVyKCk7KHA9PnAucG9zdE1lc3NhZ2U9KHE9PihtLHQpPT5xLmNhbGwocCxtLHQ/dC5maWx0ZXIodT0+IXRoaXMuX19iLmhhcyh1KSk6dCkpKHAucG9zdE1lc3NhZ2UpKSh0aGlzLnBvcnQpfX0nO1xuICAgICAgICAgIC8qXG4gICAgICAgICAgICogQnVnICMxNzA6IENocm9tZSBhbmQgRWRnZSBkbyBjYWxsIHByb2Nlc3MoKSB3aXRoIGFuIGFycmF5IHdpdGggZW1wdHkgY2hhbm5lbERhdGEgZm9yIGVhY2ggaW5wdXQgaWYgbm8gaW5wdXQgaXMgY29ubmVjdGVkLlxuICAgICAgICAgICAqXG4gICAgICAgICAgICogQnVnICMxNzk6IEZpcmVmb3ggZG9lcyBub3QgYWxsb3cgdG8gdHJhbnNmZXIgYW55IGJ1ZmZlciB3aGljaCBoYXMgYmVlbiBwYXNzZWQgdG8gdGhlIHByb2Nlc3MoKSBtZXRob2QgYXMgYW4gYXJndW1lbnQuXG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiBCdWcgIzE5MDogU2FmYXJpIGRvZXNuJ3QgdGhyb3cgYW4gZXJyb3Igd2hlbiBsb2FkaW5nIGFuIHVucGFyc2FibGUgbW9kdWxlLlxuICAgICAgICAgICAqXG4gICAgICAgICAgICogVGhpcyBpcyB0aGUgdW5taW5pZmllZCB2ZXJzaW9uIG9mIHRoZSBjb2RlIHVzZWQgYmVsb3c6XG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiBgYGBqc1xuICAgICAgICAgICAqIGAkeyBpbXBvcnRTdGF0ZW1lbnRzIH07XG4gICAgICAgICAgICogKChBdWRpb1dvcmtsZXRQcm9jZXNzb3IsIHJlZ2lzdGVyUHJvY2Vzc29yKSA9PiB7JHsgc291cmNlV2l0aG91dEltcG9ydFN0YXRlbWVudHMgfVxuICAgICAgICAgICAqIH0pKFxuICAgICAgICAgICAqICAgICAke8KgcGF0Y2hlZEF1ZGlvV29ya2xldFByb2Nlc3NvciB9LFxuICAgICAgICAgICAqICAgICAobmFtZSwgcHJvY2Vzc29yQ3RvcikgPT4gcmVnaXN0ZXJQcm9jZXNzb3IobmFtZSwgY2xhc3MgZXh0ZW5kcyBwcm9jZXNzb3JDdG9yIHtcbiAgICAgICAgICAgKlxuICAgICAgICAgICAqICAgICAgICAgX19jb2xsZWN0QnVmZmVycyA9IChhcnJheSkgPT4ge1xuICAgICAgICAgICAqICAgICAgICAgICAgIGFycmF5LmZvckVhY2goKGVsZW1lbnQpID0+IHRoaXMuX19idWZmZXJzLmFkZChlbGVtZW50LmJ1ZmZlcikpO1xuICAgICAgICAgICAqICAgICAgICAgfTtcbiAgICAgICAgICAgKlxuICAgICAgICAgICAqICAgICAgICAgcHJvY2VzcyAoaW5wdXRzLCBvdXRwdXRzLCBwYXJhbWV0ZXJzKSB7XG4gICAgICAgICAgICogICAgICAgICAgICAgaW5wdXRzLmZvckVhY2godGhpcy5fX2NvbGxlY3RCdWZmZXJzKTtcbiAgICAgICAgICAgKiAgICAgICAgICAgICBvdXRwdXRzLmZvckVhY2godGhpcy5fX2NvbGxlY3RCdWZmZXJzKTtcbiAgICAgICAgICAgKiAgICAgICAgICAgICB0aGlzLl9fY29sbGVjdEJ1ZmZlcnMoT2JqZWN0LnZhbHVlcyhwYXJhbWV0ZXJzKSk7XG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiAgICAgICAgICAgICByZXR1cm4gc3VwZXIucHJvY2VzcyhcbiAgICAgICAgICAgKiAgICAgICAgICAgICAgICAgKGlucHV0cy5tYXAoKGlucHV0KSA9PiBpbnB1dC5zb21lKChjaGFubmVsRGF0YSkgPT4gY2hhbm5lbERhdGEubGVuZ3RoID09PSAwKSkgPyBbIF0gOiBpbnB1dCksXG4gICAgICAgICAgICogICAgICAgICAgICAgICAgIG91dHB1dHMsXG4gICAgICAgICAgICogICAgICAgICAgICAgICAgIHBhcmFtZXRlcnNcbiAgICAgICAgICAgKiAgICAgICAgICAgICApO1xuICAgICAgICAgICAqICAgICAgICAgfVxuICAgICAgICAgICAqXG4gICAgICAgICAgICogICAgIH0pXG4gICAgICAgICAgICogKTtcbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIHJlZ2lzdGVyUHJvY2Vzc29yKGBfX3NhYyR7Y3VycmVudEluZGV4fWAsIGNsYXNzIGV4dGVuZHMgQXVkaW9Xb3JrbGV0UHJvY2Vzc29ye1xuICAgICAgICAgICAqXG4gICAgICAgICAgICogICAgIHByb2Nlc3MgKCkge1xuICAgICAgICAgICAqICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAqICAgICB9XG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiB9KWBcbiAgICAgICAgICAgKiBgYGBcbiAgICAgICAgICAgKi9cbiAgICAgICAgICB2YXIgbWVtYmVyRGVmaW5pdGlvbiA9IGlzU3VwcG9ydGluZ1Bvc3RNZXNzYWdlID8gJycgOiAnX19jID0gKGEpID0+IGEuZm9yRWFjaChlPT50aGlzLl9fYi5hZGQoZS5idWZmZXIpKTsnO1xuICAgICAgICAgIHZhciBidWZmZXJSZWdpc3RyYXRpb24gPSBpc1N1cHBvcnRpbmdQb3N0TWVzc2FnZSA/ICcnIDogJ2kuZm9yRWFjaCh0aGlzLl9fYyk7by5mb3JFYWNoKHRoaXMuX19jKTt0aGlzLl9fYyhPYmplY3QudmFsdWVzKHApKTsnO1xuICAgICAgICAgIHZhciB3cmFwcGVkU291cmNlID0gXCJcIi5jb25jYXQoaW1wb3J0U3RhdGVtZW50cywgXCI7KChBdWRpb1dvcmtsZXRQcm9jZXNzb3IscmVnaXN0ZXJQcm9jZXNzb3IpPT57XCIpLmNvbmNhdChzb3VyY2VXaXRob3V0SW1wb3J0U3RhdGVtZW50cywgXCJcXG59KShcIikuY29uY2F0KHBhdGNoZWRBdWRpb1dvcmtsZXRQcm9jZXNzb3IsIFwiLChuLHApPT5yZWdpc3RlclByb2Nlc3NvcihuLGNsYXNzIGV4dGVuZHMgcHtcIikuY29uY2F0KG1lbWJlckRlZmluaXRpb24sIFwicHJvY2VzcyhpLG8scCl7XCIpLmNvbmNhdChidWZmZXJSZWdpc3RyYXRpb24sIFwicmV0dXJuIHN1cGVyLnByb2Nlc3MoaS5tYXAoaj0+ai5zb21lKGs9PmsubGVuZ3RoPT09MCk/W106aiksbyxwKX19KSk7cmVnaXN0ZXJQcm9jZXNzb3IoJ19fc2FjXCIpLmNvbmNhdChjdXJyZW50SW5kZXgsIFwiJyxjbGFzcyBleHRlbmRzIEF1ZGlvV29ya2xldFByb2Nlc3Nvcntwcm9jZXNzKCl7cmV0dXJuICExfX0pXCIpO1xuICAgICAgICAgIHZhciBibG9iID0gbmV3IEJsb2IoW3dyYXBwZWRTb3VyY2VdLCB7XG4gICAgICAgICAgICB0eXBlOiAnYXBwbGljYXRpb24vamF2YXNjcmlwdDsgY2hhcnNldD11dGYtOCdcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YXIgdXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcbiAgICAgICAgICByZXR1cm4gbmF0aXZlQ29udGV4dC5hdWRpb1dvcmtsZXQuYWRkTW9kdWxlKHVybCwgb3B0aW9ucykudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoaXNOYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KG5hdGl2ZUNvbnRleHQpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBuYXRpdmVDb250ZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQnVnICMxODY6IENocm9tZSBhbmQgRWRnZSBkbyBub3QgYWxsb3cgdG8gY3JlYXRlIGFuIEF1ZGlvV29ya2xldE5vZGUgb24gYSBjbG9zZWQgQXVkaW9Db250ZXh0LlxuICAgICAgICAgICAgdmFyIGJhY2t1cE9mZmxpbmVBdWRpb0NvbnRleHQgPSBnZXRPckNyZWF0ZUJhY2t1cE9mZmxpbmVBdWRpb0NvbnRleHQobmF0aXZlQ29udGV4dCk7XG4gICAgICAgICAgICByZXR1cm4gYmFja3VwT2ZmbGluZUF1ZGlvQ29udGV4dC5hdWRpb1dvcmtsZXQuYWRkTW9kdWxlKHVybCwgb3B0aW9ucykudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBiYWNrdXBPZmZsaW5lQXVkaW9Db250ZXh0O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAobmF0aXZlQ29udGV4dE9yQmFja3VwT2ZmbGluZUF1ZGlvQ29udGV4dCkge1xuICAgICAgICAgICAgaWYgKG5hdGl2ZUF1ZGlvV29ya2xldE5vZGVDb25zdHJ1Y3RvciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIC8vIEJ1ZyAjMTkwOiBTYWZhcmkgZG9lc24ndCB0aHJvdyBhbiBlcnJvciB3aGVuIGxvYWRpbmcgYW4gdW5wYXJzYWJsZSBtb2R1bGUuXG4gICAgICAgICAgICAgIG5ldyBuYXRpdmVBdWRpb1dvcmtsZXROb2RlQ29uc3RydWN0b3IobmF0aXZlQ29udGV4dE9yQmFja3VwT2ZmbGluZUF1ZGlvQ29udGV4dCwgXCJfX3NhY1wiLmNvbmNhdChjdXJyZW50SW5kZXgpKTsgLy8gdHNsaW50OmRpc2FibGUtbGluZTpuby11bnVzZWQtZXhwcmVzc2lvblxuICAgICAgICAgICAgfSBjYXRjaCAoX3VudXNlZCkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVtcImZpbmFsbHlcIl0oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIFVSTC5yZXZva2VPYmplY3RVUkwodXJsKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChvbmdvaW5nUmVxdWVzdHNPZkNvbnRleHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIG9uZ29pbmdSZXF1ZXN0cy5zZXQoY29udGV4dCwgbmV3IE1hcChbW21vZHVsZVVSTCwgcHJvbWlzZV1dKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb25nb2luZ1JlcXVlc3RzT2ZDb250ZXh0LnNldChtb2R1bGVVUkwsIHByb21pc2UpO1xuICAgICAgICB9XG4gICAgICAgIHByb21pc2UudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIHVwZGF0ZWRSZXNvbHZlZFJlcXVlc3RzT2ZDb250ZXh0ID0gcmVzb2x2ZWRSZXF1ZXN0cy5nZXQoY29udGV4dCk7XG4gICAgICAgICAgaWYgKHVwZGF0ZWRSZXNvbHZlZFJlcXVlc3RzT2ZDb250ZXh0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlc29sdmVkUmVxdWVzdHMuc2V0KGNvbnRleHQsIG5ldyBTZXQoW21vZHVsZVVSTF0pKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdXBkYXRlZFJlc29sdmVkUmVxdWVzdHNPZkNvbnRleHQuYWRkKG1vZHVsZVVSTCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KVtcImZpbmFsbHlcIl0oZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciB1cGRhdGVkT25nb2luZ1JlcXVlc3RzT2ZDb250ZXh0ID0gb25nb2luZ1JlcXVlc3RzLmdldChjb250ZXh0KTtcbiAgICAgICAgICBpZiAodXBkYXRlZE9uZ29pbmdSZXF1ZXN0c09mQ29udGV4dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB1cGRhdGVkT25nb2luZ1JlcXVlc3RzT2ZDb250ZXh0W1wiZGVsZXRlXCJdKG1vZHVsZVVSTCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgZ2V0VmFsdWVGb3JLZXkgPSBmdW5jdGlvbiBnZXRWYWx1ZUZvcktleShtYXAsIGtleSkge1xuICAgICAgdmFyIHZhbHVlID0gbWFwLmdldChrZXkpO1xuICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBIHZhbHVlIHdpdGggdGhlIGdpdmVuIGtleSBjb3VsZCBub3QgYmUgZm91bmQuJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcblxuICAgIHZhciBwaWNrRWxlbWVudEZyb21TZXQgPSBmdW5jdGlvbiBwaWNrRWxlbWVudEZyb21TZXQoc2V0LCBwcmVkaWNhdGUpIHtcbiAgICAgIHZhciBtYXRjaGluZ0VsZW1lbnRzID0gQXJyYXkuZnJvbShzZXQpLmZpbHRlcihwcmVkaWNhdGUpO1xuICAgICAgaWYgKG1hdGNoaW5nRWxlbWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICB0aHJvdyBFcnJvcignTW9yZSB0aGFuIG9uZSBlbGVtZW50IHdhcyBmb3VuZC4nKTtcbiAgICAgIH1cbiAgICAgIGlmIChtYXRjaGluZ0VsZW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBFcnJvcignTm8gZWxlbWVudCB3YXMgZm91bmQuJyk7XG4gICAgICB9XG4gICAgICB2YXIgX21hdGNoaW5nRWxlbWVudHMgPSBfc2xpY2VkVG9BcnJheShtYXRjaGluZ0VsZW1lbnRzLCAxKSxcbiAgICAgICAgbWF0Y2hpbmdFbGVtZW50ID0gX21hdGNoaW5nRWxlbWVudHNbMF07XG4gICAgICBzZXRbXCJkZWxldGVcIl0obWF0Y2hpbmdFbGVtZW50KTtcbiAgICAgIHJldHVybiBtYXRjaGluZ0VsZW1lbnQ7XG4gICAgfTtcblxuICAgIHZhciBkZWxldGVQYXNzaXZlSW5wdXRDb25uZWN0aW9uVG9BdWRpb05vZGUgPSBmdW5jdGlvbiBkZWxldGVQYXNzaXZlSW5wdXRDb25uZWN0aW9uVG9BdWRpb05vZGUocGFzc2l2ZUlucHV0cywgc291cmNlLCBvdXRwdXQsIGlucHV0KSB7XG4gICAgICB2YXIgcGFzc2l2ZUlucHV0Q29ubmVjdGlvbnMgPSBnZXRWYWx1ZUZvcktleShwYXNzaXZlSW5wdXRzLCBzb3VyY2UpO1xuICAgICAgdmFyIG1hdGNoaW5nQ29ubmVjdGlvbiA9IHBpY2tFbGVtZW50RnJvbVNldChwYXNzaXZlSW5wdXRDb25uZWN0aW9ucywgZnVuY3Rpb24gKHBhc3NpdmVJbnB1dENvbm5lY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIHBhc3NpdmVJbnB1dENvbm5lY3Rpb25bMF0gPT09IG91dHB1dCAmJiBwYXNzaXZlSW5wdXRDb25uZWN0aW9uWzFdID09PSBpbnB1dDtcbiAgICAgIH0pO1xuICAgICAgaWYgKHBhc3NpdmVJbnB1dENvbm5lY3Rpb25zLnNpemUgPT09IDApIHtcbiAgICAgICAgcGFzc2l2ZUlucHV0c1tcImRlbGV0ZVwiXShzb3VyY2UpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1hdGNoaW5nQ29ubmVjdGlvbjtcbiAgICB9O1xuXG4gICAgdmFyIGdldEV2ZW50TGlzdGVuZXJzT2ZBdWRpb05vZGUgPSBmdW5jdGlvbiBnZXRFdmVudExpc3RlbmVyc09mQXVkaW9Ob2RlKGF1ZGlvTm9kZSkge1xuICAgICAgcmV0dXJuIGdldFZhbHVlRm9yS2V5KEVWRU5UX0xJU1RFTkVSUywgYXVkaW9Ob2RlKTtcbiAgICB9O1xuXG4gICAgdmFyIHNldEludGVybmFsU3RhdGVUb0FjdGl2ZSA9IGZ1bmN0aW9uIHNldEludGVybmFsU3RhdGVUb0FjdGl2ZShhdWRpb05vZGUpIHtcbiAgICAgIGlmIChBQ1RJVkVfQVVESU9fTk9ERV9TVE9SRS5oYXMoYXVkaW9Ob2RlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBBdWRpb05vZGUgaXMgYWxyZWFkeSBzdG9yZWQuJyk7XG4gICAgICB9XG4gICAgICBBQ1RJVkVfQVVESU9fTk9ERV9TVE9SRS5hZGQoYXVkaW9Ob2RlKTtcbiAgICAgIGdldEV2ZW50TGlzdGVuZXJzT2ZBdWRpb05vZGUoYXVkaW9Ob2RlKS5mb3JFYWNoKGZ1bmN0aW9uIChldmVudExpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiBldmVudExpc3RlbmVyKHRydWUpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHZhciBpc0F1ZGlvV29ya2xldE5vZGUgPSBmdW5jdGlvbiBpc0F1ZGlvV29ya2xldE5vZGUoYXVkaW9Ob2RlKSB7XG4gICAgICByZXR1cm4gJ3BvcnQnIGluIGF1ZGlvTm9kZTtcbiAgICB9O1xuXG4gICAgdmFyIHNldEludGVybmFsU3RhdGVUb1Bhc3NpdmUgPSBmdW5jdGlvbiBzZXRJbnRlcm5hbFN0YXRlVG9QYXNzaXZlKGF1ZGlvTm9kZSkge1xuICAgICAgaWYgKCFBQ1RJVkVfQVVESU9fTk9ERV9TVE9SRS5oYXMoYXVkaW9Ob2RlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBBdWRpb05vZGUgaXMgbm90IHN0b3JlZC4nKTtcbiAgICAgIH1cbiAgICAgIEFDVElWRV9BVURJT19OT0RFX1NUT1JFW1wiZGVsZXRlXCJdKGF1ZGlvTm9kZSk7XG4gICAgICBnZXRFdmVudExpc3RlbmVyc09mQXVkaW9Ob2RlKGF1ZGlvTm9kZSkuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnRMaXN0ZW5lcikge1xuICAgICAgICByZXR1cm4gZXZlbnRMaXN0ZW5lcihmYWxzZSk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgLy8gU2V0IHRoZSBpbnRlcm5hbFN0YXRlIG9mIHRoZSBhdWRpb05vZGUgdG8gJ3Bhc3NpdmUnIGlmIGl0IGlzIG5vdCBhbiBBdWRpb1dvcmtsZXROb2RlIGFuZCBpZiBpdCBoYXMgbm8gJ2FjdGl2ZScgaW5wdXQgY29ubmVjdGlvbnMuXG4gICAgdmFyIHNldEludGVybmFsU3RhdGVUb1Bhc3NpdmVXaGVuTmVjZXNzYXJ5ID0gZnVuY3Rpb24gc2V0SW50ZXJuYWxTdGF0ZVRvUGFzc2l2ZVdoZW5OZWNlc3NhcnkoYXVkaW9Ob2RlLCBhY3RpdmVJbnB1dHMpIHtcbiAgICAgIGlmICghaXNBdWRpb1dvcmtsZXROb2RlKGF1ZGlvTm9kZSkgJiYgYWN0aXZlSW5wdXRzLmV2ZXJ5KGZ1bmN0aW9uIChjb25uZWN0aW9ucykge1xuICAgICAgICByZXR1cm4gY29ubmVjdGlvbnMuc2l6ZSA9PT0gMDtcbiAgICAgIH0pKSB7XG4gICAgICAgIHNldEludGVybmFsU3RhdGVUb1Bhc3NpdmUoYXVkaW9Ob2RlKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZUFkZENvbm5lY3Rpb25Ub0F1ZGlvTm9kZSA9IGZ1bmN0aW9uIGNyZWF0ZUFkZENvbm5lY3Rpb25Ub0F1ZGlvTm9kZShhZGRBY3RpdmVJbnB1dENvbm5lY3Rpb25Ub0F1ZGlvTm9kZSwgYWRkUGFzc2l2ZUlucHV0Q29ubmVjdGlvblRvQXVkaW9Ob2RlLCBjb25uZWN0TmF0aXZlQXVkaW9Ob2RlVG9OYXRpdmVBdWRpb05vZGUsIGRlbGV0ZUFjdGl2ZUlucHV0Q29ubmVjdGlvblRvQXVkaW9Ob2RlLCBkaXNjb25uZWN0TmF0aXZlQXVkaW9Ob2RlRnJvbU5hdGl2ZUF1ZGlvTm9kZSwgZ2V0QXVkaW9Ob2RlQ29ubmVjdGlvbnMsIGdldEF1ZGlvTm9kZVRhaWxUaW1lLCBnZXRFdmVudExpc3RlbmVyc09mQXVkaW9Ob2RlLCBnZXROYXRpdmVBdWRpb05vZGUsIGluc2VydEVsZW1lbnRJblNldCwgaXNBY3RpdmVBdWRpb05vZGUsIGlzUGFydE9mQUN5Y2xlLCBpc1Bhc3NpdmVBdWRpb05vZGUpIHtcbiAgICAgIHZhciB0YWlsVGltZVRpbWVvdXRJZHMgPSBuZXcgV2Vha01hcCgpO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChzb3VyY2UsIGRlc3RpbmF0aW9uLCBvdXRwdXQsIGlucHV0LCBpc09mZmxpbmUpIHtcbiAgICAgICAgdmFyIF9nZXRBdWRpb05vZGVDb25uZWN0aSA9IGdldEF1ZGlvTm9kZUNvbm5lY3Rpb25zKGRlc3RpbmF0aW9uKSxcbiAgICAgICAgICBhY3RpdmVJbnB1dHMgPSBfZ2V0QXVkaW9Ob2RlQ29ubmVjdGkuYWN0aXZlSW5wdXRzLFxuICAgICAgICAgIHBhc3NpdmVJbnB1dHMgPSBfZ2V0QXVkaW9Ob2RlQ29ubmVjdGkucGFzc2l2ZUlucHV0cztcbiAgICAgICAgdmFyIF9nZXRBdWRpb05vZGVDb25uZWN0aTIgPSBnZXRBdWRpb05vZGVDb25uZWN0aW9ucyhzb3VyY2UpLFxuICAgICAgICAgIG91dHB1dHMgPSBfZ2V0QXVkaW9Ob2RlQ29ubmVjdGkyLm91dHB1dHM7XG4gICAgICAgIHZhciBldmVudExpc3RlbmVycyA9IGdldEV2ZW50TGlzdGVuZXJzT2ZBdWRpb05vZGUoc291cmNlKTtcbiAgICAgICAgdmFyIGV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiBldmVudExpc3RlbmVyKGlzQWN0aXZlKSB7XG4gICAgICAgICAgdmFyIG5hdGl2ZURlc3RpbmF0aW9uQXVkaW9Ob2RlID0gZ2V0TmF0aXZlQXVkaW9Ob2RlKGRlc3RpbmF0aW9uKTtcbiAgICAgICAgICB2YXIgbmF0aXZlU291cmNlQXVkaW9Ob2RlID0gZ2V0TmF0aXZlQXVkaW9Ob2RlKHNvdXJjZSk7XG4gICAgICAgICAgaWYgKGlzQWN0aXZlKSB7XG4gICAgICAgICAgICB2YXIgcGFydGlhbENvbm5lY3Rpb24gPSBkZWxldGVQYXNzaXZlSW5wdXRDb25uZWN0aW9uVG9BdWRpb05vZGUocGFzc2l2ZUlucHV0cywgc291cmNlLCBvdXRwdXQsIGlucHV0KTtcbiAgICAgICAgICAgIGFkZEFjdGl2ZUlucHV0Q29ubmVjdGlvblRvQXVkaW9Ob2RlKGFjdGl2ZUlucHV0cywgc291cmNlLCBwYXJ0aWFsQ29ubmVjdGlvbiwgZmFsc2UpO1xuICAgICAgICAgICAgaWYgKCFpc09mZmxpbmUgJiYgIWlzUGFydE9mQUN5Y2xlKHNvdXJjZSkpIHtcbiAgICAgICAgICAgICAgY29ubmVjdE5hdGl2ZUF1ZGlvTm9kZVRvTmF0aXZlQXVkaW9Ob2RlKG5hdGl2ZVNvdXJjZUF1ZGlvTm9kZSwgbmF0aXZlRGVzdGluYXRpb25BdWRpb05vZGUsIG91dHB1dCwgaW5wdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzUGFzc2l2ZUF1ZGlvTm9kZShkZXN0aW5hdGlvbikpIHtcbiAgICAgICAgICAgICAgc2V0SW50ZXJuYWxTdGF0ZVRvQWN0aXZlKGRlc3RpbmF0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIF9wYXJ0aWFsQ29ubmVjdGlvbiA9IGRlbGV0ZUFjdGl2ZUlucHV0Q29ubmVjdGlvblRvQXVkaW9Ob2RlKGFjdGl2ZUlucHV0cywgc291cmNlLCBvdXRwdXQsIGlucHV0KTtcbiAgICAgICAgICAgIGFkZFBhc3NpdmVJbnB1dENvbm5lY3Rpb25Ub0F1ZGlvTm9kZShwYXNzaXZlSW5wdXRzLCBpbnB1dCwgX3BhcnRpYWxDb25uZWN0aW9uLCBmYWxzZSk7XG4gICAgICAgICAgICBpZiAoIWlzT2ZmbGluZSAmJiAhaXNQYXJ0T2ZBQ3ljbGUoc291cmNlKSkge1xuICAgICAgICAgICAgICBkaXNjb25uZWN0TmF0aXZlQXVkaW9Ob2RlRnJvbU5hdGl2ZUF1ZGlvTm9kZShuYXRpdmVTb3VyY2VBdWRpb05vZGUsIG5hdGl2ZURlc3RpbmF0aW9uQXVkaW9Ob2RlLCBvdXRwdXQsIGlucHV0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB0YWlsVGltZSA9IGdldEF1ZGlvTm9kZVRhaWxUaW1lKGRlc3RpbmF0aW9uKTtcbiAgICAgICAgICAgIGlmICh0YWlsVGltZSA9PT0gMCkge1xuICAgICAgICAgICAgICBpZiAoaXNBY3RpdmVBdWRpb05vZGUoZGVzdGluYXRpb24pKSB7XG4gICAgICAgICAgICAgICAgc2V0SW50ZXJuYWxTdGF0ZVRvUGFzc2l2ZVdoZW5OZWNlc3NhcnkoZGVzdGluYXRpb24sIGFjdGl2ZUlucHV0cyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhciB0YWlsVGltZVRpbWVvdXRJZCA9IHRhaWxUaW1lVGltZW91dElkcy5nZXQoZGVzdGluYXRpb24pO1xuICAgICAgICAgICAgICBpZiAodGFpbFRpbWVUaW1lb3V0SWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0YWlsVGltZVRpbWVvdXRJZCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGFpbFRpbWVUaW1lb3V0SWRzLnNldChkZXN0aW5hdGlvbiwgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzQWN0aXZlQXVkaW9Ob2RlKGRlc3RpbmF0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgc2V0SW50ZXJuYWxTdGF0ZVRvUGFzc2l2ZVdoZW5OZWNlc3NhcnkoZGVzdGluYXRpb24sIGFjdGl2ZUlucHV0cyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9LCB0YWlsVGltZSAqIDEwMDApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGlmIChpbnNlcnRFbGVtZW50SW5TZXQob3V0cHV0cywgW2Rlc3RpbmF0aW9uLCBvdXRwdXQsIGlucHV0XSwgZnVuY3Rpb24gKG91dHB1dENvbm5lY3Rpb24pIHtcbiAgICAgICAgICByZXR1cm4gb3V0cHV0Q29ubmVjdGlvblswXSA9PT0gZGVzdGluYXRpb24gJiYgb3V0cHV0Q29ubmVjdGlvblsxXSA9PT0gb3V0cHV0ICYmIG91dHB1dENvbm5lY3Rpb25bMl0gPT09IGlucHV0O1xuICAgICAgICB9LCB0cnVlKSkge1xuICAgICAgICAgIGV2ZW50TGlzdGVuZXJzLmFkZChldmVudExpc3RlbmVyKTtcbiAgICAgICAgICBpZiAoaXNBY3RpdmVBdWRpb05vZGUoc291cmNlKSkge1xuICAgICAgICAgICAgYWRkQWN0aXZlSW5wdXRDb25uZWN0aW9uVG9BdWRpb05vZGUoYWN0aXZlSW5wdXRzLCBzb3VyY2UsIFtvdXRwdXQsIGlucHV0LCBldmVudExpc3RlbmVyXSwgdHJ1ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFkZFBhc3NpdmVJbnB1dENvbm5lY3Rpb25Ub0F1ZGlvTm9kZShwYXNzaXZlSW5wdXRzLCBpbnB1dCwgW3NvdXJjZSwgb3V0cHV0LCBldmVudExpc3RlbmVyXSwgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVBZGRQYXNzaXZlSW5wdXRDb25uZWN0aW9uVG9BdWRpb05vZGUgPSBmdW5jdGlvbiBjcmVhdGVBZGRQYXNzaXZlSW5wdXRDb25uZWN0aW9uVG9BdWRpb05vZGUoaW5zZXJ0RWxlbWVudEluU2V0KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKHBhc3NpdmVJbnB1dHMsIGlucHV0LCBfcmVmLCBpZ25vcmVEdXBsaWNhdGVzKSB7XG4gICAgICAgIHZhciBfcmVmMiA9IF9zbGljZWRUb0FycmF5KF9yZWYsIDMpLFxuICAgICAgICAgIHNvdXJjZSA9IF9yZWYyWzBdLFxuICAgICAgICAgIG91dHB1dCA9IF9yZWYyWzFdLFxuICAgICAgICAgIGV2ZW50TGlzdGVuZXIgPSBfcmVmMlsyXTtcbiAgICAgICAgdmFyIHBhc3NpdmVJbnB1dENvbm5lY3Rpb25zID0gcGFzc2l2ZUlucHV0cy5nZXQoc291cmNlKTtcbiAgICAgICAgaWYgKHBhc3NpdmVJbnB1dENvbm5lY3Rpb25zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBwYXNzaXZlSW5wdXRzLnNldChzb3VyY2UsIG5ldyBTZXQoW1tvdXRwdXQsIGlucHV0LCBldmVudExpc3RlbmVyXV0pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbnNlcnRFbGVtZW50SW5TZXQocGFzc2l2ZUlucHV0Q29ubmVjdGlvbnMsIFtvdXRwdXQsIGlucHV0LCBldmVudExpc3RlbmVyXSwgZnVuY3Rpb24gKHBhc3NpdmVJbnB1dENvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgIHJldHVybiBwYXNzaXZlSW5wdXRDb25uZWN0aW9uWzBdID09PSBvdXRwdXQgJiYgcGFzc2l2ZUlucHV0Q29ubmVjdGlvblsxXSA9PT0gaW5wdXQ7XG4gICAgICAgICAgfSwgaWdub3JlRHVwbGljYXRlcyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVBZGRTaWxlbnRDb25uZWN0aW9uID0gZnVuY3Rpb24gY3JlYXRlQWRkU2lsZW50Q29ubmVjdGlvbihjcmVhdGVOYXRpdmVHYWluTm9kZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChuYXRpdmVDb250ZXh0LCBuYXRpdmVBdWRpb1NjaGVkdWxlZFNvdXJjZU5vZGUpIHtcbiAgICAgICAgdmFyIG5hdGl2ZUdhaW5Ob2RlID0gY3JlYXRlTmF0aXZlR2Fpbk5vZGUobmF0aXZlQ29udGV4dCwge1xuICAgICAgICAgIGNoYW5uZWxDb3VudDogMSxcbiAgICAgICAgICBjaGFubmVsQ291bnRNb2RlOiAnZXhwbGljaXQnLFxuICAgICAgICAgIGNoYW5uZWxJbnRlcnByZXRhdGlvbjogJ2Rpc2NyZXRlJyxcbiAgICAgICAgICBnYWluOiAwXG4gICAgICAgIH0pO1xuICAgICAgICBuYXRpdmVBdWRpb1NjaGVkdWxlZFNvdXJjZU5vZGUuY29ubmVjdChuYXRpdmVHYWluTm9kZSkuY29ubmVjdChuYXRpdmVDb250ZXh0LmRlc3RpbmF0aW9uKTtcbiAgICAgICAgdmFyIF9kaXNjb25uZWN0ID0gZnVuY3Rpb24gZGlzY29ubmVjdCgpIHtcbiAgICAgICAgICBuYXRpdmVBdWRpb1NjaGVkdWxlZFNvdXJjZU5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcignZW5kZWQnLCBfZGlzY29ubmVjdCk7XG4gICAgICAgICAgbmF0aXZlQXVkaW9TY2hlZHVsZWRTb3VyY2VOb2RlLmRpc2Nvbm5lY3QobmF0aXZlR2Fpbk5vZGUpO1xuICAgICAgICAgIG5hdGl2ZUdhaW5Ob2RlLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgfTtcbiAgICAgICAgbmF0aXZlQXVkaW9TY2hlZHVsZWRTb3VyY2VOb2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2VuZGVkJywgX2Rpc2Nvbm5lY3QpO1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZUFkZFVucmVuZGVyZWRBdWRpb1dvcmtsZXROb2RlID0gZnVuY3Rpb24gY3JlYXRlQWRkVW5yZW5kZXJlZEF1ZGlvV29ya2xldE5vZGUoZ2V0VW5yZW5kZXJlZEF1ZGlvV29ya2xldE5vZGVzKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKG5hdGl2ZUNvbnRleHQsIGF1ZGlvV29ya2xldE5vZGUpIHtcbiAgICAgICAgZ2V0VW5yZW5kZXJlZEF1ZGlvV29ya2xldE5vZGVzKG5hdGl2ZUNvbnRleHQpLmFkZChhdWRpb1dvcmtsZXROb2RlKTtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIG93bktleXMkdyhlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XG4gICAgZnVuY3Rpb24gX29iamVjdFNwcmVhZCR3KGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMkdyhPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMkdyhPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxuICAgIGZ1bmN0aW9uIF9jYWxsU3VwZXIkcih0LCBvLCBlKSB7IHJldHVybiBvID0gX2dldFByb3RvdHlwZU9mKG8pLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0LCBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JHIoKSA/IFJlZmxlY3QuY29uc3RydWN0KG8sIGUgfHwgW10sIF9nZXRQcm90b3R5cGVPZih0KS5jb25zdHJ1Y3RvcikgOiBvLmFwcGx5KHQsIGUpKTsgfVxuICAgIGZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkcigpIHsgdHJ5IHsgdmFyIHQgPSAhQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyB9IGNhdGNoICh0KSB7fSByZXR1cm4gKF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkciA9IGZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IHJldHVybiAhIXQ7IH0pKCk7IH1cbiAgICB2YXIgREVGQVVMVF9PUFRJT05TJGsgPSB7XG4gICAgICBjaGFubmVsQ291bnQ6IDIsXG4gICAgICBjaGFubmVsQ291bnRNb2RlOiAnbWF4JyxcbiAgICAgIGNoYW5uZWxJbnRlcnByZXRhdGlvbjogJ3NwZWFrZXJzJyxcbiAgICAgIGZmdFNpemU6IDIwNDgsXG4gICAgICBtYXhEZWNpYmVsczogLTMwLFxuICAgICAgbWluRGVjaWJlbHM6IC0xMDAsXG4gICAgICBzbW9vdGhpbmdUaW1lQ29uc3RhbnQ6IDAuOFxuICAgIH07XG4gICAgdmFyIGNyZWF0ZUFuYWx5c2VyTm9kZUNvbnN0cnVjdG9yID0gZnVuY3Rpb24gY3JlYXRlQW5hbHlzZXJOb2RlQ29uc3RydWN0b3IoYXVkaW9uTm9kZUNvbnN0cnVjdG9yLCBjcmVhdGVBbmFseXNlck5vZGVSZW5kZXJlciwgY3JlYXRlSW5kZXhTaXplRXJyb3IsIGNyZWF0ZU5hdGl2ZUFuYWx5c2VyTm9kZSwgZ2V0TmF0aXZlQ29udGV4dCwgaXNOYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KSB7XG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfYXVkaW9uTm9kZUNvbnN0cnVjdG8pIHtcbiAgICAgICAgZnVuY3Rpb24gQW5hbHlzZXJOb2RlKGNvbnRleHQsIG9wdGlvbnMpIHtcbiAgICAgICAgICB2YXIgX3RoaXM7XG4gICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEFuYWx5c2VyTm9kZSk7XG4gICAgICAgICAgdmFyIG5hdGl2ZUNvbnRleHQgPSBnZXROYXRpdmVDb250ZXh0KGNvbnRleHQpO1xuICAgICAgICAgIHZhciBtZXJnZWRPcHRpb25zID0gX29iamVjdFNwcmVhZCR3KF9vYmplY3RTcHJlYWQkdyh7fSwgREVGQVVMVF9PUFRJT05TJGspLCBvcHRpb25zKTtcbiAgICAgICAgICB2YXIgbmF0aXZlQW5hbHlzZXJOb2RlID0gY3JlYXRlTmF0aXZlQW5hbHlzZXJOb2RlKG5hdGl2ZUNvbnRleHQsIG1lcmdlZE9wdGlvbnMpO1xuICAgICAgICAgIHZhciBhbmFseXNlck5vZGVSZW5kZXJlciA9IGlzTmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dChuYXRpdmVDb250ZXh0KSA/IGNyZWF0ZUFuYWx5c2VyTm9kZVJlbmRlcmVyKCkgOiBudWxsO1xuICAgICAgICAgIF90aGlzID0gX2NhbGxTdXBlciRyKHRoaXMsIEFuYWx5c2VyTm9kZSwgW2NvbnRleHQsIGZhbHNlLCBuYXRpdmVBbmFseXNlck5vZGUsIGFuYWx5c2VyTm9kZVJlbmRlcmVyXSk7XG4gICAgICAgICAgX3RoaXMuX25hdGl2ZUFuYWx5c2VyTm9kZSA9IG5hdGl2ZUFuYWx5c2VyTm9kZTtcbiAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgIH1cbiAgICAgICAgX2luaGVyaXRzKEFuYWx5c2VyTm9kZSwgX2F1ZGlvbk5vZGVDb25zdHJ1Y3RvKTtcbiAgICAgICAgcmV0dXJuIF9jcmVhdGVDbGFzcyhBbmFseXNlck5vZGUsIFt7XG4gICAgICAgICAga2V5OiBcImZmdFNpemVcIixcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9uYXRpdmVBbmFseXNlck5vZGUuZmZ0U2l6ZTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9uYXRpdmVBbmFseXNlck5vZGUuZmZ0U2l6ZSA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIGtleTogXCJmcmVxdWVuY3lCaW5Db3VudFwiLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25hdGl2ZUFuYWx5c2VyTm9kZS5mcmVxdWVuY3lCaW5Db3VudDtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBrZXk6IFwibWF4RGVjaWJlbHNcIixcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9uYXRpdmVBbmFseXNlck5vZGUubWF4RGVjaWJlbHM7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICAgICAgLy8gQnVnICMxMTg6IFNhZmFyaSBkb2VzIG5vdCB0aHJvdyBhbiBlcnJvciBpZiBtYXhEZWNpYmVscyBpcyBub3QgbW9yZSB0aGFuIG1pbkRlY2liZWxzLlxuICAgICAgICAgICAgdmFyIG1heERlY2liZWxzID0gdGhpcy5fbmF0aXZlQW5hbHlzZXJOb2RlLm1heERlY2liZWxzO1xuICAgICAgICAgICAgdGhpcy5fbmF0aXZlQW5hbHlzZXJOb2RlLm1heERlY2liZWxzID0gdmFsdWU7XG4gICAgICAgICAgICBpZiAoISh2YWx1ZSA+IHRoaXMuX25hdGl2ZUFuYWx5c2VyTm9kZS5taW5EZWNpYmVscykpIHtcbiAgICAgICAgICAgICAgdGhpcy5fbmF0aXZlQW5hbHlzZXJOb2RlLm1heERlY2liZWxzID0gbWF4RGVjaWJlbHM7XG4gICAgICAgICAgICAgIHRocm93IGNyZWF0ZUluZGV4U2l6ZUVycm9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcIm1pbkRlY2liZWxzXCIsXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbmF0aXZlQW5hbHlzZXJOb2RlLm1pbkRlY2liZWxzO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgICAgIC8vIEJ1ZyAjMTE4OiBTYWZhcmkgZG9lcyBub3QgdGhyb3cgYW4gZXJyb3IgaWYgbWF4RGVjaWJlbHMgaXMgbm90IG1vcmUgdGhhbiBtaW5EZWNpYmVscy5cbiAgICAgICAgICAgIHZhciBtaW5EZWNpYmVscyA9IHRoaXMuX25hdGl2ZUFuYWx5c2VyTm9kZS5taW5EZWNpYmVscztcbiAgICAgICAgICAgIHRoaXMuX25hdGl2ZUFuYWx5c2VyTm9kZS5taW5EZWNpYmVscyA9IHZhbHVlO1xuICAgICAgICAgICAgaWYgKCEodGhpcy5fbmF0aXZlQW5hbHlzZXJOb2RlLm1heERlY2liZWxzID4gdmFsdWUpKSB7XG4gICAgICAgICAgICAgIHRoaXMuX25hdGl2ZUFuYWx5c2VyTm9kZS5taW5EZWNpYmVscyA9IG1pbkRlY2liZWxzO1xuICAgICAgICAgICAgICB0aHJvdyBjcmVhdGVJbmRleFNpemVFcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIGtleTogXCJzbW9vdGhpbmdUaW1lQ29uc3RhbnRcIixcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9uYXRpdmVBbmFseXNlck5vZGUuc21vb3RoaW5nVGltZUNvbnN0YW50O1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX25hdGl2ZUFuYWx5c2VyTm9kZS5zbW9vdGhpbmdUaW1lQ29uc3RhbnQgPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBrZXk6IFwiZ2V0Qnl0ZUZyZXF1ZW5jeURhdGFcIixcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Qnl0ZUZyZXF1ZW5jeURhdGEoYXJyYXkpIHtcbiAgICAgICAgICAgIHRoaXMuX25hdGl2ZUFuYWx5c2VyTm9kZS5nZXRCeXRlRnJlcXVlbmN5RGF0YShhcnJheSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcImdldEJ5dGVUaW1lRG9tYWluRGF0YVwiLFxuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRCeXRlVGltZURvbWFpbkRhdGEoYXJyYXkpIHtcbiAgICAgICAgICAgIHRoaXMuX25hdGl2ZUFuYWx5c2VyTm9kZS5nZXRCeXRlVGltZURvbWFpbkRhdGEoYXJyYXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIGtleTogXCJnZXRGbG9hdEZyZXF1ZW5jeURhdGFcIixcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RmxvYXRGcmVxdWVuY3lEYXRhKGFycmF5KSB7XG4gICAgICAgICAgICB0aGlzLl9uYXRpdmVBbmFseXNlck5vZGUuZ2V0RmxvYXRGcmVxdWVuY3lEYXRhKGFycmF5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBrZXk6IFwiZ2V0RmxvYXRUaW1lRG9tYWluRGF0YVwiLFxuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRGbG9hdFRpbWVEb21haW5EYXRhKGFycmF5KSB7XG4gICAgICAgICAgICB0aGlzLl9uYXRpdmVBbmFseXNlck5vZGUuZ2V0RmxvYXRUaW1lRG9tYWluRGF0YShhcnJheSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XSk7XG4gICAgICB9KGF1ZGlvbk5vZGVDb25zdHJ1Y3Rvcik7XG4gICAgfTtcblxuICAgIHZhciBpc093bmVkQnlDb250ZXh0ID0gZnVuY3Rpb24gaXNPd25lZEJ5Q29udGV4dChuYXRpdmVBdWRpb05vZGUsIG5hdGl2ZUNvbnRleHQpIHtcbiAgICAgIHJldHVybiBuYXRpdmVBdWRpb05vZGUuY29udGV4dCA9PT0gbmF0aXZlQ29udGV4dDtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZUFuYWx5c2VyTm9kZVJlbmRlcmVyRmFjdG9yeSA9IGZ1bmN0aW9uIGNyZWF0ZUFuYWx5c2VyTm9kZVJlbmRlcmVyRmFjdG9yeShjcmVhdGVOYXRpdmVBbmFseXNlck5vZGUsIGdldE5hdGl2ZUF1ZGlvTm9kZSwgcmVuZGVySW5wdXRzT2ZBdWRpb05vZGUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZW5kZXJlZE5hdGl2ZUFuYWx5c2VyTm9kZXMgPSBuZXcgV2Vha01hcCgpO1xuICAgICAgICB2YXIgY3JlYXRlQW5hbHlzZXJOb2RlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgX3JlZiA9IF9hc3luY1RvR2VuZXJhdG9yKC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZShwcm94eSwgbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCkge1xuICAgICAgICAgICAgdmFyIG5hdGl2ZUFuYWx5c2VyTm9kZSwgbmF0aXZlQW5hbHlzZXJOb2RlSXNPd25lZEJ5Q29udGV4dCwgb3B0aW9ucztcbiAgICAgICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgICAgICAgICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICBuYXRpdmVBbmFseXNlck5vZGUgPSBnZXROYXRpdmVBdWRpb05vZGUocHJveHkpOyAvLyBJZiB0aGUgaW5pdGlhbGx5IHVzZWQgbmF0aXZlQW5hbHlzZXJOb2RlIHdhcyBub3QgY29uc3RydWN0ZWQgb24gdGhlIHNhbWUgT2ZmbGluZUF1ZGlvQ29udGV4dCBpdCBuZWVkcyB0byBiZSBjcmVhdGVkIGFnYWluLlxuICAgICAgICAgICAgICAgICAgbmF0aXZlQW5hbHlzZXJOb2RlSXNPd25lZEJ5Q29udGV4dCA9IGlzT3duZWRCeUNvbnRleHQobmF0aXZlQW5hbHlzZXJOb2RlLCBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KTtcbiAgICAgICAgICAgICAgICAgIGlmICghbmF0aXZlQW5hbHlzZXJOb2RlSXNPd25lZEJ5Q29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zID0ge1xuICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWxDb3VudDogbmF0aXZlQW5hbHlzZXJOb2RlLmNoYW5uZWxDb3VudCxcbiAgICAgICAgICAgICAgICAgICAgICBjaGFubmVsQ291bnRNb2RlOiBuYXRpdmVBbmFseXNlck5vZGUuY2hhbm5lbENvdW50TW9kZSxcbiAgICAgICAgICAgICAgICAgICAgICBjaGFubmVsSW50ZXJwcmV0YXRpb246IG5hdGl2ZUFuYWx5c2VyTm9kZS5jaGFubmVsSW50ZXJwcmV0YXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgZmZ0U2l6ZTogbmF0aXZlQW5hbHlzZXJOb2RlLmZmdFNpemUsXG4gICAgICAgICAgICAgICAgICAgICAgbWF4RGVjaWJlbHM6IG5hdGl2ZUFuYWx5c2VyTm9kZS5tYXhEZWNpYmVscyxcbiAgICAgICAgICAgICAgICAgICAgICBtaW5EZWNpYmVsczogbmF0aXZlQW5hbHlzZXJOb2RlLm1pbkRlY2liZWxzLFxuICAgICAgICAgICAgICAgICAgICAgIHNtb290aGluZ1RpbWVDb25zdGFudDogbmF0aXZlQW5hbHlzZXJOb2RlLnNtb290aGluZ1RpbWVDb25zdGFudFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBuYXRpdmVBbmFseXNlck5vZGUgPSBjcmVhdGVOYXRpdmVBbmFseXNlck5vZGUobmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICByZW5kZXJlZE5hdGl2ZUFuYWx5c2VyTm9kZXMuc2V0KG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQsIG5hdGl2ZUFuYWx5c2VyTm9kZSk7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNjtcbiAgICAgICAgICAgICAgICAgIHJldHVybiByZW5kZXJJbnB1dHNPZkF1ZGlvTm9kZShwcm94eSwgbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCwgbmF0aXZlQW5hbHlzZXJOb2RlKTtcbiAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIG5hdGl2ZUFuYWx5c2VyTm9kZSk7XG4gICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIF9jYWxsZWUpO1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlQW5hbHlzZXJOb2RlKF94LCBfeDIpIHtcbiAgICAgICAgICAgIHJldHVybiBfcmVmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKHByb3h5LCBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KSB7XG4gICAgICAgICAgICB2YXIgcmVuZGVyZWROYXRpdmVBbmFseXNlck5vZGUgPSByZW5kZXJlZE5hdGl2ZUFuYWx5c2VyTm9kZXMuZ2V0KG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQpO1xuICAgICAgICAgICAgaWYgKHJlbmRlcmVkTmF0aXZlQW5hbHlzZXJOb2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZW5kZXJlZE5hdGl2ZUFuYWx5c2VyTm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlQW5hbHlzZXJOb2RlKHByb3h5LCBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgdGVzdEF1ZGlvQnVmZmVyQ29weUNoYW5uZWxNZXRob2RzT3V0T2ZCb3VuZHNTdXBwb3J0ID0gZnVuY3Rpb24gdGVzdEF1ZGlvQnVmZmVyQ29weUNoYW5uZWxNZXRob2RzT3V0T2ZCb3VuZHNTdXBwb3J0KG5hdGl2ZUF1ZGlvQnVmZmVyKSB7XG4gICAgICB0cnkge1xuICAgICAgICBuYXRpdmVBdWRpb0J1ZmZlci5jb3B5VG9DaGFubmVsKG5ldyBGbG9hdDMyQXJyYXkoMSksIDAsIC0xKTtcbiAgICAgIH0gY2F0Y2ggKF91bnVzZWQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVJbmRleFNpemVFcnJvciA9IGZ1bmN0aW9uIGNyZWF0ZUluZGV4U2l6ZUVycm9yKCkge1xuICAgICAgcmV0dXJuIG5ldyBET01FeGNlcHRpb24oJycsICdJbmRleFNpemVFcnJvcicpO1xuICAgIH07XG5cbiAgICB2YXIgd3JhcEF1ZGlvQnVmZmVyR2V0Q2hhbm5lbERhdGFNZXRob2QgPSBmdW5jdGlvbiB3cmFwQXVkaW9CdWZmZXJHZXRDaGFubmVsRGF0YU1ldGhvZChhdWRpb0J1ZmZlcikge1xuICAgICAgYXVkaW9CdWZmZXIuZ2V0Q2hhbm5lbERhdGEgPSBmdW5jdGlvbiAoZ2V0Q2hhbm5lbERhdGEpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChjaGFubmVsKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBnZXRDaGFubmVsRGF0YS5jYWxsKGF1ZGlvQnVmZmVyLCBjaGFubmVsKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGlmIChlcnIuY29kZSA9PT0gMTIpIHtcbiAgICAgICAgICAgICAgdGhyb3cgY3JlYXRlSW5kZXhTaXplRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9KGF1ZGlvQnVmZmVyLmdldENoYW5uZWxEYXRhKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gb3duS2V5cyR2KGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cbiAgICBmdW5jdGlvbiBfb2JqZWN0U3ByZWFkJHYoZSkgeyBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykgeyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gb3duS2V5cyR2KE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyR2KE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XG4gICAgdmFyIERFRkFVTFRfT1BUSU9OUyRqID0ge1xuICAgICAgbnVtYmVyT2ZDaGFubmVsczogMVxuICAgIH07XG4gICAgdmFyIGNyZWF0ZUF1ZGlvQnVmZmVyQ29uc3RydWN0b3IgPSBmdW5jdGlvbiBjcmVhdGVBdWRpb0J1ZmZlckNvbnN0cnVjdG9yKGF1ZGlvQnVmZmVyU3RvcmUsIGNhY2hlVGVzdFJlc3VsdCwgY3JlYXRlTm90U3VwcG9ydGVkRXJyb3IsIG5hdGl2ZUF1ZGlvQnVmZmVyQ29uc3RydWN0b3IsIG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHRDb25zdHJ1Y3RvciwgdGVzdE5hdGl2ZUF1ZGlvQnVmZmVyQ29uc3RydWN0b3JTdXBwb3J0LCB3cmFwQXVkaW9CdWZmZXJDb3B5Q2hhbm5lbE1ldGhvZHMsIHdyYXBBdWRpb0J1ZmZlckNvcHlDaGFubmVsTWV0aG9kc091dE9mQm91bmRzKSB7XG4gICAgICB2YXIgbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCA9IG51bGw7XG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gQXVkaW9CdWZmZXIob3B0aW9ucykge1xuICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBdWRpb0J1ZmZlcik7XG4gICAgICAgICAgaWYgKG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHRDb25zdHJ1Y3RvciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHRoZSBuYXRpdmUgT2ZmbGluZUF1ZGlvQ29udGV4dCBjb25zdHJ1Y3Rvci4nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIF9ERUZBVUxUX09QVElPTlMkb3B0aSA9IF9vYmplY3RTcHJlYWQkdihfb2JqZWN0U3ByZWFkJHYoe30sIERFRkFVTFRfT1BUSU9OUyRqKSwgb3B0aW9ucyksXG4gICAgICAgICAgICBsZW5ndGggPSBfREVGQVVMVF9PUFRJT05TJG9wdGkubGVuZ3RoLFxuICAgICAgICAgICAgbnVtYmVyT2ZDaGFubmVscyA9IF9ERUZBVUxUX09QVElPTlMkb3B0aS5udW1iZXJPZkNoYW5uZWxzLFxuICAgICAgICAgICAgc2FtcGxlUmF0ZSA9IF9ERUZBVUxUX09QVElPTlMkb3B0aS5zYW1wbGVSYXRlO1xuICAgICAgICAgIGlmIChuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0ID09PSBudWxsKSB7XG4gICAgICAgICAgICBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0ID0gbmV3IG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHRDb25zdHJ1Y3RvcigxLCAxLCA0NDEwMCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8qXG4gICAgICAgICAgICogQnVnICM5OTogRmlyZWZveCBkb2VzIG5vdCB0aHJvdyBhIE5vdFN1cHBvcnRlZEVycm9yIHdoZW4gdGhlIG51bWJlck9mQ2hhbm5lbHMgaXMgemVyby4gQnV0IGl0IG9ubHkgZG9lcyBpdCB3aGVuIHVzaW5nIHRoZVxuICAgICAgICAgICAqIGZhY3RvcnkgZnVuY3Rpb24uIEJ1dCBzaW5jZSBGaXJlZm94IGFsc28gc3VwcG9ydHMgdGhlIGNvbnN0cnVjdG9yIGV2ZXJ5dGhpbmcgc2hvdWxkIGJlIGZpbmUuXG4gICAgICAgICAgICovXG4gICAgICAgICAgdmFyIGF1ZGlvQnVmZmVyID0gbmF0aXZlQXVkaW9CdWZmZXJDb25zdHJ1Y3RvciAhPT0gbnVsbCAmJiBjYWNoZVRlc3RSZXN1bHQodGVzdE5hdGl2ZUF1ZGlvQnVmZmVyQ29uc3RydWN0b3JTdXBwb3J0LCB0ZXN0TmF0aXZlQXVkaW9CdWZmZXJDb25zdHJ1Y3RvclN1cHBvcnQpID8gbmV3IG5hdGl2ZUF1ZGlvQnVmZmVyQ29uc3RydWN0b3Ioe1xuICAgICAgICAgICAgbGVuZ3RoOiBsZW5ndGgsXG4gICAgICAgICAgICBudW1iZXJPZkNoYW5uZWxzOiBudW1iZXJPZkNoYW5uZWxzLFxuICAgICAgICAgICAgc2FtcGxlUmF0ZTogc2FtcGxlUmF0ZVxuICAgICAgICAgIH0pIDogbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dC5jcmVhdGVCdWZmZXIobnVtYmVyT2ZDaGFubmVscywgbGVuZ3RoLCBzYW1wbGVSYXRlKTtcbiAgICAgICAgICAvLyBCdWcgIzk5OiBTYWZhcmkgZG9lcyBub3QgdGhyb3cgYW4gZXJyb3Igd2hlbiB0aGUgbnVtYmVyT2ZDaGFubmVscyBpcyB6ZXJvLlxuICAgICAgICAgIGlmIChhdWRpb0J1ZmZlci5udW1iZXJPZkNoYW5uZWxzID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBjcmVhdGVOb3RTdXBwb3J0ZWRFcnJvcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBCdWcgIzU6IFNhZmFyaSBkb2VzIG5vdCBzdXBwb3J0IGNvcHlGcm9tQ2hhbm5lbCgpIGFuZCBjb3B5VG9DaGFubmVsKCkuXG4gICAgICAgICAgLy8gQnVnICMxMDA6IFNhZmFyaSBkb2VzIHRocm93IGEgd3JvbmcgZXJyb3Igd2hlbiBjYWxsaW5nIGdldENoYW5uZWxEYXRhKCkgd2l0aCBhbiBvdXQtb2YtYm91bmRzIHZhbHVlLlxuICAgICAgICAgIGlmICh0eXBlb2YgYXVkaW9CdWZmZXIuY29weUZyb21DaGFubmVsICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB3cmFwQXVkaW9CdWZmZXJDb3B5Q2hhbm5lbE1ldGhvZHMoYXVkaW9CdWZmZXIpO1xuICAgICAgICAgICAgd3JhcEF1ZGlvQnVmZmVyR2V0Q2hhbm5lbERhdGFNZXRob2QoYXVkaW9CdWZmZXIpO1xuICAgICAgICAgICAgLy8gQnVnICMxNTc6IEZpcmVmb3ggZG9lcyBub3QgYWxsb3cgdGhlIGJ1ZmZlck9mZnNldCB0byBiZSBvdXQtb2YtYm91bmRzLlxuICAgICAgICAgIH0gZWxzZSBpZiAoIWNhY2hlVGVzdFJlc3VsdCh0ZXN0QXVkaW9CdWZmZXJDb3B5Q2hhbm5lbE1ldGhvZHNPdXRPZkJvdW5kc1N1cHBvcnQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0ZXN0QXVkaW9CdWZmZXJDb3B5Q2hhbm5lbE1ldGhvZHNPdXRPZkJvdW5kc1N1cHBvcnQoYXVkaW9CdWZmZXIpO1xuICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICB3cmFwQXVkaW9CdWZmZXJDb3B5Q2hhbm5lbE1ldGhvZHNPdXRPZkJvdW5kcyhhdWRpb0J1ZmZlcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGF1ZGlvQnVmZmVyU3RvcmUuYWRkKGF1ZGlvQnVmZmVyKTtcbiAgICAgICAgICAvKlxuICAgICAgICAgICAqIFRoaXMgZG9lcyB2aW9sYXRlIGFsbCBnb29kIHByYXRpY2VzIGJ1dCBpdCBpcyBuZWNlc3NhcnkgdG8gYWxsb3cgdGhpcyBBdWRpb0J1ZmZlciB0byBiZSB1c2VkIHdpdGggbmF0aXZlXG4gICAgICAgICAgICogKE9mZmxpbmUpQXVkaW9Db250ZXh0cy5cbiAgICAgICAgICAgKi9cbiAgICAgICAgICByZXR1cm4gYXVkaW9CdWZmZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9jcmVhdGVDbGFzcyhBdWRpb0J1ZmZlciwgbnVsbCwgW3tcbiAgICAgICAgICBrZXk6IFN5bWJvbC5oYXNJbnN0YW5jZSxcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoaW5zdGFuY2UpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnN0YW5jZSAhPT0gbnVsbCAmJiBfdHlwZW9mKGluc3RhbmNlKSA9PT0gJ29iamVjdCcgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKGluc3RhbmNlKSA9PT0gQXVkaW9CdWZmZXIucHJvdG90eXBlIHx8IGF1ZGlvQnVmZmVyU3RvcmUuaGFzKGluc3RhbmNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1dKTtcbiAgICAgIH0oKTtcbiAgICB9O1xuXG4gICAgdmFyIE1PU1RfTkVHQVRJVkVfU0lOR0xFX0ZMT0FUID0gLTMuNDAyODIzNDY2Mzg1Mjg4NmUzODtcbiAgICB2YXIgTU9TVF9QT1NJVElWRV9TSU5HTEVfRkxPQVQgPSAtTU9TVF9ORUdBVElWRV9TSU5HTEVfRkxPQVQ7XG5cbiAgICB2YXIgaXNBY3RpdmVBdWRpb05vZGUgPSBmdW5jdGlvbiBpc0FjdGl2ZUF1ZGlvTm9kZShhdWRpb05vZGUpIHtcbiAgICAgIHJldHVybiBBQ1RJVkVfQVVESU9fTk9ERV9TVE9SRS5oYXMoYXVkaW9Ob2RlKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gb3duS2V5cyR1KGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cbiAgICBmdW5jdGlvbiBfb2JqZWN0U3ByZWFkJHUoZSkgeyBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykgeyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gb3duS2V5cyR1KE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyR1KE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XG4gICAgZnVuY3Rpb24gX2NhbGxTdXBlciRxKHQsIG8sIGUpIHsgcmV0dXJuIG8gPSBfZ2V0UHJvdG90eXBlT2YobyksIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHQsIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkcSgpID8gUmVmbGVjdC5jb25zdHJ1Y3QobywgZSB8fCBbXSwgX2dldFByb3RvdHlwZU9mKHQpLmNvbnN0cnVjdG9yKSA6IG8uYXBwbHkodCwgZSkpOyB9XG4gICAgZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRxKCkgeyB0cnkgeyB2YXIgdCA9ICFCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IH0gY2F0Y2ggKHQpIHt9IHJldHVybiAoX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRxID0gZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgcmV0dXJuICEhdDsgfSkoKTsgfVxuICAgIHZhciBERUZBVUxUX09QVElPTlMkaSA9IHtcbiAgICAgIGJ1ZmZlcjogbnVsbCxcbiAgICAgIGNoYW5uZWxDb3VudDogMixcbiAgICAgIGNoYW5uZWxDb3VudE1vZGU6ICdtYXgnLFxuICAgICAgY2hhbm5lbEludGVycHJldGF0aW9uOiAnc3BlYWtlcnMnLFxuICAgICAgLy8gQnVnICMxNDk6IFNhZmFyaSBkb2VzIG5vdCB5ZXQgc3VwcG9ydCB0aGUgZGV0dW5lIEF1ZGlvUGFyYW0uXG4gICAgICBsb29wOiBmYWxzZSxcbiAgICAgIGxvb3BFbmQ6IDAsXG4gICAgICBsb29wU3RhcnQ6IDAsXG4gICAgICBwbGF5YmFja1JhdGU6IDFcbiAgICB9O1xuICAgIHZhciBjcmVhdGVBdWRpb0J1ZmZlclNvdXJjZU5vZGVDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uIGNyZWF0ZUF1ZGlvQnVmZmVyU291cmNlTm9kZUNvbnN0cnVjdG9yKGF1ZGlvTm9kZUNvbnN0cnVjdG9yLCBjcmVhdGVBdWRpb0J1ZmZlclNvdXJjZU5vZGVSZW5kZXJlciwgY3JlYXRlQXVkaW9QYXJhbSwgY3JlYXRlSW52YWxpZFN0YXRlRXJyb3IsIGNyZWF0ZU5hdGl2ZUF1ZGlvQnVmZmVyU291cmNlTm9kZSwgZ2V0TmF0aXZlQ29udGV4dCwgaXNOYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LCB3cmFwRXZlbnRMaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX2F1ZGlvTm9kZUNvbnN0cnVjdG9yKSB7XG4gICAgICAgIGZ1bmN0aW9uIEF1ZGlvQnVmZmVyU291cmNlTm9kZShjb250ZXh0LCBvcHRpb25zKSB7XG4gICAgICAgICAgdmFyIF90aGlzO1xuICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBdWRpb0J1ZmZlclNvdXJjZU5vZGUpO1xuICAgICAgICAgIHZhciBuYXRpdmVDb250ZXh0ID0gZ2V0TmF0aXZlQ29udGV4dChjb250ZXh0KTtcbiAgICAgICAgICB2YXIgbWVyZ2VkT3B0aW9ucyA9IF9vYmplY3RTcHJlYWQkdShfb2JqZWN0U3ByZWFkJHUoe30sIERFRkFVTFRfT1BUSU9OUyRpKSwgb3B0aW9ucyk7XG4gICAgICAgICAgdmFyIG5hdGl2ZUF1ZGlvQnVmZmVyU291cmNlTm9kZSA9IGNyZWF0ZU5hdGl2ZUF1ZGlvQnVmZmVyU291cmNlTm9kZShuYXRpdmVDb250ZXh0LCBtZXJnZWRPcHRpb25zKTtcbiAgICAgICAgICB2YXIgaXNPZmZsaW5lID0gaXNOYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KG5hdGl2ZUNvbnRleHQpO1xuICAgICAgICAgIHZhciBhdWRpb0J1ZmZlclNvdXJjZU5vZGVSZW5kZXJlciA9IGlzT2ZmbGluZSA/IGNyZWF0ZUF1ZGlvQnVmZmVyU291cmNlTm9kZVJlbmRlcmVyKCkgOiBudWxsO1xuICAgICAgICAgIF90aGlzID0gX2NhbGxTdXBlciRxKHRoaXMsIEF1ZGlvQnVmZmVyU291cmNlTm9kZSwgW2NvbnRleHQsIGZhbHNlLCBuYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGUsIGF1ZGlvQnVmZmVyU291cmNlTm9kZVJlbmRlcmVyXSk7XG4gICAgICAgICAgX3RoaXMuX2F1ZGlvQnVmZmVyU291cmNlTm9kZVJlbmRlcmVyID0gYXVkaW9CdWZmZXJTb3VyY2VOb2RlUmVuZGVyZXI7XG4gICAgICAgICAgX3RoaXMuX2lzQnVmZmVyTnVsbGlmaWVkID0gZmFsc2U7XG4gICAgICAgICAgX3RoaXMuX2lzQnVmZmVyU2V0ID0gbWVyZ2VkT3B0aW9ucy5idWZmZXIgIT09IG51bGw7XG4gICAgICAgICAgX3RoaXMuX25hdGl2ZUF1ZGlvQnVmZmVyU291cmNlTm9kZSA9IG5hdGl2ZUF1ZGlvQnVmZmVyU291cmNlTm9kZTtcbiAgICAgICAgICBfdGhpcy5fb25lbmRlZCA9IG51bGw7XG4gICAgICAgICAgLy8gQnVnICM3MzogU2FmYXJpIGRvZXMgbm90IGV4cG9ydCB0aGUgY29ycmVjdCB2YWx1ZXMgZm9yIG1heFZhbHVlIGFuZCBtaW5WYWx1ZS5cbiAgICAgICAgICBfdGhpcy5fcGxheWJhY2tSYXRlID0gY3JlYXRlQXVkaW9QYXJhbShfdGhpcywgaXNPZmZsaW5lLCBuYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGUucGxheWJhY2tSYXRlLCBNT1NUX1BPU0lUSVZFX1NJTkdMRV9GTE9BVCwgTU9TVF9ORUdBVElWRV9TSU5HTEVfRkxPQVQpO1xuICAgICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgICAgfVxuICAgICAgICBfaW5oZXJpdHMoQXVkaW9CdWZmZXJTb3VyY2VOb2RlLCBfYXVkaW9Ob2RlQ29uc3RydWN0b3IpO1xuICAgICAgICByZXR1cm4gX2NyZWF0ZUNsYXNzKEF1ZGlvQnVmZmVyU291cmNlTm9kZSwgW3tcbiAgICAgICAgICBrZXk6IFwiYnVmZmVyXCIsXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5faXNCdWZmZXJOdWxsaWZpZWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2RlLmJ1ZmZlcjtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9uYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGUuYnVmZmVyID0gdmFsdWU7XG4gICAgICAgICAgICAvLyBCdWcgIzcyOiBPbmx5IENocm9tZSAmIEVkZ2UgZG8gbm90IGFsbG93IHRvIHJlYXNzaWduIHRoZSBidWZmZXIgeWV0LlxuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLl9pc0J1ZmZlclNldCkge1xuICAgICAgICAgICAgICAgIHRocm93IGNyZWF0ZUludmFsaWRTdGF0ZUVycm9yKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhpcy5faXNCdWZmZXJTZXQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIGtleTogXCJsb29wXCIsXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2RlLmxvb3A7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fbmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2RlLmxvb3AgPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBrZXk6IFwibG9vcEVuZFwiLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25hdGl2ZUF1ZGlvQnVmZmVyU291cmNlTm9kZS5sb29wRW5kO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX25hdGl2ZUF1ZGlvQnVmZmVyU291cmNlTm9kZS5sb29wRW5kID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcImxvb3BTdGFydFwiLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25hdGl2ZUF1ZGlvQnVmZmVyU291cmNlTm9kZS5sb29wU3RhcnQ7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fbmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2RlLmxvb3BTdGFydCA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIGtleTogXCJvbmVuZGVkXCIsXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fb25lbmRlZDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgd3JhcHBlZExpc3RlbmVyID0gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nID8gd3JhcEV2ZW50TGlzdGVuZXIodGhpcywgdmFsdWUpIDogbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX25hdGl2ZUF1ZGlvQnVmZmVyU291cmNlTm9kZS5vbmVuZGVkID0gd3JhcHBlZExpc3RlbmVyO1xuICAgICAgICAgICAgdmFyIG5hdGl2ZU9uRW5kZWQgPSB0aGlzLl9uYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGUub25lbmRlZDtcbiAgICAgICAgICAgIHRoaXMuX29uZW5kZWQgPSBuYXRpdmVPbkVuZGVkICE9PSBudWxsICYmIG5hdGl2ZU9uRW5kZWQgPT09IHdyYXBwZWRMaXN0ZW5lciA/IHZhbHVlIDogbmF0aXZlT25FbmRlZDtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBrZXk6IFwicGxheWJhY2tSYXRlXCIsXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcGxheWJhY2tSYXRlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIGtleTogXCJzdGFydFwiLFxuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzdGFydCgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIHdoZW4gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDA7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuICAgICAgICAgICAgdmFyIGR1cmF0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLl9uYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGUuc3RhcnQod2hlbiwgb2Zmc2V0LCBkdXJhdGlvbik7XG4gICAgICAgICAgICBpZiAodGhpcy5fYXVkaW9CdWZmZXJTb3VyY2VOb2RlUmVuZGVyZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgdGhpcy5fYXVkaW9CdWZmZXJTb3VyY2VOb2RlUmVuZGVyZXIuc3RhcnQgPSBkdXJhdGlvbiA9PT0gdW5kZWZpbmVkID8gW3doZW4sIG9mZnNldF0gOiBbd2hlbiwgb2Zmc2V0LCBkdXJhdGlvbl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb250ZXh0LnN0YXRlICE9PSAnY2xvc2VkJykge1xuICAgICAgICAgICAgICBzZXRJbnRlcm5hbFN0YXRlVG9BY3RpdmUodGhpcyk7XG4gICAgICAgICAgICAgIHZhciBfcmVzZXRJbnRlcm5hbFN0YXRlVG9QYXNzaXZlID0gZnVuY3Rpb24gcmVzZXRJbnRlcm5hbFN0YXRlVG9QYXNzaXZlKCkge1xuICAgICAgICAgICAgICAgIF90aGlzMi5fbmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2VuZGVkJywgX3Jlc2V0SW50ZXJuYWxTdGF0ZVRvUGFzc2l2ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGlzQWN0aXZlQXVkaW9Ob2RlKF90aGlzMikpIHtcbiAgICAgICAgICAgICAgICAgIHNldEludGVybmFsU3RhdGVUb1Bhc3NpdmUoX3RoaXMyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIHRoaXMuX25hdGl2ZUF1ZGlvQnVmZmVyU291cmNlTm9kZS5hZGRFdmVudExpc3RlbmVyKCdlbmRlZCcsIF9yZXNldEludGVybmFsU3RhdGVUb1Bhc3NpdmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIGtleTogXCJzdG9wXCIsXG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHN0b3AoKSB7XG4gICAgICAgICAgICB2YXIgd2hlbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogMDtcbiAgICAgICAgICAgIHRoaXMuX25hdGl2ZUF1ZGlvQnVmZmVyU291cmNlTm9kZS5zdG9wKHdoZW4pO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2F1ZGlvQnVmZmVyU291cmNlTm9kZVJlbmRlcmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2F1ZGlvQnVmZmVyU291cmNlTm9kZVJlbmRlcmVyLnN0b3AgPSB3aGVuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfV0pO1xuICAgICAgfShhdWRpb05vZGVDb25zdHJ1Y3Rvcik7XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVBdWRpb0J1ZmZlclNvdXJjZU5vZGVSZW5kZXJlckZhY3RvcnkgPSBmdW5jdGlvbiBjcmVhdGVBdWRpb0J1ZmZlclNvdXJjZU5vZGVSZW5kZXJlckZhY3RvcnkoY29ubmVjdEF1ZGlvUGFyYW0sIGNyZWF0ZU5hdGl2ZUF1ZGlvQnVmZmVyU291cmNlTm9kZSwgZ2V0TmF0aXZlQXVkaW9Ob2RlLCByZW5kZXJBdXRvbWF0aW9uLCByZW5kZXJJbnB1dHNPZkF1ZGlvTm9kZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlbmRlcmVkTmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2RlcyA9IG5ldyBXZWFrTWFwKCk7XG4gICAgICAgIHZhciBzdGFydCA9IG51bGw7XG4gICAgICAgIHZhciBzdG9wID0gbnVsbDtcbiAgICAgICAgdmFyIGNyZWF0ZUF1ZGlvQnVmZmVyU291cmNlTm9kZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIF9yZWYgPSBfYXN5bmNUb0dlbmVyYXRvcigvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUocHJveHksIG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciBuYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGUsIG5hdGl2ZUF1ZGlvQnVmZmVyU291cmNlTm9kZUlzT3duZWRCeUNvbnRleHQsIG9wdGlvbnMsIF9uYXRpdmVBdWRpb0J1ZmZlclNvdTtcbiAgICAgICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgICAgICAgICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICBuYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGUgPSBnZXROYXRpdmVBdWRpb05vZGUocHJveHkpO1xuICAgICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgICAqIElmIHRoZSBpbml0aWFsbHkgdXNlZCBuYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGUgd2FzIG5vdCBjb25zdHJ1Y3RlZCBvbiB0aGUgc2FtZSBPZmZsaW5lQXVkaW9Db250ZXh0IGl0IG5lZWRzIHRvIGJlIGNyZWF0ZWRcbiAgICAgICAgICAgICAgICAgICAqIGFnYWluLlxuICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICBuYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGVJc093bmVkQnlDb250ZXh0ID0gaXNPd25lZEJ5Q29udGV4dChuYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGUsIG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgaWYgKCFuYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGVJc093bmVkQnlDb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgYnVmZmVyOiBuYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGUuYnVmZmVyLFxuICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWxDb3VudDogbmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2RlLmNoYW5uZWxDb3VudCxcbiAgICAgICAgICAgICAgICAgICAgICBjaGFubmVsQ291bnRNb2RlOiBuYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGUuY2hhbm5lbENvdW50TW9kZSxcbiAgICAgICAgICAgICAgICAgICAgICBjaGFubmVsSW50ZXJwcmV0YXRpb246IG5hdGl2ZUF1ZGlvQnVmZmVyU291cmNlTm9kZS5jaGFubmVsSW50ZXJwcmV0YXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgLy8gQnVnICMxNDk6IFNhZmFyaSBkb2VzIG5vdCB5ZXQgc3VwcG9ydCB0aGUgZGV0dW5lIEF1ZGlvUGFyYW0uXG4gICAgICAgICAgICAgICAgICAgICAgbG9vcDogbmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2RlLmxvb3AsXG4gICAgICAgICAgICAgICAgICAgICAgbG9vcEVuZDogbmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2RlLmxvb3BFbmQsXG4gICAgICAgICAgICAgICAgICAgICAgbG9vcFN0YXJ0OiBuYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGUubG9vcFN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgIHBsYXliYWNrUmF0ZTogbmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2RlLnBsYXliYWNrUmF0ZS52YWx1ZVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBuYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGUgPSBjcmVhdGVOYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGUobmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGFydCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgIChfbmF0aXZlQXVkaW9CdWZmZXJTb3UgPSBuYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGUpLnN0YXJ0LmFwcGx5KF9uYXRpdmVBdWRpb0J1ZmZlclNvdSwgX3RvQ29uc3VtYWJsZUFycmF5KHN0YXJ0KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0b3AgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICBuYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGUuc3RvcChzdG9wKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgcmVuZGVyZWROYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGVzLnNldChuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LCBuYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGUpO1xuICAgICAgICAgICAgICAgICAgaWYgKG5hdGl2ZUF1ZGlvQnVmZmVyU291cmNlTm9kZUlzT3duZWRCeUNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDc7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcmVuZGVyQXV0b21hdGlvbihuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LCBwcm94eS5wbGF5YmFja1JhdGUsIG5hdGl2ZUF1ZGlvQnVmZmVyU291cmNlTm9kZS5wbGF5YmFja1JhdGUpO1xuICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxMTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxMTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBjb25uZWN0QXVkaW9QYXJhbShuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LCBwcm94eS5wbGF5YmFja1JhdGUsIG5hdGl2ZUF1ZGlvQnVmZmVyU291cmNlTm9kZS5wbGF5YmFja1JhdGUpO1xuICAgICAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTM7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcmVuZGVySW5wdXRzT2ZBdWRpb05vZGUocHJveHksIG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQsIG5hdGl2ZUF1ZGlvQnVmZmVyU291cmNlTm9kZSk7XG4gICAgICAgICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgbmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2RlKTtcbiAgICAgICAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIF9jYWxsZWUpO1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlQXVkaW9CdWZmZXJTb3VyY2VOb2RlKF94LCBfeDIpIHtcbiAgICAgICAgICAgIHJldHVybiBfcmVmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHNldCBzdGFydCh2YWx1ZSkge1xuICAgICAgICAgICAgc3RhcnQgPSB2YWx1ZTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNldCBzdG9wKHZhbHVlKSB7XG4gICAgICAgICAgICBzdG9wID0gdmFsdWU7XG4gICAgICAgICAgfSxcbiAgICAgICAgICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihwcm94eSwgbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCkge1xuICAgICAgICAgICAgdmFyIHJlbmRlcmVkTmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2RlID0gcmVuZGVyZWROYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGVzLmdldChuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KTtcbiAgICAgICAgICAgIGlmIChyZW5kZXJlZE5hdGl2ZUF1ZGlvQnVmZmVyU291cmNlTm9kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVuZGVyZWROYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUF1ZGlvQnVmZmVyU291cmNlTm9kZShwcm94eSwgbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIGlzQXVkaW9CdWZmZXJTb3VyY2VOb2RlID0gZnVuY3Rpb24gaXNBdWRpb0J1ZmZlclNvdXJjZU5vZGUoYXVkaW9Ob2RlKSB7XG4gICAgICByZXR1cm4gJ3BsYXliYWNrUmF0ZScgaW4gYXVkaW9Ob2RlO1xuICAgIH07XG5cbiAgICB2YXIgaXNCaXF1YWRGaWx0ZXJOb2RlID0gZnVuY3Rpb24gaXNCaXF1YWRGaWx0ZXJOb2RlKGF1ZGlvTm9kZSkge1xuICAgICAgcmV0dXJuICdmcmVxdWVuY3knIGluIGF1ZGlvTm9kZSAmJiAnZ2FpbicgaW4gYXVkaW9Ob2RlO1xuICAgIH07XG5cbiAgICB2YXIgaXNDb25zdGFudFNvdXJjZU5vZGUgPSBmdW5jdGlvbiBpc0NvbnN0YW50U291cmNlTm9kZShhdWRpb05vZGUpIHtcbiAgICAgIHJldHVybiAnb2Zmc2V0JyBpbiBhdWRpb05vZGU7XG4gICAgfTtcblxuICAgIHZhciBpc0dhaW5Ob2RlID0gZnVuY3Rpb24gaXNHYWluTm9kZShhdWRpb05vZGUpIHtcbiAgICAgIHJldHVybiAhKCdmcmVxdWVuY3knIGluIGF1ZGlvTm9kZSkgJiYgJ2dhaW4nIGluIGF1ZGlvTm9kZTtcbiAgICB9O1xuXG4gICAgdmFyIGlzT3NjaWxsYXRvck5vZGUgPSBmdW5jdGlvbiBpc09zY2lsbGF0b3JOb2RlKGF1ZGlvTm9kZSkge1xuICAgICAgcmV0dXJuICdkZXR1bmUnIGluIGF1ZGlvTm9kZSAmJiAnZnJlcXVlbmN5JyBpbiBhdWRpb05vZGUgJiYgISgnZ2FpbicgaW4gYXVkaW9Ob2RlKTtcbiAgICB9O1xuXG4gICAgdmFyIGlzU3RlcmVvUGFubmVyTm9kZSA9IGZ1bmN0aW9uIGlzU3RlcmVvUGFubmVyTm9kZShhdWRpb05vZGUpIHtcbiAgICAgIHJldHVybiAncGFuJyBpbiBhdWRpb05vZGU7XG4gICAgfTtcblxuICAgIHZhciBnZXRBdWRpb05vZGVDb25uZWN0aW9ucyA9IGZ1bmN0aW9uIGdldEF1ZGlvTm9kZUNvbm5lY3Rpb25zKGF1ZGlvTm9kZSkge1xuICAgICAgcmV0dXJuIGdldFZhbHVlRm9yS2V5KEFVRElPX05PREVfQ09OTkVDVElPTlNfU1RPUkUsIGF1ZGlvTm9kZSk7XG4gICAgfTtcblxuICAgIHZhciBnZXRBdWRpb1BhcmFtQ29ubmVjdGlvbnMgPSBmdW5jdGlvbiBnZXRBdWRpb1BhcmFtQ29ubmVjdGlvbnMoYXVkaW9QYXJhbSkge1xuICAgICAgcmV0dXJuIGdldFZhbHVlRm9yS2V5KEFVRElPX1BBUkFNX0NPTk5FQ1RJT05TX1NUT1JFLCBhdWRpb1BhcmFtKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkYihyLCBlKSB7IHZhciB0ID0gXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgU3ltYm9sICYmIHJbU3ltYm9sLml0ZXJhdG9yXSB8fCByW1wiQEBpdGVyYXRvclwiXTsgaWYgKCF0KSB7IGlmIChBcnJheS5pc0FycmF5KHIpIHx8ICh0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5JGIocikpIHx8IGUpIHsgdCAmJiAociA9IHQpOyB2YXIgX24gPSAwLCBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyByZXR1cm4gX24gPj0gci5sZW5ndGggPyB7IGRvbmU6ICEwIH0gOiB7IGRvbmU6ICExLCB2YWx1ZTogcltfbisrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKHIpIHsgdGhyb3cgcjsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbywgYSA9ICEwLCB1ID0gITE7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IHQgPSB0LmNhbGwocik7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciByID0gdC5uZXh0KCk7IHJldHVybiBhID0gci5kb25lLCByOyB9LCBlOiBmdW5jdGlvbiBlKHIpIHsgdSA9ICEwLCBvID0gcjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgYSB8fCBudWxsID09IHRbXCJyZXR1cm5cIl0gfHwgdFtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAodSkgdGhyb3cgbzsgfSB9IH07IH1cbiAgICBmdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkYihyLCBhKSB7IGlmIChyKSB7IGlmIChcInN0cmluZ1wiID09IHR5cGVvZiByKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkkYihyLCBhKTsgdmFyIHQgPSB7fS50b1N0cmluZy5jYWxsKHIpLnNsaWNlKDgsIC0xKTsgcmV0dXJuIFwiT2JqZWN0XCIgPT09IHQgJiYgci5jb25zdHJ1Y3RvciAmJiAodCA9IHIuY29uc3RydWN0b3IubmFtZSksIFwiTWFwXCIgPT09IHQgfHwgXCJTZXRcIiA9PT0gdCA/IEFycmF5LmZyb20ocikgOiBcIkFyZ3VtZW50c1wiID09PSB0IHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KHQpID8gX2FycmF5TGlrZVRvQXJyYXkkYihyLCBhKSA6IHZvaWQgMDsgfSB9XG4gICAgZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkkYihyLCBhKSB7IChudWxsID09IGEgfHwgYSA+IHIubGVuZ3RoKSAmJiAoYSA9IHIubGVuZ3RoKTsgZm9yICh2YXIgZSA9IDAsIG4gPSBBcnJheShhKTsgZSA8IGE7IGUrKykgbltlXSA9IHJbZV07IHJldHVybiBuOyB9XG4gICAgdmFyIF9kZWFjdGl2YXRlQWN0aXZlQXVkaW9Ob2RlSW5wdXRDb25uZWN0aW9ucyA9IGZ1bmN0aW9uIGRlYWN0aXZhdGVBY3RpdmVBdWRpb05vZGVJbnB1dENvbm5lY3Rpb25zKGF1ZGlvTm9kZSwgdHJhY2UpIHtcbiAgICAgIHZhciBfZ2V0QXVkaW9Ob2RlQ29ubmVjdGkgPSBnZXRBdWRpb05vZGVDb25uZWN0aW9ucyhhdWRpb05vZGUpLFxuICAgICAgICBhY3RpdmVJbnB1dHMgPSBfZ2V0QXVkaW9Ob2RlQ29ubmVjdGkuYWN0aXZlSW5wdXRzO1xuICAgICAgYWN0aXZlSW5wdXRzLmZvckVhY2goZnVuY3Rpb24gKGNvbm5lY3Rpb25zKSB7XG4gICAgICAgIHJldHVybiBjb25uZWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICAgICAgdmFyIF9yZWYyID0gX3NsaWNlZFRvQXJyYXkoX3JlZiwgMSksXG4gICAgICAgICAgICBzb3VyY2UgPSBfcmVmMlswXTtcbiAgICAgICAgICBpZiAoIXRyYWNlLmluY2x1ZGVzKGF1ZGlvTm9kZSkpIHtcbiAgICAgICAgICAgIF9kZWFjdGl2YXRlQWN0aXZlQXVkaW9Ob2RlSW5wdXRDb25uZWN0aW9ucyhzb3VyY2UsIFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkodHJhY2UpLCBbYXVkaW9Ob2RlXSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHZhciBhdWRpb1BhcmFtcyA9IGlzQXVkaW9CdWZmZXJTb3VyY2VOb2RlKGF1ZGlvTm9kZSkgPyBbXG4gICAgICAvLyBCdWcgIzE0OTogU2FmYXJpIGRvZXMgbm90IHlldCBzdXBwb3J0IHRoZSBkZXR1bmUgQXVkaW9QYXJhbS5cbiAgICAgIGF1ZGlvTm9kZS5wbGF5YmFja1JhdGVdIDogaXNBdWRpb1dvcmtsZXROb2RlKGF1ZGlvTm9kZSkgPyBBcnJheS5mcm9tKGF1ZGlvTm9kZS5wYXJhbWV0ZXJzLnZhbHVlcygpKSA6IGlzQmlxdWFkRmlsdGVyTm9kZShhdWRpb05vZGUpID8gW2F1ZGlvTm9kZS5RLCBhdWRpb05vZGUuZGV0dW5lLCBhdWRpb05vZGUuZnJlcXVlbmN5LCBhdWRpb05vZGUuZ2Fpbl0gOiBpc0NvbnN0YW50U291cmNlTm9kZShhdWRpb05vZGUpID8gW2F1ZGlvTm9kZS5vZmZzZXRdIDogaXNHYWluTm9kZShhdWRpb05vZGUpID8gW2F1ZGlvTm9kZS5nYWluXSA6IGlzT3NjaWxsYXRvck5vZGUoYXVkaW9Ob2RlKSA/IFthdWRpb05vZGUuZGV0dW5lLCBhdWRpb05vZGUuZnJlcXVlbmN5XSA6IGlzU3RlcmVvUGFubmVyTm9kZShhdWRpb05vZGUpID8gW2F1ZGlvTm9kZS5wYW5dIDogW107XG4gICAgICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkYihhdWRpb1BhcmFtcyksXG4gICAgICAgIF9zdGVwO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgYXVkaW9QYXJhbSA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgIHZhciBhdWRpb1BhcmFtQ29ubmVjdGlvbnMgPSBnZXRBdWRpb1BhcmFtQ29ubmVjdGlvbnMoYXVkaW9QYXJhbSk7XG4gICAgICAgICAgaWYgKGF1ZGlvUGFyYW1Db25uZWN0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBhdWRpb1BhcmFtQ29ubmVjdGlvbnMuYWN0aXZlSW5wdXRzLmZvckVhY2goZnVuY3Rpb24gKF9yZWYzKSB7XG4gICAgICAgICAgICAgIHZhciBfcmVmNCA9IF9zbGljZWRUb0FycmF5KF9yZWYzLCAxKSxcbiAgICAgICAgICAgICAgICBzb3VyY2UgPSBfcmVmNFswXTtcbiAgICAgICAgICAgICAgcmV0dXJuIF9kZWFjdGl2YXRlQWN0aXZlQXVkaW9Ob2RlSW5wdXRDb25uZWN0aW9ucyhzb3VyY2UsIHRyYWNlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IuZigpO1xuICAgICAgfVxuICAgICAgaWYgKGlzQWN0aXZlQXVkaW9Ob2RlKGF1ZGlvTm9kZSkpIHtcbiAgICAgICAgc2V0SW50ZXJuYWxTdGF0ZVRvUGFzc2l2ZShhdWRpb05vZGUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgZGVhY3RpdmF0ZUF1ZGlvR3JhcGggPSBmdW5jdGlvbiBkZWFjdGl2YXRlQXVkaW9HcmFwaChjb250ZXh0KSB7XG4gICAgICBfZGVhY3RpdmF0ZUFjdGl2ZUF1ZGlvTm9kZUlucHV0Q29ubmVjdGlvbnMoY29udGV4dC5kZXN0aW5hdGlvbiwgW10pO1xuICAgIH07XG5cbiAgICB2YXIgaXNWYWxpZExhdGVuY3lIaW50ID0gZnVuY3Rpb24gaXNWYWxpZExhdGVuY3lIaW50KGxhdGVuY3lIaW50KSB7XG4gICAgICByZXR1cm4gbGF0ZW5jeUhpbnQgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgbGF0ZW5jeUhpbnQgPT09ICdudW1iZXInIHx8IHR5cGVvZiBsYXRlbmN5SGludCA9PT0gJ3N0cmluZycgJiYgKGxhdGVuY3lIaW50ID09PSAnYmFsYW5jZWQnIHx8IGxhdGVuY3lIaW50ID09PSAnaW50ZXJhY3RpdmUnIHx8IGxhdGVuY3lIaW50ID09PSAncGxheWJhY2snKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gX2NhbGxTdXBlciRwKHQsIG8sIGUpIHsgcmV0dXJuIG8gPSBfZ2V0UHJvdG90eXBlT2YobyksIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHQsIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkcCgpID8gUmVmbGVjdC5jb25zdHJ1Y3QobywgZSB8fCBbXSwgX2dldFByb3RvdHlwZU9mKHQpLmNvbnN0cnVjdG9yKSA6IG8uYXBwbHkodCwgZSkpOyB9XG4gICAgZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRwKCkgeyB0cnkgeyB2YXIgdCA9ICFCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IH0gY2F0Y2ggKHQpIHt9IHJldHVybiAoX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRwID0gZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgcmV0dXJuICEhdDsgfSkoKTsgfVxuICAgIHZhciBjcmVhdGVBdWRpb0NvbnRleHRDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uIGNyZWF0ZUF1ZGlvQ29udGV4dENvbnN0cnVjdG9yKGJhc2VBdWRpb0NvbnRleHRDb25zdHJ1Y3RvciwgY3JlYXRlSW52YWxpZFN0YXRlRXJyb3IsIGNyZWF0ZU5vdFN1cHBvcnRlZEVycm9yLCBjcmVhdGVVbmtub3duRXJyb3IsIG1lZGlhRWxlbWVudEF1ZGlvU291cmNlTm9kZUNvbnN0cnVjdG9yLCBtZWRpYVN0cmVhbUF1ZGlvRGVzdGluYXRpb25Ob2RlQ29uc3RydWN0b3IsIG1lZGlhU3RyZWFtQXVkaW9Tb3VyY2VOb2RlQ29uc3RydWN0b3IsIG1lZGlhU3RyZWFtVHJhY2tBdWRpb1NvdXJjZU5vZGVDb25zdHJ1Y3RvciwgbmF0aXZlQXVkaW9Db250ZXh0Q29uc3RydWN0b3IpIHtcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9iYXNlQXVkaW9Db250ZXh0Q29ucykge1xuICAgICAgICBmdW5jdGlvbiBBdWRpb0NvbnRleHQoKSB7XG4gICAgICAgICAgdmFyIF90aGlzO1xuICAgICAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQXVkaW9Db250ZXh0KTtcbiAgICAgICAgICBpZiAobmF0aXZlQXVkaW9Db250ZXh0Q29uc3RydWN0b3IgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyB0aGUgbmF0aXZlIEF1ZGlvQ29udGV4dCBjb25zdHJ1Y3Rvci4nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIG5hdGl2ZUF1ZGlvQ29udGV4dDtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgbmF0aXZlQXVkaW9Db250ZXh0ID0gbmV3IG5hdGl2ZUF1ZGlvQ29udGV4dENvbnN0cnVjdG9yKG9wdGlvbnMpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgLy8gQnVnICMxOTIgU2FmYXJpIGRvZXMgdGhyb3cgYSBTeW50YXhFcnJvciBpZiB0aGUgc2FtcGxlUmF0ZSBpcyBub3Qgc3VwcG9ydGVkLlxuICAgICAgICAgICAgaWYgKGVyci5jb2RlID09PSAxMiAmJiBlcnIubWVzc2FnZSA9PT0gJ3NhbXBsZVJhdGUgaXMgbm90IGluIHJhbmdlJykge1xuICAgICAgICAgICAgICB0aHJvdyBjcmVhdGVOb3RTdXBwb3J0ZWRFcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBCdWcgIzEzMSBTYWZhcmkgcmV0dXJucyBudWxsIHdoZW4gdGhlcmUgYXJlIGZvdXIgb3RoZXIgQXVkaW9Db250ZXh0cyBydW5uaW5nIGFscmVhZHkuXG4gICAgICAgICAgaWYgKG5hdGl2ZUF1ZGlvQ29udGV4dCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgY3JlYXRlVW5rbm93bkVycm9yKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIEJ1ZyAjNTEgT25seSBDaHJvbWUgYW5kIEVkZ2UgdGhyb3cgYW4gZXJyb3IgaWYgdGhlIGdpdmVuIGxhdGVuY3lIaW50IGlzIGludmFsaWQuXG4gICAgICAgICAgaWYgKCFpc1ZhbGlkTGF0ZW5jeUhpbnQob3B0aW9ucy5sYXRlbmN5SGludCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJUaGUgcHJvdmlkZWQgdmFsdWUgJ1wiLmNvbmNhdChvcHRpb25zLmxhdGVuY3lIaW50LCBcIicgaXMgbm90IGEgdmFsaWQgZW51bSB2YWx1ZSBvZiB0eXBlIEF1ZGlvQ29udGV4dExhdGVuY3lDYXRlZ29yeS5cIikpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBCdWcgIzE1MCBTYWZhcmkgZG9lcyBub3Qgc3VwcG9ydCBzZXR0aW5nIHRoZSBzYW1wbGVSYXRlLlxuICAgICAgICAgIGlmIChvcHRpb25zLnNhbXBsZVJhdGUgIT09IHVuZGVmaW5lZCAmJiBuYXRpdmVBdWRpb0NvbnRleHQuc2FtcGxlUmF0ZSAhPT0gb3B0aW9ucy5zYW1wbGVSYXRlKSB7XG4gICAgICAgICAgICB0aHJvdyBjcmVhdGVOb3RTdXBwb3J0ZWRFcnJvcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBfdGhpcyA9IF9jYWxsU3VwZXIkcCh0aGlzLCBBdWRpb0NvbnRleHQsIFtuYXRpdmVBdWRpb0NvbnRleHQsIDJdKTtcbiAgICAgICAgICB2YXIgbGF0ZW5jeUhpbnQgPSBvcHRpb25zLmxhdGVuY3lIaW50O1xuICAgICAgICAgIHZhciBfbmF0aXZlQXVkaW9Db250ZXh0ID0gbmF0aXZlQXVkaW9Db250ZXh0LFxuICAgICAgICAgICAgc2FtcGxlUmF0ZSA9IF9uYXRpdmVBdWRpb0NvbnRleHQuc2FtcGxlUmF0ZTtcbiAgICAgICAgICAvLyBAdG9kbyBUaGUgdmFsdWVzIGZvciAnYmFsYW5jZWQnLCAnaW50ZXJhY3RpdmUnIGFuZCAncGxheWJhY2snIGFyZSBqdXN0IGNvcGllZCBmcm9tIENocm9tZSdzIGltcGxlbWVudGF0aW9uLlxuICAgICAgICAgIF90aGlzLl9iYXNlTGF0ZW5jeSA9IHR5cGVvZiBuYXRpdmVBdWRpb0NvbnRleHQuYmFzZUxhdGVuY3kgPT09ICdudW1iZXInID8gbmF0aXZlQXVkaW9Db250ZXh0LmJhc2VMYXRlbmN5IDogbGF0ZW5jeUhpbnQgPT09ICdiYWxhbmNlZCcgPyA1MTIgLyBzYW1wbGVSYXRlIDogbGF0ZW5jeUhpbnQgPT09ICdpbnRlcmFjdGl2ZScgfHwgbGF0ZW5jeUhpbnQgPT09IHVuZGVmaW5lZCA/IDI1NiAvIHNhbXBsZVJhdGUgOiBsYXRlbmN5SGludCA9PT0gJ3BsYXliYWNrJyA/IDEwMjQgLyBzYW1wbGVSYXRlIDpcbiAgICAgICAgICAvKlxuICAgICAgICAgICAqIEB0b2RvIFRoZSBtaW4gKDI1NikgYW5kIG1heCAoMTYzODQpIHZhbHVlcyBhcmUgdGFrZW4gZnJvbSB0aGUgYWxsb3dlZCBidWZmZXJTaXplIHZhbHVlcyBvZiBhXG4gICAgICAgICAgICogU2NyaXB0UHJvY2Vzc29yTm9kZS5cbiAgICAgICAgICAgKi9cbiAgICAgICAgICBNYXRoLm1heCgyLCBNYXRoLm1pbigxMjgsIE1hdGgucm91bmQobGF0ZW5jeUhpbnQgKiBzYW1wbGVSYXRlIC8gMTI4KSkpICogMTI4IC8gc2FtcGxlUmF0ZTtcbiAgICAgICAgICBfdGhpcy5fbmF0aXZlQXVkaW9Db250ZXh0ID0gbmF0aXZlQXVkaW9Db250ZXh0O1xuICAgICAgICAgIC8vIEJ1ZyAjMTg4OiBTYWZhcmkgd2lsbCBzZXQgdGhlIGNvbnRleHQncyBzdGF0ZSB0byAnaW50ZXJydXB0ZWQnIGluIGNhc2UgdGhlIHVzZXIgc3dpdGNoZXMgdGFicy5cbiAgICAgICAgICBpZiAobmF0aXZlQXVkaW9Db250ZXh0Q29uc3RydWN0b3IubmFtZSA9PT0gJ3dlYmtpdEF1ZGlvQ29udGV4dCcpIHtcbiAgICAgICAgICAgIF90aGlzLl9uYXRpdmVHYWluTm9kZSA9IG5hdGl2ZUF1ZGlvQ29udGV4dC5jcmVhdGVHYWluKCk7XG4gICAgICAgICAgICBfdGhpcy5fbmF0aXZlT3NjaWxsYXRvck5vZGUgPSBuYXRpdmVBdWRpb0NvbnRleHQuY3JlYXRlT3NjaWxsYXRvcigpO1xuICAgICAgICAgICAgX3RoaXMuX25hdGl2ZUdhaW5Ob2RlLmdhaW4udmFsdWUgPSAxZS0zNztcbiAgICAgICAgICAgIF90aGlzLl9uYXRpdmVPc2NpbGxhdG9yTm9kZS5jb25uZWN0KF90aGlzLl9uYXRpdmVHYWluTm9kZSkuY29ubmVjdChuYXRpdmVBdWRpb0NvbnRleHQuZGVzdGluYXRpb24pO1xuICAgICAgICAgICAgX3RoaXMuX25hdGl2ZU9zY2lsbGF0b3JOb2RlLnN0YXJ0KCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF90aGlzLl9uYXRpdmVHYWluTm9kZSA9IG51bGw7XG4gICAgICAgICAgICBfdGhpcy5fbmF0aXZlT3NjaWxsYXRvck5vZGUgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBfdGhpcy5fc3RhdGUgPSBudWxsO1xuICAgICAgICAgIC8qXG4gICAgICAgICAgICogQnVnICMzNDogQ2hyb21lIGFuZCBFZGdlIHByZXRlbmQgdG8gYmUgcnVubmluZyByaWdodCBhd2F5LCBidXQgZmlyZSBhbiBvbnN0YXRlY2hhbmdlIGV2ZW50IHdoZW4gdGhlIHN0YXRlIGFjdHVhbGx5IGNoYW5nZXNcbiAgICAgICAgICAgKiB0byAncnVubmluZycuXG4gICAgICAgICAgICovXG4gICAgICAgICAgaWYgKG5hdGl2ZUF1ZGlvQ29udGV4dC5zdGF0ZSA9PT0gJ3J1bm5pbmcnKSB7XG4gICAgICAgICAgICBfdGhpcy5fc3RhdGUgPSAnc3VzcGVuZGVkJztcbiAgICAgICAgICAgIHZhciBfcmV2b2tlU3RhdGUgPSBmdW5jdGlvbiByZXZva2VTdGF0ZSgpIHtcbiAgICAgICAgICAgICAgaWYgKF90aGlzLl9zdGF0ZSA9PT0gJ3N1c3BlbmRlZCcpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fc3RhdGUgPSBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG5hdGl2ZUF1ZGlvQ29udGV4dC5yZW1vdmVFdmVudExpc3RlbmVyKCdzdGF0ZWNoYW5nZScsIF9yZXZva2VTdGF0ZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbmF0aXZlQXVkaW9Db250ZXh0LmFkZEV2ZW50TGlzdGVuZXIoJ3N0YXRlY2hhbmdlJywgX3Jldm9rZVN0YXRlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICB9XG4gICAgICAgIF9pbmhlcml0cyhBdWRpb0NvbnRleHQsIF9iYXNlQXVkaW9Db250ZXh0Q29ucyk7XG4gICAgICAgIHJldHVybiBfY3JlYXRlQ2xhc3MoQXVkaW9Db250ZXh0LCBbe1xuICAgICAgICAgIGtleTogXCJiYXNlTGF0ZW5jeVwiLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Jhc2VMYXRlbmN5O1xuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIGtleTogXCJzdGF0ZVwiLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXRlICE9PSBudWxsID8gdGhpcy5fc3RhdGUgOiB0aGlzLl9uYXRpdmVBdWRpb0NvbnRleHQuc3RhdGU7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcImNsb3NlXCIsXG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG4gICAgICAgICAgICAvLyBCdWcgIzM1OiBGaXJlZm94IGRvZXMgbm90IHRocm93IGFuIGVycm9yIGlmIHRoZSBBdWRpb0NvbnRleHQgd2FzIGNsb3NlZCBiZWZvcmUuXG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25hdGl2ZUF1ZGlvQ29udGV4dC5jbG9zZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRocm93IGNyZWF0ZUludmFsaWRTdGF0ZUVycm9yKCk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQnVnICMzNDogSWYgdGhlIHN0YXRlIHdhcyBzZXQgdG8gc3VzcGVuZGVkIGJlZm9yZSBpdCBzaG91bGQgYmUgcmV2b2tlZCBub3cuXG4gICAgICAgICAgICBpZiAodGhpcy5fc3RhdGUgPT09ICdzdXNwZW5kZWQnKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9uYXRpdmVBdWRpb0NvbnRleHQuY2xvc2UoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgaWYgKF90aGlzMi5fbmF0aXZlR2Fpbk5vZGUgIT09IG51bGwgJiYgX3RoaXMyLl9uYXRpdmVPc2NpbGxhdG9yTm9kZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIF90aGlzMi5fbmF0aXZlT3NjaWxsYXRvck5vZGUuc3RvcCgpO1xuICAgICAgICAgICAgICAgIF90aGlzMi5fbmF0aXZlR2Fpbk5vZGUuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgICAgIF90aGlzMi5fbmF0aXZlT3NjaWxsYXRvck5vZGUuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGRlYWN0aXZhdGVBdWRpb0dyYXBoKF90aGlzMik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBrZXk6IFwiY3JlYXRlTWVkaWFFbGVtZW50U291cmNlXCIsXG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZU1lZGlhRWxlbWVudFNvdXJjZShtZWRpYUVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgbWVkaWFFbGVtZW50QXVkaW9Tb3VyY2VOb2RlQ29uc3RydWN0b3IodGhpcywge1xuICAgICAgICAgICAgICBtZWRpYUVsZW1lbnQ6IG1lZGlhRWxlbWVudFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcImNyZWF0ZU1lZGlhU3RyZWFtRGVzdGluYXRpb25cIixcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlTWVkaWFTdHJlYW1EZXN0aW5hdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgbWVkaWFTdHJlYW1BdWRpb0Rlc3RpbmF0aW9uTm9kZUNvbnN0cnVjdG9yKHRoaXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIGtleTogXCJjcmVhdGVNZWRpYVN0cmVhbVNvdXJjZVwiLFxuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVNZWRpYVN0cmVhbVNvdXJjZShtZWRpYVN0cmVhbSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBtZWRpYVN0cmVhbUF1ZGlvU291cmNlTm9kZUNvbnN0cnVjdG9yKHRoaXMsIHtcbiAgICAgICAgICAgICAgbWVkaWFTdHJlYW06IG1lZGlhU3RyZWFtXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBrZXk6IFwiY3JlYXRlTWVkaWFTdHJlYW1UcmFja1NvdXJjZVwiLFxuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVNZWRpYVN0cmVhbVRyYWNrU291cmNlKG1lZGlhU3RyZWFtVHJhY2spIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgbWVkaWFTdHJlYW1UcmFja0F1ZGlvU291cmNlTm9kZUNvbnN0cnVjdG9yKHRoaXMsIHtcbiAgICAgICAgICAgICAgbWVkaWFTdHJlYW1UcmFjazogbWVkaWFTdHJlYW1UcmFja1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcInJlc3VtZVwiLFxuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZXN1bWUoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMzID0gdGhpcztcbiAgICAgICAgICAgIGlmICh0aGlzLl9zdGF0ZSA9PT0gJ3N1c3BlbmRlZCcpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3Jlc29sdmVQcm9taXNlID0gZnVuY3Rpb24gcmVzb2x2ZVByb21pc2UoKSB7XG4gICAgICAgICAgICAgICAgICBfdGhpczMuX25hdGl2ZUF1ZGlvQ29udGV4dC5yZW1vdmVFdmVudExpc3RlbmVyKCdzdGF0ZWNoYW5nZScsIF9yZXNvbHZlUHJvbWlzZSk7XG4gICAgICAgICAgICAgICAgICBpZiAoX3RoaXMzLl9uYXRpdmVBdWRpb0NvbnRleHQuc3RhdGUgPT09ICdydW5uaW5nJykge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBfdGhpczMucmVzdW1lKCkudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgX3RoaXMzLl9uYXRpdmVBdWRpb0NvbnRleHQuYWRkRXZlbnRMaXN0ZW5lcignc3RhdGVjaGFuZ2UnLCBfcmVzb2x2ZVByb21pc2UpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9uYXRpdmVBdWRpb0NvbnRleHQucmVzdW1lKClbXCJjYXRjaFwiXShmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgIC8vIEJ1ZyAjNTU6IENocm9tZSBhbmQgRWRnZSBkbyB0aHJvdyBhbiBJbnZhbGlkQWNjZXNzRXJyb3IgaW5zdGVhZCBvZiBhbiBJbnZhbGlkU3RhdGVFcnJvci5cbiAgICAgICAgICAgICAgLy8gQnVnICM1NjogU2FmYXJpIGludm9rZXMgdGhlIGNhdGNoIGhhbmRsZXIgYnV0IHdpdGhvdXQgYW4gZXJyb3IuXG4gICAgICAgICAgICAgIGlmIChlcnIgPT09IHVuZGVmaW5lZCB8fCBlcnIuY29kZSA9PT0gMTUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBjcmVhdGVJbnZhbGlkU3RhdGVFcnJvcigpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIGtleTogXCJzdXNwZW5kXCIsXG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHN1c3BlbmQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbmF0aXZlQXVkaW9Db250ZXh0LnN1c3BlbmQoKVtcImNhdGNoXCJdKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgLy8gQnVnICM1NjogU2FmYXJpIGludm9rZXMgdGhlIGNhdGNoIGhhbmRsZXIgYnV0IHdpdGhvdXQgYW4gZXJyb3IuXG4gICAgICAgICAgICAgIGlmIChlcnIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IGNyZWF0ZUludmFsaWRTdGF0ZUVycm9yKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XSk7XG4gICAgICB9KGJhc2VBdWRpb0NvbnRleHRDb25zdHJ1Y3Rvcik7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIF9jYWxsU3VwZXIkbyh0LCBvLCBlKSB7IHJldHVybiBvID0gX2dldFByb3RvdHlwZU9mKG8pLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0LCBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JG8oKSA/IFJlZmxlY3QuY29uc3RydWN0KG8sIGUgfHwgW10sIF9nZXRQcm90b3R5cGVPZih0KS5jb25zdHJ1Y3RvcikgOiBvLmFwcGx5KHQsIGUpKTsgfVxuICAgIGZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkbygpIHsgdHJ5IHsgdmFyIHQgPSAhQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyB9IGNhdGNoICh0KSB7fSByZXR1cm4gKF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkbyA9IGZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IHJldHVybiAhIXQ7IH0pKCk7IH1cbiAgICB2YXIgY3JlYXRlQXVkaW9EZXN0aW5hdGlvbk5vZGVDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uIGNyZWF0ZUF1ZGlvRGVzdGluYXRpb25Ob2RlQ29uc3RydWN0b3IoYXVkaW9Ob2RlQ29uc3RydWN0b3IsIGNyZWF0ZUF1ZGlvRGVzdGluYXRpb25Ob2RlUmVuZGVyZXIsIGNyZWF0ZUluZGV4U2l6ZUVycm9yLCBjcmVhdGVJbnZhbGlkU3RhdGVFcnJvciwgY3JlYXRlTmF0aXZlQXVkaW9EZXN0aW5hdGlvbk5vZGUsIGdldE5hdGl2ZUNvbnRleHQsIGlzTmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCwgcmVuZGVySW5wdXRzT2ZBdWRpb05vZGUpIHtcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9hdWRpb05vZGVDb25zdHJ1Y3Rvcikge1xuICAgICAgICBmdW5jdGlvbiBBdWRpb0Rlc3RpbmF0aW9uTm9kZShjb250ZXh0LCBjaGFubmVsQ291bnQpIHtcbiAgICAgICAgICB2YXIgX3RoaXM7XG4gICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEF1ZGlvRGVzdGluYXRpb25Ob2RlKTtcbiAgICAgICAgICB2YXIgbmF0aXZlQ29udGV4dCA9IGdldE5hdGl2ZUNvbnRleHQoY29udGV4dCk7XG4gICAgICAgICAgdmFyIGlzT2ZmbGluZSA9IGlzTmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dChuYXRpdmVDb250ZXh0KTtcbiAgICAgICAgICB2YXIgbmF0aXZlQXVkaW9EZXN0aW5hdGlvbk5vZGUgPSBjcmVhdGVOYXRpdmVBdWRpb0Rlc3RpbmF0aW9uTm9kZShuYXRpdmVDb250ZXh0LCBjaGFubmVsQ291bnQsIGlzT2ZmbGluZSk7XG4gICAgICAgICAgdmFyIGF1ZGlvRGVzdGluYXRpb25Ob2RlUmVuZGVyZXIgPSBpc09mZmxpbmUgPyBjcmVhdGVBdWRpb0Rlc3RpbmF0aW9uTm9kZVJlbmRlcmVyKHJlbmRlcklucHV0c09mQXVkaW9Ob2RlKSA6IG51bGw7XG4gICAgICAgICAgX3RoaXMgPSBfY2FsbFN1cGVyJG8odGhpcywgQXVkaW9EZXN0aW5hdGlvbk5vZGUsIFtjb250ZXh0LCBmYWxzZSwgbmF0aXZlQXVkaW9EZXN0aW5hdGlvbk5vZGUsIGF1ZGlvRGVzdGluYXRpb25Ob2RlUmVuZGVyZXJdKTtcbiAgICAgICAgICBfdGhpcy5faXNOb2RlT2ZOYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0ID0gaXNPZmZsaW5lO1xuICAgICAgICAgIF90aGlzLl9uYXRpdmVBdWRpb0Rlc3RpbmF0aW9uTm9kZSA9IG5hdGl2ZUF1ZGlvRGVzdGluYXRpb25Ob2RlO1xuICAgICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgICAgfVxuICAgICAgICBfaW5oZXJpdHMoQXVkaW9EZXN0aW5hdGlvbk5vZGUsIF9hdWRpb05vZGVDb25zdHJ1Y3Rvcik7XG4gICAgICAgIHJldHVybiBfY3JlYXRlQ2xhc3MoQXVkaW9EZXN0aW5hdGlvbk5vZGUsIFt7XG4gICAgICAgICAga2V5OiBcImNoYW5uZWxDb3VudFwiLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25hdGl2ZUF1ZGlvRGVzdGluYXRpb25Ob2RlLmNoYW5uZWxDb3VudDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgICAgICAvLyBCdWcgIzUyOiBDaHJvbWUsIEVkZ2UgJiBTYWZhcmkgZG8gbm90IHRocm93IGFuIGV4Y2VwdGlvbiBhdCBhbGwuXG4gICAgICAgICAgICAvLyBCdWcgIzU0OiBGaXJlZm94IGRvZXMgdGhyb3cgYW4gSW5kZXhTaXplRXJyb3IuXG4gICAgICAgICAgICBpZiAodGhpcy5faXNOb2RlT2ZOYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KSB7XG4gICAgICAgICAgICAgIHRocm93IGNyZWF0ZUludmFsaWRTdGF0ZUVycm9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBCdWcgIzQ3OiBUaGUgQXVkaW9EZXN0aW5hdGlvbk5vZGUgaW4gU2FmYXJpIGRvZXMgbm90IGluaXRpYWxpemUgdGhlIG1heENoYW5uZWxDb3VudCBwcm9wZXJ0eSBjb3JyZWN0bHkuXG4gICAgICAgICAgICBpZiAodmFsdWUgPiB0aGlzLl9uYXRpdmVBdWRpb0Rlc3RpbmF0aW9uTm9kZS5tYXhDaGFubmVsQ291bnQpIHtcbiAgICAgICAgICAgICAgdGhyb3cgY3JlYXRlSW5kZXhTaXplRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX25hdGl2ZUF1ZGlvRGVzdGluYXRpb25Ob2RlLmNoYW5uZWxDb3VudCA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIGtleTogXCJjaGFubmVsQ291bnRNb2RlXCIsXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbmF0aXZlQXVkaW9EZXN0aW5hdGlvbk5vZGUuY2hhbm5lbENvdW50TW9kZTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgICAgICAvLyBCdWcgIzUzOiBObyBicm93c2VyIGRvZXMgdGhyb3cgYW4gZXhjZXB0aW9uIHlldC5cbiAgICAgICAgICAgIGlmICh0aGlzLl9pc05vZGVPZk5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQpIHtcbiAgICAgICAgICAgICAgdGhyb3cgY3JlYXRlSW52YWxpZFN0YXRlRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX25hdGl2ZUF1ZGlvRGVzdGluYXRpb25Ob2RlLmNoYW5uZWxDb3VudE1vZGUgPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBrZXk6IFwibWF4Q2hhbm5lbENvdW50XCIsXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbmF0aXZlQXVkaW9EZXN0aW5hdGlvbk5vZGUubWF4Q2hhbm5lbENvdW50O1xuICAgICAgICAgIH1cbiAgICAgICAgfV0pO1xuICAgICAgfShhdWRpb05vZGVDb25zdHJ1Y3Rvcik7XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVBdWRpb0Rlc3RpbmF0aW9uTm9kZVJlbmRlcmVyID0gZnVuY3Rpb24gY3JlYXRlQXVkaW9EZXN0aW5hdGlvbk5vZGVSZW5kZXJlcihyZW5kZXJJbnB1dHNPZkF1ZGlvTm9kZSkge1xuICAgICAgdmFyIHJlbmRlcmVkTmF0aXZlQXVkaW9EZXN0aW5hdGlvbk5vZGVzID0gbmV3IFdlYWtNYXAoKTtcbiAgICAgIHZhciBjcmVhdGVBdWRpb0Rlc3RpbmF0aW9uTm9kZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfcmVmID0gX2FzeW5jVG9HZW5lcmF0b3IoLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlKHByb3h5LCBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KSB7XG4gICAgICAgICAgdmFyIG5hdGl2ZUF1ZGlvRGVzdGluYXRpb25Ob2RlO1xuICAgICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgICAgICAgIHdoaWxlICgxKSBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBuYXRpdmVBdWRpb0Rlc3RpbmF0aW9uTm9kZSA9IG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQuZGVzdGluYXRpb247XG4gICAgICAgICAgICAgICAgcmVuZGVyZWROYXRpdmVBdWRpb0Rlc3RpbmF0aW9uTm9kZXMuc2V0KG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQsIG5hdGl2ZUF1ZGlvRGVzdGluYXRpb25Ob2RlKTtcbiAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNDtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVuZGVySW5wdXRzT2ZBdWRpb05vZGUocHJveHksIG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQsIG5hdGl2ZUF1ZGlvRGVzdGluYXRpb25Ob2RlKTtcbiAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgbmF0aXZlQXVkaW9EZXN0aW5hdGlvbk5vZGUpO1xuICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIF9jYWxsZWUpO1xuICAgICAgICB9KSk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBjcmVhdGVBdWRpb0Rlc3RpbmF0aW9uTm9kZShfeCwgX3gyKSB7XG4gICAgICAgICAgcmV0dXJuIF9yZWYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICAgIH0oKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKHByb3h5LCBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KSB7XG4gICAgICAgICAgdmFyIHJlbmRlcmVkTmF0aXZlQXVkaW9EZXN0aW5hdGlvbk5vZGUgPSByZW5kZXJlZE5hdGl2ZUF1ZGlvRGVzdGluYXRpb25Ob2Rlcy5nZXQobmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCk7XG4gICAgICAgICAgaWYgKHJlbmRlcmVkTmF0aXZlQXVkaW9EZXN0aW5hdGlvbk5vZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZW5kZXJlZE5hdGl2ZUF1ZGlvRGVzdGluYXRpb25Ob2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZUF1ZGlvRGVzdGluYXRpb25Ob2RlKHByb3h5LCBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZUF1ZGlvTGlzdGVuZXJGYWN0b3J5ID0gZnVuY3Rpb24gY3JlYXRlQXVkaW9MaXN0ZW5lckZhY3RvcnkoY3JlYXRlQXVkaW9QYXJhbSwgY3JlYXRlTmF0aXZlQ2hhbm5lbE1lcmdlck5vZGUsIGNyZWF0ZU5hdGl2ZUNvbnN0YW50U291cmNlTm9kZSwgY3JlYXRlTmF0aXZlU2NyaXB0UHJvY2Vzc29yTm9kZSwgY3JlYXRlTm90U3VwcG9ydGVkRXJyb3IsIGdldEZpcnN0U2FtcGxlLCBpc05hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQsIG92ZXJ3cml0ZUFjY2Vzc29ycykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChjb250ZXh0LCBuYXRpdmVDb250ZXh0KSB7XG4gICAgICAgIHZhciBuYXRpdmVMaXN0ZW5lciA9IG5hdGl2ZUNvbnRleHQubGlzdGVuZXI7XG4gICAgICAgIC8vIEJ1ZyAjMTE3OiBPbmx5IENocm9tZSAmIEVkZ2Ugc3VwcG9ydCB0aGUgbmV3IGludGVyZmFjZSBhbHJlYWR5LlxuICAgICAgICB2YXIgY3JlYXRlRmFrZUF1ZGlvUGFyYW1zID0gZnVuY3Rpb24gY3JlYXRlRmFrZUF1ZGlvUGFyYW1zKCkge1xuICAgICAgICAgIHZhciBidWZmZXIgPSBuZXcgRmxvYXQzMkFycmF5KDEpO1xuICAgICAgICAgIHZhciBjaGFubmVsTWVyZ2VyTm9kZSA9IGNyZWF0ZU5hdGl2ZUNoYW5uZWxNZXJnZXJOb2RlKG5hdGl2ZUNvbnRleHQsIHtcbiAgICAgICAgICAgIGNoYW5uZWxDb3VudDogMSxcbiAgICAgICAgICAgIGNoYW5uZWxDb3VudE1vZGU6ICdleHBsaWNpdCcsXG4gICAgICAgICAgICBjaGFubmVsSW50ZXJwcmV0YXRpb246ICdzcGVha2VycycsXG4gICAgICAgICAgICBudW1iZXJPZklucHV0czogOVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHZhciBpc09mZmxpbmUgPSBpc05hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQobmF0aXZlQ29udGV4dCk7XG4gICAgICAgICAgdmFyIGlzU2NyaXB0UHJvY2Vzc29yTm9kZUNyZWF0ZWQgPSBmYWxzZTtcbiAgICAgICAgICB2YXIgbGFzdE9yaWVudGF0aW9uID0gWzAsIDAsIC0xLCAwLCAxLCAwXTtcbiAgICAgICAgICB2YXIgbGFzdFBvc2l0aW9uID0gWzAsIDAsIDBdO1xuICAgICAgICAgIHZhciBjcmVhdGVTY3JpcHRQcm9jZXNzb3JOb2RlID0gZnVuY3Rpb24gY3JlYXRlU2NyaXB0UHJvY2Vzc29yTm9kZSgpIHtcbiAgICAgICAgICAgIGlmIChpc1NjcmlwdFByb2Nlc3Nvck5vZGVDcmVhdGVkKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlzU2NyaXB0UHJvY2Vzc29yTm9kZUNyZWF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIHNjcmlwdFByb2Nlc3Nvck5vZGUgPSBjcmVhdGVOYXRpdmVTY3JpcHRQcm9jZXNzb3JOb2RlKG5hdGl2ZUNvbnRleHQsIDI1NiwgOSwgMCk7XG4gICAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6ZGVwcmVjYXRpb25cbiAgICAgICAgICAgIHNjcmlwdFByb2Nlc3Nvck5vZGUub25hdWRpb3Byb2Nlc3MgPSBmdW5jdGlvbiAoX3JlZikge1xuICAgICAgICAgICAgICB2YXIgaW5wdXRCdWZmZXIgPSBfcmVmLmlucHV0QnVmZmVyO1xuICAgICAgICAgICAgICB2YXIgb3JpZW50YXRpb24gPSBbZ2V0Rmlyc3RTYW1wbGUoaW5wdXRCdWZmZXIsIGJ1ZmZlciwgMCksIGdldEZpcnN0U2FtcGxlKGlucHV0QnVmZmVyLCBidWZmZXIsIDEpLCBnZXRGaXJzdFNhbXBsZShpbnB1dEJ1ZmZlciwgYnVmZmVyLCAyKSwgZ2V0Rmlyc3RTYW1wbGUoaW5wdXRCdWZmZXIsIGJ1ZmZlciwgMyksIGdldEZpcnN0U2FtcGxlKGlucHV0QnVmZmVyLCBidWZmZXIsIDQpLCBnZXRGaXJzdFNhbXBsZShpbnB1dEJ1ZmZlciwgYnVmZmVyLCA1KV07XG4gICAgICAgICAgICAgIGlmIChvcmllbnRhdGlvbi5zb21lKGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgIT09IGxhc3RPcmllbnRhdGlvbltpbmRleF07XG4gICAgICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICAgICAgbmF0aXZlTGlzdGVuZXIuc2V0T3JpZW50YXRpb24uYXBwbHkobmF0aXZlTGlzdGVuZXIsIG9yaWVudGF0aW9uKTsgLy8gdHNsaW50OmRpc2FibGUtbGluZTpkZXByZWNhdGlvblxuICAgICAgICAgICAgICAgIGxhc3RPcmllbnRhdGlvbiA9IG9yaWVudGF0aW9uO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhciBwb3NpdG9uID0gW2dldEZpcnN0U2FtcGxlKGlucHV0QnVmZmVyLCBidWZmZXIsIDYpLCBnZXRGaXJzdFNhbXBsZShpbnB1dEJ1ZmZlciwgYnVmZmVyLCA3KSwgZ2V0Rmlyc3RTYW1wbGUoaW5wdXRCdWZmZXIsIGJ1ZmZlciwgOCldO1xuICAgICAgICAgICAgICBpZiAocG9zaXRvbi5zb21lKGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgIT09IGxhc3RQb3NpdGlvbltpbmRleF07XG4gICAgICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICAgICAgbmF0aXZlTGlzdGVuZXIuc2V0UG9zaXRpb24uYXBwbHkobmF0aXZlTGlzdGVuZXIsIHBvc2l0b24pOyAvLyB0c2xpbnQ6ZGlzYWJsZS1saW5lOmRlcHJlY2F0aW9uXG4gICAgICAgICAgICAgICAgbGFzdFBvc2l0aW9uID0gcG9zaXRvbjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNoYW5uZWxNZXJnZXJOb2RlLmNvbm5lY3Qoc2NyaXB0UHJvY2Vzc29yTm9kZSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICB2YXIgY3JlYXRlU2V0T3JpZW50YXRpb24gPSBmdW5jdGlvbiBjcmVhdGVTZXRPcmllbnRhdGlvbihpbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICBpZiAodmFsdWUgIT09IGxhc3RPcmllbnRhdGlvbltpbmRleF0pIHtcbiAgICAgICAgICAgICAgICBsYXN0T3JpZW50YXRpb25baW5kZXhdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgbmF0aXZlTGlzdGVuZXIuc2V0T3JpZW50YXRpb24uYXBwbHkobmF0aXZlTGlzdGVuZXIsIF90b0NvbnN1bWFibGVBcnJheShsYXN0T3JpZW50YXRpb24pKTsgLy8gdHNsaW50OmRpc2FibGUtbGluZTpkZXByZWNhdGlvblxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH07XG4gICAgICAgICAgdmFyIGNyZWF0ZVNldFBvc2l0aW9uID0gZnVuY3Rpb24gY3JlYXRlU2V0UG9zaXRpb24oaW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSBsYXN0UG9zaXRpb25baW5kZXhdKSB7XG4gICAgICAgICAgICAgICAgbGFzdFBvc2l0aW9uW2luZGV4XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIG5hdGl2ZUxpc3RlbmVyLnNldFBvc2l0aW9uLmFwcGx5KG5hdGl2ZUxpc3RlbmVyLCBfdG9Db25zdW1hYmxlQXJyYXkobGFzdFBvc2l0aW9uKSk7IC8vIHRzbGludDpkaXNhYmxlLWxpbmU6ZGVwcmVjYXRpb25cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIHZhciBjcmVhdGVGYWtlQXVkaW9QYXJhbSA9IGZ1bmN0aW9uIGNyZWF0ZUZha2VBdWRpb1BhcmFtKGlucHV0LCBpbml0aWFsVmFsdWUsIHNldFZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgY29uc3RhbnRTb3VyY2VOb2RlID0gY3JlYXRlTmF0aXZlQ29uc3RhbnRTb3VyY2VOb2RlKG5hdGl2ZUNvbnRleHQsIHtcbiAgICAgICAgICAgICAgY2hhbm5lbENvdW50OiAxLFxuICAgICAgICAgICAgICBjaGFubmVsQ291bnRNb2RlOiAnZXhwbGljaXQnLFxuICAgICAgICAgICAgICBjaGFubmVsSW50ZXJwcmV0YXRpb246ICdkaXNjcmV0ZScsXG4gICAgICAgICAgICAgIG9mZnNldDogaW5pdGlhbFZhbHVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0YW50U291cmNlTm9kZS5jb25uZWN0KGNoYW5uZWxNZXJnZXJOb2RlLCAwLCBpbnB1dCk7XG4gICAgICAgICAgICAvLyBAdG9kbyBUaGlzIHNob3VsZCBiZSBzdG9wcGVkIHdoZW4gdGhlIGNvbnRleHQgaXMgY2xvc2VkLlxuICAgICAgICAgICAgY29uc3RhbnRTb3VyY2VOb2RlLnN0YXJ0KCk7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29uc3RhbnRTb3VyY2VOb2RlLm9mZnNldCwgJ2RlZmF1bHRWYWx1ZScsIHtcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGluaXRpYWxWYWx1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogQnVnICM2MiAmICM3NDogU2FmYXJpIGRvZXMgbm90IHN1cHBvcnQgQ29uc3RhbnRTb3VyY2VOb2RlcyBhbmQgZG9lcyBub3QgZXhwb3J0IHRoZSBjb3JyZWN0IHZhbHVlcyBmb3IgbWF4VmFsdWUgYW5kXG4gICAgICAgICAgICAgKiBtaW5WYWx1ZSBmb3IgR2Fpbk5vZGVzLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2YXIgYXVkaW9QYXJhbSA9IGNyZWF0ZUF1ZGlvUGFyYW0oe1xuICAgICAgICAgICAgICBjb250ZXh0OiBjb250ZXh0XG4gICAgICAgICAgICB9LCBpc09mZmxpbmUsIGNvbnN0YW50U291cmNlTm9kZS5vZmZzZXQsIE1PU1RfUE9TSVRJVkVfU0lOR0xFX0ZMT0FULCBNT1NUX05FR0FUSVZFX1NJTkdMRV9GTE9BVCk7XG4gICAgICAgICAgICBvdmVyd3JpdGVBY2Nlc3NvcnMoYXVkaW9QYXJhbSwgJ3ZhbHVlJywgZnVuY3Rpb24gKGdldCkge1xuICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXQuY2FsbChhdWRpb1BhcmFtKTtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChzZXQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICBzZXQuY2FsbChhdWRpb1BhcmFtLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoZXJyLmNvZGUgIT09IDkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjcmVhdGVTY3JpcHRQcm9jZXNzb3JOb2RlKCk7XG4gICAgICAgICAgICAgICAgaWYgKGlzT2ZmbGluZSkge1xuICAgICAgICAgICAgICAgICAgLy8gQnVnICMxMTc6IFVzaW5nIHNldE9yaWVudGF0aW9uKCkgYW5kIHNldFBvc2l0aW9uKCkgZG9lc24ndCB3b3JrIHdpdGggYW4gT2ZmbGluZUF1ZGlvQ29udGV4dC5cbiAgICAgICAgICAgICAgICAgIHNldFZhbHVlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGF1ZGlvUGFyYW0uY2FuY2VsQW5kSG9sZEF0VGltZSA9IGZ1bmN0aW9uIChjYW5jZWxBbmRIb2xkQXRUaW1lKSB7XG4gICAgICAgICAgICAgIGlmIChpc09mZmxpbmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgY3JlYXRlTm90U3VwcG9ydGVkRXJyb3IoKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgICAgICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBjYW5jZWxBbmRIb2xkQXRUaW1lLmFwcGx5KGF1ZGlvUGFyYW0sIGFyZ3MpO1xuICAgICAgICAgICAgICAgIGNyZWF0ZVNjcmlwdFByb2Nlc3Nvck5vZGUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KGF1ZGlvUGFyYW0uY2FuY2VsQW5kSG9sZEF0VGltZSk7XG4gICAgICAgICAgICBhdWRpb1BhcmFtLmNhbmNlbFNjaGVkdWxlZFZhbHVlcyA9IGZ1bmN0aW9uIChjYW5jZWxTY2hlZHVsZWRWYWx1ZXMpIHtcbiAgICAgICAgICAgICAgaWYgKGlzT2ZmbGluZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBjcmVhdGVOb3RTdXBwb3J0ZWRFcnJvcigpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgICAgICAgICAgIGFyZ3NbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gY2FuY2VsU2NoZWR1bGVkVmFsdWVzLmFwcGx5KGF1ZGlvUGFyYW0sIGFyZ3MpO1xuICAgICAgICAgICAgICAgIGNyZWF0ZVNjcmlwdFByb2Nlc3Nvck5vZGUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KGF1ZGlvUGFyYW0uY2FuY2VsU2NoZWR1bGVkVmFsdWVzKTtcbiAgICAgICAgICAgIGF1ZGlvUGFyYW0uZXhwb25lbnRpYWxSYW1wVG9WYWx1ZUF0VGltZSA9IGZ1bmN0aW9uIChleHBvbmVudGlhbFJhbXBUb1ZhbHVlQXRUaW1lKSB7XG4gICAgICAgICAgICAgIGlmIChpc09mZmxpbmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgY3JlYXRlTm90U3VwcG9ydGVkRXJyb3IoKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2xlbjMgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4zKSwgX2tleTMgPSAwOyBfa2V5MyA8IF9sZW4zOyBfa2V5MysrKSB7XG4gICAgICAgICAgICAgICAgICBhcmdzW19rZXkzXSA9IGFyZ3VtZW50c1tfa2V5M107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGV4cG9uZW50aWFsUmFtcFRvVmFsdWVBdFRpbWUuYXBwbHkoYXVkaW9QYXJhbSwgYXJncyk7XG4gICAgICAgICAgICAgICAgY3JlYXRlU2NyaXB0UHJvY2Vzc29yTm9kZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0oYXVkaW9QYXJhbS5leHBvbmVudGlhbFJhbXBUb1ZhbHVlQXRUaW1lKTtcbiAgICAgICAgICAgIGF1ZGlvUGFyYW0ubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUgPSBmdW5jdGlvbiAobGluZWFyUmFtcFRvVmFsdWVBdFRpbWUpIHtcbiAgICAgICAgICAgICAgaWYgKGlzT2ZmbGluZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBjcmVhdGVOb3RTdXBwb3J0ZWRFcnJvcigpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfbGVuNCA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjQpLCBfa2V5NCA9IDA7IF9rZXk0IDwgX2xlbjQ7IF9rZXk0KyspIHtcbiAgICAgICAgICAgICAgICAgIGFyZ3NbX2tleTRdID0gYXJndW1lbnRzW19rZXk0XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gbGluZWFyUmFtcFRvVmFsdWVBdFRpbWUuYXBwbHkoYXVkaW9QYXJhbSwgYXJncyk7XG4gICAgICAgICAgICAgICAgY3JlYXRlU2NyaXB0UHJvY2Vzc29yTm9kZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0oYXVkaW9QYXJhbS5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZSk7XG4gICAgICAgICAgICBhdWRpb1BhcmFtLnNldFRhcmdldEF0VGltZSA9IGZ1bmN0aW9uIChzZXRUYXJnZXRBdFRpbWUpIHtcbiAgICAgICAgICAgICAgaWYgKGlzT2ZmbGluZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBjcmVhdGVOb3RTdXBwb3J0ZWRFcnJvcigpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfbGVuNSA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjUpLCBfa2V5NSA9IDA7IF9rZXk1IDwgX2xlbjU7IF9rZXk1KyspIHtcbiAgICAgICAgICAgICAgICAgIGFyZ3NbX2tleTVdID0gYXJndW1lbnRzW19rZXk1XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gc2V0VGFyZ2V0QXRUaW1lLmFwcGx5KGF1ZGlvUGFyYW0sIGFyZ3MpO1xuICAgICAgICAgICAgICAgIGNyZWF0ZVNjcmlwdFByb2Nlc3Nvck5vZGUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KGF1ZGlvUGFyYW0uc2V0VGFyZ2V0QXRUaW1lKTtcbiAgICAgICAgICAgIGF1ZGlvUGFyYW0uc2V0VmFsdWVBdFRpbWUgPSBmdW5jdGlvbiAoc2V0VmFsdWVBdFRpbWUpIHtcbiAgICAgICAgICAgICAgaWYgKGlzT2ZmbGluZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBjcmVhdGVOb3RTdXBwb3J0ZWRFcnJvcigpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfbGVuNiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjYpLCBfa2V5NiA9IDA7IF9rZXk2IDwgX2xlbjY7IF9rZXk2KyspIHtcbiAgICAgICAgICAgICAgICAgIGFyZ3NbX2tleTZdID0gYXJndW1lbnRzW19rZXk2XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gc2V0VmFsdWVBdFRpbWUuYXBwbHkoYXVkaW9QYXJhbSwgYXJncyk7XG4gICAgICAgICAgICAgICAgY3JlYXRlU2NyaXB0UHJvY2Vzc29yTm9kZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0oYXVkaW9QYXJhbS5zZXRWYWx1ZUF0VGltZSk7XG4gICAgICAgICAgICBhdWRpb1BhcmFtLnNldFZhbHVlQ3VydmVBdFRpbWUgPSBmdW5jdGlvbiAoc2V0VmFsdWVDdXJ2ZUF0VGltZSkge1xuICAgICAgICAgICAgICBpZiAoaXNPZmZsaW5lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IGNyZWF0ZU5vdFN1cHBvcnRlZEVycm9yKCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9sZW43ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNyksIF9rZXk3ID0gMDsgX2tleTcgPCBfbGVuNzsgX2tleTcrKykge1xuICAgICAgICAgICAgICAgICAgYXJnc1tfa2V5N10gPSBhcmd1bWVudHNbX2tleTddO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBzZXRWYWx1ZUN1cnZlQXRUaW1lLmFwcGx5KGF1ZGlvUGFyYW0sIGFyZ3MpO1xuICAgICAgICAgICAgICAgIGNyZWF0ZVNjcmlwdFByb2Nlc3Nvck5vZGUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KGF1ZGlvUGFyYW0uc2V0VmFsdWVDdXJ2ZUF0VGltZSk7XG4gICAgICAgICAgICByZXR1cm4gYXVkaW9QYXJhbTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmb3J3YXJkWDogY3JlYXRlRmFrZUF1ZGlvUGFyYW0oMCwgMCwgY3JlYXRlU2V0T3JpZW50YXRpb24oMCkpLFxuICAgICAgICAgICAgZm9yd2FyZFk6IGNyZWF0ZUZha2VBdWRpb1BhcmFtKDEsIDAsIGNyZWF0ZVNldE9yaWVudGF0aW9uKDEpKSxcbiAgICAgICAgICAgIGZvcndhcmRaOiBjcmVhdGVGYWtlQXVkaW9QYXJhbSgyLCAtMSwgY3JlYXRlU2V0T3JpZW50YXRpb24oMikpLFxuICAgICAgICAgICAgcG9zaXRpb25YOiBjcmVhdGVGYWtlQXVkaW9QYXJhbSg2LCAwLCBjcmVhdGVTZXRQb3NpdGlvbigwKSksXG4gICAgICAgICAgICBwb3NpdGlvblk6IGNyZWF0ZUZha2VBdWRpb1BhcmFtKDcsIDAsIGNyZWF0ZVNldFBvc2l0aW9uKDEpKSxcbiAgICAgICAgICAgIHBvc2l0aW9uWjogY3JlYXRlRmFrZUF1ZGlvUGFyYW0oOCwgMCwgY3JlYXRlU2V0UG9zaXRpb24oMikpLFxuICAgICAgICAgICAgdXBYOiBjcmVhdGVGYWtlQXVkaW9QYXJhbSgzLCAwLCBjcmVhdGVTZXRPcmllbnRhdGlvbigzKSksXG4gICAgICAgICAgICB1cFk6IGNyZWF0ZUZha2VBdWRpb1BhcmFtKDQsIDEsIGNyZWF0ZVNldE9yaWVudGF0aW9uKDQpKSxcbiAgICAgICAgICAgIHVwWjogY3JlYXRlRmFrZUF1ZGlvUGFyYW0oNSwgMCwgY3JlYXRlU2V0T3JpZW50YXRpb24oNSkpXG4gICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIF9yZWYyID0gbmF0aXZlTGlzdGVuZXIuZm9yd2FyZFggPT09IHVuZGVmaW5lZCA/IGNyZWF0ZUZha2VBdWRpb1BhcmFtcygpIDogbmF0aXZlTGlzdGVuZXIsXG4gICAgICAgICAgZm9yd2FyZFggPSBfcmVmMi5mb3J3YXJkWCxcbiAgICAgICAgICBmb3J3YXJkWSA9IF9yZWYyLmZvcndhcmRZLFxuICAgICAgICAgIGZvcndhcmRaID0gX3JlZjIuZm9yd2FyZFosXG4gICAgICAgICAgcG9zaXRpb25YID0gX3JlZjIucG9zaXRpb25YLFxuICAgICAgICAgIHBvc2l0aW9uWSA9IF9yZWYyLnBvc2l0aW9uWSxcbiAgICAgICAgICBwb3NpdGlvblogPSBfcmVmMi5wb3NpdGlvblosXG4gICAgICAgICAgdXBYID0gX3JlZjIudXBYLFxuICAgICAgICAgIHVwWSA9IF9yZWYyLnVwWSxcbiAgICAgICAgICB1cFogPSBfcmVmMi51cFo7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZ2V0IGZvcndhcmRYKCkge1xuICAgICAgICAgICAgcmV0dXJuIGZvcndhcmRYO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZ2V0IGZvcndhcmRZKCkge1xuICAgICAgICAgICAgcmV0dXJuIGZvcndhcmRZO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZ2V0IGZvcndhcmRaKCkge1xuICAgICAgICAgICAgcmV0dXJuIGZvcndhcmRaO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZ2V0IHBvc2l0aW9uWCgpIHtcbiAgICAgICAgICAgIHJldHVybiBwb3NpdGlvblg7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBnZXQgcG9zaXRpb25ZKCkge1xuICAgICAgICAgICAgcmV0dXJuIHBvc2l0aW9uWTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGdldCBwb3NpdGlvblooKSB7XG4gICAgICAgICAgICByZXR1cm4gcG9zaXRpb25aO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZ2V0IHVwWCgpIHtcbiAgICAgICAgICAgIHJldHVybiB1cFg7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBnZXQgdXBZKCkge1xuICAgICAgICAgICAgcmV0dXJuIHVwWTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGdldCB1cFooKSB7XG4gICAgICAgICAgICByZXR1cm4gdXBaO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBpc0F1ZGlvTm9kZSA9IGZ1bmN0aW9uIGlzQXVkaW9Ob2RlKGF1ZGlvTm9kZU9yQXVkaW9QYXJhbSkge1xuICAgICAgcmV0dXJuICdjb250ZXh0JyBpbiBhdWRpb05vZGVPckF1ZGlvUGFyYW07XG4gICAgfTtcblxuICAgIHZhciBpc0F1ZGlvTm9kZU91dHB1dENvbm5lY3Rpb24gPSBmdW5jdGlvbiBpc0F1ZGlvTm9kZU91dHB1dENvbm5lY3Rpb24ob3V0cHV0Q29ubmVjdGlvbikge1xuICAgICAgcmV0dXJuIGlzQXVkaW9Ob2RlKG91dHB1dENvbm5lY3Rpb25bMF0pO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciRhKHIsIGUpIHsgdmFyIHQgPSBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBTeW1ib2wgJiYgcltTeW1ib2wuaXRlcmF0b3JdIHx8IHJbXCJAQGl0ZXJhdG9yXCJdOyBpZiAoIXQpIHsgaWYgKEFycmF5LmlzQXJyYXkocikgfHwgKHQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkYShyKSkgfHwgZSkgeyB0ICYmIChyID0gdCk7IHZhciBfbiA9IDAsIEYgPSBmdW5jdGlvbiBGKCkge307IHJldHVybiB7IHM6IEYsIG46IGZ1bmN0aW9uIG4oKSB7IHJldHVybiBfbiA+PSByLmxlbmd0aCA/IHsgZG9uZTogITAgfSA6IHsgZG9uZTogITEsIHZhbHVlOiByW19uKytdIH07IH0sIGU6IGZ1bmN0aW9uIGUocikgeyB0aHJvdyByOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBvLCBhID0gITAsIHUgPSAhMTsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgdCA9IHQuY2FsbChyKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHIgPSB0Lm5leHQoKTsgcmV0dXJuIGEgPSByLmRvbmUsIHI7IH0sIGU6IGZ1bmN0aW9uIGUocikgeyB1ID0gITAsIG8gPSByOyB9LCBmOiBmdW5jdGlvbiBmKCkgeyB0cnkgeyBhIHx8IG51bGwgPT0gdFtcInJldHVyblwiXSB8fCB0W1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmICh1KSB0aHJvdyBvOyB9IH0gfTsgfVxuICAgIGZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSRhKHIsIGEpIHsgaWYgKHIpIHsgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIHIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheSRhKHIsIGEpOyB2YXIgdCA9IHt9LnRvU3RyaW5nLmNhbGwocikuc2xpY2UoOCwgLTEpOyByZXR1cm4gXCJPYmplY3RcIiA9PT0gdCAmJiByLmNvbnN0cnVjdG9yICYmICh0ID0gci5jb25zdHJ1Y3Rvci5uYW1lKSwgXCJNYXBcIiA9PT0gdCB8fCBcIlNldFwiID09PSB0ID8gQXJyYXkuZnJvbShyKSA6IFwiQXJndW1lbnRzXCIgPT09IHQgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QodCkgPyBfYXJyYXlMaWtlVG9BcnJheSRhKHIsIGEpIDogdm9pZCAwOyB9IH1cbiAgICBmdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheSRhKHIsIGEpIHsgKG51bGwgPT0gYSB8fCBhID4gci5sZW5ndGgpICYmIChhID0gci5sZW5ndGgpOyBmb3IgKHZhciBlID0gMCwgbiA9IEFycmF5KGEpOyBlIDwgYTsgZSsrKSBuW2VdID0gcltlXTsgcmV0dXJuIG47IH1cbiAgICB2YXIgaW5zZXJ0RWxlbWVudEluU2V0ID0gZnVuY3Rpb24gaW5zZXJ0RWxlbWVudEluU2V0KHNldCwgZWxlbWVudCwgcHJlZGljYXRlLCBpZ25vcmVEdXBsaWNhdGVzKSB7XG4gICAgICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkYShzZXQpLFxuICAgICAgICBfc3RlcDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIGxtbnQgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICBpZiAocHJlZGljYXRlKGxtbnQpKSB7XG4gICAgICAgICAgICBpZiAoaWdub3JlRHVwbGljYXRlcykge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBFcnJvcignVGhlIHNldCBjb250YWlucyBhdCBsZWFzdCBvbmUgc2ltaWxhciBlbGVtZW50LicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IuZigpO1xuICAgICAgfVxuICAgICAgc2V0LmFkZChlbGVtZW50KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICB2YXIgYWRkQWN0aXZlSW5wdXRDb25uZWN0aW9uVG9BdWRpb1BhcmFtID0gZnVuY3Rpb24gYWRkQWN0aXZlSW5wdXRDb25uZWN0aW9uVG9BdWRpb1BhcmFtKGFjdGl2ZUlucHV0cywgc291cmNlLCBfcmVmLCBpZ25vcmVEdXBsaWNhdGVzKSB7XG4gICAgICB2YXIgX3JlZjIgPSBfc2xpY2VkVG9BcnJheShfcmVmLCAyKSxcbiAgICAgICAgb3V0cHV0ID0gX3JlZjJbMF0sXG4gICAgICAgIGV2ZW50TGlzdGVuZXIgPSBfcmVmMlsxXTtcbiAgICAgIGluc2VydEVsZW1lbnRJblNldChhY3RpdmVJbnB1dHMsIFtzb3VyY2UsIG91dHB1dCwgZXZlbnRMaXN0ZW5lcl0sIGZ1bmN0aW9uIChhY3RpdmVJbnB1dENvbm5lY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIGFjdGl2ZUlucHV0Q29ubmVjdGlvblswXSA9PT0gc291cmNlICYmIGFjdGl2ZUlucHV0Q29ubmVjdGlvblsxXSA9PT0gb3V0cHV0O1xuICAgICAgfSwgaWdub3JlRHVwbGljYXRlcyk7XG4gICAgfTtcblxuICAgIHZhciBhZGRQYXNzaXZlSW5wdXRDb25uZWN0aW9uVG9BdWRpb1BhcmFtID0gZnVuY3Rpb24gYWRkUGFzc2l2ZUlucHV0Q29ubmVjdGlvblRvQXVkaW9QYXJhbShwYXNzaXZlSW5wdXRzLCBfcmVmLCBpZ25vcmVEdXBsaWNhdGVzKSB7XG4gICAgICB2YXIgX3JlZjIgPSBfc2xpY2VkVG9BcnJheShfcmVmLCAzKSxcbiAgICAgICAgc291cmNlID0gX3JlZjJbMF0sXG4gICAgICAgIG91dHB1dCA9IF9yZWYyWzFdLFxuICAgICAgICBldmVudExpc3RlbmVyID0gX3JlZjJbMl07XG4gICAgICB2YXIgcGFzc2l2ZUlucHV0Q29ubmVjdGlvbnMgPSBwYXNzaXZlSW5wdXRzLmdldChzb3VyY2UpO1xuICAgICAgaWYgKHBhc3NpdmVJbnB1dENvbm5lY3Rpb25zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcGFzc2l2ZUlucHV0cy5zZXQoc291cmNlLCBuZXcgU2V0KFtbb3V0cHV0LCBldmVudExpc3RlbmVyXV0pKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluc2VydEVsZW1lbnRJblNldChwYXNzaXZlSW5wdXRDb25uZWN0aW9ucywgW291dHB1dCwgZXZlbnRMaXN0ZW5lcl0sIGZ1bmN0aW9uIChwYXNzaXZlSW5wdXRDb25uZWN0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIHBhc3NpdmVJbnB1dENvbm5lY3Rpb25bMF0gPT09IG91dHB1dDtcbiAgICAgICAgfSwgaWdub3JlRHVwbGljYXRlcyk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBpc05hdGl2ZUF1ZGlvTm9kZUZha2VyID0gZnVuY3Rpb24gaXNOYXRpdmVBdWRpb05vZGVGYWtlcihuYXRpdmVBdWRpb05vZGVPck5hdGl2ZUF1ZGlvTm9kZUZha2VyKSB7XG4gICAgICByZXR1cm4gJ2lucHV0cycgaW4gbmF0aXZlQXVkaW9Ob2RlT3JOYXRpdmVBdWRpb05vZGVGYWtlcjtcbiAgICB9O1xuXG4gICAgdmFyIGNvbm5lY3ROYXRpdmVBdWRpb05vZGVUb05hdGl2ZUF1ZGlvTm9kZSA9IGZ1bmN0aW9uIGNvbm5lY3ROYXRpdmVBdWRpb05vZGVUb05hdGl2ZUF1ZGlvTm9kZShuYXRpdmVTb3VyY2VBdWRpb05vZGUsIG5hdGl2ZURlc3RpbmF0aW9uQXVkaW9Ob2RlLCBvdXRwdXQsIGlucHV0KSB7XG4gICAgICBpZiAoaXNOYXRpdmVBdWRpb05vZGVGYWtlcihuYXRpdmVEZXN0aW5hdGlvbkF1ZGlvTm9kZSkpIHtcbiAgICAgICAgdmFyIGZha2VOYXRpdmVEZXN0aW5hdGlvbkF1ZGlvTm9kZSA9IG5hdGl2ZURlc3RpbmF0aW9uQXVkaW9Ob2RlLmlucHV0c1tpbnB1dF07XG4gICAgICAgIG5hdGl2ZVNvdXJjZUF1ZGlvTm9kZS5jb25uZWN0KGZha2VOYXRpdmVEZXN0aW5hdGlvbkF1ZGlvTm9kZSwgb3V0cHV0LCAwKTtcbiAgICAgICAgcmV0dXJuIFtmYWtlTmF0aXZlRGVzdGluYXRpb25BdWRpb05vZGUsIG91dHB1dCwgMF07XG4gICAgICB9XG4gICAgICBuYXRpdmVTb3VyY2VBdWRpb05vZGUuY29ubmVjdChuYXRpdmVEZXN0aW5hdGlvbkF1ZGlvTm9kZSwgb3V0cHV0LCBpbnB1dCk7XG4gICAgICByZXR1cm4gW25hdGl2ZURlc3RpbmF0aW9uQXVkaW9Ob2RlLCBvdXRwdXQsIGlucHV0XTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkOShyLCBlKSB7IHZhciB0ID0gXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgU3ltYm9sICYmIHJbU3ltYm9sLml0ZXJhdG9yXSB8fCByW1wiQEBpdGVyYXRvclwiXTsgaWYgKCF0KSB7IGlmIChBcnJheS5pc0FycmF5KHIpIHx8ICh0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5JDkocikpIHx8IGUpIHsgdCAmJiAociA9IHQpOyB2YXIgX24gPSAwLCBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyByZXR1cm4gX24gPj0gci5sZW5ndGggPyB7IGRvbmU6ICEwIH0gOiB7IGRvbmU6ICExLCB2YWx1ZTogcltfbisrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKHIpIHsgdGhyb3cgcjsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbywgYSA9ICEwLCB1ID0gITE7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IHQgPSB0LmNhbGwocik7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciByID0gdC5uZXh0KCk7IHJldHVybiBhID0gci5kb25lLCByOyB9LCBlOiBmdW5jdGlvbiBlKHIpIHsgdSA9ICEwLCBvID0gcjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgYSB8fCBudWxsID09IHRbXCJyZXR1cm5cIl0gfHwgdFtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAodSkgdGhyb3cgbzsgfSB9IH07IH1cbiAgICBmdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkOShyLCBhKSB7IGlmIChyKSB7IGlmIChcInN0cmluZ1wiID09IHR5cGVvZiByKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkkOShyLCBhKTsgdmFyIHQgPSB7fS50b1N0cmluZy5jYWxsKHIpLnNsaWNlKDgsIC0xKTsgcmV0dXJuIFwiT2JqZWN0XCIgPT09IHQgJiYgci5jb25zdHJ1Y3RvciAmJiAodCA9IHIuY29uc3RydWN0b3IubmFtZSksIFwiTWFwXCIgPT09IHQgfHwgXCJTZXRcIiA9PT0gdCA/IEFycmF5LmZyb20ocikgOiBcIkFyZ3VtZW50c1wiID09PSB0IHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KHQpID8gX2FycmF5TGlrZVRvQXJyYXkkOShyLCBhKSA6IHZvaWQgMDsgfSB9XG4gICAgZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkkOShyLCBhKSB7IChudWxsID09IGEgfHwgYSA+IHIubGVuZ3RoKSAmJiAoYSA9IHIubGVuZ3RoKTsgZm9yICh2YXIgZSA9IDAsIG4gPSBBcnJheShhKTsgZSA8IGE7IGUrKykgbltlXSA9IHJbZV07IHJldHVybiBuOyB9XG4gICAgdmFyIGRlbGV0ZUFjdGl2ZUlucHV0Q29ubmVjdGlvbiA9IGZ1bmN0aW9uIGRlbGV0ZUFjdGl2ZUlucHV0Q29ubmVjdGlvbihhY3RpdmVJbnB1dENvbm5lY3Rpb25zLCBzb3VyY2UsIG91dHB1dCkge1xuICAgICAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDkoYWN0aXZlSW5wdXRDb25uZWN0aW9ucyksXG4gICAgICAgIF9zdGVwO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgYWN0aXZlSW5wdXRDb25uZWN0aW9uID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgaWYgKGFjdGl2ZUlucHV0Q29ubmVjdGlvblswXSA9PT0gc291cmNlICYmIGFjdGl2ZUlucHV0Q29ubmVjdGlvblsxXSA9PT0gb3V0cHV0KSB7XG4gICAgICAgICAgICBhY3RpdmVJbnB1dENvbm5lY3Rpb25zW1wiZGVsZXRlXCJdKGFjdGl2ZUlucHV0Q29ubmVjdGlvbik7XG4gICAgICAgICAgICByZXR1cm4gYWN0aXZlSW5wdXRDb25uZWN0aW9uO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IuZigpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIHZhciBkZWxldGVBY3RpdmVJbnB1dENvbm5lY3Rpb25Ub0F1ZGlvUGFyYW0gPSBmdW5jdGlvbiBkZWxldGVBY3RpdmVJbnB1dENvbm5lY3Rpb25Ub0F1ZGlvUGFyYW0oYWN0aXZlSW5wdXRzLCBzb3VyY2UsIG91dHB1dCkge1xuICAgICAgcmV0dXJuIHBpY2tFbGVtZW50RnJvbVNldChhY3RpdmVJbnB1dHMsIGZ1bmN0aW9uIChhY3RpdmVJbnB1dENvbm5lY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIGFjdGl2ZUlucHV0Q29ubmVjdGlvblswXSA9PT0gc291cmNlICYmIGFjdGl2ZUlucHV0Q29ubmVjdGlvblsxXSA9PT0gb3V0cHV0O1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHZhciBkZWxldGVFdmVudExpc3RlbmVyT2ZBdWRpb05vZGUgPSBmdW5jdGlvbiBkZWxldGVFdmVudExpc3RlbmVyT2ZBdWRpb05vZGUoYXVkaW9Ob2RlLCBldmVudExpc3RlbmVyKSB7XG4gICAgICB2YXIgZXZlbnRMaXN0ZW5lcnMgPSBnZXRFdmVudExpc3RlbmVyc09mQXVkaW9Ob2RlKGF1ZGlvTm9kZSk7XG4gICAgICBpZiAoIWV2ZW50TGlzdGVuZXJzW1wiZGVsZXRlXCJdKGV2ZW50TGlzdGVuZXIpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyB0aGUgZXhwZWN0ZWQgZXZlbnQgbGlzdGVuZXIuJyk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBkZWxldGVQYXNzaXZlSW5wdXRDb25uZWN0aW9uVG9BdWRpb1BhcmFtID0gZnVuY3Rpb24gZGVsZXRlUGFzc2l2ZUlucHV0Q29ubmVjdGlvblRvQXVkaW9QYXJhbShwYXNzaXZlSW5wdXRzLCBzb3VyY2UsIG91dHB1dCkge1xuICAgICAgdmFyIHBhc3NpdmVJbnB1dENvbm5lY3Rpb25zID0gZ2V0VmFsdWVGb3JLZXkocGFzc2l2ZUlucHV0cywgc291cmNlKTtcbiAgICAgIHZhciBtYXRjaGluZ0Nvbm5lY3Rpb24gPSBwaWNrRWxlbWVudEZyb21TZXQocGFzc2l2ZUlucHV0Q29ubmVjdGlvbnMsIGZ1bmN0aW9uIChwYXNzaXZlSW5wdXRDb25uZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBwYXNzaXZlSW5wdXRDb25uZWN0aW9uWzBdID09PSBvdXRwdXQ7XG4gICAgICB9KTtcbiAgICAgIGlmIChwYXNzaXZlSW5wdXRDb25uZWN0aW9ucy5zaXplID09PSAwKSB7XG4gICAgICAgIHBhc3NpdmVJbnB1dHNbXCJkZWxldGVcIl0oc291cmNlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXRjaGluZ0Nvbm5lY3Rpb247XG4gICAgfTtcblxuICAgIHZhciBkaXNjb25uZWN0TmF0aXZlQXVkaW9Ob2RlRnJvbU5hdGl2ZUF1ZGlvTm9kZSA9IGZ1bmN0aW9uIGRpc2Nvbm5lY3ROYXRpdmVBdWRpb05vZGVGcm9tTmF0aXZlQXVkaW9Ob2RlKG5hdGl2ZVNvdXJjZUF1ZGlvTm9kZSwgbmF0aXZlRGVzdGluYXRpb25BdWRpb05vZGUsIG91dHB1dCwgaW5wdXQpIHtcbiAgICAgIGlmIChpc05hdGl2ZUF1ZGlvTm9kZUZha2VyKG5hdGl2ZURlc3RpbmF0aW9uQXVkaW9Ob2RlKSkge1xuICAgICAgICBuYXRpdmVTb3VyY2VBdWRpb05vZGUuZGlzY29ubmVjdChuYXRpdmVEZXN0aW5hdGlvbkF1ZGlvTm9kZS5pbnB1dHNbaW5wdXRdLCBvdXRwdXQsIDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmF0aXZlU291cmNlQXVkaW9Ob2RlLmRpc2Nvbm5lY3QobmF0aXZlRGVzdGluYXRpb25BdWRpb05vZGUsIG91dHB1dCwgaW5wdXQpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgZ2V0TmF0aXZlQXVkaW9Ob2RlID0gZnVuY3Rpb24gZ2V0TmF0aXZlQXVkaW9Ob2RlKGF1ZGlvTm9kZSkge1xuICAgICAgcmV0dXJuIGdldFZhbHVlRm9yS2V5KEFVRElPX05PREVfU1RPUkUsIGF1ZGlvTm9kZSk7XG4gICAgfTtcblxuICAgIHZhciBnZXROYXRpdmVBdWRpb1BhcmFtID0gZnVuY3Rpb24gZ2V0TmF0aXZlQXVkaW9QYXJhbShhdWRpb1BhcmFtKSB7XG4gICAgICByZXR1cm4gZ2V0VmFsdWVGb3JLZXkoQVVESU9fUEFSQU1fU1RPUkUsIGF1ZGlvUGFyYW0pO1xuICAgIH07XG5cbiAgICB2YXIgaXNQYXJ0T2ZBQ3ljbGUgPSBmdW5jdGlvbiBpc1BhcnRPZkFDeWNsZShhdWRpb05vZGUpIHtcbiAgICAgIHJldHVybiBDWUNMRV9DT1VOVEVSUy5oYXMoYXVkaW9Ob2RlKTtcbiAgICB9O1xuXG4gICAgdmFyIGlzUGFzc2l2ZUF1ZGlvTm9kZSA9IGZ1bmN0aW9uIGlzUGFzc2l2ZUF1ZGlvTm9kZShhdWRpb05vZGUpIHtcbiAgICAgIHJldHVybiAhQUNUSVZFX0FVRElPX05PREVfU1RPUkUuaGFzKGF1ZGlvTm9kZSk7XG4gICAgfTtcblxuICAgIHZhciB0ZXN0QXVkaW9Ob2RlRGlzY29ubmVjdE1ldGhvZFN1cHBvcnQgPSBmdW5jdGlvbiB0ZXN0QXVkaW9Ob2RlRGlzY29ubmVjdE1ldGhvZFN1cHBvcnQobmF0aXZlQXVkaW9Db250ZXh0LCBuYXRpdmVBdWRpb1dvcmtsZXROb2RlQ29uc3RydWN0b3IpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAvKlxuICAgICAgICAgKiBUaGlzIGJ1ZyBleGlzdGVkIGluIFNhZmFyaSB1cCB1bnRpbCB2MTQuMC4yLiBTaW5jZSBBdWRpb1dvcmtsZXRzIHdlcmUgbm90IHN1cHBvcnRlZCBpbiBTYWZhcmkgdW50aWwgdjE0LjEgdGhlIHByZXNlbmNlIG9mIHRoZVxuICAgICAgICAgKiBjb25zdHJ1Y3RvciBmb3IgYW4gQXVkaW9Xb3JrbGV0Tm9kZSBjYW4gYmUgdXNlZCBoZXJlIHRvIHNraXAgdGhlIHRlc3QuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAobmF0aXZlQXVkaW9Xb3JrbGV0Tm9kZUNvbnN0cnVjdG9yICE9PSBudWxsKSB7XG4gICAgICAgICAgcmVzb2x2ZSh0cnVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgYW5hbHl6ZXIgPSBuYXRpdmVBdWRpb0NvbnRleHQuY3JlYXRlU2NyaXB0UHJvY2Vzc29yKDI1NiwgMSwgMSk7IC8vIHRzbGludDpkaXNhYmxlLWxpbmUgZGVwcmVjYXRpb25cbiAgICAgICAgICB2YXIgZHVtbXkgPSBuYXRpdmVBdWRpb0NvbnRleHQuY3JlYXRlR2FpbigpO1xuICAgICAgICAgIC8vIEJ1ZyAjOTU6IFNhZmFyaSBkb2VzIG5vdCBwbGF5IG9uZSBzYW1wbGUgYnVmZmVycy5cbiAgICAgICAgICB2YXIgb25lcyA9IG5hdGl2ZUF1ZGlvQ29udGV4dC5jcmVhdGVCdWZmZXIoMSwgMiwgNDQxMDApO1xuICAgICAgICAgIHZhciBjaGFubmVsRGF0YSA9IG9uZXMuZ2V0Q2hhbm5lbERhdGEoMCk7XG4gICAgICAgICAgY2hhbm5lbERhdGFbMF0gPSAxO1xuICAgICAgICAgIGNoYW5uZWxEYXRhWzFdID0gMTtcbiAgICAgICAgICB2YXIgc291cmNlID0gbmF0aXZlQXVkaW9Db250ZXh0LmNyZWF0ZUJ1ZmZlclNvdXJjZSgpO1xuICAgICAgICAgIHNvdXJjZS5idWZmZXIgPSBvbmVzO1xuICAgICAgICAgIHNvdXJjZS5sb29wID0gdHJ1ZTtcbiAgICAgICAgICBzb3VyY2UuY29ubmVjdChhbmFseXplcikuY29ubmVjdChuYXRpdmVBdWRpb0NvbnRleHQuZGVzdGluYXRpb24pO1xuICAgICAgICAgIHNvdXJjZS5jb25uZWN0KGR1bW15KTtcbiAgICAgICAgICBzb3VyY2UuZGlzY29ubmVjdChkdW1teSk7XG4gICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOmRlcHJlY2F0aW9uXG4gICAgICAgICAgYW5hbHl6ZXIub25hdWRpb3Byb2Nlc3MgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBjaG5ubER0ID0gZXZlbnQuaW5wdXRCdWZmZXIuZ2V0Q2hhbm5lbERhdGEoMCk7IC8vIHRzbGludDpkaXNhYmxlLWxpbmUgZGVwcmVjYXRpb25cbiAgICAgICAgICAgIGlmIChBcnJheS5wcm90b3R5cGUuc29tZS5jYWxsKGNobm5sRHQsIGZ1bmN0aW9uIChzYW1wbGUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHNhbXBsZSA9PT0gMTtcbiAgICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICAgIHJlc29sdmUodHJ1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXNvbHZlKGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNvdXJjZS5zdG9wKCk7XG4gICAgICAgICAgICBhbmFseXplci5vbmF1ZGlvcHJvY2VzcyA9IG51bGw7IC8vIHRzbGludDpkaXNhYmxlLWxpbmU6ZGVwcmVjYXRpb25cbiAgICAgICAgICAgIHNvdXJjZS5kaXNjb25uZWN0KGFuYWx5emVyKTtcbiAgICAgICAgICAgIGFuYWx5emVyLmRpc2Nvbm5lY3QobmF0aXZlQXVkaW9Db250ZXh0LmRlc3RpbmF0aW9uKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIHNvdXJjZS5zdGFydCgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkOChyLCBlKSB7IHZhciB0ID0gXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgU3ltYm9sICYmIHJbU3ltYm9sLml0ZXJhdG9yXSB8fCByW1wiQEBpdGVyYXRvclwiXTsgaWYgKCF0KSB7IGlmIChBcnJheS5pc0FycmF5KHIpIHx8ICh0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5JDgocikpIHx8IGUpIHsgdCAmJiAociA9IHQpOyB2YXIgX24gPSAwLCBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyByZXR1cm4gX24gPj0gci5sZW5ndGggPyB7IGRvbmU6ICEwIH0gOiB7IGRvbmU6ICExLCB2YWx1ZTogcltfbisrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKHIpIHsgdGhyb3cgcjsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbywgYSA9ICEwLCB1ID0gITE7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IHQgPSB0LmNhbGwocik7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciByID0gdC5uZXh0KCk7IHJldHVybiBhID0gci5kb25lLCByOyB9LCBlOiBmdW5jdGlvbiBlKHIpIHsgdSA9ICEwLCBvID0gcjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgYSB8fCBudWxsID09IHRbXCJyZXR1cm5cIl0gfHwgdFtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAodSkgdGhyb3cgbzsgfSB9IH07IH1cbiAgICBmdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkOChyLCBhKSB7IGlmIChyKSB7IGlmIChcInN0cmluZ1wiID09IHR5cGVvZiByKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkkOChyLCBhKTsgdmFyIHQgPSB7fS50b1N0cmluZy5jYWxsKHIpLnNsaWNlKDgsIC0xKTsgcmV0dXJuIFwiT2JqZWN0XCIgPT09IHQgJiYgci5jb25zdHJ1Y3RvciAmJiAodCA9IHIuY29uc3RydWN0b3IubmFtZSksIFwiTWFwXCIgPT09IHQgfHwgXCJTZXRcIiA9PT0gdCA/IEFycmF5LmZyb20ocikgOiBcIkFyZ3VtZW50c1wiID09PSB0IHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KHQpID8gX2FycmF5TGlrZVRvQXJyYXkkOChyLCBhKSA6IHZvaWQgMDsgfSB9XG4gICAgZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkkOChyLCBhKSB7IChudWxsID09IGEgfHwgYSA+IHIubGVuZ3RoKSAmJiAoYSA9IHIubGVuZ3RoKTsgZm9yICh2YXIgZSA9IDAsIG4gPSBBcnJheShhKTsgZSA8IGE7IGUrKykgbltlXSA9IHJbZV07IHJldHVybiBuOyB9XG4gICAgdmFyIHZpc2l0RWFjaEF1ZGlvTm9kZU9uY2UgPSBmdW5jdGlvbiB2aXNpdEVhY2hBdWRpb05vZGVPbmNlKGN5Y2xlcywgdmlzaXRvcikge1xuICAgICAgdmFyIGNvdW50cyA9IG5ldyBNYXAoKTtcbiAgICAgIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQ4KGN5Y2xlcyksXG4gICAgICAgIF9zdGVwO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgY3ljbGUgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICB2YXIgX2l0ZXJhdG9yMiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDgoY3ljbGUpLFxuICAgICAgICAgICAgX3N0ZXAyO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKF9pdGVyYXRvcjIucygpOyAhKF9zdGVwMiA9IF9pdGVyYXRvcjIubigpKS5kb25lOykge1xuICAgICAgICAgICAgICB2YXIgYXVkaW9Ob2RlID0gX3N0ZXAyLnZhbHVlO1xuICAgICAgICAgICAgICB2YXIgY291bnQgPSBjb3VudHMuZ2V0KGF1ZGlvTm9kZSk7XG4gICAgICAgICAgICAgIGNvdW50cy5zZXQoYXVkaW9Ob2RlLCBjb3VudCA9PT0gdW5kZWZpbmVkID8gMSA6IGNvdW50ICsgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBfaXRlcmF0b3IyLmUoZXJyKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgX2l0ZXJhdG9yMi5mKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvci5mKCk7XG4gICAgICB9XG4gICAgICBjb3VudHMuZm9yRWFjaChmdW5jdGlvbiAoY291bnQsIGF1ZGlvTm9kZSkge1xuICAgICAgICByZXR1cm4gdmlzaXRvcihhdWRpb05vZGUsIGNvdW50KTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICB2YXIgaXNOYXRpdmVBdWRpb05vZGUkMSA9IGZ1bmN0aW9uIGlzTmF0aXZlQXVkaW9Ob2RlKG5hdGl2ZUF1ZGlvTm9kZU9yQXVkaW9QYXJhbSkge1xuICAgICAgcmV0dXJuICdjb250ZXh0JyBpbiBuYXRpdmVBdWRpb05vZGVPckF1ZGlvUGFyYW07XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDcociwgZSkgeyB2YXIgdCA9IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIFN5bWJvbCAmJiByW1N5bWJvbC5pdGVyYXRvcl0gfHwgcltcIkBAaXRlcmF0b3JcIl07IGlmICghdCkgeyBpZiAoQXJyYXkuaXNBcnJheShyKSB8fCAodCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSQ3KHIpKSB8fCBlKSB7IHQgJiYgKHIgPSB0KTsgdmFyIF9uID0gMCwgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgcmV0dXJuIF9uID49IHIubGVuZ3RoID8geyBkb25lOiAhMCB9IDogeyBkb25lOiAhMSwgdmFsdWU6IHJbX24rK10gfTsgfSwgZTogZnVuY3Rpb24gZShyKSB7IHRocm93IHI7IH0sIGY6IEYgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH0gdmFyIG8sIGEgPSAhMCwgdSA9ICExOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyB0ID0gdC5jYWxsKHIpOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgciA9IHQubmV4dCgpOyByZXR1cm4gYSA9IHIuZG9uZSwgcjsgfSwgZTogZnVuY3Rpb24gZShyKSB7IHUgPSAhMCwgbyA9IHI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGEgfHwgbnVsbCA9PSB0W1wicmV0dXJuXCJdIHx8IHRbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKHUpIHRocm93IG87IH0gfSB9OyB9XG4gICAgZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5JDcociwgYSkgeyBpZiAocikgeyBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgcikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5JDcociwgYSk7IHZhciB0ID0ge30udG9TdHJpbmcuY2FsbChyKS5zbGljZSg4LCAtMSk7IHJldHVybiBcIk9iamVjdFwiID09PSB0ICYmIHIuY29uc3RydWN0b3IgJiYgKHQgPSByLmNvbnN0cnVjdG9yLm5hbWUpLCBcIk1hcFwiID09PSB0IHx8IFwiU2V0XCIgPT09IHQgPyBBcnJheS5mcm9tKHIpIDogXCJBcmd1bWVudHNcIiA9PT0gdCB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdCh0KSA/IF9hcnJheUxpa2VUb0FycmF5JDcociwgYSkgOiB2b2lkIDA7IH0gfVxuICAgIGZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5JDcociwgYSkgeyAobnVsbCA9PSBhIHx8IGEgPiByLmxlbmd0aCkgJiYgKGEgPSByLmxlbmd0aCk7IGZvciAodmFyIGUgPSAwLCBuID0gQXJyYXkoYSk7IGUgPCBhOyBlKyspIG5bZV0gPSByW2VdOyByZXR1cm4gbjsgfVxuICAgIHZhciB3cmFwQXVkaW9Ob2RlRGlzY29ubmVjdE1ldGhvZCA9IGZ1bmN0aW9uIHdyYXBBdWRpb05vZGVEaXNjb25uZWN0TWV0aG9kKG5hdGl2ZUF1ZGlvTm9kZSkge1xuICAgICAgdmFyIGNvbm5lY3Rpb25zID0gbmV3IE1hcCgpO1xuICAgICAgbmF0aXZlQXVkaW9Ob2RlLmNvbm5lY3QgPSBmdW5jdGlvbiAoY29ubmVjdCkge1xuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6aW52YWxpZC12b2lkIG5vLWluZmVycmFibGUtdHlwZXNcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkZXN0aW5hdGlvbikge1xuICAgICAgICAgIHZhciBvdXRwdXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDA7XG4gICAgICAgICAgdmFyIGlucHV0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAwO1xuICAgICAgICAgIHZhciByZXR1cm5WYWx1ZSA9IGlzTmF0aXZlQXVkaW9Ob2RlJDEoZGVzdGluYXRpb24pID8gY29ubmVjdChkZXN0aW5hdGlvbiwgb3V0cHV0LCBpbnB1dCkgOiBjb25uZWN0KGRlc3RpbmF0aW9uLCBvdXRwdXQpO1xuICAgICAgICAgIC8vIFNhdmUgdGhlIG5ldyBjb25uZWN0aW9uIG9ubHkgaWYgdGhlIGNhbGxzIHRvIGNvbm5lY3QgYWJvdmUgZGlkbid0IHRocm93IGFuIGVycm9yLlxuICAgICAgICAgIHZhciBjb25uZWN0aW9uc1RvRGVzdGluYXRpb24gPSBjb25uZWN0aW9ucy5nZXQoZGVzdGluYXRpb24pO1xuICAgICAgICAgIGlmIChjb25uZWN0aW9uc1RvRGVzdGluYXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29ubmVjdGlvbnMuc2V0KGRlc3RpbmF0aW9uLCBbe1xuICAgICAgICAgICAgICBpbnB1dDogaW5wdXQsXG4gICAgICAgICAgICAgIG91dHB1dDogb3V0cHV0XG4gICAgICAgICAgICB9XSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChjb25uZWN0aW9uc1RvRGVzdGluYXRpb24uZXZlcnkoZnVuY3Rpb24gKGNvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb24uaW5wdXQgIT09IGlucHV0IHx8IGNvbm5lY3Rpb24ub3V0cHV0ICE9PSBvdXRwdXQ7XG4gICAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgICBjb25uZWN0aW9uc1RvRGVzdGluYXRpb24ucHVzaCh7XG4gICAgICAgICAgICAgICAgaW5wdXQ6IGlucHV0LFxuICAgICAgICAgICAgICAgIG91dHB1dDogb3V0cHV0XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gICAgICAgIH07XG4gICAgICB9KG5hdGl2ZUF1ZGlvTm9kZS5jb25uZWN0LmJpbmQobmF0aXZlQXVkaW9Ob2RlKSk7XG4gICAgICBuYXRpdmVBdWRpb05vZGUuZGlzY29ubmVjdCA9IGZ1bmN0aW9uIChkaXNjb25uZWN0KSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZGVzdGluYXRpb25Pck91dHB1dCwgb3V0cHV0LCBpbnB1dCkge1xuICAgICAgICAgIGRpc2Nvbm5lY3QuYXBwbHkobmF0aXZlQXVkaW9Ob2RlKTtcbiAgICAgICAgICBpZiAoZGVzdGluYXRpb25Pck91dHB1dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25uZWN0aW9ucy5jbGVhcigpO1xuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGRlc3RpbmF0aW9uT3JPdXRwdXQgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkNyhjb25uZWN0aW9ucyksXG4gICAgICAgICAgICAgIF9zdGVwO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICAgICAgICB2YXIgX3N0ZXAkdmFsdWUgPSBfc2xpY2VkVG9BcnJheShfc3RlcC52YWx1ZSwgMiksXG4gICAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbiA9IF9zdGVwJHZhbHVlWzBdLFxuICAgICAgICAgICAgICAgICAgY29ubmVjdGlvbnNUb0Rlc3RpbmF0aW9uID0gX3N0ZXAkdmFsdWVbMV07XG4gICAgICAgICAgICAgICAgdmFyIGZpbHRlcmVkQ29ubmVjdGlvbnMgPSBjb25uZWN0aW9uc1RvRGVzdGluYXRpb24uZmlsdGVyKGZ1bmN0aW9uIChjb25uZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gY29ubmVjdGlvbi5vdXRwdXQgIT09IGRlc3RpbmF0aW9uT3JPdXRwdXQ7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKGZpbHRlcmVkQ29ubmVjdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICBjb25uZWN0aW9uc1tcImRlbGV0ZVwiXShkZXN0aW5hdGlvbik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25zLnNldChkZXN0aW5hdGlvbiwgZmlsdGVyZWRDb25uZWN0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgIF9pdGVyYXRvci5mKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChjb25uZWN0aW9ucy5oYXMoZGVzdGluYXRpb25Pck91dHB1dCkpIHtcbiAgICAgICAgICAgIGlmIChvdXRwdXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBjb25uZWN0aW9uc1tcImRlbGV0ZVwiXShkZXN0aW5hdGlvbk9yT3V0cHV0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhciBfY29ubmVjdGlvbnNUb0Rlc3RpbmF0aW9uID0gY29ubmVjdGlvbnMuZ2V0KGRlc3RpbmF0aW9uT3JPdXRwdXQpO1xuICAgICAgICAgICAgICBpZiAoX2Nvbm5lY3Rpb25zVG9EZXN0aW5hdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9maWx0ZXJlZENvbm5lY3Rpb25zID0gX2Nvbm5lY3Rpb25zVG9EZXN0aW5hdGlvbi5maWx0ZXIoZnVuY3Rpb24gKGNvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBjb25uZWN0aW9uLm91dHB1dCAhPT0gb3V0cHV0ICYmIChjb25uZWN0aW9uLmlucHV0ICE9PSBpbnB1dCB8fCBpbnB1dCA9PT0gdW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoX2ZpbHRlcmVkQ29ubmVjdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICBjb25uZWN0aW9uc1tcImRlbGV0ZVwiXShkZXN0aW5hdGlvbk9yT3V0cHV0KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgY29ubmVjdGlvbnMuc2V0KGRlc3RpbmF0aW9uT3JPdXRwdXQsIF9maWx0ZXJlZENvbm5lY3Rpb25zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIF9pdGVyYXRvcjIgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQ3KGNvbm5lY3Rpb25zKSxcbiAgICAgICAgICAgIF9zdGVwMjtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoKSB7XG4gICAgICAgICAgICAgIHZhciBfc3RlcDIkdmFsdWUgPSBfc2xpY2VkVG9BcnJheShfc3RlcDIudmFsdWUsIDIpLFxuICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uID0gX3N0ZXAyJHZhbHVlWzBdLFxuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25zVG9EZXN0aW5hdGlvbiA9IF9zdGVwMiR2YWx1ZVsxXTtcbiAgICAgICAgICAgICAgY29ubmVjdGlvbnNUb0Rlc3RpbmF0aW9uLmZvckVhY2goZnVuY3Rpb24gKGNvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNOYXRpdmVBdWRpb05vZGUkMShkZXN0aW5hdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgIG5hdGl2ZUF1ZGlvTm9kZS5jb25uZWN0KGRlc3RpbmF0aW9uLCBjb25uZWN0aW9uLm91dHB1dCwgY29ubmVjdGlvbi5pbnB1dCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIG5hdGl2ZUF1ZGlvTm9kZS5jb25uZWN0KGRlc3RpbmF0aW9uLCBjb25uZWN0aW9uLm91dHB1dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBmb3IgKF9pdGVyYXRvcjIucygpOyAhKF9zdGVwMiA9IF9pdGVyYXRvcjIubigpKS5kb25lOykge1xuICAgICAgICAgICAgICBfbG9vcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgX2l0ZXJhdG9yMi5lKGVycik7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIF9pdGVyYXRvcjIuZigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH0obmF0aXZlQXVkaW9Ob2RlLmRpc2Nvbm5lY3QpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBfY2FsbFN1cGVyJG4odCwgbywgZSkgeyByZXR1cm4gbyA9IF9nZXRQcm90b3R5cGVPZihvKSwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odCwgX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRuKCkgPyBSZWZsZWN0LmNvbnN0cnVjdChvLCBlIHx8IFtdLCBfZ2V0UHJvdG90eXBlT2YodCkuY29uc3RydWN0b3IpIDogby5hcHBseSh0LCBlKSk7IH1cbiAgICBmdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JG4oKSB7IHRyeSB7IHZhciB0ID0gIUJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgfSBjYXRjaCAodCkge30gcmV0dXJuIChfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JG4gPSBmdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyByZXR1cm4gISF0OyB9KSgpOyB9XG4gICAgZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkNihyLCBlKSB7IHZhciB0ID0gXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgU3ltYm9sICYmIHJbU3ltYm9sLml0ZXJhdG9yXSB8fCByW1wiQEBpdGVyYXRvclwiXTsgaWYgKCF0KSB7IGlmIChBcnJheS5pc0FycmF5KHIpIHx8ICh0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5JDYocikpIHx8IGUpIHsgdCAmJiAociA9IHQpOyB2YXIgX24gPSAwLCBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyByZXR1cm4gX24gPj0gci5sZW5ndGggPyB7IGRvbmU6ICEwIH0gOiB7IGRvbmU6ICExLCB2YWx1ZTogcltfbisrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKHIpIHsgdGhyb3cgcjsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbywgYSA9ICEwLCB1ID0gITE7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IHQgPSB0LmNhbGwocik7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciByID0gdC5uZXh0KCk7IHJldHVybiBhID0gci5kb25lLCByOyB9LCBlOiBmdW5jdGlvbiBlKHIpIHsgdSA9ICEwLCBvID0gcjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgYSB8fCBudWxsID09IHRbXCJyZXR1cm5cIl0gfHwgdFtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAodSkgdGhyb3cgbzsgfSB9IH07IH1cbiAgICBmdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkNihyLCBhKSB7IGlmIChyKSB7IGlmIChcInN0cmluZ1wiID09IHR5cGVvZiByKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkkNihyLCBhKTsgdmFyIHQgPSB7fS50b1N0cmluZy5jYWxsKHIpLnNsaWNlKDgsIC0xKTsgcmV0dXJuIFwiT2JqZWN0XCIgPT09IHQgJiYgci5jb25zdHJ1Y3RvciAmJiAodCA9IHIuY29uc3RydWN0b3IubmFtZSksIFwiTWFwXCIgPT09IHQgfHwgXCJTZXRcIiA9PT0gdCA/IEFycmF5LmZyb20ocikgOiBcIkFyZ3VtZW50c1wiID09PSB0IHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KHQpID8gX2FycmF5TGlrZVRvQXJyYXkkNihyLCBhKSA6IHZvaWQgMDsgfSB9XG4gICAgZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkkNihyLCBhKSB7IChudWxsID09IGEgfHwgYSA+IHIubGVuZ3RoKSAmJiAoYSA9IHIubGVuZ3RoKTsgZm9yICh2YXIgZSA9IDAsIG4gPSBBcnJheShhKTsgZSA8IGE7IGUrKykgbltlXSA9IHJbZV07IHJldHVybiBuOyB9XG4gICAgdmFyIGFkZENvbm5lY3Rpb25Ub0F1ZGlvUGFyYW1PZkF1ZGlvQ29udGV4dCA9IGZ1bmN0aW9uIGFkZENvbm5lY3Rpb25Ub0F1ZGlvUGFyYW1PZkF1ZGlvQ29udGV4dChzb3VyY2UsIGRlc3RpbmF0aW9uLCBvdXRwdXQsIGlzT2ZmbGluZSkge1xuICAgICAgdmFyIF9nZXRBdWRpb1BhcmFtQ29ubmVjdCA9IGdldEF1ZGlvUGFyYW1Db25uZWN0aW9ucyhkZXN0aW5hdGlvbiksXG4gICAgICAgIGFjdGl2ZUlucHV0cyA9IF9nZXRBdWRpb1BhcmFtQ29ubmVjdC5hY3RpdmVJbnB1dHMsXG4gICAgICAgIHBhc3NpdmVJbnB1dHMgPSBfZ2V0QXVkaW9QYXJhbUNvbm5lY3QucGFzc2l2ZUlucHV0cztcbiAgICAgIHZhciBfZ2V0QXVkaW9Ob2RlQ29ubmVjdGkgPSBnZXRBdWRpb05vZGVDb25uZWN0aW9ucyhzb3VyY2UpLFxuICAgICAgICBvdXRwdXRzID0gX2dldEF1ZGlvTm9kZUNvbm5lY3RpLm91dHB1dHM7XG4gICAgICB2YXIgZXZlbnRMaXN0ZW5lcnMgPSBnZXRFdmVudExpc3RlbmVyc09mQXVkaW9Ob2RlKHNvdXJjZSk7XG4gICAgICB2YXIgZXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIGV2ZW50TGlzdGVuZXIoaXNBY3RpdmUpIHtcbiAgICAgICAgdmFyIG5hdGl2ZUF1ZGlvTm9kZSA9IGdldE5hdGl2ZUF1ZGlvTm9kZShzb3VyY2UpO1xuICAgICAgICB2YXIgbmF0aXZlQXVkaW9QYXJhbSA9IGdldE5hdGl2ZUF1ZGlvUGFyYW0oZGVzdGluYXRpb24pO1xuICAgICAgICBpZiAoaXNBY3RpdmUpIHtcbiAgICAgICAgICB2YXIgcGFydGlhbENvbm5lY3Rpb24gPSBkZWxldGVQYXNzaXZlSW5wdXRDb25uZWN0aW9uVG9BdWRpb1BhcmFtKHBhc3NpdmVJbnB1dHMsIHNvdXJjZSwgb3V0cHV0KTtcbiAgICAgICAgICBhZGRBY3RpdmVJbnB1dENvbm5lY3Rpb25Ub0F1ZGlvUGFyYW0oYWN0aXZlSW5wdXRzLCBzb3VyY2UsIHBhcnRpYWxDb25uZWN0aW9uLCBmYWxzZSk7XG4gICAgICAgICAgaWYgKCFpc09mZmxpbmUgJiYgIWlzUGFydE9mQUN5Y2xlKHNvdXJjZSkpIHtcbiAgICAgICAgICAgIG5hdGl2ZUF1ZGlvTm9kZS5jb25uZWN0KG5hdGl2ZUF1ZGlvUGFyYW0sIG91dHB1dCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBfcGFydGlhbENvbm5lY3Rpb24gPSBkZWxldGVBY3RpdmVJbnB1dENvbm5lY3Rpb25Ub0F1ZGlvUGFyYW0oYWN0aXZlSW5wdXRzLCBzb3VyY2UsIG91dHB1dCk7XG4gICAgICAgICAgYWRkUGFzc2l2ZUlucHV0Q29ubmVjdGlvblRvQXVkaW9QYXJhbShwYXNzaXZlSW5wdXRzLCBfcGFydGlhbENvbm5lY3Rpb24sIGZhbHNlKTtcbiAgICAgICAgICBpZiAoIWlzT2ZmbGluZSAmJiAhaXNQYXJ0T2ZBQ3ljbGUoc291cmNlKSkge1xuICAgICAgICAgICAgbmF0aXZlQXVkaW9Ob2RlLmRpc2Nvbm5lY3QobmF0aXZlQXVkaW9QYXJhbSwgb3V0cHV0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBpZiAoaW5zZXJ0RWxlbWVudEluU2V0KG91dHB1dHMsIFtkZXN0aW5hdGlvbiwgb3V0cHV0XSwgZnVuY3Rpb24gKG91dHB1dENvbm5lY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIG91dHB1dENvbm5lY3Rpb25bMF0gPT09IGRlc3RpbmF0aW9uICYmIG91dHB1dENvbm5lY3Rpb25bMV0gPT09IG91dHB1dDtcbiAgICAgIH0sIHRydWUpKSB7XG4gICAgICAgIGV2ZW50TGlzdGVuZXJzLmFkZChldmVudExpc3RlbmVyKTtcbiAgICAgICAgaWYgKGlzQWN0aXZlQXVkaW9Ob2RlKHNvdXJjZSkpIHtcbiAgICAgICAgICBhZGRBY3RpdmVJbnB1dENvbm5lY3Rpb25Ub0F1ZGlvUGFyYW0oYWN0aXZlSW5wdXRzLCBzb3VyY2UsIFtvdXRwdXQsIGV2ZW50TGlzdGVuZXJdLCB0cnVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhZGRQYXNzaXZlSW5wdXRDb25uZWN0aW9uVG9BdWRpb1BhcmFtKHBhc3NpdmVJbnB1dHMsIFtzb3VyY2UsIG91dHB1dCwgZXZlbnRMaXN0ZW5lcl0sIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgdmFyIGRlbGV0ZUlucHV0Q29ubmVjdGlvbk9mQXVkaW9Ob2RlID0gZnVuY3Rpb24gZGVsZXRlSW5wdXRDb25uZWN0aW9uT2ZBdWRpb05vZGUoc291cmNlLCBkZXN0aW5hdGlvbiwgb3V0cHV0LCBpbnB1dCkge1xuICAgICAgdmFyIF9nZXRBdWRpb05vZGVDb25uZWN0aTIgPSBnZXRBdWRpb05vZGVDb25uZWN0aW9ucyhkZXN0aW5hdGlvbiksXG4gICAgICAgIGFjdGl2ZUlucHV0cyA9IF9nZXRBdWRpb05vZGVDb25uZWN0aTIuYWN0aXZlSW5wdXRzLFxuICAgICAgICBwYXNzaXZlSW5wdXRzID0gX2dldEF1ZGlvTm9kZUNvbm5lY3RpMi5wYXNzaXZlSW5wdXRzO1xuICAgICAgdmFyIGFjdGl2ZUlucHV0Q29ubmVjdGlvbiA9IGRlbGV0ZUFjdGl2ZUlucHV0Q29ubmVjdGlvbihhY3RpdmVJbnB1dHNbaW5wdXRdLCBzb3VyY2UsIG91dHB1dCk7XG4gICAgICBpZiAoYWN0aXZlSW5wdXRDb25uZWN0aW9uID09PSBudWxsKSB7XG4gICAgICAgIHZhciBwYXNzaXZlSW5wdXRDb25uZWN0aW9uID0gZGVsZXRlUGFzc2l2ZUlucHV0Q29ubmVjdGlvblRvQXVkaW9Ob2RlKHBhc3NpdmVJbnB1dHMsIHNvdXJjZSwgb3V0cHV0LCBpbnB1dCk7XG4gICAgICAgIHJldHVybiBbcGFzc2l2ZUlucHV0Q29ubmVjdGlvblsyXSwgZmFsc2VdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFthY3RpdmVJbnB1dENvbm5lY3Rpb25bMl0sIHRydWVdO1xuICAgIH07XG4gICAgdmFyIGRlbGV0ZUlucHV0Q29ubmVjdGlvbk9mQXVkaW9QYXJhbSA9IGZ1bmN0aW9uIGRlbGV0ZUlucHV0Q29ubmVjdGlvbk9mQXVkaW9QYXJhbShzb3VyY2UsIGRlc3RpbmF0aW9uLCBvdXRwdXQpIHtcbiAgICAgIHZhciBfZ2V0QXVkaW9QYXJhbUNvbm5lY3QyID0gZ2V0QXVkaW9QYXJhbUNvbm5lY3Rpb25zKGRlc3RpbmF0aW9uKSxcbiAgICAgICAgYWN0aXZlSW5wdXRzID0gX2dldEF1ZGlvUGFyYW1Db25uZWN0Mi5hY3RpdmVJbnB1dHMsXG4gICAgICAgIHBhc3NpdmVJbnB1dHMgPSBfZ2V0QXVkaW9QYXJhbUNvbm5lY3QyLnBhc3NpdmVJbnB1dHM7XG4gICAgICB2YXIgYWN0aXZlSW5wdXRDb25uZWN0aW9uID0gZGVsZXRlQWN0aXZlSW5wdXRDb25uZWN0aW9uKGFjdGl2ZUlucHV0cywgc291cmNlLCBvdXRwdXQpO1xuICAgICAgaWYgKGFjdGl2ZUlucHV0Q29ubmVjdGlvbiA9PT0gbnVsbCkge1xuICAgICAgICB2YXIgcGFzc2l2ZUlucHV0Q29ubmVjdGlvbiA9IGRlbGV0ZVBhc3NpdmVJbnB1dENvbm5lY3Rpb25Ub0F1ZGlvUGFyYW0ocGFzc2l2ZUlucHV0cywgc291cmNlLCBvdXRwdXQpO1xuICAgICAgICByZXR1cm4gW3Bhc3NpdmVJbnB1dENvbm5lY3Rpb25bMV0sIGZhbHNlXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbYWN0aXZlSW5wdXRDb25uZWN0aW9uWzJdLCB0cnVlXTtcbiAgICB9O1xuICAgIHZhciBkZWxldGVJbnB1dHNPZkF1ZGlvTm9kZSA9IGZ1bmN0aW9uIGRlbGV0ZUlucHV0c09mQXVkaW9Ob2RlKHNvdXJjZSwgaXNPZmZsaW5lLCBkZXN0aW5hdGlvbiwgb3V0cHV0LCBpbnB1dCkge1xuICAgICAgdmFyIF9kZWxldGVJbnB1dENvbm5lY3RpbyA9IGRlbGV0ZUlucHV0Q29ubmVjdGlvbk9mQXVkaW9Ob2RlKHNvdXJjZSwgZGVzdGluYXRpb24sIG91dHB1dCwgaW5wdXQpLFxuICAgICAgICBfZGVsZXRlSW5wdXRDb25uZWN0aW8yID0gX3NsaWNlZFRvQXJyYXkoX2RlbGV0ZUlucHV0Q29ubmVjdGlvLCAyKSxcbiAgICAgICAgbGlzdGVuZXIgPSBfZGVsZXRlSW5wdXRDb25uZWN0aW8yWzBdLFxuICAgICAgICBpc0FjdGl2ZSA9IF9kZWxldGVJbnB1dENvbm5lY3RpbzJbMV07XG4gICAgICBpZiAobGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgZGVsZXRlRXZlbnRMaXN0ZW5lck9mQXVkaW9Ob2RlKHNvdXJjZSwgbGlzdGVuZXIpO1xuICAgICAgICBpZiAoaXNBY3RpdmUgJiYgIWlzT2ZmbGluZSAmJiAhaXNQYXJ0T2ZBQ3ljbGUoc291cmNlKSkge1xuICAgICAgICAgIGRpc2Nvbm5lY3ROYXRpdmVBdWRpb05vZGVGcm9tTmF0aXZlQXVkaW9Ob2RlKGdldE5hdGl2ZUF1ZGlvTm9kZShzb3VyY2UpLCBnZXROYXRpdmVBdWRpb05vZGUoZGVzdGluYXRpb24pLCBvdXRwdXQsIGlucHV0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGlzQWN0aXZlQXVkaW9Ob2RlKGRlc3RpbmF0aW9uKSkge1xuICAgICAgICB2YXIgX2dldEF1ZGlvTm9kZUNvbm5lY3RpMyA9IGdldEF1ZGlvTm9kZUNvbm5lY3Rpb25zKGRlc3RpbmF0aW9uKSxcbiAgICAgICAgICBhY3RpdmVJbnB1dHMgPSBfZ2V0QXVkaW9Ob2RlQ29ubmVjdGkzLmFjdGl2ZUlucHV0cztcbiAgICAgICAgc2V0SW50ZXJuYWxTdGF0ZVRvUGFzc2l2ZVdoZW5OZWNlc3NhcnkoZGVzdGluYXRpb24sIGFjdGl2ZUlucHV0cyk7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgZGVsZXRlSW5wdXRzT2ZBdWRpb1BhcmFtID0gZnVuY3Rpb24gZGVsZXRlSW5wdXRzT2ZBdWRpb1BhcmFtKHNvdXJjZSwgaXNPZmZsaW5lLCBkZXN0aW5hdGlvbiwgb3V0cHV0KSB7XG4gICAgICB2YXIgX2RlbGV0ZUlucHV0Q29ubmVjdGlvMyA9IGRlbGV0ZUlucHV0Q29ubmVjdGlvbk9mQXVkaW9QYXJhbShzb3VyY2UsIGRlc3RpbmF0aW9uLCBvdXRwdXQpLFxuICAgICAgICBfZGVsZXRlSW5wdXRDb25uZWN0aW80ID0gX3NsaWNlZFRvQXJyYXkoX2RlbGV0ZUlucHV0Q29ubmVjdGlvMywgMiksXG4gICAgICAgIGxpc3RlbmVyID0gX2RlbGV0ZUlucHV0Q29ubmVjdGlvNFswXSxcbiAgICAgICAgaXNBY3RpdmUgPSBfZGVsZXRlSW5wdXRDb25uZWN0aW80WzFdO1xuICAgICAgaWYgKGxpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgIGRlbGV0ZUV2ZW50TGlzdGVuZXJPZkF1ZGlvTm9kZShzb3VyY2UsIGxpc3RlbmVyKTtcbiAgICAgICAgaWYgKGlzQWN0aXZlICYmICFpc09mZmxpbmUgJiYgIWlzUGFydE9mQUN5Y2xlKHNvdXJjZSkpIHtcbiAgICAgICAgICBnZXROYXRpdmVBdWRpb05vZGUoc291cmNlKS5kaXNjb25uZWN0KGdldE5hdGl2ZUF1ZGlvUGFyYW0oZGVzdGluYXRpb24pLCBvdXRwdXQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgZGVsZXRlQW55Q29ubmVjdGlvbiA9IGZ1bmN0aW9uIGRlbGV0ZUFueUNvbm5lY3Rpb24oc291cmNlLCBpc09mZmxpbmUpIHtcbiAgICAgIHZhciBhdWRpb05vZGVDb25uZWN0aW9uc09mU291cmNlID0gZ2V0QXVkaW9Ob2RlQ29ubmVjdGlvbnMoc291cmNlKTtcbiAgICAgIHZhciBkZXN0aW5hdGlvbnMgPSBbXTtcbiAgICAgIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQ2KGF1ZGlvTm9kZUNvbm5lY3Rpb25zT2ZTb3VyY2Uub3V0cHV0cyksXG4gICAgICAgIF9zdGVwO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgb3V0cHV0Q29ubmVjdGlvbiA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgIGlmIChpc0F1ZGlvTm9kZU91dHB1dENvbm5lY3Rpb24ob3V0cHV0Q29ubmVjdGlvbikpIHtcbiAgICAgICAgICAgIGRlbGV0ZUlucHV0c09mQXVkaW9Ob2RlLmFwcGx5KHZvaWQgMCwgW3NvdXJjZSwgaXNPZmZsaW5lXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KG91dHB1dENvbm5lY3Rpb24pKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRlbGV0ZUlucHV0c09mQXVkaW9QYXJhbS5hcHBseSh2b2lkIDAsIFtzb3VyY2UsIGlzT2ZmbGluZV0uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShvdXRwdXRDb25uZWN0aW9uKSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZXN0aW5hdGlvbnMucHVzaChvdXRwdXRDb25uZWN0aW9uWzBdKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IuZigpO1xuICAgICAgfVxuICAgICAgYXVkaW9Ob2RlQ29ubmVjdGlvbnNPZlNvdXJjZS5vdXRwdXRzLmNsZWFyKCk7XG4gICAgICByZXR1cm4gZGVzdGluYXRpb25zO1xuICAgIH07XG4gICAgdmFyIGRlbGV0ZUNvbm5lY3Rpb25BdE91dHB1dCA9IGZ1bmN0aW9uIGRlbGV0ZUNvbm5lY3Rpb25BdE91dHB1dChzb3VyY2UsIGlzT2ZmbGluZSwgb3V0cHV0KSB7XG4gICAgICB2YXIgYXVkaW9Ob2RlQ29ubmVjdGlvbnNPZlNvdXJjZSA9IGdldEF1ZGlvTm9kZUNvbm5lY3Rpb25zKHNvdXJjZSk7XG4gICAgICB2YXIgZGVzdGluYXRpb25zID0gW107XG4gICAgICB2YXIgX2l0ZXJhdG9yMiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDYoYXVkaW9Ob2RlQ29ubmVjdGlvbnNPZlNvdXJjZS5vdXRwdXRzKSxcbiAgICAgICAgX3N0ZXAyO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IyLnMoKTsgIShfc3RlcDIgPSBfaXRlcmF0b3IyLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgb3V0cHV0Q29ubmVjdGlvbiA9IF9zdGVwMi52YWx1ZTtcbiAgICAgICAgICBpZiAob3V0cHV0Q29ubmVjdGlvblsxXSA9PT0gb3V0cHV0KSB7XG4gICAgICAgICAgICBpZiAoaXNBdWRpb05vZGVPdXRwdXRDb25uZWN0aW9uKG91dHB1dENvbm5lY3Rpb24pKSB7XG4gICAgICAgICAgICAgIGRlbGV0ZUlucHV0c09mQXVkaW9Ob2RlLmFwcGx5KHZvaWQgMCwgW3NvdXJjZSwgaXNPZmZsaW5lXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KG91dHB1dENvbm5lY3Rpb24pKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBkZWxldGVJbnB1dHNPZkF1ZGlvUGFyYW0uYXBwbHkodm9pZCAwLCBbc291cmNlLCBpc09mZmxpbmVdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkob3V0cHV0Q29ubmVjdGlvbikpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlc3RpbmF0aW9ucy5wdXNoKG91dHB1dENvbm5lY3Rpb25bMF0pO1xuICAgICAgICAgICAgYXVkaW9Ob2RlQ29ubmVjdGlvbnNPZlNvdXJjZS5vdXRwdXRzW1wiZGVsZXRlXCJdKG91dHB1dENvbm5lY3Rpb24pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvcjIuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yMi5mKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVzdGluYXRpb25zO1xuICAgIH07XG4gICAgdmFyIGRlbGV0ZUNvbm5lY3Rpb25Ub0Rlc3RpbmF0aW9uID0gZnVuY3Rpb24gZGVsZXRlQ29ubmVjdGlvblRvRGVzdGluYXRpb24oc291cmNlLCBpc09mZmxpbmUsIGRlc3RpbmF0aW9uLCBvdXRwdXQsIGlucHV0KSB7XG4gICAgICB2YXIgYXVkaW9Ob2RlQ29ubmVjdGlvbnNPZlNvdXJjZSA9IGdldEF1ZGlvTm9kZUNvbm5lY3Rpb25zKHNvdXJjZSk7XG4gICAgICByZXR1cm4gQXJyYXkuZnJvbShhdWRpb05vZGVDb25uZWN0aW9uc09mU291cmNlLm91dHB1dHMpLmZpbHRlcihmdW5jdGlvbiAob3V0cHV0Q29ubmVjdGlvbikge1xuICAgICAgICByZXR1cm4gb3V0cHV0Q29ubmVjdGlvblswXSA9PT0gZGVzdGluYXRpb24gJiYgKG91dHB1dCA9PT0gdW5kZWZpbmVkIHx8IG91dHB1dENvbm5lY3Rpb25bMV0gPT09IG91dHB1dCkgJiYgKGlucHV0ID09PSB1bmRlZmluZWQgfHwgb3V0cHV0Q29ubmVjdGlvblsyXSA9PT0gaW5wdXQpO1xuICAgICAgfSkubWFwKGZ1bmN0aW9uIChvdXRwdXRDb25uZWN0aW9uKSB7XG4gICAgICAgIGlmIChpc0F1ZGlvTm9kZU91dHB1dENvbm5lY3Rpb24ob3V0cHV0Q29ubmVjdGlvbikpIHtcbiAgICAgICAgICBkZWxldGVJbnB1dHNPZkF1ZGlvTm9kZS5hcHBseSh2b2lkIDAsIFtzb3VyY2UsIGlzT2ZmbGluZV0uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShvdXRwdXRDb25uZWN0aW9uKSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZUlucHV0c09mQXVkaW9QYXJhbS5hcHBseSh2b2lkIDAsIFtzb3VyY2UsIGlzT2ZmbGluZV0uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShvdXRwdXRDb25uZWN0aW9uKSkpO1xuICAgICAgICB9XG4gICAgICAgIGF1ZGlvTm9kZUNvbm5lY3Rpb25zT2ZTb3VyY2Uub3V0cHV0c1tcImRlbGV0ZVwiXShvdXRwdXRDb25uZWN0aW9uKTtcbiAgICAgICAgcmV0dXJuIG91dHB1dENvbm5lY3Rpb25bMF07XG4gICAgICB9KTtcbiAgICB9O1xuICAgIHZhciBjcmVhdGVBdWRpb05vZGVDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uIGNyZWF0ZUF1ZGlvTm9kZUNvbnN0cnVjdG9yKGFkZEF1ZGlvTm9kZUNvbm5lY3Rpb25zLCBhZGRDb25uZWN0aW9uVG9BdWRpb05vZGUsIGNhY2hlVGVzdFJlc3VsdCwgY3JlYXRlSW5jcmVtZW50Q3ljbGVDb3VudGVyLCBjcmVhdGVJbmRleFNpemVFcnJvciwgY3JlYXRlSW52YWxpZEFjY2Vzc0Vycm9yLCBjcmVhdGVOb3RTdXBwb3J0ZWRFcnJvciwgZGVjcmVtZW50Q3ljbGVDb3VudGVyLCBkZXRlY3RDeWNsZXMsIGV2ZW50VGFyZ2V0Q29uc3RydWN0b3IsIGdldE5hdGl2ZUNvbnRleHQsIGlzTmF0aXZlQXVkaW9Db250ZXh0LCBpc05hdGl2ZUF1ZGlvTm9kZSwgaXNOYXRpdmVBdWRpb1BhcmFtLCBpc05hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQsIG5hdGl2ZUF1ZGlvV29ya2xldE5vZGVDb25zdHJ1Y3Rvcikge1xuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX2V2ZW50VGFyZ2V0Q29uc3RydWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIEF1ZGlvTm9kZShjb250ZXh0LCBpc0FjdGl2ZSwgbmF0aXZlQXVkaW9Ob2RlLCBhdWRpb05vZGVSZW5kZXJlcikge1xuICAgICAgICAgIHZhciBfdGhpcztcbiAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQXVkaW9Ob2RlKTtcbiAgICAgICAgICBfdGhpcyA9IF9jYWxsU3VwZXIkbih0aGlzLCBBdWRpb05vZGUsIFtuYXRpdmVBdWRpb05vZGVdKTtcbiAgICAgICAgICBfdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgICAgX3RoaXMuX25hdGl2ZUF1ZGlvTm9kZSA9IG5hdGl2ZUF1ZGlvTm9kZTtcbiAgICAgICAgICB2YXIgbmF0aXZlQ29udGV4dCA9IGdldE5hdGl2ZUNvbnRleHQoY29udGV4dCk7XG4gICAgICAgICAgLy8gQnVnICMxMjogU2FmYXJpIGRvZXMgbm90IHN1cHBvcnQgdG8gZGlzY29ubmVjdCBhIHNwZWNpZmljIGRlc3RpbmF0aW9uLlxuICAgICAgICAgIGlmIChpc05hdGl2ZUF1ZGlvQ29udGV4dChuYXRpdmVDb250ZXh0KSAmJiB0cnVlICE9PSBjYWNoZVRlc3RSZXN1bHQodGVzdEF1ZGlvTm9kZURpc2Nvbm5lY3RNZXRob2RTdXBwb3J0LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGVzdEF1ZGlvTm9kZURpc2Nvbm5lY3RNZXRob2RTdXBwb3J0KG5hdGl2ZUNvbnRleHQsIG5hdGl2ZUF1ZGlvV29ya2xldE5vZGVDb25zdHJ1Y3Rvcik7XG4gICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgIHdyYXBBdWRpb05vZGVEaXNjb25uZWN0TWV0aG9kKG5hdGl2ZUF1ZGlvTm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIEFVRElPX05PREVfU1RPUkUuc2V0KF90aGlzLCBuYXRpdmVBdWRpb05vZGUpO1xuICAgICAgICAgIEVWRU5UX0xJU1RFTkVSUy5zZXQoX3RoaXMsIG5ldyBTZXQoKSk7XG4gICAgICAgICAgaWYgKGNvbnRleHQuc3RhdGUgIT09ICdjbG9zZWQnICYmIGlzQWN0aXZlKSB7XG4gICAgICAgICAgICBzZXRJbnRlcm5hbFN0YXRlVG9BY3RpdmUoX3RoaXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhZGRBdWRpb05vZGVDb25uZWN0aW9ucyhfdGhpcywgYXVkaW9Ob2RlUmVuZGVyZXIsIG5hdGl2ZUF1ZGlvTm9kZSk7XG4gICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICB9XG4gICAgICAgIF9pbmhlcml0cyhBdWRpb05vZGUsIF9ldmVudFRhcmdldENvbnN0cnVjdCk7XG4gICAgICAgIHJldHVybiBfY3JlYXRlQ2xhc3MoQXVkaW9Ob2RlLCBbe1xuICAgICAgICAgIGtleTogXCJjaGFubmVsQ291bnRcIixcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9uYXRpdmVBdWRpb05vZGUuY2hhbm5lbENvdW50O1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX25hdGl2ZUF1ZGlvTm9kZS5jaGFubmVsQ291bnQgPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBrZXk6IFwiY2hhbm5lbENvdW50TW9kZVwiLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25hdGl2ZUF1ZGlvTm9kZS5jaGFubmVsQ291bnRNb2RlO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX25hdGl2ZUF1ZGlvTm9kZS5jaGFubmVsQ291bnRNb2RlID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcImNoYW5uZWxJbnRlcnByZXRhdGlvblwiLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25hdGl2ZUF1ZGlvTm9kZS5jaGFubmVsSW50ZXJwcmV0YXRpb247XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fbmF0aXZlQXVkaW9Ob2RlLmNoYW5uZWxJbnRlcnByZXRhdGlvbiA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIGtleTogXCJjb250ZXh0XCIsXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29udGV4dDtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBrZXk6IFwibnVtYmVyT2ZJbnB1dHNcIixcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9uYXRpdmVBdWRpb05vZGUubnVtYmVyT2ZJbnB1dHM7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcIm51bWJlck9mT3V0cHV0c1wiLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25hdGl2ZUF1ZGlvTm9kZS5udW1iZXJPZk91dHB1dHM7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTppbnZhbGlkLXZvaWRcbiAgICAgICAgfSwge1xuICAgICAgICAgIGtleTogXCJjb25uZWN0XCIsXG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNvbm5lY3QoZGVzdGluYXRpb24pIHtcbiAgICAgICAgICAgIHZhciBvdXRwdXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDA7XG4gICAgICAgICAgICB2YXIgaW5wdXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDA7XG4gICAgICAgICAgICAvLyBCdWcgIzE3NDogU2FmYXJpIGRvZXMgZXhwb3NlIGEgd3JvbmcgbnVtYmVyT2ZPdXRwdXRzIGZvciBNZWRpYVN0cmVhbUF1ZGlvRGVzdGluYXRpb25Ob2Rlcy5cbiAgICAgICAgICAgIGlmIChvdXRwdXQgPCAwIHx8IG91dHB1dCA+PSB0aGlzLl9uYXRpdmVBdWRpb05vZGUubnVtYmVyT2ZPdXRwdXRzKSB7XG4gICAgICAgICAgICAgIHRocm93IGNyZWF0ZUluZGV4U2l6ZUVycm9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbmF0aXZlQ29udGV4dCA9IGdldE5hdGl2ZUNvbnRleHQodGhpcy5fY29udGV4dCk7XG4gICAgICAgICAgICB2YXIgaXNPZmZsaW5lID0gaXNOYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KG5hdGl2ZUNvbnRleHQpO1xuICAgICAgICAgICAgaWYgKGlzTmF0aXZlQXVkaW9Ob2RlKGRlc3RpbmF0aW9uKSB8fCBpc05hdGl2ZUF1ZGlvUGFyYW0oZGVzdGluYXRpb24pKSB7XG4gICAgICAgICAgICAgIHRocm93IGNyZWF0ZUludmFsaWRBY2Nlc3NFcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzQXVkaW9Ob2RlKGRlc3RpbmF0aW9uKSkge1xuICAgICAgICAgICAgICB2YXIgbmF0aXZlRGVzdGluYXRpb25BdWRpb05vZGUgPSBnZXROYXRpdmVBdWRpb05vZGUoZGVzdGluYXRpb24pO1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhciBjb25uZWN0aW9uID0gY29ubmVjdE5hdGl2ZUF1ZGlvTm9kZVRvTmF0aXZlQXVkaW9Ob2RlKHRoaXMuX25hdGl2ZUF1ZGlvTm9kZSwgbmF0aXZlRGVzdGluYXRpb25BdWRpb05vZGUsIG91dHB1dCwgaW5wdXQpO1xuICAgICAgICAgICAgICAgIHZhciBpc1Bhc3NpdmUgPSBpc1Bhc3NpdmVBdWRpb05vZGUodGhpcyk7XG4gICAgICAgICAgICAgICAgaWYgKGlzT2ZmbGluZSB8fCBpc1Bhc3NpdmUpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBfdGhpcyRfbmF0aXZlQXVkaW9Ob2Q7XG4gICAgICAgICAgICAgICAgICAoX3RoaXMkX25hdGl2ZUF1ZGlvTm9kID0gdGhpcy5fbmF0aXZlQXVkaW9Ob2RlKS5kaXNjb25uZWN0LmFwcGx5KF90aGlzJF9uYXRpdmVBdWRpb05vZCwgX3RvQ29uc3VtYWJsZUFycmF5KGNvbm5lY3Rpb24pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY29udGV4dC5zdGF0ZSAhPT0gJ2Nsb3NlZCcgJiYgIWlzUGFzc2l2ZSAmJiBpc1Bhc3NpdmVBdWRpb05vZGUoZGVzdGluYXRpb24pKSB7XG4gICAgICAgICAgICAgICAgICBzZXRJbnRlcm5hbFN0YXRlVG9BY3RpdmUoZGVzdGluYXRpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgLy8gQnVnICM0MTogU2FmYXJpIGRvZXMgbm90IHRocm93IHRoZSBjb3JyZWN0IGV4Y2VwdGlvbiBzbyBmYXIuXG4gICAgICAgICAgICAgICAgaWYgKGVyci5jb2RlID09PSAxMikge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgY3JlYXRlSW52YWxpZEFjY2Vzc0Vycm9yKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2YXIgaXNOZXdDb25uZWN0aW9uVG9BdWRpb05vZGUgPSBhZGRDb25uZWN0aW9uVG9BdWRpb05vZGUodGhpcywgZGVzdGluYXRpb24sIG91dHB1dCwgaW5wdXQsIGlzT2ZmbGluZSk7XG4gICAgICAgICAgICAgIC8vIEJ1ZyAjMTY0OiBPbmx5IEZpcmVmb3ggZGV0ZWN0cyBjeWNsZXMgc28gZmFyLlxuICAgICAgICAgICAgICBpZiAoaXNOZXdDb25uZWN0aW9uVG9BdWRpb05vZGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgY3ljbGVzID0gZGV0ZWN0Q3ljbGVzKFt0aGlzXSwgZGVzdGluYXRpb24pO1xuICAgICAgICAgICAgICAgIHZpc2l0RWFjaEF1ZGlvTm9kZU9uY2UoY3ljbGVzLCBjcmVhdGVJbmNyZW1lbnRDeWNsZUNvdW50ZXIoaXNPZmZsaW5lKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGRlc3RpbmF0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG5hdGl2ZUF1ZGlvUGFyYW0gPSBnZXROYXRpdmVBdWRpb1BhcmFtKGRlc3RpbmF0aW9uKTtcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBCdWcgIzczLCAjMTQ3ICYgIzE1MzogU2FmYXJpIGRvZXMgbm90IHN1cHBvcnQgdG8gY29ubmVjdCBhbiBpbnB1dCBzaWduYWwgdG8gdGhlIHBsYXliYWNrUmF0ZSBBdWRpb1BhcmFtIG9mIGFuXG4gICAgICAgICAgICAgKiBBdWRpb0J1ZmZlclNvdXJjZU5vZGUuIFRoaXMgY2FuJ3QgYmUgZWFzaWx5IGRldGVjdGVkIGFuZCB0aGF0J3Mgd2h5IHRoZSBvdXRkYXRlZCBuYW1lIHByb3BlcnR5IGlzIHVzZWQgaGVyZSB0byBpZGVudGlmeVxuICAgICAgICAgICAgICogU2FmYXJpLiBJbiBhZGRpdGlvbiB0byB0aGF0IHRoZSBtYXhWYWx1ZSBwcm9wZXJ0eSBpcyB1c2VkIHRvIG9ubHkgZGV0ZWN0IHRoZSBhZmZlY3RlZCB2ZXJzaW9ucyBiZWxvdyB2MTQuMC4yLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAobmF0aXZlQXVkaW9QYXJhbS5uYW1lID09PSAncGxheWJhY2tSYXRlJyAmJiBuYXRpdmVBdWRpb1BhcmFtLm1heFZhbHVlID09PSAxMDI0KSB7XG4gICAgICAgICAgICAgIHRocm93IGNyZWF0ZU5vdFN1cHBvcnRlZEVycm9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB0aGlzLl9uYXRpdmVBdWRpb05vZGUuY29ubmVjdChuYXRpdmVBdWRpb1BhcmFtLCBvdXRwdXQpO1xuICAgICAgICAgICAgICBpZiAoaXNPZmZsaW5lIHx8IGlzUGFzc2l2ZUF1ZGlvTm9kZSh0aGlzKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX25hdGl2ZUF1ZGlvTm9kZS5kaXNjb25uZWN0KG5hdGl2ZUF1ZGlvUGFyYW0sIG91dHB1dCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAvLyBCdWcgIzU4OiBTYWZhcmkgZG9lc24ndCB0aHJvdyBhbiBJbnZhbGlkQWNjZXNzRXJyb3IgeWV0LlxuICAgICAgICAgICAgICBpZiAoZXJyLmNvZGUgPT09IDEyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgY3JlYXRlSW52YWxpZEFjY2Vzc0Vycm9yKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGlzTmV3Q29ubmVjdGlvblRvQXVkaW9QYXJhbSA9IGFkZENvbm5lY3Rpb25Ub0F1ZGlvUGFyYW1PZkF1ZGlvQ29udGV4dCh0aGlzLCBkZXN0aW5hdGlvbiwgb3V0cHV0LCBpc09mZmxpbmUpO1xuICAgICAgICAgICAgLy8gQnVnICMxNjQ6IE9ubHkgRmlyZWZveCBkZXRlY3RzIGN5Y2xlcyBzbyBmYXIuXG4gICAgICAgICAgICBpZiAoaXNOZXdDb25uZWN0aW9uVG9BdWRpb1BhcmFtKSB7XG4gICAgICAgICAgICAgIHZhciBfY3ljbGVzID0gZGV0ZWN0Q3ljbGVzKFt0aGlzXSwgZGVzdGluYXRpb24pO1xuICAgICAgICAgICAgICB2aXNpdEVhY2hBdWRpb05vZGVPbmNlKF9jeWNsZXMsIGNyZWF0ZUluY3JlbWVudEN5Y2xlQ291bnRlcihpc09mZmxpbmUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBrZXk6IFwiZGlzY29ubmVjdFwiLFxuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNjb25uZWN0KGRlc3RpbmF0aW9uT3JPdXRwdXQsIG91dHB1dCwgaW5wdXQpIHtcbiAgICAgICAgICAgIHZhciBkZXN0aW5hdGlvbnM7XG4gICAgICAgICAgICB2YXIgbmF0aXZlQ29udGV4dCA9IGdldE5hdGl2ZUNvbnRleHQodGhpcy5fY29udGV4dCk7XG4gICAgICAgICAgICB2YXIgaXNPZmZsaW5lID0gaXNOYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KG5hdGl2ZUNvbnRleHQpO1xuICAgICAgICAgICAgaWYgKGRlc3RpbmF0aW9uT3JPdXRwdXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBkZXN0aW5hdGlvbnMgPSBkZWxldGVBbnlDb25uZWN0aW9uKHRoaXMsIGlzT2ZmbGluZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBkZXN0aW5hdGlvbk9yT3V0cHV0ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICBpZiAoZGVzdGluYXRpb25Pck91dHB1dCA8IDAgfHwgZGVzdGluYXRpb25Pck91dHB1dCA+PSB0aGlzLm51bWJlck9mT3V0cHV0cykge1xuICAgICAgICAgICAgICAgIHRocm93IGNyZWF0ZUluZGV4U2l6ZUVycm9yKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZGVzdGluYXRpb25zID0gZGVsZXRlQ29ubmVjdGlvbkF0T3V0cHV0KHRoaXMsIGlzT2ZmbGluZSwgZGVzdGluYXRpb25Pck91dHB1dCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAob3V0cHV0ICE9PSB1bmRlZmluZWQgJiYgKG91dHB1dCA8IDAgfHwgb3V0cHV0ID49IHRoaXMubnVtYmVyT2ZPdXRwdXRzKSkge1xuICAgICAgICAgICAgICAgIHRocm93IGNyZWF0ZUluZGV4U2l6ZUVycm9yKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGlzQXVkaW9Ob2RlKGRlc3RpbmF0aW9uT3JPdXRwdXQpICYmIGlucHV0ICE9PSB1bmRlZmluZWQgJiYgKGlucHV0IDwgMCB8fCBpbnB1dCA+PSBkZXN0aW5hdGlvbk9yT3V0cHV0Lm51bWJlck9mSW5wdXRzKSkge1xuICAgICAgICAgICAgICAgIHRocm93IGNyZWF0ZUluZGV4U2l6ZUVycm9yKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZGVzdGluYXRpb25zID0gZGVsZXRlQ29ubmVjdGlvblRvRGVzdGluYXRpb24odGhpcywgaXNPZmZsaW5lLCBkZXN0aW5hdGlvbk9yT3V0cHV0LCBvdXRwdXQsIGlucHV0KTtcbiAgICAgICAgICAgICAgaWYgKGRlc3RpbmF0aW9ucy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBjcmVhdGVJbnZhbGlkQWNjZXNzRXJyb3IoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQnVnICMxNjQ6IE9ubHkgRmlyZWZveCBkZXRlY3RzIGN5Y2xlcyBzbyBmYXIuXG4gICAgICAgICAgICB2YXIgX2l0ZXJhdG9yMyA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDYoZGVzdGluYXRpb25zKSxcbiAgICAgICAgICAgICAgX3N0ZXAzO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgZm9yIChfaXRlcmF0b3IzLnMoKTsgIShfc3RlcDMgPSBfaXRlcmF0b3IzLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICAgICAgICB2YXIgZGVzdGluYXRpb24gPSBfc3RlcDMudmFsdWU7XG4gICAgICAgICAgICAgICAgdmFyIGN5Y2xlcyA9IGRldGVjdEN5Y2xlcyhbdGhpc10sIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgICAgICAgICB2aXNpdEVhY2hBdWRpb05vZGVPbmNlKGN5Y2xlcywgZGVjcmVtZW50Q3ljbGVDb3VudGVyKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgIF9pdGVyYXRvcjMuZShlcnIpO1xuICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgX2l0ZXJhdG9yMy5mKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XSk7XG4gICAgICB9KGV2ZW50VGFyZ2V0Q29uc3RydWN0b3IpO1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlQXVkaW9QYXJhbUZhY3RvcnkgPSBmdW5jdGlvbiBjcmVhdGVBdWRpb1BhcmFtRmFjdG9yeShhZGRBdWRpb1BhcmFtQ29ubmVjdGlvbnMsIGF1ZGlvUGFyYW1BdWRpb05vZGVTdG9yZSwgYXVkaW9QYXJhbVN0b3JlLCBjcmVhdGVBdWRpb1BhcmFtUmVuZGVyZXIsIGNyZWF0ZUNhbmNlbEFuZEhvbGRBdXRvbWF0aW9uRXZlbnQsIGNyZWF0ZUNhbmNlbFNjaGVkdWxlZFZhbHVlc0F1dG9tYXRpb25FdmVudCwgY3JlYXRlRXhwb25lbnRpYWxSYW1wVG9WYWx1ZUF1dG9tYXRpb25FdmVudCwgY3JlYXRlTGluZWFyUmFtcFRvVmFsdWVBdXRvbWF0aW9uRXZlbnQsIGNyZWF0ZVNldFRhcmdldEF1dG9tYXRpb25FdmVudCwgY3JlYXRlU2V0VmFsdWVBdXRvbWF0aW9uRXZlbnQsIGNyZWF0ZVNldFZhbHVlQ3VydmVBdXRvbWF0aW9uRXZlbnQsIG5hdGl2ZUF1ZGlvQ29udGV4dENvbnN0cnVjdG9yLCBzZXRWYWx1ZUF0VGltZVVudGlsUG9zc2libGUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoYXVkaW9Ob2RlLCBpc0F1ZGlvUGFyYW1PZk9mZmxpbmVBdWRpb0NvbnRleHQsIG5hdGl2ZUF1ZGlvUGFyYW0pIHtcbiAgICAgICAgdmFyIG1heFZhbHVlID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBudWxsO1xuICAgICAgICB2YXIgbWluVmFsdWUgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IG51bGw7XG4gICAgICAgIC8vIEJ1ZyAjMTk2IE9ubHkgU2FmYXJpIHNldHMgdGhlIGRlZmF1bHRWYWx1ZSB0byB0aGUgaW5pdGlhbCB2YWx1ZS5cbiAgICAgICAgdmFyIGRlZmF1bHRWYWx1ZSA9IG5hdGl2ZUF1ZGlvUGFyYW0udmFsdWU7XG4gICAgICAgIHZhciBhdXRvbWF0aW9uRXZlbnRMaXN0ID0gbmV3IGF1dG9tYXRpb25FdmVudHMuQXV0b21hdGlvbkV2ZW50TGlzdChkZWZhdWx0VmFsdWUpO1xuICAgICAgICB2YXIgYXVkaW9QYXJhbVJlbmRlcmVyID0gaXNBdWRpb1BhcmFtT2ZPZmZsaW5lQXVkaW9Db250ZXh0ID8gY3JlYXRlQXVkaW9QYXJhbVJlbmRlcmVyKGF1dG9tYXRpb25FdmVudExpc3QpIDogbnVsbDtcbiAgICAgICAgdmFyIGF1ZGlvUGFyYW0gPSB7XG4gICAgICAgICAgZ2V0IGRlZmF1bHRWYWx1ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBnZXQgbWF4VmFsdWUoKSB7XG4gICAgICAgICAgICByZXR1cm4gbWF4VmFsdWUgPT09IG51bGwgPyBuYXRpdmVBdWRpb1BhcmFtLm1heFZhbHVlIDogbWF4VmFsdWU7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBnZXQgbWluVmFsdWUoKSB7XG4gICAgICAgICAgICByZXR1cm4gbWluVmFsdWUgPT09IG51bGwgPyBuYXRpdmVBdWRpb1BhcmFtLm1pblZhbHVlIDogbWluVmFsdWU7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBnZXQgdmFsdWUoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmF0aXZlQXVkaW9QYXJhbS52YWx1ZTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNldCB2YWx1ZSh2YWx1ZSkge1xuICAgICAgICAgICAgbmF0aXZlQXVkaW9QYXJhbS52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgLy8gQnVnICM5ODogRmlyZWZveCAmIFNhZmFyaSBkbyBub3QgeWV0IHRyZWF0IHRoZSB2YWx1ZSBzZXR0ZXIgbGlrZSBhIGNhbGwgdG8gc2V0VmFsdWVBdFRpbWUoKS5cbiAgICAgICAgICAgIGF1ZGlvUGFyYW0uc2V0VmFsdWVBdFRpbWUodmFsdWUsIGF1ZGlvTm9kZS5jb250ZXh0LmN1cnJlbnRUaW1lKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNhbmNlbEFuZEhvbGRBdFRpbWU6IGZ1bmN0aW9uIGNhbmNlbEFuZEhvbGRBdFRpbWUoY2FuY2VsVGltZSkge1xuICAgICAgICAgICAgLy8gQnVnICMyODogRmlyZWZveCAmIFNhZmFyaSBkbyBub3QgeWV0IGltcGxlbWVudCBjYW5jZWxBbmRIb2xkQXRUaW1lKCkuXG4gICAgICAgICAgICBpZiAodHlwZW9mIG5hdGl2ZUF1ZGlvUGFyYW0uY2FuY2VsQW5kSG9sZEF0VGltZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICBpZiAoYXVkaW9QYXJhbVJlbmRlcmVyID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgYXV0b21hdGlvbkV2ZW50TGlzdC5mbHVzaChhdWRpb05vZGUuY29udGV4dC5jdXJyZW50VGltZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYXV0b21hdGlvbkV2ZW50TGlzdC5hZGQoY3JlYXRlQ2FuY2VsQW5kSG9sZEF1dG9tYXRpb25FdmVudChjYW5jZWxUaW1lKSk7XG4gICAgICAgICAgICAgIG5hdGl2ZUF1ZGlvUGFyYW0uY2FuY2VsQW5kSG9sZEF0VGltZShjYW5jZWxUaW1lKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhciBwcmV2aW91c0xhc3RFdmVudCA9IEFycmF5LmZyb20oYXV0b21hdGlvbkV2ZW50TGlzdCkucG9wKCk7XG4gICAgICAgICAgICAgIGlmIChhdWRpb1BhcmFtUmVuZGVyZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBhdXRvbWF0aW9uRXZlbnRMaXN0LmZsdXNoKGF1ZGlvTm9kZS5jb250ZXh0LmN1cnJlbnRUaW1lKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBhdXRvbWF0aW9uRXZlbnRMaXN0LmFkZChjcmVhdGVDYW5jZWxBbmRIb2xkQXV0b21hdGlvbkV2ZW50KGNhbmNlbFRpbWUpKTtcbiAgICAgICAgICAgICAgdmFyIGN1cnJlbnRMYXN0RXZlbnQgPSBBcnJheS5mcm9tKGF1dG9tYXRpb25FdmVudExpc3QpLnBvcCgpO1xuICAgICAgICAgICAgICBuYXRpdmVBdWRpb1BhcmFtLmNhbmNlbFNjaGVkdWxlZFZhbHVlcyhjYW5jZWxUaW1lKTtcbiAgICAgICAgICAgICAgaWYgKHByZXZpb3VzTGFzdEV2ZW50ICE9PSBjdXJyZW50TGFzdEV2ZW50ICYmIGN1cnJlbnRMYXN0RXZlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50TGFzdEV2ZW50LnR5cGUgPT09ICdleHBvbmVudGlhbFJhbXBUb1ZhbHVlJykge1xuICAgICAgICAgICAgICAgICAgbmF0aXZlQXVkaW9QYXJhbS5leHBvbmVudGlhbFJhbXBUb1ZhbHVlQXRUaW1lKGN1cnJlbnRMYXN0RXZlbnQudmFsdWUsIGN1cnJlbnRMYXN0RXZlbnQuZW5kVGltZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50TGFzdEV2ZW50LnR5cGUgPT09ICdsaW5lYXJSYW1wVG9WYWx1ZScpIHtcbiAgICAgICAgICAgICAgICAgIG5hdGl2ZUF1ZGlvUGFyYW0ubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUoY3VycmVudExhc3RFdmVudC52YWx1ZSwgY3VycmVudExhc3RFdmVudC5lbmRUaW1lKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnRMYXN0RXZlbnQudHlwZSA9PT0gJ3NldFZhbHVlJykge1xuICAgICAgICAgICAgICAgICAgbmF0aXZlQXVkaW9QYXJhbS5zZXRWYWx1ZUF0VGltZShjdXJyZW50TGFzdEV2ZW50LnZhbHVlLCBjdXJyZW50TGFzdEV2ZW50LnN0YXJ0VGltZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50TGFzdEV2ZW50LnR5cGUgPT09ICdzZXRWYWx1ZUN1cnZlJykge1xuICAgICAgICAgICAgICAgICAgbmF0aXZlQXVkaW9QYXJhbS5zZXRWYWx1ZUN1cnZlQXRUaW1lKGN1cnJlbnRMYXN0RXZlbnQudmFsdWVzLCBjdXJyZW50TGFzdEV2ZW50LnN0YXJ0VGltZSwgY3VycmVudExhc3RFdmVudC5kdXJhdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYXVkaW9QYXJhbTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNhbmNlbFNjaGVkdWxlZFZhbHVlczogZnVuY3Rpb24gY2FuY2VsU2NoZWR1bGVkVmFsdWVzKGNhbmNlbFRpbWUpIHtcbiAgICAgICAgICAgIGlmIChhdWRpb1BhcmFtUmVuZGVyZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgYXV0b21hdGlvbkV2ZW50TGlzdC5mbHVzaChhdWRpb05vZGUuY29udGV4dC5jdXJyZW50VGltZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhdXRvbWF0aW9uRXZlbnRMaXN0LmFkZChjcmVhdGVDYW5jZWxTY2hlZHVsZWRWYWx1ZXNBdXRvbWF0aW9uRXZlbnQoY2FuY2VsVGltZSkpO1xuICAgICAgICAgICAgbmF0aXZlQXVkaW9QYXJhbS5jYW5jZWxTY2hlZHVsZWRWYWx1ZXMoY2FuY2VsVGltZSk7XG4gICAgICAgICAgICByZXR1cm4gYXVkaW9QYXJhbTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGV4cG9uZW50aWFsUmFtcFRvVmFsdWVBdFRpbWU6IGZ1bmN0aW9uIGV4cG9uZW50aWFsUmFtcFRvVmFsdWVBdFRpbWUodmFsdWUsIGVuZFRpbWUpIHtcbiAgICAgICAgICAgIC8vIEJ1ZyAjNDU6IFNhZmFyaSBkb2VzIG5vdCB0aHJvdyBhbiBlcnJvciB5ZXQuXG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IDApIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEJ1ZyAjMTg3OiBTYWZhcmkgZG9lcyBub3QgdGhyb3cgYW4gZXJyb3IgeWV0LlxuICAgICAgICAgICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoZW5kVGltZSkgfHwgZW5kVGltZSA8IDApIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjdXJyZW50VGltZSA9IGF1ZGlvTm9kZS5jb250ZXh0LmN1cnJlbnRUaW1lO1xuICAgICAgICAgICAgaWYgKGF1ZGlvUGFyYW1SZW5kZXJlciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICBhdXRvbWF0aW9uRXZlbnRMaXN0LmZsdXNoKGN1cnJlbnRUaW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEJ1ZyAjMTk0OiBGaXJlZm94IGRvZXMgbm90IGltcGxpY2l0bHkgY2FsbCBzZXRWYWx1ZUF0VGltZSgpIGlmIHRoZXJlIGlzIG5vIHByZXZpb3VzIGV2ZW50LlxuICAgICAgICAgICAgaWYgKEFycmF5LmZyb20oYXV0b21hdGlvbkV2ZW50TGlzdCkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgIGF1dG9tYXRpb25FdmVudExpc3QuYWRkKGNyZWF0ZVNldFZhbHVlQXV0b21hdGlvbkV2ZW50KGRlZmF1bHRWYWx1ZSwgY3VycmVudFRpbWUpKTtcbiAgICAgICAgICAgICAgbmF0aXZlQXVkaW9QYXJhbS5zZXRWYWx1ZUF0VGltZShkZWZhdWx0VmFsdWUsIGN1cnJlbnRUaW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF1dG9tYXRpb25FdmVudExpc3QuYWRkKGNyZWF0ZUV4cG9uZW50aWFsUmFtcFRvVmFsdWVBdXRvbWF0aW9uRXZlbnQodmFsdWUsIGVuZFRpbWUpKTtcbiAgICAgICAgICAgIG5hdGl2ZUF1ZGlvUGFyYW0uZXhwb25lbnRpYWxSYW1wVG9WYWx1ZUF0VGltZSh2YWx1ZSwgZW5kVGltZSk7XG4gICAgICAgICAgICByZXR1cm4gYXVkaW9QYXJhbTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lOiBmdW5jdGlvbiBsaW5lYXJSYW1wVG9WYWx1ZUF0VGltZSh2YWx1ZSwgZW5kVGltZSkge1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRUaW1lID0gYXVkaW9Ob2RlLmNvbnRleHQuY3VycmVudFRpbWU7XG4gICAgICAgICAgICBpZiAoYXVkaW9QYXJhbVJlbmRlcmVyID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIGF1dG9tYXRpb25FdmVudExpc3QuZmx1c2goY3VycmVudFRpbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQnVnICMxOTU6IEZpcmVmb3ggZG9lcyBub3QgaW1wbGljaXRseSBjYWxsIHNldFZhbHVlQXRUaW1lKCkgaWYgdGhlcmUgaXMgbm8gcHJldmlvdXMgZXZlbnQuXG4gICAgICAgICAgICBpZiAoQXJyYXkuZnJvbShhdXRvbWF0aW9uRXZlbnRMaXN0KS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgYXV0b21hdGlvbkV2ZW50TGlzdC5hZGQoY3JlYXRlU2V0VmFsdWVBdXRvbWF0aW9uRXZlbnQoZGVmYXVsdFZhbHVlLCBjdXJyZW50VGltZSkpO1xuICAgICAgICAgICAgICBuYXRpdmVBdWRpb1BhcmFtLnNldFZhbHVlQXRUaW1lKGRlZmF1bHRWYWx1ZSwgY3VycmVudFRpbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXV0b21hdGlvbkV2ZW50TGlzdC5hZGQoY3JlYXRlTGluZWFyUmFtcFRvVmFsdWVBdXRvbWF0aW9uRXZlbnQodmFsdWUsIGVuZFRpbWUpKTtcbiAgICAgICAgICAgIG5hdGl2ZUF1ZGlvUGFyYW0ubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUodmFsdWUsIGVuZFRpbWUpO1xuICAgICAgICAgICAgcmV0dXJuIGF1ZGlvUGFyYW07XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzZXRUYXJnZXRBdFRpbWU6IGZ1bmN0aW9uIHNldFRhcmdldEF0VGltZSh0YXJnZXQsIHN0YXJ0VGltZSwgdGltZUNvbnN0YW50KSB7XG4gICAgICAgICAgICBpZiAoYXVkaW9QYXJhbVJlbmRlcmVyID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIGF1dG9tYXRpb25FdmVudExpc3QuZmx1c2goYXVkaW9Ob2RlLmNvbnRleHQuY3VycmVudFRpbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXV0b21hdGlvbkV2ZW50TGlzdC5hZGQoY3JlYXRlU2V0VGFyZ2V0QXV0b21hdGlvbkV2ZW50KHRhcmdldCwgc3RhcnRUaW1lLCB0aW1lQ29uc3RhbnQpKTtcbiAgICAgICAgICAgIG5hdGl2ZUF1ZGlvUGFyYW0uc2V0VGFyZ2V0QXRUaW1lKHRhcmdldCwgc3RhcnRUaW1lLCB0aW1lQ29uc3RhbnQpO1xuICAgICAgICAgICAgcmV0dXJuIGF1ZGlvUGFyYW07XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzZXRWYWx1ZUF0VGltZTogZnVuY3Rpb24gc2V0VmFsdWVBdFRpbWUodmFsdWUsIHN0YXJ0VGltZSkge1xuICAgICAgICAgICAgaWYgKGF1ZGlvUGFyYW1SZW5kZXJlciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICBhdXRvbWF0aW9uRXZlbnRMaXN0LmZsdXNoKGF1ZGlvTm9kZS5jb250ZXh0LmN1cnJlbnRUaW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF1dG9tYXRpb25FdmVudExpc3QuYWRkKGNyZWF0ZVNldFZhbHVlQXV0b21hdGlvbkV2ZW50KHZhbHVlLCBzdGFydFRpbWUpKTtcbiAgICAgICAgICAgIG5hdGl2ZUF1ZGlvUGFyYW0uc2V0VmFsdWVBdFRpbWUodmFsdWUsIHN0YXJ0VGltZSk7XG4gICAgICAgICAgICByZXR1cm4gYXVkaW9QYXJhbTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNldFZhbHVlQ3VydmVBdFRpbWU6IGZ1bmN0aW9uIHNldFZhbHVlQ3VydmVBdFRpbWUodmFsdWVzLCBzdGFydFRpbWUsIGR1cmF0aW9uKSB7XG4gICAgICAgICAgICAvLyBCdWcgMTgzOiBTYWZhcmkgb25seSBhY2NlcHRzIGEgRmxvYXQzMkFycmF5LlxuICAgICAgICAgICAgdmFyIGNvbnZlcnRlZFZhbHVlcyA9IHZhbHVlcyBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSA/IHZhbHVlcyA6IG5ldyBGbG9hdDMyQXJyYXkodmFsdWVzKTtcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBCdWcgIzE1MjogU2FmYXJpIGRvZXMgbm90IGNvcnJlY3RseSBpbnRlcnBvbGF0ZSB0aGUgdmFsdWVzIG9mIHRoZSBjdXJ2ZS5cbiAgICAgICAgICAgICAqIEB0b2RvIFVuZm9ydHVuYXRlbHkgdGhlcmUgaXMgbm8gd2F5IHRvIHRlc3QgZm9yIHRoaXMgYmVoYXZpb3IgaW4gYSBzeW5jaHJvbm91cyBmYXNoaW9uIHdoaWNoIGlzIHdoeSB0ZXN0aW5nIGZvciB0aGVcbiAgICAgICAgICAgICAqIGV4aXN0ZW5jZSBvZiB0aGUgd2Via2l0QXVkaW9Db250ZXh0IGlzIHVzZWQgYXMgYSB3b3JrYXJvdW5kIGhlcmUuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmIChuYXRpdmVBdWRpb0NvbnRleHRDb25zdHJ1Y3RvciAhPT0gbnVsbCAmJiBuYXRpdmVBdWRpb0NvbnRleHRDb25zdHJ1Y3Rvci5uYW1lID09PSAnd2Via2l0QXVkaW9Db250ZXh0Jykge1xuICAgICAgICAgICAgICB2YXIgZW5kVGltZSA9IHN0YXJ0VGltZSArIGR1cmF0aW9uO1xuICAgICAgICAgICAgICB2YXIgc2FtcGxlUmF0ZSA9IGF1ZGlvTm9kZS5jb250ZXh0LnNhbXBsZVJhdGU7XG4gICAgICAgICAgICAgIHZhciBmaXJzdFNhbXBsZSA9IE1hdGguY2VpbChzdGFydFRpbWUgKiBzYW1wbGVSYXRlKTtcbiAgICAgICAgICAgICAgdmFyIGxhc3RTYW1wbGUgPSBNYXRoLmZsb29yKGVuZFRpbWUgKiBzYW1wbGVSYXRlKTtcbiAgICAgICAgICAgICAgdmFyIG51bWJlck9mSW50ZXJwb2xhdGVkVmFsdWVzID0gbGFzdFNhbXBsZSAtIGZpcnN0U2FtcGxlO1xuICAgICAgICAgICAgICB2YXIgaW50ZXJwb2xhdGVkVmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheShudW1iZXJPZkludGVycG9sYXRlZFZhbHVlcyk7XG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtYmVyT2ZJbnRlcnBvbGF0ZWRWYWx1ZXM7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgIHZhciB0aGVvcmV0aWNJbmRleCA9IChjb252ZXJ0ZWRWYWx1ZXMubGVuZ3RoIC0gMSkgLyBkdXJhdGlvbiAqICgoZmlyc3RTYW1wbGUgKyBpKSAvIHNhbXBsZVJhdGUgLSBzdGFydFRpbWUpO1xuICAgICAgICAgICAgICAgIHZhciBsb3dlckluZGV4ID0gTWF0aC5mbG9vcih0aGVvcmV0aWNJbmRleCk7XG4gICAgICAgICAgICAgICAgdmFyIHVwcGVySW5kZXggPSBNYXRoLmNlaWwodGhlb3JldGljSW5kZXgpO1xuICAgICAgICAgICAgICAgIGludGVycG9sYXRlZFZhbHVlc1tpXSA9IGxvd2VySW5kZXggPT09IHVwcGVySW5kZXggPyBjb252ZXJ0ZWRWYWx1ZXNbbG93ZXJJbmRleF0gOiAoMSAtICh0aGVvcmV0aWNJbmRleCAtIGxvd2VySW5kZXgpKSAqIGNvbnZlcnRlZFZhbHVlc1tsb3dlckluZGV4XSArICgxIC0gKHVwcGVySW5kZXggLSB0aGVvcmV0aWNJbmRleCkpICogY29udmVydGVkVmFsdWVzW3VwcGVySW5kZXhdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChhdWRpb1BhcmFtUmVuZGVyZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBhdXRvbWF0aW9uRXZlbnRMaXN0LmZsdXNoKGF1ZGlvTm9kZS5jb250ZXh0LmN1cnJlbnRUaW1lKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBhdXRvbWF0aW9uRXZlbnRMaXN0LmFkZChjcmVhdGVTZXRWYWx1ZUN1cnZlQXV0b21hdGlvbkV2ZW50KGludGVycG9sYXRlZFZhbHVlcywgc3RhcnRUaW1lLCBkdXJhdGlvbikpO1xuICAgICAgICAgICAgICBuYXRpdmVBdWRpb1BhcmFtLnNldFZhbHVlQ3VydmVBdFRpbWUoaW50ZXJwb2xhdGVkVmFsdWVzLCBzdGFydFRpbWUsIGR1cmF0aW9uKTtcbiAgICAgICAgICAgICAgdmFyIHRpbWVPZkxhc3RTYW1wbGUgPSBsYXN0U2FtcGxlIC8gc2FtcGxlUmF0ZTtcbiAgICAgICAgICAgICAgaWYgKHRpbWVPZkxhc3RTYW1wbGUgPCBlbmRUaW1lKSB7XG4gICAgICAgICAgICAgICAgc2V0VmFsdWVBdFRpbWVVbnRpbFBvc3NpYmxlKGF1ZGlvUGFyYW0sIGludGVycG9sYXRlZFZhbHVlc1tpbnRlcnBvbGF0ZWRWYWx1ZXMubGVuZ3RoIC0gMV0sIHRpbWVPZkxhc3RTYW1wbGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHNldFZhbHVlQXRUaW1lVW50aWxQb3NzaWJsZShhdWRpb1BhcmFtLCBjb252ZXJ0ZWRWYWx1ZXNbY29udmVydGVkVmFsdWVzLmxlbmd0aCAtIDFdLCBlbmRUaW1lKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChhdWRpb1BhcmFtUmVuZGVyZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBhdXRvbWF0aW9uRXZlbnRMaXN0LmZsdXNoKGF1ZGlvTm9kZS5jb250ZXh0LmN1cnJlbnRUaW1lKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBhdXRvbWF0aW9uRXZlbnRMaXN0LmFkZChjcmVhdGVTZXRWYWx1ZUN1cnZlQXV0b21hdGlvbkV2ZW50KGNvbnZlcnRlZFZhbHVlcywgc3RhcnRUaW1lLCBkdXJhdGlvbikpO1xuICAgICAgICAgICAgICBuYXRpdmVBdWRpb1BhcmFtLnNldFZhbHVlQ3VydmVBdFRpbWUoY29udmVydGVkVmFsdWVzLCBzdGFydFRpbWUsIGR1cmF0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhdWRpb1BhcmFtO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgYXVkaW9QYXJhbVN0b3JlLnNldChhdWRpb1BhcmFtLCBuYXRpdmVBdWRpb1BhcmFtKTtcbiAgICAgICAgYXVkaW9QYXJhbUF1ZGlvTm9kZVN0b3JlLnNldChhdWRpb1BhcmFtLCBhdWRpb05vZGUpO1xuICAgICAgICBhZGRBdWRpb1BhcmFtQ29ubmVjdGlvbnMoYXVkaW9QYXJhbSwgYXVkaW9QYXJhbVJlbmRlcmVyKTtcbiAgICAgICAgcmV0dXJuIGF1ZGlvUGFyYW07XG4gICAgICB9O1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQ1KHIsIGUpIHsgdmFyIHQgPSBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBTeW1ib2wgJiYgcltTeW1ib2wuaXRlcmF0b3JdIHx8IHJbXCJAQGl0ZXJhdG9yXCJdOyBpZiAoIXQpIHsgaWYgKEFycmF5LmlzQXJyYXkocikgfHwgKHQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkNShyKSkgfHwgZSkgeyB0ICYmIChyID0gdCk7IHZhciBfbiA9IDAsIEYgPSBmdW5jdGlvbiBGKCkge307IHJldHVybiB7IHM6IEYsIG46IGZ1bmN0aW9uIG4oKSB7IHJldHVybiBfbiA+PSByLmxlbmd0aCA/IHsgZG9uZTogITAgfSA6IHsgZG9uZTogITEsIHZhbHVlOiByW19uKytdIH07IH0sIGU6IGZ1bmN0aW9uIGUocikgeyB0aHJvdyByOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBvLCBhID0gITAsIHUgPSAhMTsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgdCA9IHQuY2FsbChyKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHIgPSB0Lm5leHQoKTsgcmV0dXJuIGEgPSByLmRvbmUsIHI7IH0sIGU6IGZ1bmN0aW9uIGUocikgeyB1ID0gITAsIG8gPSByOyB9LCBmOiBmdW5jdGlvbiBmKCkgeyB0cnkgeyBhIHx8IG51bGwgPT0gdFtcInJldHVyblwiXSB8fCB0W1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmICh1KSB0aHJvdyBvOyB9IH0gfTsgfVxuICAgIGZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSQ1KHIsIGEpIHsgaWYgKHIpIHsgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIHIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheSQ1KHIsIGEpOyB2YXIgdCA9IHt9LnRvU3RyaW5nLmNhbGwocikuc2xpY2UoOCwgLTEpOyByZXR1cm4gXCJPYmplY3RcIiA9PT0gdCAmJiByLmNvbnN0cnVjdG9yICYmICh0ID0gci5jb25zdHJ1Y3Rvci5uYW1lKSwgXCJNYXBcIiA9PT0gdCB8fCBcIlNldFwiID09PSB0ID8gQXJyYXkuZnJvbShyKSA6IFwiQXJndW1lbnRzXCIgPT09IHQgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QodCkgPyBfYXJyYXlMaWtlVG9BcnJheSQ1KHIsIGEpIDogdm9pZCAwOyB9IH1cbiAgICBmdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheSQ1KHIsIGEpIHsgKG51bGwgPT0gYSB8fCBhID4gci5sZW5ndGgpICYmIChhID0gci5sZW5ndGgpOyBmb3IgKHZhciBlID0gMCwgbiA9IEFycmF5KGEpOyBlIDwgYTsgZSsrKSBuW2VdID0gcltlXTsgcmV0dXJuIG47IH1cbiAgICB2YXIgY3JlYXRlQXVkaW9QYXJhbVJlbmRlcmVyID0gZnVuY3Rpb24gY3JlYXRlQXVkaW9QYXJhbVJlbmRlcmVyKGF1dG9tYXRpb25FdmVudExpc3QpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlcGxheTogZnVuY3Rpb24gcmVwbGF5KGF1ZGlvUGFyYW0pIHtcbiAgICAgICAgICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkNShhdXRvbWF0aW9uRXZlbnRMaXN0KSxcbiAgICAgICAgICAgIF9zdGVwO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgICAgICAgICB2YXIgYXV0b21hdGlvbkV2ZW50ID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgICAgIGlmIChhdXRvbWF0aW9uRXZlbnQudHlwZSA9PT0gJ2V4cG9uZW50aWFsUmFtcFRvVmFsdWUnKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVuZFRpbWUgPSBhdXRvbWF0aW9uRXZlbnQuZW5kVGltZSxcbiAgICAgICAgICAgICAgICAgIHZhbHVlID0gYXV0b21hdGlvbkV2ZW50LnZhbHVlO1xuICAgICAgICAgICAgICAgIGF1ZGlvUGFyYW0uZXhwb25lbnRpYWxSYW1wVG9WYWx1ZUF0VGltZSh2YWx1ZSwgZW5kVGltZSk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoYXV0b21hdGlvbkV2ZW50LnR5cGUgPT09ICdsaW5lYXJSYW1wVG9WYWx1ZScpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2VuZFRpbWUgPSBhdXRvbWF0aW9uRXZlbnQuZW5kVGltZSxcbiAgICAgICAgICAgICAgICAgIF92YWx1ZSA9IGF1dG9tYXRpb25FdmVudC52YWx1ZTtcbiAgICAgICAgICAgICAgICBhdWRpb1BhcmFtLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKF92YWx1ZSwgX2VuZFRpbWUpO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGF1dG9tYXRpb25FdmVudC50eXBlID09PSAnc2V0VGFyZ2V0Jykge1xuICAgICAgICAgICAgICAgIHZhciBzdGFydFRpbWUgPSBhdXRvbWF0aW9uRXZlbnQuc3RhcnRUaW1lLFxuICAgICAgICAgICAgICAgICAgdGFyZ2V0ID0gYXV0b21hdGlvbkV2ZW50LnRhcmdldCxcbiAgICAgICAgICAgICAgICAgIHRpbWVDb25zdGFudCA9IGF1dG9tYXRpb25FdmVudC50aW1lQ29uc3RhbnQ7XG4gICAgICAgICAgICAgICAgYXVkaW9QYXJhbS5zZXRUYXJnZXRBdFRpbWUodGFyZ2V0LCBzdGFydFRpbWUsIHRpbWVDb25zdGFudCk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoYXV0b21hdGlvbkV2ZW50LnR5cGUgPT09ICdzZXRWYWx1ZScpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3N0YXJ0VGltZSA9IGF1dG9tYXRpb25FdmVudC5zdGFydFRpbWUsXG4gICAgICAgICAgICAgICAgICBfdmFsdWUyID0gYXV0b21hdGlvbkV2ZW50LnZhbHVlO1xuICAgICAgICAgICAgICAgIGF1ZGlvUGFyYW0uc2V0VmFsdWVBdFRpbWUoX3ZhbHVlMiwgX3N0YXJ0VGltZSk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoYXV0b21hdGlvbkV2ZW50LnR5cGUgPT09ICdzZXRWYWx1ZUN1cnZlJykge1xuICAgICAgICAgICAgICAgIHZhciBkdXJhdGlvbiA9IGF1dG9tYXRpb25FdmVudC5kdXJhdGlvbixcbiAgICAgICAgICAgICAgICAgIF9zdGFydFRpbWUyID0gYXV0b21hdGlvbkV2ZW50LnN0YXJ0VGltZSxcbiAgICAgICAgICAgICAgICAgIHZhbHVlcyA9IGF1dG9tYXRpb25FdmVudC52YWx1ZXM7XG4gICAgICAgICAgICAgICAgYXVkaW9QYXJhbS5zZXRWYWx1ZUN1cnZlQXRUaW1lKHZhbHVlcywgX3N0YXJ0VGltZTIsIGR1cmF0aW9uKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBhcHBseSBhbiB1bmtub3duIGF1dG9tYXRpb24uXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBfaXRlcmF0b3IuZShlcnIpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBfaXRlcmF0b3IuZigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIFJlYWRPbmx5TWFwID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIFJlYWRPbmx5TWFwKHBhcmFtZXRlcnMpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJlYWRPbmx5TWFwKTtcbiAgICAgICAgdGhpcy5fbWFwID0gbmV3IE1hcChwYXJhbWV0ZXJzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfY3JlYXRlQ2xhc3MoUmVhZE9ubHlNYXAsIFt7XG4gICAgICAgIGtleTogXCJzaXplXCIsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9tYXAuc2l6ZTtcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICBrZXk6IFwiZW50cmllc1wiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZW50cmllcygpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fbWFwLmVudHJpZXMoKTtcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICBrZXk6IFwiZm9yRWFjaFwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZm9yRWFjaChjYWxsYmFjaykge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgdmFyIHRoaXNBcmcgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IG51bGw7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX21hcC5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2suY2FsbCh0aGlzQXJnLCB2YWx1ZSwga2V5LCBfdGhpcyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiBcImdldFwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0KG5hbWUpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fbWFwLmdldChuYW1lKTtcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICBrZXk6IFwiaGFzXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBoYXMobmFtZSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9tYXAuaGFzKG5hbWUpO1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIGtleTogXCJrZXlzXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBrZXlzKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9tYXAua2V5cygpO1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIGtleTogXCJ2YWx1ZXNcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlcygpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fbWFwLnZhbHVlcygpO1xuICAgICAgICB9XG4gICAgICB9XSk7XG4gICAgfSgpO1xuXG4gICAgZnVuY3Rpb24gb3duS2V5cyR0KGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cbiAgICBmdW5jdGlvbiBfb2JqZWN0U3ByZWFkJHQoZSkgeyBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykgeyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gb3duS2V5cyR0KE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyR0KE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XG4gICAgZnVuY3Rpb24gX2NhbGxTdXBlciRtKHQsIG8sIGUpIHsgcmV0dXJuIG8gPSBfZ2V0UHJvdG90eXBlT2YobyksIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHQsIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkbSgpID8gUmVmbGVjdC5jb25zdHJ1Y3QobywgZSB8fCBbXSwgX2dldFByb3RvdHlwZU9mKHQpLmNvbnN0cnVjdG9yKSA6IG8uYXBwbHkodCwgZSkpOyB9XG4gICAgZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRtKCkgeyB0cnkgeyB2YXIgdCA9ICFCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IH0gY2F0Y2ggKHQpIHt9IHJldHVybiAoX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRtID0gZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgcmV0dXJuICEhdDsgfSkoKTsgfVxuICAgIHZhciBERUZBVUxUX09QVElPTlMkaCA9IHtcbiAgICAgIGNoYW5uZWxDb3VudDogMixcbiAgICAgIC8vIEJ1ZyAjNjE6IFRoZSBjaGFubmVsQ291bnRNb2RlIHNob3VsZCBiZSAnbWF4JyBhY2NvcmRpbmcgdG8gdGhlIHNwZWMgYnV0IGlzIHNldCB0byAnZXhwbGljaXQnIHRvIGFjaGlldmUgY29uc2lzdGVudCBiZWhhdmlvci5cbiAgICAgIGNoYW5uZWxDb3VudE1vZGU6ICdleHBsaWNpdCcsXG4gICAgICBjaGFubmVsSW50ZXJwcmV0YXRpb246ICdzcGVha2VycycsXG4gICAgICBudW1iZXJPZklucHV0czogMSxcbiAgICAgIG51bWJlck9mT3V0cHV0czogMSxcbiAgICAgIHBhcmFtZXRlckRhdGE6IHt9LFxuICAgICAgcHJvY2Vzc29yT3B0aW9uczoge31cbiAgICB9O1xuICAgIHZhciBjcmVhdGVBdWRpb1dvcmtsZXROb2RlQ29uc3RydWN0b3IgPSBmdW5jdGlvbiBjcmVhdGVBdWRpb1dvcmtsZXROb2RlQ29uc3RydWN0b3IoYWRkVW5yZW5kZXJlZEF1ZGlvV29ya2xldE5vZGUsIGF1ZGlvTm9kZUNvbnN0cnVjdG9yLCBjcmVhdGVBdWRpb1BhcmFtLCBjcmVhdGVBdWRpb1dvcmtsZXROb2RlUmVuZGVyZXIsIGNyZWF0ZU5hdGl2ZUF1ZGlvV29ya2xldE5vZGUsIGdldEF1ZGlvTm9kZUNvbm5lY3Rpb25zLCBnZXRCYWNrdXBPZmZsaW5lQXVkaW9Db250ZXh0LCBnZXROYXRpdmVDb250ZXh0LCBpc05hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQsIG5hdGl2ZUF1ZGlvV29ya2xldE5vZGVDb25zdHJ1Y3Rvciwgc2FuaXRpemVBdWRpb1dvcmtsZXROb2RlT3B0aW9ucywgc2V0QWN0aXZlQXVkaW9Xb3JrbGV0Tm9kZUlucHV0cywgdGVzdEF1ZGlvV29ya2xldE5vZGVPcHRpb25zQ2xvbmFiaWxpdHksIHdyYXBFdmVudExpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfYXVkaW9Ob2RlQ29uc3RydWN0b3IpIHtcbiAgICAgICAgZnVuY3Rpb24gQXVkaW9Xb3JrbGV0Tm9kZShjb250ZXh0LCBuYW1lLCBvcHRpb25zKSB7XG4gICAgICAgICAgdmFyIF90aGlzO1xuICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBdWRpb1dvcmtsZXROb2RlKTtcbiAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgdmFyIG5hdGl2ZUNvbnRleHQgPSBnZXROYXRpdmVDb250ZXh0KGNvbnRleHQpO1xuICAgICAgICAgIHZhciBpc09mZmxpbmUgPSBpc05hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQobmF0aXZlQ29udGV4dCk7XG4gICAgICAgICAgdmFyIG1lcmdlZE9wdGlvbnMgPSBzYW5pdGl6ZUF1ZGlvV29ya2xldE5vZGVPcHRpb25zKF9vYmplY3RTcHJlYWQkdChfb2JqZWN0U3ByZWFkJHQoe30sIERFRkFVTFRfT1BUSU9OUyRoKSwgb3B0aW9ucykpO1xuICAgICAgICAgIC8vIEJ1ZyAjMTkxOiBTYWZhcmkgZG9lc24ndCB0aHJvdyBhbiBlcnJvciBpZiB0aGUgb3B0aW9ucyBhcmVuJ3QgY2xvbmFibGUuXG4gICAgICAgICAgdGVzdEF1ZGlvV29ya2xldE5vZGVPcHRpb25zQ2xvbmFiaWxpdHkobWVyZ2VkT3B0aW9ucyk7XG4gICAgICAgICAgdmFyIG5vZGVOYW1lVG9Qcm9jZXNzb3JDb25zdHJ1Y3Rvck1hcCA9IE5PREVfTkFNRV9UT19QUk9DRVNTT1JfQ09OU1RSVUNUT1JfTUFQUy5nZXQobmF0aXZlQ29udGV4dCk7XG4gICAgICAgICAgdmFyIHByb2Nlc3NvckNvbnN0cnVjdG9yID0gbm9kZU5hbWVUb1Byb2Nlc3NvckNvbnN0cnVjdG9yTWFwID09PSBudWxsIHx8IG5vZGVOYW1lVG9Qcm9jZXNzb3JDb25zdHJ1Y3Rvck1hcCA9PT0gdm9pZCAwID8gdm9pZCAwIDogbm9kZU5hbWVUb1Byb2Nlc3NvckNvbnN0cnVjdG9yTWFwLmdldChuYW1lKTtcbiAgICAgICAgICAvLyBCdWcgIzE4NjogQ2hyb21lIGFuZCBFZGdlIGRvIG5vdCBhbGxvdyB0byBjcmVhdGUgYW4gQXVkaW9Xb3JrbGV0Tm9kZSBvbiBhIGNsb3NlZCBBdWRpb0NvbnRleHQuXG4gICAgICAgICAgdmFyIG5hdGl2ZUNvbnRleHRPckJhY2t1cE9mZmxpbmVBdWRpb0NvbnRleHQgPSBpc09mZmxpbmUgfHwgbmF0aXZlQ29udGV4dC5zdGF0ZSAhPT0gJ2Nsb3NlZCcgPyBuYXRpdmVDb250ZXh0IDogKF9hID0gZ2V0QmFja3VwT2ZmbGluZUF1ZGlvQ29udGV4dChuYXRpdmVDb250ZXh0KSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbmF0aXZlQ29udGV4dDtcbiAgICAgICAgICB2YXIgbmF0aXZlQXVkaW9Xb3JrbGV0Tm9kZSA9IGNyZWF0ZU5hdGl2ZUF1ZGlvV29ya2xldE5vZGUobmF0aXZlQ29udGV4dE9yQmFja3VwT2ZmbGluZUF1ZGlvQ29udGV4dCwgaXNPZmZsaW5lID8gbnVsbCA6IGNvbnRleHQuYmFzZUxhdGVuY3ksIG5hdGl2ZUF1ZGlvV29ya2xldE5vZGVDb25zdHJ1Y3RvciwgbmFtZSwgcHJvY2Vzc29yQ29uc3RydWN0b3IsIG1lcmdlZE9wdGlvbnMpO1xuICAgICAgICAgIHZhciBhdWRpb1dvcmtsZXROb2RlUmVuZGVyZXIgPSBpc09mZmxpbmUgPyBjcmVhdGVBdWRpb1dvcmtsZXROb2RlUmVuZGVyZXIobmFtZSwgbWVyZ2VkT3B0aW9ucywgcHJvY2Vzc29yQ29uc3RydWN0b3IpIDogbnVsbDtcbiAgICAgICAgICAvKlxuICAgICAgICAgICAqIEB0b2RvIEFkZCBhIG1lY2hhbmlzbSB0byBzd2l0Y2ggYW4gQXVkaW9Xb3JrbGV0Tm9kZSB0byBwYXNzaXZlIG9uY2UgdGhlIHByb2Nlc3MoKSBmdW5jdGlvbiBvZiB0aGUgQXVkaW9Xb3JrbGV0UHJvY2Vzc29yXG4gICAgICAgICAgICogcmV0dXJucyBmYWxzZS5cbiAgICAgICAgICAgKi9cbiAgICAgICAgICBfdGhpcyA9IF9jYWxsU3VwZXIkbSh0aGlzLCBBdWRpb1dvcmtsZXROb2RlLCBbY29udGV4dCwgdHJ1ZSwgbmF0aXZlQXVkaW9Xb3JrbGV0Tm9kZSwgYXVkaW9Xb3JrbGV0Tm9kZVJlbmRlcmVyXSk7XG4gICAgICAgICAgdmFyIHBhcmFtZXRlcnMgPSBbXTtcbiAgICAgICAgICBuYXRpdmVBdWRpb1dvcmtsZXROb2RlLnBhcmFtZXRlcnMuZm9yRWFjaChmdW5jdGlvbiAobmF0aXZlQXVkaW9QYXJhbSwgbm0pIHtcbiAgICAgICAgICAgIHZhciBhdWRpb1BhcmFtID0gY3JlYXRlQXVkaW9QYXJhbShfdGhpcywgaXNPZmZsaW5lLCBuYXRpdmVBdWRpb1BhcmFtKTtcbiAgICAgICAgICAgIHBhcmFtZXRlcnMucHVzaChbbm0sIGF1ZGlvUGFyYW1dKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBfdGhpcy5fbmF0aXZlQXVkaW9Xb3JrbGV0Tm9kZSA9IG5hdGl2ZUF1ZGlvV29ya2xldE5vZGU7XG4gICAgICAgICAgX3RoaXMuX29ucHJvY2Vzc29yZXJyb3IgPSBudWxsO1xuICAgICAgICAgIF90aGlzLl9wYXJhbWV0ZXJzID0gbmV3IFJlYWRPbmx5TWFwKHBhcmFtZXRlcnMpO1xuICAgICAgICAgIC8qXG4gICAgICAgICAgICogQnVnICM4NiAmICM4NzogSW52b2tpbmcgdGhlIHJlbmRlcmVyIG9mIGFuIEF1ZGlvV29ya2xldE5vZGUgbWlnaHQgYmUgbmVjZXNzYXJ5IGlmIGl0IGhhcyBubyBkaXJlY3Qgb3IgaW5kaXJlY3QgY29ubmVjdGlvbiB0b1xuICAgICAgICAgICAqIHRoZSBkZXN0aW5hdGlvbi5cbiAgICAgICAgICAgKi9cbiAgICAgICAgICBpZiAoaXNPZmZsaW5lKSB7XG4gICAgICAgICAgICBhZGRVbnJlbmRlcmVkQXVkaW9Xb3JrbGV0Tm9kZShuYXRpdmVDb250ZXh0LCBfdGhpcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBfZ2V0QXVkaW9Ob2RlQ29ubmVjdGkgPSBnZXRBdWRpb05vZGVDb25uZWN0aW9ucyhfdGhpcyksXG4gICAgICAgICAgICBhY3RpdmVJbnB1dHMgPSBfZ2V0QXVkaW9Ob2RlQ29ubmVjdGkuYWN0aXZlSW5wdXRzO1xuICAgICAgICAgIHNldEFjdGl2ZUF1ZGlvV29ya2xldE5vZGVJbnB1dHMobmF0aXZlQXVkaW9Xb3JrbGV0Tm9kZSwgYWN0aXZlSW5wdXRzKTtcbiAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgIH1cbiAgICAgICAgX2luaGVyaXRzKEF1ZGlvV29ya2xldE5vZGUsIF9hdWRpb05vZGVDb25zdHJ1Y3Rvcik7XG4gICAgICAgIHJldHVybiBfY3JlYXRlQ2xhc3MoQXVkaW9Xb3JrbGV0Tm9kZSwgW3tcbiAgICAgICAgICBrZXk6IFwib25wcm9jZXNzb3JlcnJvclwiLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX29ucHJvY2Vzc29yZXJyb3I7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIHdyYXBwZWRMaXN0ZW5lciA9IHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyA/IHdyYXBFdmVudExpc3RlbmVyKHRoaXMsIHZhbHVlKSA6IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9uYXRpdmVBdWRpb1dvcmtsZXROb2RlLm9ucHJvY2Vzc29yZXJyb3IgPSB3cmFwcGVkTGlzdGVuZXI7XG4gICAgICAgICAgICB2YXIgbmF0aXZlT25Qcm9jZXNzb3JFcnJvciA9IHRoaXMuX25hdGl2ZUF1ZGlvV29ya2xldE5vZGUub25wcm9jZXNzb3JlcnJvcjtcbiAgICAgICAgICAgIHRoaXMuX29ucHJvY2Vzc29yZXJyb3IgPSBuYXRpdmVPblByb2Nlc3NvckVycm9yICE9PSBudWxsICYmIG5hdGl2ZU9uUHJvY2Vzc29yRXJyb3IgPT09IHdyYXBwZWRMaXN0ZW5lciA/IHZhbHVlIDogbmF0aXZlT25Qcm9jZXNzb3JFcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBrZXk6IFwicGFyYW1ldGVyc1wiLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3BhcmFtZXRlcnMgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgLy8gQHRvZG8gVGhlIGRlZmluaXRpb24gdGhhdCBUeXBlU2NyaXB0IHVzZXMgb2YgdGhlIEF1ZGlvUGFyYW1NYXAgaXMgbGFja2luZyBtYW55IG1ldGhvZHMuXG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLl9uYXRpdmVBdWRpb1dvcmtsZXROb2RlLnBhcmFtZXRlcnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcGFyYW1ldGVycztcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBrZXk6IFwicG9ydFwiLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25hdGl2ZUF1ZGlvV29ya2xldE5vZGUucG9ydDtcbiAgICAgICAgICB9XG4gICAgICAgIH1dKTtcbiAgICAgIH0oYXVkaW9Ob2RlQ29uc3RydWN0b3IpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBjb3B5RnJvbUNoYW5uZWwoYXVkaW9CdWZmZXIsXG4gICAgLy8gQHRvZG8gVGhlcmUgaXMgY3VycmVudGx5IG5vIHdheSB0byBkZWZpbmUgc29tZXRoaW5nIGxpa2UgeyBbIGtleTogbnVtYmVyIHwgc3RyaW5nIF06IEZsb2F0MzJBcnJheSB9XG4gICAgcGFyZW50LCBrZXksIGNoYW5uZWxOdW1iZXIsIGJ1ZmZlck9mZnNldCkge1xuICAgICAgaWYgKHR5cGVvZiBhdWRpb0J1ZmZlci5jb3B5RnJvbUNoYW5uZWwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gVGhlIGJ5dGVMZW5ndGggd2lsbCBiZSAwIHdoZW4gdGhlIEFycmF5QnVmZmVyIHdhcyB0cmFuc2ZlcnJlZC5cbiAgICAgICAgaWYgKHBhcmVudFtrZXldLmJ5dGVMZW5ndGggPT09IDApIHtcbiAgICAgICAgICBwYXJlbnRba2V5XSA9IG5ldyBGbG9hdDMyQXJyYXkoMTI4KTtcbiAgICAgICAgfVxuICAgICAgICBhdWRpb0J1ZmZlci5jb3B5RnJvbUNoYW5uZWwocGFyZW50W2tleV0sIGNoYW5uZWxOdW1iZXIsIGJ1ZmZlck9mZnNldCk7XG4gICAgICAgIC8vIEJ1ZyAjNTogU2FmYXJpIGRvZXMgbm90IHN1cHBvcnQgY29weUZyb21DaGFubmVsKCkuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgY2hhbm5lbERhdGEgPSBhdWRpb0J1ZmZlci5nZXRDaGFubmVsRGF0YShjaGFubmVsTnVtYmVyKTtcbiAgICAgICAgLy8gVGhlIGJ5dGVMZW5ndGggd2lsbCBiZSAwIHdoZW4gdGhlIEFycmF5QnVmZmVyIHdhcyB0cmFuc2ZlcnJlZC5cbiAgICAgICAgaWYgKHBhcmVudFtrZXldLmJ5dGVMZW5ndGggPT09IDApIHtcbiAgICAgICAgICBwYXJlbnRba2V5XSA9IGNoYW5uZWxEYXRhLnNsaWNlKGJ1ZmZlck9mZnNldCwgYnVmZmVyT2Zmc2V0ICsgMTI4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgc2xpY2VkSW5wdXQgPSBuZXcgRmxvYXQzMkFycmF5KGNoYW5uZWxEYXRhLmJ1ZmZlciwgYnVmZmVyT2Zmc2V0ICogRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULCAxMjgpO1xuICAgICAgICAgIHBhcmVudFtrZXldLnNldChzbGljZWRJbnB1dCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgY29weVRvQ2hhbm5lbCA9IGZ1bmN0aW9uIGNvcHlUb0NoYW5uZWwoYXVkaW9CdWZmZXIsIHBhcmVudCwga2V5LCBjaGFubmVsTnVtYmVyLCBidWZmZXJPZmZzZXQpIHtcbiAgICAgIGlmICh0eXBlb2YgYXVkaW9CdWZmZXIuY29weVRvQ2hhbm5lbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBUaGUgYnl0ZUxlbmd0aCB3aWxsIGJlIDAgd2hlbiB0aGUgQXJyYXlCdWZmZXIgd2FzIHRyYW5zZmVycmVkLlxuICAgICAgICBpZiAocGFyZW50W2tleV0uYnl0ZUxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgIGF1ZGlvQnVmZmVyLmNvcHlUb0NoYW5uZWwocGFyZW50W2tleV0sIGNoYW5uZWxOdW1iZXIsIGJ1ZmZlck9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQnVnICM1OiBTYWZhcmkgZG9lcyBub3Qgc3VwcG9ydCBjb3B5VG9DaGFubmVsKCkuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGUgYnl0ZUxlbmd0aCB3aWxsIGJlIDAgd2hlbiB0aGUgQXJyYXlCdWZmZXIgd2FzIHRyYW5zZmVycmVkLlxuICAgICAgICBpZiAocGFyZW50W2tleV0uYnl0ZUxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgIGF1ZGlvQnVmZmVyLmdldENoYW5uZWxEYXRhKGNoYW5uZWxOdW1iZXIpLnNldChwYXJlbnRba2V5XSwgYnVmZmVyT2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlTmVzdGVkQXJyYXlzID0gZnVuY3Rpb24gY3JlYXRlTmVzdGVkQXJyYXlzKHgsIHkpIHtcbiAgICAgIHZhciBhcnJheXMgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBhcnJheSA9IFtdO1xuICAgICAgICB2YXIgbGVuZ3RoID0gdHlwZW9mIHkgPT09ICdudW1iZXInID8geSA6IHlbaV07XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGVuZ3RoOyBqICs9IDEpIHtcbiAgICAgICAgICBhcnJheS5wdXNoKG5ldyBGbG9hdDMyQXJyYXkoMTI4KSk7XG4gICAgICAgIH1cbiAgICAgICAgYXJyYXlzLnB1c2goYXJyYXkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFycmF5cztcbiAgICB9O1xuXG4gICAgdmFyIGdldEF1ZGlvV29ya2xldFByb2Nlc3NvciA9IGZ1bmN0aW9uIGdldEF1ZGlvV29ya2xldFByb2Nlc3NvcihuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LCBwcm94eSkge1xuICAgICAgdmFyIG5vZGVUb1Byb2Nlc3Nvck1hcCA9IGdldFZhbHVlRm9yS2V5KE5PREVfVE9fUFJPQ0VTU09SX01BUFMsIG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQpO1xuICAgICAgdmFyIG5hdGl2ZUF1ZGlvV29ya2xldE5vZGUgPSBnZXROYXRpdmVBdWRpb05vZGUocHJveHkpO1xuICAgICAgcmV0dXJuIGdldFZhbHVlRm9yS2V5KG5vZGVUb1Byb2Nlc3Nvck1hcCwgbmF0aXZlQXVkaW9Xb3JrbGV0Tm9kZSk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDQociwgZSkgeyB2YXIgdCA9IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIFN5bWJvbCAmJiByW1N5bWJvbC5pdGVyYXRvcl0gfHwgcltcIkBAaXRlcmF0b3JcIl07IGlmICghdCkgeyBpZiAoQXJyYXkuaXNBcnJheShyKSB8fCAodCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSQ0KHIpKSB8fCBlKSB7IHQgJiYgKHIgPSB0KTsgdmFyIF9uID0gMCwgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgcmV0dXJuIF9uID49IHIubGVuZ3RoID8geyBkb25lOiAhMCB9IDogeyBkb25lOiAhMSwgdmFsdWU6IHJbX24rK10gfTsgfSwgZTogZnVuY3Rpb24gZShyKSB7IHRocm93IHI7IH0sIGY6IEYgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH0gdmFyIG8sIGEgPSAhMCwgdSA9ICExOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyB0ID0gdC5jYWxsKHIpOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgciA9IHQubmV4dCgpOyByZXR1cm4gYSA9IHIuZG9uZSwgcjsgfSwgZTogZnVuY3Rpb24gZShyKSB7IHUgPSAhMCwgbyA9IHI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGEgfHwgbnVsbCA9PSB0W1wicmV0dXJuXCJdIHx8IHRbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKHUpIHRocm93IG87IH0gfSB9OyB9XG4gICAgZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5JDQociwgYSkgeyBpZiAocikgeyBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgcikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5JDQociwgYSk7IHZhciB0ID0ge30udG9TdHJpbmcuY2FsbChyKS5zbGljZSg4LCAtMSk7IHJldHVybiBcIk9iamVjdFwiID09PSB0ICYmIHIuY29uc3RydWN0b3IgJiYgKHQgPSByLmNvbnN0cnVjdG9yLm5hbWUpLCBcIk1hcFwiID09PSB0IHx8IFwiU2V0XCIgPT09IHQgPyBBcnJheS5mcm9tKHIpIDogXCJBcmd1bWVudHNcIiA9PT0gdCB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdCh0KSA/IF9hcnJheUxpa2VUb0FycmF5JDQociwgYSkgOiB2b2lkIDA7IH0gfVxuICAgIGZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5JDQociwgYSkgeyAobnVsbCA9PSBhIHx8IGEgPiByLmxlbmd0aCkgJiYgKGEgPSByLmxlbmd0aCk7IGZvciAodmFyIGUgPSAwLCBuID0gQXJyYXkoYSk7IGUgPCBhOyBlKyspIG5bZV0gPSByW2VdOyByZXR1cm4gbjsgfVxuICAgIGZ1bmN0aW9uIG93bktleXMkcyhlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XG4gICAgZnVuY3Rpb24gX29iamVjdFNwcmVhZCRzKGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMkcyhPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMkcyhPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxuICAgIHZhciBwcm9jZXNzQnVmZmVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfcmVmID0gX2FzeW5jVG9HZW5lcmF0b3IoLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlKHByb3h5LCByZW5kZXJlZEJ1ZmZlciwgbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCwgb3B0aW9ucywgb3V0cHV0Q2hhbm5lbENvdW50LCBwcm9jZXNzb3JDb25zdHJ1Y3RvciwgZXhwb3NlQ3VycmVudEZyYW1lQW5kQ3VycmVudFRpbWUpIHtcbiAgICAgICAgdmFyIGxlbmd0aCwgbnVtYmVyT2ZJbnB1dENoYW5uZWxzLCBudW1iZXJPZk91dHB1dENoYW5uZWxzLCBwcm9jZXNzZWRCdWZmZXIsIGF1ZGlvTm9kZUNvbm5lY3Rpb25zLCBhdWRpb1dvcmtsZXRQcm9jZXNzb3IsIGlucHV0cywgb3V0cHV0cywgcGFyYW1ldGVycywgX2xvb3AsIF9yZXQsIGk7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQyKSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQyLnByZXYgPSBfY29udGV4dDIubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAvLyBDZWlsIHRoZSBsZW5ndGggdG8gdGhlIG5leHQgZnVsbCByZW5kZXIgcXVhbnR1bS5cbiAgICAgICAgICAgICAgLy8gQnVnICMxNzogU2FmYXJpIGRvZXMgbm90IHlldCBleHBvc2UgdGhlIGxlbmd0aC5cbiAgICAgICAgICAgICAgbGVuZ3RoID0gcmVuZGVyZWRCdWZmZXIgPT09IG51bGwgPyBNYXRoLmNlaWwocHJveHkuY29udGV4dC5sZW5ndGggLyAxMjgpICogMTI4IDogcmVuZGVyZWRCdWZmZXIubGVuZ3RoO1xuICAgICAgICAgICAgICBudW1iZXJPZklucHV0Q2hhbm5lbHMgPSBvcHRpb25zLmNoYW5uZWxDb3VudCAqIG9wdGlvbnMubnVtYmVyT2ZJbnB1dHM7XG4gICAgICAgICAgICAgIG51bWJlck9mT3V0cHV0Q2hhbm5lbHMgPSBvdXRwdXRDaGFubmVsQ291bnQucmVkdWNlKGZ1bmN0aW9uIChzdW0sIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1bSArIHZhbHVlO1xuICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgICAgcHJvY2Vzc2VkQnVmZmVyID0gbnVtYmVyT2ZPdXRwdXRDaGFubmVscyA9PT0gMCA/IG51bGwgOiBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LmNyZWF0ZUJ1ZmZlcihudW1iZXJPZk91dHB1dENoYW5uZWxzLCBsZW5ndGgsIG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQuc2FtcGxlUmF0ZSk7XG4gICAgICAgICAgICAgIGlmICghKHByb2Nlc3NvckNvbnN0cnVjdG9yID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSA2O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyB0aGUgcHJvY2Vzc29yIGNvbnN0cnVjdG9yLicpO1xuICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICBhdWRpb05vZGVDb25uZWN0aW9ucyA9IGdldEF1ZGlvTm9kZUNvbm5lY3Rpb25zKHByb3h5KTtcbiAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSA5O1xuICAgICAgICAgICAgICByZXR1cm4gZ2V0QXVkaW9Xb3JrbGV0UHJvY2Vzc29yKG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQsIHByb3h5KTtcbiAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgYXVkaW9Xb3JrbGV0UHJvY2Vzc29yID0gX2NvbnRleHQyLnNlbnQ7XG4gICAgICAgICAgICAgIGlucHV0cyA9IGNyZWF0ZU5lc3RlZEFycmF5cyhvcHRpb25zLm51bWJlck9mSW5wdXRzLCBvcHRpb25zLmNoYW5uZWxDb3VudCk7XG4gICAgICAgICAgICAgIG91dHB1dHMgPSBjcmVhdGVOZXN0ZWRBcnJheXMob3B0aW9ucy5udW1iZXJPZk91dHB1dHMsIG91dHB1dENoYW5uZWxDb3VudCk7XG4gICAgICAgICAgICAgIHBhcmFtZXRlcnMgPSBBcnJheS5mcm9tKHByb3h5LnBhcmFtZXRlcnMua2V5cygpKS5yZWR1Y2UoZnVuY3Rpb24gKHBybXRycywgbmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkJHMoX29iamVjdFNwcmVhZCRzKHt9LCBwcm10cnMpLCB7fSwgX2RlZmluZVByb3BlcnR5KHt9LCBuYW1lLCBuZXcgRmxvYXQzMkFycmF5KDEyOCkpKTtcbiAgICAgICAgICAgICAgfSwge30pO1xuICAgICAgICAgICAgICBfbG9vcCA9IC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2xvb3AoaSkge1xuICAgICAgICAgICAgICAgIHZhciBqLCBrLCBfaiwgX2ssIHBvdGVudGlhbGx5RW1wdHlJbnB1dHMsIGFjdGl2ZVNvdXJjZUZsYWcsIF9qMiwgb3V0cHV0Q2hhbm5lbFNwbGl0dGVyTm9kZU91dHB1dCwgX2syO1xuICAgICAgICAgICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2xvb3AkKF9jb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICB3aGlsZSAoMSkgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMubnVtYmVyT2ZJbnB1dHMgPiAwICYmIHJlbmRlcmVkQnVmZmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgb3B0aW9ucy5udW1iZXJPZklucHV0czsgaiArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCBvcHRpb25zLmNoYW5uZWxDb3VudDsgayArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29weUZyb21DaGFubmVsKHJlbmRlcmVkQnVmZmVyLCBpbnB1dHNbal0sIGssIGssIGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzb3JDb25zdHJ1Y3Rvci5wYXJhbWV0ZXJEZXNjcmlwdG9ycyAhPT0gdW5kZWZpbmVkICYmIHJlbmRlcmVkQnVmZmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9jZXNzb3JDb25zdHJ1Y3Rvci5wYXJhbWV0ZXJEZXNjcmlwdG9ycy5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmMiwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBfcmVmMi5uYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjb3B5RnJvbUNoYW5uZWwocmVuZGVyZWRCdWZmZXIsIHBhcmFtZXRlcnMsIG5hbWUsIG51bWJlck9mSW5wdXRDaGFubmVscyArIGluZGV4LCBpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBmb3IgKF9qID0gMDsgX2ogPCBvcHRpb25zLm51bWJlck9mSW5wdXRzOyBfaiArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKF9rID0gMDsgX2sgPCBvdXRwdXRDaGFubmVsQ291bnRbX2pdOyBfayArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBieXRlTGVuZ3RoIHdpbGwgYmUgMCB3aGVuIHRoZSBBcnJheUJ1ZmZlciB3YXMgdHJhbnNmZXJyZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvdXRwdXRzW19qXVtfa10uYnl0ZUxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dHNbX2pdW19rXSA9IG5ldyBGbG9hdDMyQXJyYXkoMTI4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMztcbiAgICAgICAgICAgICAgICAgICAgICBwb3RlbnRpYWxseUVtcHR5SW5wdXRzID0gaW5wdXRzLm1hcChmdW5jdGlvbiAoaW5wdXQsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXVkaW9Ob2RlQ29ubmVjdGlvbnMuYWN0aXZlSW5wdXRzW2luZGV4XS5zaXplID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpbnB1dDtcbiAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICBhY3RpdmVTb3VyY2VGbGFnID0gZXhwb3NlQ3VycmVudEZyYW1lQW5kQ3VycmVudFRpbWUoaSAvIG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQuc2FtcGxlUmF0ZSwgbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dC5zYW1wbGVSYXRlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXVkaW9Xb3JrbGV0UHJvY2Vzc29yLnByb2Nlc3MocG90ZW50aWFsbHlFbXB0eUlucHV0cywgb3V0cHV0cywgcGFyYW1ldGVycyk7XG4gICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHByb2Nlc3NlZEJ1ZmZlciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChfajIgPSAwLCBvdXRwdXRDaGFubmVsU3BsaXR0ZXJOb2RlT3V0cHV0ID0gMDsgX2oyIDwgb3B0aW9ucy5udW1iZXJPZk91dHB1dHM7IF9qMiArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoX2syID0gMDsgX2syIDwgb3V0cHV0Q2hhbm5lbENvdW50W19qMl07IF9rMiArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29weVRvQ2hhbm5lbChwcm9jZXNzZWRCdWZmZXIsIG91dHB1dHNbX2oyXSwgX2syLCBvdXRwdXRDaGFubmVsU3BsaXR0ZXJOb2RlT3V0cHV0ICsgX2syLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRDaGFubmVsU3BsaXR0ZXJOb2RlT3V0cHV0ICs9IG91dHB1dENoYW5uZWxDb3VudFtfajJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBpZiAoYWN0aXZlU291cmNlRmxhZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxNTtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMTE7XG4gICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQudDAgPSBfY29udGV4dFtcImNhdGNoXCJdKDMpO1xuICAgICAgICAgICAgICAgICAgICAgIHByb3h5LmRpc3BhdGNoRXZlbnQobmV3IEVycm9yRXZlbnQoJ3Byb2Nlc3NvcmVycm9yJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sbm86IF9jb250ZXh0LnQwLmNvbG5vLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZW5hbWU6IF9jb250ZXh0LnQwLmZpbGVuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGluZW5vOiBfY29udGV4dC50MC5saW5lbm8sXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBfY29udGV4dC50MC5tZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgMCk7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIF9sb29wLCBudWxsLCBbWzMsIDExXV0pO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgaSA9IDA7XG4gICAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgICBpZiAoIShpIDwgbGVuZ3RoKSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMjM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5kZWxlZ2F0ZVlpZWxkKF9sb29wKGkpLCBcInQwXCIsIDE3KTtcbiAgICAgICAgICAgIGNhc2UgMTc6XG4gICAgICAgICAgICAgIF9yZXQgPSBfY29udGV4dDIudDA7XG4gICAgICAgICAgICAgIGlmICghKF9yZXQgPT09IDApKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAyMDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcImJyZWFrXCIsIDIzKTtcbiAgICAgICAgICAgIGNhc2UgMjA6XG4gICAgICAgICAgICAgIGkgKz0gMTI4O1xuICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDE1O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMjM6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsIHByb2Nlc3NlZEJ1ZmZlcik7XG4gICAgICAgICAgICBjYXNlIDI0OlxuICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUpO1xuICAgICAgfSkpO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIHByb2Nlc3NCdWZmZXIoX3gsIF94MiwgX3gzLCBfeDQsIF94NSwgX3g2LCBfeDcpIHtcbiAgICAgICAgcmV0dXJuIF9yZWYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gICAgfSgpO1xuICAgIHZhciBjcmVhdGVBdWRpb1dvcmtsZXROb2RlUmVuZGVyZXJGYWN0b3J5ID0gZnVuY3Rpb24gY3JlYXRlQXVkaW9Xb3JrbGV0Tm9kZVJlbmRlcmVyRmFjdG9yeShjb25uZWN0QXVkaW9QYXJhbSwgY29ubmVjdE11bHRpcGxlT3V0cHV0cywgY3JlYXRlTmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2RlLCBjcmVhdGVOYXRpdmVDaGFubmVsTWVyZ2VyTm9kZSwgY3JlYXRlTmF0aXZlQ2hhbm5lbFNwbGl0dGVyTm9kZSwgY3JlYXRlTmF0aXZlQ29uc3RhbnRTb3VyY2VOb2RlLCBjcmVhdGVOYXRpdmVHYWluTm9kZSwgZGVsZXRlVW5yZW5kZXJlZEF1ZGlvV29ya2xldE5vZGUsIGRpc2Nvbm5lY3RNdWx0aXBsZU91dHB1dHMsIGV4cG9zZUN1cnJlbnRGcmFtZUFuZEN1cnJlbnRUaW1lLCBnZXROYXRpdmVBdWRpb05vZGUsIG5hdGl2ZUF1ZGlvV29ya2xldE5vZGVDb25zdHJ1Y3RvciwgbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dENvbnN0cnVjdG9yLCByZW5kZXJBdXRvbWF0aW9uLCByZW5kZXJJbnB1dHNPZkF1ZGlvTm9kZSwgcmVuZGVyTmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChuYW1lLCBvcHRpb25zLCBwcm9jZXNzb3JDb25zdHJ1Y3Rvcikge1xuICAgICAgICB2YXIgcmVuZGVyZWROYXRpdmVBdWRpb05vZGVzID0gbmV3IFdlYWtNYXAoKTtcbiAgICAgICAgdmFyIHByb2Nlc3NlZEJ1ZmZlclByb21pc2UgPSBudWxsO1xuICAgICAgICB2YXIgY3JlYXRlQXVkaW9Ob2RlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgX3JlZjMgPSBfYXN5bmNUb0dlbmVyYXRvcigvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU0KHByb3h5LCBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KSB7XG4gICAgICAgICAgICB2YXIgbmF0aXZlQXVkaW9Xb3JrbGV0Tm9kZSwgbmF0aXZlT3V0cHV0Tm9kZXMsIG5hdGl2ZUF1ZGlvV29ya2xldE5vZGVJc093bmVkQnlDb250ZXh0LCBvdXRwdXRDaGFubmVsQ291bnQsIG51bWJlck9mT3V0cHV0Q2hhbm5lbHMsIG91dHB1dENoYW5uZWxTcGxpdHRlck5vZGUsIG91dHB1dENoYW5uZWxNZXJnZXJOb2RlcywgaSwgb3V0cHV0R2Fpbk5vZGUsIG51bWJlck9mSW5wdXRDaGFubmVscywgbnVtYmVyT2ZQYXJhbWV0ZXJzLCBudW1iZXJPZkNoYW5uZWxzLCByZW5kZXJCdWZmZXIsIHByb2Nlc3NlZEJ1ZmZlciwgYXVkaW9CdWZmZXJTb3VyY2VOb2RlLCBfbmF0aXZlT3V0cHV0Tm9kZXMsIF9uYXRpdmVPdXRwdXROb2RlczIsIF9vdXRwdXRDaGFubmVsU3BsaXR0ZXJOb2RlLCBfb3V0cHV0Q2hhbm5lbE1lcmdlck5vZGVzLCBfb3V0cHV0R2Fpbk5vZGUsIF9pMywgb3V0cHV0Q2hhbm5lbFNwbGl0dGVyTm9kZU91dHB1dCwgb3V0cHV0Q2hhbm5lbE1lcmdlck5vZGUsIGosIF9pdGVyYXRvcjIsIF9zdGVwMiwgX3N0ZXAyJHZhbHVlLCBubSwgYXVkaW9QYXJhbSwgX2l0ZXJhdG9yMywgX3N0ZXAzLCBfc3RlcDMkdmFsdWUsIF9ubSwgX2F1ZGlvUGFyYW07XG4gICAgICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU0JChfY29udGV4dDUpIHtcbiAgICAgICAgICAgICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQ1LnByZXYgPSBfY29udGV4dDUubmV4dCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgIG5hdGl2ZUF1ZGlvV29ya2xldE5vZGUgPSBnZXROYXRpdmVBdWRpb05vZGUocHJveHkpO1xuICAgICAgICAgICAgICAgICAgbmF0aXZlT3V0cHV0Tm9kZXMgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgbmF0aXZlQXVkaW9Xb3JrbGV0Tm9kZUlzT3duZWRCeUNvbnRleHQgPSBpc093bmVkQnlDb250ZXh0KG5hdGl2ZUF1ZGlvV29ya2xldE5vZGUsIG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgb3V0cHV0Q2hhbm5lbENvdW50ID0gQXJyYXkuaXNBcnJheShvcHRpb25zLm91dHB1dENoYW5uZWxDb3VudCkgPyBvcHRpb25zLm91dHB1dENoYW5uZWxDb3VudCA6IEFycmF5LmZyb20ob3B0aW9ucy5vdXRwdXRDaGFubmVsQ291bnQpOyAvLyBCdWcgIzYxOiBPbmx5IENocm9tZSwgRWRnZSAmIEZpcmVmb3ggaGF2ZSBhbiBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgQXVkaW9Xb3JrbGV0Tm9kZSB5ZXQuXG4gICAgICAgICAgICAgICAgICBpZiAobmF0aXZlQXVkaW9Xb3JrbGV0Tm9kZUNvbnN0cnVjdG9yID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIG51bWJlck9mT3V0cHV0Q2hhbm5lbHMgPSBvdXRwdXRDaGFubmVsQ291bnQucmVkdWNlKGZ1bmN0aW9uIChzdW0sIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN1bSArIHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0Q2hhbm5lbFNwbGl0dGVyTm9kZSA9IGNyZWF0ZU5hdGl2ZUNoYW5uZWxTcGxpdHRlck5vZGUobmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCwge1xuICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWxDb3VudDogTWF0aC5tYXgoMSwgbnVtYmVyT2ZPdXRwdXRDaGFubmVscyksXG4gICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbENvdW50TW9kZTogJ2V4cGxpY2l0JyxcbiAgICAgICAgICAgICAgICAgICAgICBjaGFubmVsSW50ZXJwcmV0YXRpb246ICdkaXNjcmV0ZScsXG4gICAgICAgICAgICAgICAgICAgICAgbnVtYmVyT2ZPdXRwdXRzOiBNYXRoLm1heCgxLCBudW1iZXJPZk91dHB1dENoYW5uZWxzKVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0Q2hhbm5lbE1lcmdlck5vZGVzID0gW107XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBwcm94eS5udW1iZXJPZk91dHB1dHM7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgIG91dHB1dENoYW5uZWxNZXJnZXJOb2Rlcy5wdXNoKGNyZWF0ZU5hdGl2ZUNoYW5uZWxNZXJnZXJOb2RlKG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWxDb3VudDogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWxDb3VudE1vZGU6ICdleHBsaWNpdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFubmVsSW50ZXJwcmV0YXRpb246ICdzcGVha2VycycsXG4gICAgICAgICAgICAgICAgICAgICAgICBudW1iZXJPZklucHV0czogb3V0cHV0Q2hhbm5lbENvdW50W2ldXG4gICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dEdhaW5Ob2RlID0gY3JlYXRlTmF0aXZlR2Fpbk5vZGUobmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCwge1xuICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWxDb3VudDogb3B0aW9ucy5jaGFubmVsQ291bnQsXG4gICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbENvdW50TW9kZTogb3B0aW9ucy5jaGFubmVsQ291bnRNb2RlLFxuICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWxJbnRlcnByZXRhdGlvbjogb3B0aW9ucy5jaGFubmVsSW50ZXJwcmV0YXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgZ2FpbjogMVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0R2Fpbk5vZGUuY29ubmVjdCA9IGNvbm5lY3RNdWx0aXBsZU91dHB1dHMuYmluZChudWxsLCBvdXRwdXRDaGFubmVsTWVyZ2VyTm9kZXMpO1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXRHYWluTm9kZS5kaXNjb25uZWN0ID0gZGlzY29ubmVjdE11bHRpcGxlT3V0cHV0cy5iaW5kKG51bGwsIG91dHB1dENoYW5uZWxNZXJnZXJOb2Rlcyk7XG4gICAgICAgICAgICAgICAgICAgIG5hdGl2ZU91dHB1dE5vZGVzID0gW291dHB1dENoYW5uZWxTcGxpdHRlck5vZGUsIG91dHB1dENoYW5uZWxNZXJnZXJOb2Rlcywgb3V0cHV0R2Fpbk5vZGVdO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICghbmF0aXZlQXVkaW9Xb3JrbGV0Tm9kZUlzT3duZWRCeUNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgbmF0aXZlQXVkaW9Xb3JrbGV0Tm9kZSA9IG5ldyBuYXRpdmVBdWRpb1dvcmtsZXROb2RlQ29uc3RydWN0b3IobmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCwgbmFtZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICByZW5kZXJlZE5hdGl2ZUF1ZGlvTm9kZXMuc2V0KG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQsIG5hdGl2ZU91dHB1dE5vZGVzID09PSBudWxsID8gbmF0aXZlQXVkaW9Xb3JrbGV0Tm9kZSA6IG5hdGl2ZU91dHB1dE5vZGVzWzJdKTtcbiAgICAgICAgICAgICAgICAgIGlmICghKG5hdGl2ZU91dHB1dE5vZGVzICE9PSBudWxsKSkge1xuICAgICAgICAgICAgICAgICAgICBfY29udGV4dDUubmV4dCA9IDQxO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmICghKHByb2Nlc3NlZEJ1ZmZlclByb21pc2UgPT09IG51bGwpKSB7XG4gICAgICAgICAgICAgICAgICAgIF9jb250ZXh0NS5uZXh0ID0gMzI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKCEocHJvY2Vzc29yQ29uc3RydWN0b3IgPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ1Lm5leHQgPSAxMDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgdGhlIHByb2Nlc3NvciBjb25zdHJ1Y3Rvci4nKTtcbiAgICAgICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICAgICAgaWYgKCEobmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dENvbnN0cnVjdG9yID09PSBudWxsKSkge1xuICAgICAgICAgICAgICAgICAgICBfY29udGV4dDUubmV4dCA9IDEyO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyB0aGUgbmF0aXZlIE9mZmxpbmVBdWRpb0NvbnRleHQgY29uc3RydWN0b3IuJyk7XG4gICAgICAgICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgICAgICAgIC8vIEJ1ZyAjNDc6IFRoZSBBdWRpb0Rlc3RpbmF0aW9uTm9kZSBpbiBTYWZhcmkgZ2V0cyBub3QgaW5pdGlhbGl6ZWQgY29ycmVjdGx5LlxuICAgICAgICAgICAgICAgICAgbnVtYmVyT2ZJbnB1dENoYW5uZWxzID0gcHJveHkuY2hhbm5lbENvdW50ICogcHJveHkubnVtYmVyT2ZJbnB1dHM7XG4gICAgICAgICAgICAgICAgICBudW1iZXJPZlBhcmFtZXRlcnMgPSBwcm9jZXNzb3JDb25zdHJ1Y3Rvci5wYXJhbWV0ZXJEZXNjcmlwdG9ycyA9PT0gdW5kZWZpbmVkID8gMCA6IHByb2Nlc3NvckNvbnN0cnVjdG9yLnBhcmFtZXRlckRlc2NyaXB0b3JzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgIG51bWJlck9mQ2hhbm5lbHMgPSBudW1iZXJPZklucHV0Q2hhbm5lbHMgKyBudW1iZXJPZlBhcmFtZXRlcnM7XG4gICAgICAgICAgICAgICAgICByZW5kZXJCdWZmZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX3JlZjQgPSBfYXN5bmNUb0dlbmVyYXRvcigvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUzKCkge1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJ0aWFsT2ZmbGluZUF1ZGlvQ29udGV4dCwgZ2Fpbk5vZGVzLCBpbnB1dENoYW5uZWxTcGxpdHRlck5vZGVzLCBfaSwgY29uc3RhbnRTb3VyY2VOb2RlcywgaW5wdXRDaGFubmVsTWVyZ2VyTm9kZSwgX2kyLCBqLCBfaXRlcmF0b3IsIF9zdGVwLCBfc3RlcCR2YWx1ZSwgaW5kZXgsIGNvbnN0YW50U291cmNlTm9kZTtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUzJChfY29udGV4dDQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICgxKSBzd2l0Y2ggKF9jb250ZXh0NC5wcmV2ID0gX2NvbnRleHQ0Lm5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRpYWxPZmZsaW5lQXVkaW9Db250ZXh0ID0gbmV3IG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHRDb25zdHJ1Y3RvcihudW1iZXJPZkNoYW5uZWxzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENlaWwgdGhlIGxlbmd0aCB0byB0aGUgbmV4dCBmdWxsIHJlbmRlciBxdWFudHVtLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJ1ZyAjMTc6IFNhZmFyaSBkb2VzIG5vdCB5ZXQgZXhwb3NlIHRoZSBsZW5ndGguXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5jZWlsKHByb3h5LmNvbnRleHQubGVuZ3RoIC8gMTI4KSAqIDEyOCwgbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dC5zYW1wbGVSYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnYWluTm9kZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dENoYW5uZWxTcGxpdHRlck5vZGVzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChfaSA9IDA7IF9pIDwgb3B0aW9ucy5udW1iZXJPZklucHV0czsgX2kgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2Fpbk5vZGVzLnB1c2goY3JlYXRlTmF0aXZlR2Fpbk5vZGUocGFydGlhbE9mZmxpbmVBdWRpb0NvbnRleHQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbENvdW50OiBvcHRpb25zLmNoYW5uZWxDb3VudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbENvdW50TW9kZTogb3B0aW9ucy5jaGFubmVsQ291bnRNb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFubmVsSW50ZXJwcmV0YXRpb246IG9wdGlvbnMuY2hhbm5lbEludGVycHJldGF0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnYWluOiAxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dENoYW5uZWxTcGxpdHRlck5vZGVzLnB1c2goY3JlYXRlTmF0aXZlQ2hhbm5lbFNwbGl0dGVyTm9kZShwYXJ0aWFsT2ZmbGluZUF1ZGlvQ29udGV4dCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFubmVsQ291bnQ6IG9wdGlvbnMuY2hhbm5lbENvdW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFubmVsQ291bnRNb2RlOiAnZXhwbGljaXQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFubmVsSW50ZXJwcmV0YXRpb246ICdkaXNjcmV0ZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bWJlck9mT3V0cHV0czogb3B0aW9ucy5jaGFubmVsQ291bnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ0Lm5leHQgPSA2O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChBcnJheS5mcm9tKHByb3h5LnBhcmFtZXRlcnMudmFsdWVzKCkpLm1hcCgvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9yZWY1ID0gX2FzeW5jVG9HZW5lcmF0b3IoLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlMihhdWRpb1BhcmFtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb25zdGFudFNvdXJjZU5vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0Mykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICgxKSBzd2l0Y2ggKF9jb250ZXh0My5wcmV2ID0gX2NvbnRleHQzLm5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3RhbnRTb3VyY2VOb2RlID0gY3JlYXRlTmF0aXZlQ29uc3RhbnRTb3VyY2VOb2RlKHBhcnRpYWxPZmZsaW5lQXVkaW9Db250ZXh0LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbENvdW50OiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWxDb3VudE1vZGU6ICdleHBsaWNpdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbEludGVycHJldGF0aW9uOiAnZGlzY3JldGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldDogYXVkaW9QYXJhbS52YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSAzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVuZGVyQXV0b21hdGlvbihwYXJ0aWFsT2ZmbGluZUF1ZGlvQ29udGV4dCwgYXVkaW9QYXJhbSwgY29uc3RhbnRTb3VyY2VOb2RlLm9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuYWJydXB0KFwicmV0dXJuXCIsIGNvbnN0YW50U291cmNlTm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgX2NhbGxlZTIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChfeDEwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfcmVmNS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KCkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0YW50U291cmNlTm9kZXMgPSBfY29udGV4dDQuc2VudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dENoYW5uZWxNZXJnZXJOb2RlID0gY3JlYXRlTmF0aXZlQ2hhbm5lbE1lcmdlck5vZGUocGFydGlhbE9mZmxpbmVBdWRpb0NvbnRleHQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWxDb3VudDogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWxDb3VudE1vZGU6ICdleHBsaWNpdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFubmVsSW50ZXJwcmV0YXRpb246ICdzcGVha2VycycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudW1iZXJPZklucHV0czogTWF0aC5tYXgoMSwgbnVtYmVyT2ZJbnB1dENoYW5uZWxzICsgbnVtYmVyT2ZQYXJhbWV0ZXJzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoX2kyID0gMDsgX2kyIDwgb3B0aW9ucy5udW1iZXJPZklucHV0czsgX2kyICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdhaW5Ob2Rlc1tfaTJdLmNvbm5lY3QoaW5wdXRDaGFubmVsU3BsaXR0ZXJOb2Rlc1tfaTJdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBvcHRpb25zLmNoYW5uZWxDb3VudDsgaiArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0Q2hhbm5lbFNwbGl0dGVyTm9kZXNbX2kyXS5jb25uZWN0KGlucHV0Q2hhbm5lbE1lcmdlck5vZGUsIGosIF9pMiAqIG9wdGlvbnMuY2hhbm5lbENvdW50ICsgaik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDQoY29uc3RhbnRTb3VyY2VOb2Rlcy5lbnRyaWVzKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfc3RlcCR2YWx1ZSA9IF9zbGljZWRUb0FycmF5KF9zdGVwLnZhbHVlLCAyKSwgaW5kZXggPSBfc3RlcCR2YWx1ZVswXSwgY29uc3RhbnRTb3VyY2VOb2RlID0gX3N0ZXAkdmFsdWVbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0YW50U291cmNlTm9kZS5jb25uZWN0KGlucHV0Q2hhbm5lbE1lcmdlck5vZGUsIDAsIG51bWJlck9mSW5wdXRDaGFubmVscyArIGluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3RhbnRTb3VyY2VOb2RlLnN0YXJ0KDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRDaGFubmVsTWVyZ2VyTm9kZS5jb25uZWN0KHBhcnRpYWxPZmZsaW5lQXVkaW9Db250ZXh0LmRlc3RpbmF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDQubmV4dCA9IDE0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChnYWluTm9kZXMubWFwKGZ1bmN0aW9uIChnYWluTm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlbmRlcklucHV0c09mQXVkaW9Ob2RlKHByb3h5LCBwYXJ0aWFsT2ZmbGluZUF1ZGlvQ29udGV4dCwgZ2Fpbk5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LmFicnVwdChcInJldHVyblwiLCByZW5kZXJOYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KHBhcnRpYWxPZmZsaW5lQXVkaW9Db250ZXh0KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9LCBfY2FsbGVlMyk7XG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHJlbmRlckJ1ZmZlcigpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3JlZjQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgIH0oKTtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0NS50MCA9IHByb2Nlc3NCdWZmZXI7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDUudDEgPSBwcm94eTtcbiAgICAgICAgICAgICAgICAgIGlmICghKG51bWJlck9mQ2hhbm5lbHMgPT09IDApKSB7XG4gICAgICAgICAgICAgICAgICAgIF9jb250ZXh0NS5uZXh0ID0gMjI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgX2NvbnRleHQ1LnQyID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0NS5uZXh0ID0gMjU7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDIyOlxuICAgICAgICAgICAgICAgICAgX2NvbnRleHQ1Lm5leHQgPSAyNDtcbiAgICAgICAgICAgICAgICAgIHJldHVybiByZW5kZXJCdWZmZXIoKTtcbiAgICAgICAgICAgICAgICBjYXNlIDI0OlxuICAgICAgICAgICAgICAgICAgX2NvbnRleHQ1LnQyID0gX2NvbnRleHQ1LnNlbnQ7XG4gICAgICAgICAgICAgICAgY2FzZSAyNTpcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0NS50MyA9IF9jb250ZXh0NS50MjtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0NS50NCA9IG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQ7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDUudDUgPSBvcHRpb25zO1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQ1LnQ2ID0gb3V0cHV0Q2hhbm5lbENvdW50O1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQ1LnQ3ID0gcHJvY2Vzc29yQ29uc3RydWN0b3I7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDUudDggPSBleHBvc2VDdXJyZW50RnJhbWVBbmRDdXJyZW50VGltZTtcbiAgICAgICAgICAgICAgICAgIHByb2Nlc3NlZEJ1ZmZlclByb21pc2UgPSAoMCwgX2NvbnRleHQ1LnQwKShfY29udGV4dDUudDEsIF9jb250ZXh0NS50MywgX2NvbnRleHQ1LnQ0LCBfY29udGV4dDUudDUsIF9jb250ZXh0NS50NiwgX2NvbnRleHQ1LnQ3LCBfY29udGV4dDUudDgpO1xuICAgICAgICAgICAgICAgIGNhc2UgMzI6XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDUubmV4dCA9IDM0O1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb2Nlc3NlZEJ1ZmZlclByb21pc2U7XG4gICAgICAgICAgICAgICAgY2FzZSAzNDpcbiAgICAgICAgICAgICAgICAgIHByb2Nlc3NlZEJ1ZmZlciA9IF9jb250ZXh0NS5zZW50O1xuICAgICAgICAgICAgICAgICAgYXVkaW9CdWZmZXJTb3VyY2VOb2RlID0gY3JlYXRlTmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2RlKG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQsIHtcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBjaGFubmVsQ291bnQ6IDIsXG4gICAgICAgICAgICAgICAgICAgIGNoYW5uZWxDb3VudE1vZGU6ICdtYXgnLFxuICAgICAgICAgICAgICAgICAgICBjaGFubmVsSW50ZXJwcmV0YXRpb246ICdzcGVha2VycycsXG4gICAgICAgICAgICAgICAgICAgIGxvb3A6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBsb29wRW5kOiAwLFxuICAgICAgICAgICAgICAgICAgICBsb29wU3RhcnQ6IDAsXG4gICAgICAgICAgICAgICAgICAgIHBsYXliYWNrUmF0ZTogMVxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICBfbmF0aXZlT3V0cHV0Tm9kZXMgPSBuYXRpdmVPdXRwdXROb2RlcywgX25hdGl2ZU91dHB1dE5vZGVzMiA9IF9zbGljZWRUb0FycmF5KF9uYXRpdmVPdXRwdXROb2RlcywgMyksIF9vdXRwdXRDaGFubmVsU3BsaXR0ZXJOb2RlID0gX25hdGl2ZU91dHB1dE5vZGVzMlswXSwgX291dHB1dENoYW5uZWxNZXJnZXJOb2RlcyA9IF9uYXRpdmVPdXRwdXROb2RlczJbMV0sIF9vdXRwdXRHYWluTm9kZSA9IF9uYXRpdmVPdXRwdXROb2RlczJbMl07XG4gICAgICAgICAgICAgICAgICBpZiAocHJvY2Vzc2VkQnVmZmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGF1ZGlvQnVmZmVyU291cmNlTm9kZS5idWZmZXIgPSBwcm9jZXNzZWRCdWZmZXI7XG4gICAgICAgICAgICAgICAgICAgIGF1ZGlvQnVmZmVyU291cmNlTm9kZS5zdGFydCgwKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGF1ZGlvQnVmZmVyU291cmNlTm9kZS5jb25uZWN0KF9vdXRwdXRDaGFubmVsU3BsaXR0ZXJOb2RlKTtcbiAgICAgICAgICAgICAgICAgIGZvciAoX2kzID0gMCwgb3V0cHV0Q2hhbm5lbFNwbGl0dGVyTm9kZU91dHB1dCA9IDA7IF9pMyA8IHByb3h5Lm51bWJlck9mT3V0cHV0czsgX2kzICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0Q2hhbm5lbE1lcmdlck5vZGUgPSBfb3V0cHV0Q2hhbm5lbE1lcmdlck5vZGVzW19pM107XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBvdXRwdXRDaGFubmVsQ291bnRbX2kzXTsgaiArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgX291dHB1dENoYW5uZWxTcGxpdHRlck5vZGUuY29ubmVjdChvdXRwdXRDaGFubmVsTWVyZ2VyTm9kZSwgb3V0cHV0Q2hhbm5lbFNwbGl0dGVyTm9kZU91dHB1dCArIGosIGopO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dENoYW5uZWxTcGxpdHRlck5vZGVPdXRwdXQgKz0gb3V0cHV0Q2hhbm5lbENvdW50W19pM107XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ1LmFicnVwdChcInJldHVyblwiLCBfb3V0cHV0R2Fpbk5vZGUpO1xuICAgICAgICAgICAgICAgIGNhc2UgNDE6XG4gICAgICAgICAgICAgICAgICBpZiAobmF0aXZlQXVkaW9Xb3JrbGV0Tm9kZUlzT3duZWRCeUNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ1Lm5leHQgPSA2MTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBfaXRlcmF0b3IyID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkNChwcm94eS5wYXJhbWV0ZXJzLmVudHJpZXMoKSk7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDUucHJldiA9IDQzO1xuICAgICAgICAgICAgICAgICAgX2l0ZXJhdG9yMi5zKCk7XG4gICAgICAgICAgICAgICAgY2FzZSA0NTpcbiAgICAgICAgICAgICAgICAgIGlmICgoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uKCkpLmRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ1Lm5leHQgPSA1MTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBfc3RlcDIkdmFsdWUgPSBfc2xpY2VkVG9BcnJheShfc3RlcDIudmFsdWUsIDIpLCBubSA9IF9zdGVwMiR2YWx1ZVswXSwgYXVkaW9QYXJhbSA9IF9zdGVwMiR2YWx1ZVsxXTtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0NS5uZXh0ID0gNDk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcmVuZGVyQXV0b21hdGlvbihuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LCBhdWRpb1BhcmFtLFxuICAgICAgICAgICAgICAgICAgLy8gQHRvZG8gVGhlIGRlZmluaXRpb24gdGhhdCBUeXBlU2NyaXB0IHVzZXMgb2YgdGhlIEF1ZGlvUGFyYW1NYXAgaXMgbGFja2luZyBtYW55IG1ldGhvZHMuXG4gICAgICAgICAgICAgICAgICBuYXRpdmVBdWRpb1dvcmtsZXROb2RlLnBhcmFtZXRlcnMuZ2V0KG5tKSk7XG4gICAgICAgICAgICAgICAgY2FzZSA0OTpcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0NS5uZXh0ID0gNDU7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDUxOlxuICAgICAgICAgICAgICAgICAgX2NvbnRleHQ1Lm5leHQgPSA1NjtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNTM6XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDUucHJldiA9IDUzO1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQ1LnQ5ID0gX2NvbnRleHQ1W1wiY2F0Y2hcIl0oNDMpO1xuICAgICAgICAgICAgICAgICAgX2l0ZXJhdG9yMi5lKF9jb250ZXh0NS50OSk7XG4gICAgICAgICAgICAgICAgY2FzZSA1NjpcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0NS5wcmV2ID0gNTY7XG4gICAgICAgICAgICAgICAgICBfaXRlcmF0b3IyLmYoKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDUuZmluaXNoKDU2KTtcbiAgICAgICAgICAgICAgICBjYXNlIDU5OlxuICAgICAgICAgICAgICAgICAgX2NvbnRleHQ1Lm5leHQgPSA3ODtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNjE6XG4gICAgICAgICAgICAgICAgICBfaXRlcmF0b3IzID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkNChwcm94eS5wYXJhbWV0ZXJzLmVudHJpZXMoKSk7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDUucHJldiA9IDYyO1xuICAgICAgICAgICAgICAgICAgX2l0ZXJhdG9yMy5zKCk7XG4gICAgICAgICAgICAgICAgY2FzZSA2NDpcbiAgICAgICAgICAgICAgICAgIGlmICgoX3N0ZXAzID0gX2l0ZXJhdG9yMy5uKCkpLmRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ1Lm5leHQgPSA3MDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBfc3RlcDMkdmFsdWUgPSBfc2xpY2VkVG9BcnJheShfc3RlcDMudmFsdWUsIDIpLCBfbm0gPSBfc3RlcDMkdmFsdWVbMF0sIF9hdWRpb1BhcmFtID0gX3N0ZXAzJHZhbHVlWzFdO1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQ1Lm5leHQgPSA2ODtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBjb25uZWN0QXVkaW9QYXJhbShuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LCBfYXVkaW9QYXJhbSxcbiAgICAgICAgICAgICAgICAgIC8vIEB0b2RvIFRoZSBkZWZpbml0aW9uIHRoYXQgVHlwZVNjcmlwdCB1c2VzIG9mIHRoZSBBdWRpb1BhcmFtTWFwIGlzIGxhY2tpbmcgbWFueSBtZXRob2RzLlxuICAgICAgICAgICAgICAgICAgbmF0aXZlQXVkaW9Xb3JrbGV0Tm9kZS5wYXJhbWV0ZXJzLmdldChfbm0pKTtcbiAgICAgICAgICAgICAgICBjYXNlIDY4OlxuICAgICAgICAgICAgICAgICAgX2NvbnRleHQ1Lm5leHQgPSA2NDtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNzA6XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDUubmV4dCA9IDc1O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA3MjpcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0NS5wcmV2ID0gNzI7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDUudDEwID0gX2NvbnRleHQ1W1wiY2F0Y2hcIl0oNjIpO1xuICAgICAgICAgICAgICAgICAgX2l0ZXJhdG9yMy5lKF9jb250ZXh0NS50MTApO1xuICAgICAgICAgICAgICAgIGNhc2UgNzU6XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDUucHJldiA9IDc1O1xuICAgICAgICAgICAgICAgICAgX2l0ZXJhdG9yMy5mKCk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ1LmZpbmlzaCg3NSk7XG4gICAgICAgICAgICAgICAgY2FzZSA3ODpcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0NS5uZXh0ID0gODA7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcmVuZGVySW5wdXRzT2ZBdWRpb05vZGUocHJveHksIG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQsIG5hdGl2ZUF1ZGlvV29ya2xldE5vZGUpO1xuICAgICAgICAgICAgICAgIGNhc2UgODA6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ1LmFicnVwdChcInJldHVyblwiLCBuYXRpdmVBdWRpb1dvcmtsZXROb2RlKTtcbiAgICAgICAgICAgICAgICBjYXNlIDgxOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDUuc3RvcCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBfY2FsbGVlNCwgbnVsbCwgW1s0MywgNTMsIDU2LCA1OV0sIFs2MiwgNzIsIDc1LCA3OF1dKTtcbiAgICAgICAgICB9KSk7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZUF1ZGlvTm9kZShfeDgsIF94OSkge1xuICAgICAgICAgICAgcmV0dXJuIF9yZWYzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKHByb3h5LCBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KSB7XG4gICAgICAgICAgICBkZWxldGVVbnJlbmRlcmVkQXVkaW9Xb3JrbGV0Tm9kZShuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LCBwcm94eSk7XG4gICAgICAgICAgICB2YXIgcmVuZGVyZWROYXRpdmVBdWRpb1dvcmtsZXROb2RlT3JHYWluTm9kZSA9IHJlbmRlcmVkTmF0aXZlQXVkaW9Ob2Rlcy5nZXQobmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCk7XG4gICAgICAgICAgICBpZiAocmVuZGVyZWROYXRpdmVBdWRpb1dvcmtsZXROb2RlT3JHYWluTm9kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVuZGVyZWROYXRpdmVBdWRpb1dvcmtsZXROb2RlT3JHYWluTm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlQXVkaW9Ob2RlKHByb3h5LCBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9O1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBvd25LZXlzJHIoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuICAgIGZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkcihlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzJHIoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzJHIoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTsgfSk7IH0gcmV0dXJuIGU7IH1cbiAgICBmdW5jdGlvbiBfY2FsbFN1cGVyJGwodCwgbywgZSkgeyByZXR1cm4gbyA9IF9nZXRQcm90b3R5cGVPZihvKSwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odCwgX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRsKCkgPyBSZWZsZWN0LmNvbnN0cnVjdChvLCBlIHx8IFtdLCBfZ2V0UHJvdG90eXBlT2YodCkuY29uc3RydWN0b3IpIDogby5hcHBseSh0LCBlKSk7IH1cbiAgICBmdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JGwoKSB7IHRyeSB7IHZhciB0ID0gIUJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgfSBjYXRjaCAodCkge30gcmV0dXJuIChfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JGwgPSBmdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyByZXR1cm4gISF0OyB9KSgpOyB9XG4gICAgdmFyIGNyZWF0ZUJhc2VBdWRpb0NvbnRleHRDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uIGNyZWF0ZUJhc2VBdWRpb0NvbnRleHRDb25zdHJ1Y3RvcihhZGRBdWRpb1dvcmtsZXRNb2R1bGUsIGFuYWx5c2VyTm9kZUNvbnN0cnVjdG9yLCBhdWRpb0J1ZmZlckNvbnN0cnVjdG9yLCBhdWRpb0J1ZmZlclNvdXJjZU5vZGVDb25zdHJ1Y3RvciwgYmlxdWFkRmlsdGVyTm9kZUNvbnN0cnVjdG9yLCBjaGFubmVsTWVyZ2VyTm9kZUNvbnN0cnVjdG9yLCBjaGFubmVsU3BsaXR0ZXJOb2RlQ29uc3RydWN0b3IsIGNvbnN0YW50U291cmNlTm9kZUNvbnN0cnVjdG9yLCBjb252b2x2ZXJOb2RlQ29uc3RydWN0b3IsIF9kZWNvZGVBdWRpb0RhdGEsIGRlbGF5Tm9kZUNvbnN0cnVjdG9yLCBkeW5hbWljc0NvbXByZXNzb3JOb2RlQ29uc3RydWN0b3IsIGdhaW5Ob2RlQ29uc3RydWN0b3IsIGlJUkZpbHRlck5vZGVDb25zdHJ1Y3RvciwgbWluaW1hbEJhc2VBdWRpb0NvbnRleHRDb25zdHJ1Y3Rvciwgb3NjaWxsYXRvck5vZGVDb25zdHJ1Y3RvciwgcGFubmVyTm9kZUNvbnN0cnVjdG9yLCBwZXJpb2RpY1dhdmVDb25zdHJ1Y3Rvciwgc3RlcmVvUGFubmVyTm9kZUNvbnN0cnVjdG9yLCB3YXZlU2hhcGVyTm9kZUNvbnN0cnVjdG9yKSB7XG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfbWluaW1hbEJhc2VBdWRpb0NvbnQpIHtcbiAgICAgICAgZnVuY3Rpb24gQmFzZUF1ZGlvQ29udGV4dChfbmF0aXZlQ29udGV4dCwgbnVtYmVyT2ZDaGFubmVscykge1xuICAgICAgICAgIHZhciBfdGhpcztcbiAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQmFzZUF1ZGlvQ29udGV4dCk7XG4gICAgICAgICAgX3RoaXMgPSBfY2FsbFN1cGVyJGwodGhpcywgQmFzZUF1ZGlvQ29udGV4dCwgW19uYXRpdmVDb250ZXh0LCBudW1iZXJPZkNoYW5uZWxzXSk7XG4gICAgICAgICAgX3RoaXMuX25hdGl2ZUNvbnRleHQgPSBfbmF0aXZlQ29udGV4dDtcbiAgICAgICAgICBfdGhpcy5fYXVkaW9Xb3JrbGV0ID0gYWRkQXVkaW9Xb3JrbGV0TW9kdWxlID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiB7XG4gICAgICAgICAgICBhZGRNb2R1bGU6IGZ1bmN0aW9uIGFkZE1vZHVsZShtb2R1bGVVUkwsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGFkZEF1ZGlvV29ya2xldE1vZHVsZShfdGhpcywgbW9kdWxlVVJMLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgICAgfVxuICAgICAgICBfaW5oZXJpdHMoQmFzZUF1ZGlvQ29udGV4dCwgX21pbmltYWxCYXNlQXVkaW9Db250KTtcbiAgICAgICAgcmV0dXJuIF9jcmVhdGVDbGFzcyhCYXNlQXVkaW9Db250ZXh0LCBbe1xuICAgICAgICAgIGtleTogXCJhdWRpb1dvcmtsZXRcIixcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hdWRpb1dvcmtsZXQ7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcImNyZWF0ZUFuYWx5c2VyXCIsXG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZUFuYWx5c2VyKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBhbmFseXNlck5vZGVDb25zdHJ1Y3Rvcih0aGlzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBrZXk6IFwiY3JlYXRlQmlxdWFkRmlsdGVyXCIsXG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZUJpcXVhZEZpbHRlcigpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgYmlxdWFkRmlsdGVyTm9kZUNvbnN0cnVjdG9yKHRoaXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIGtleTogXCJjcmVhdGVCdWZmZXJcIixcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlQnVmZmVyKG51bWJlck9mQ2hhbm5lbHMsIGxlbmd0aCwgc2FtcGxlUmF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBhdWRpb0J1ZmZlckNvbnN0cnVjdG9yKHtcbiAgICAgICAgICAgICAgbGVuZ3RoOiBsZW5ndGgsXG4gICAgICAgICAgICAgIG51bWJlck9mQ2hhbm5lbHM6IG51bWJlck9mQ2hhbm5lbHMsXG4gICAgICAgICAgICAgIHNhbXBsZVJhdGU6IHNhbXBsZVJhdGVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIGtleTogXCJjcmVhdGVCdWZmZXJTb3VyY2VcIixcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlQnVmZmVyU291cmNlKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBhdWRpb0J1ZmZlclNvdXJjZU5vZGVDb25zdHJ1Y3Rvcih0aGlzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBrZXk6IFwiY3JlYXRlQ2hhbm5lbE1lcmdlclwiLFxuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVDaGFubmVsTWVyZ2VyKCkge1xuICAgICAgICAgICAgdmFyIG51bWJlck9mSW5wdXRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiA2O1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBjaGFubmVsTWVyZ2VyTm9kZUNvbnN0cnVjdG9yKHRoaXMsIHtcbiAgICAgICAgICAgICAgbnVtYmVyT2ZJbnB1dHM6IG51bWJlck9mSW5wdXRzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBrZXk6IFwiY3JlYXRlQ2hhbm5lbFNwbGl0dGVyXCIsXG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZUNoYW5uZWxTcGxpdHRlcigpIHtcbiAgICAgICAgICAgIHZhciBudW1iZXJPZk91dHB1dHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDY7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGNoYW5uZWxTcGxpdHRlck5vZGVDb25zdHJ1Y3Rvcih0aGlzLCB7XG4gICAgICAgICAgICAgIG51bWJlck9mT3V0cHV0czogbnVtYmVyT2ZPdXRwdXRzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBrZXk6IFwiY3JlYXRlQ29uc3RhbnRTb3VyY2VcIixcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlQ29uc3RhbnRTb3VyY2UoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGNvbnN0YW50U291cmNlTm9kZUNvbnN0cnVjdG9yKHRoaXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIGtleTogXCJjcmVhdGVDb252b2x2ZXJcIixcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlQ29udm9sdmVyKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBjb252b2x2ZXJOb2RlQ29uc3RydWN0b3IodGhpcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcImNyZWF0ZURlbGF5XCIsXG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZURlbGF5KCkge1xuICAgICAgICAgICAgdmFyIG1heERlbGF5VGltZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogMTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgZGVsYXlOb2RlQ29uc3RydWN0b3IodGhpcywge1xuICAgICAgICAgICAgICBtYXhEZWxheVRpbWU6IG1heERlbGF5VGltZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcImNyZWF0ZUR5bmFtaWNzQ29tcHJlc3NvclwiLFxuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVEeW5hbWljc0NvbXByZXNzb3IoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGR5bmFtaWNzQ29tcHJlc3Nvck5vZGVDb25zdHJ1Y3Rvcih0aGlzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBrZXk6IFwiY3JlYXRlR2FpblwiLFxuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVHYWluKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBnYWluTm9kZUNvbnN0cnVjdG9yKHRoaXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIGtleTogXCJjcmVhdGVJSVJGaWx0ZXJcIixcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlSUlSRmlsdGVyKGZlZWRmb3J3YXJkLCBmZWVkYmFjaykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBpSVJGaWx0ZXJOb2RlQ29uc3RydWN0b3IodGhpcywge1xuICAgICAgICAgICAgICBmZWVkYmFjazogZmVlZGJhY2ssXG4gICAgICAgICAgICAgIGZlZWRmb3J3YXJkOiBmZWVkZm9yd2FyZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcImNyZWF0ZU9zY2lsbGF0b3JcIixcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlT3NjaWxsYXRvcigpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgb3NjaWxsYXRvck5vZGVDb25zdHJ1Y3Rvcih0aGlzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBrZXk6IFwiY3JlYXRlUGFubmVyXCIsXG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZVBhbm5lcigpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgcGFubmVyTm9kZUNvbnN0cnVjdG9yKHRoaXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIGtleTogXCJjcmVhdGVQZXJpb2RpY1dhdmVcIixcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlUGVyaW9kaWNXYXZlKHJlYWwsIGltYWcpIHtcbiAgICAgICAgICAgIHZhciBjb25zdHJhaW50cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge1xuICAgICAgICAgICAgICBkaXNhYmxlTm9ybWFsaXphdGlvbjogZmFsc2VcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gbmV3IHBlcmlvZGljV2F2ZUNvbnN0cnVjdG9yKHRoaXMsIF9vYmplY3RTcHJlYWQkcihfb2JqZWN0U3ByZWFkJHIoe30sIGNvbnN0cmFpbnRzKSwge30sIHtcbiAgICAgICAgICAgICAgaW1hZzogaW1hZyxcbiAgICAgICAgICAgICAgcmVhbDogcmVhbFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIGtleTogXCJjcmVhdGVTdGVyZW9QYW5uZXJcIixcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlU3RlcmVvUGFubmVyKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBzdGVyZW9QYW5uZXJOb2RlQ29uc3RydWN0b3IodGhpcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcImNyZWF0ZVdhdmVTaGFwZXJcIixcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlV2F2ZVNoYXBlcigpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgd2F2ZVNoYXBlck5vZGVDb25zdHJ1Y3Rvcih0aGlzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBrZXk6IFwiZGVjb2RlQXVkaW9EYXRhXCIsXG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlY29kZUF1ZGlvRGF0YShhdWRpb0RhdGEsIHN1Y2Nlc3NDYWxsYmFjaywgZXJyb3JDYWxsYmFjaykge1xuICAgICAgICAgICAgcmV0dXJuIF9kZWNvZGVBdWRpb0RhdGEodGhpcy5fbmF0aXZlQ29udGV4dCwgYXVkaW9EYXRhKS50aGVuKGZ1bmN0aW9uIChhdWRpb0J1ZmZlcikge1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIHN1Y2Nlc3NDYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3NDYWxsYmFjayhhdWRpb0J1ZmZlcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGF1ZGlvQnVmZmVyO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIGVycm9yQ2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBlcnJvckNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XSk7XG4gICAgICB9KG1pbmltYWxCYXNlQXVkaW9Db250ZXh0Q29uc3RydWN0b3IpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBvd25LZXlzJHEoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuICAgIGZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkcShlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzJHEoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzJHEoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTsgfSk7IH0gcmV0dXJuIGU7IH1cbiAgICBmdW5jdGlvbiBfY2FsbFN1cGVyJGsodCwgbywgZSkgeyByZXR1cm4gbyA9IF9nZXRQcm90b3R5cGVPZihvKSwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odCwgX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRrKCkgPyBSZWZsZWN0LmNvbnN0cnVjdChvLCBlIHx8IFtdLCBfZ2V0UHJvdG90eXBlT2YodCkuY29uc3RydWN0b3IpIDogby5hcHBseSh0LCBlKSk7IH1cbiAgICBmdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JGsoKSB7IHRyeSB7IHZhciB0ID0gIUJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgfSBjYXRjaCAodCkge30gcmV0dXJuIChfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JGsgPSBmdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyByZXR1cm4gISF0OyB9KSgpOyB9XG4gICAgdmFyIERFRkFVTFRfT1BUSU9OUyRnID0ge1xuICAgICAgUTogMSxcbiAgICAgIGNoYW5uZWxDb3VudDogMixcbiAgICAgIGNoYW5uZWxDb3VudE1vZGU6ICdtYXgnLFxuICAgICAgY2hhbm5lbEludGVycHJldGF0aW9uOiAnc3BlYWtlcnMnLFxuICAgICAgZGV0dW5lOiAwLFxuICAgICAgZnJlcXVlbmN5OiAzNTAsXG4gICAgICBnYWluOiAwLFxuICAgICAgdHlwZTogJ2xvd3Bhc3MnXG4gICAgfTtcbiAgICB2YXIgY3JlYXRlQmlxdWFkRmlsdGVyTm9kZUNvbnN0cnVjdG9yID0gZnVuY3Rpb24gY3JlYXRlQmlxdWFkRmlsdGVyTm9kZUNvbnN0cnVjdG9yKGF1ZGlvTm9kZUNvbnN0cnVjdG9yLCBjcmVhdGVBdWRpb1BhcmFtLCBjcmVhdGVCaXF1YWRGaWx0ZXJOb2RlUmVuZGVyZXIsIGNyZWF0ZUludmFsaWRBY2Nlc3NFcnJvciwgY3JlYXRlTmF0aXZlQmlxdWFkRmlsdGVyTm9kZSwgZ2V0TmF0aXZlQ29udGV4dCwgaXNOYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LCBzZXRBdWRpb05vZGVUYWlsVGltZSkge1xuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX2F1ZGlvTm9kZUNvbnN0cnVjdG9yKSB7XG4gICAgICAgIGZ1bmN0aW9uIEJpcXVhZEZpbHRlck5vZGUoY29udGV4dCwgb3B0aW9ucykge1xuICAgICAgICAgIHZhciBfdGhpcztcbiAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQmlxdWFkRmlsdGVyTm9kZSk7XG4gICAgICAgICAgdmFyIG5hdGl2ZUNvbnRleHQgPSBnZXROYXRpdmVDb250ZXh0KGNvbnRleHQpO1xuICAgICAgICAgIHZhciBtZXJnZWRPcHRpb25zID0gX29iamVjdFNwcmVhZCRxKF9vYmplY3RTcHJlYWQkcSh7fSwgREVGQVVMVF9PUFRJT05TJGcpLCBvcHRpb25zKTtcbiAgICAgICAgICB2YXIgbmF0aXZlQmlxdWFkRmlsdGVyTm9kZSA9IGNyZWF0ZU5hdGl2ZUJpcXVhZEZpbHRlck5vZGUobmF0aXZlQ29udGV4dCwgbWVyZ2VkT3B0aW9ucyk7XG4gICAgICAgICAgdmFyIGlzT2ZmbGluZSA9IGlzTmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dChuYXRpdmVDb250ZXh0KTtcbiAgICAgICAgICB2YXIgYmlxdWFkRmlsdGVyTm9kZVJlbmRlcmVyID0gaXNPZmZsaW5lID8gY3JlYXRlQmlxdWFkRmlsdGVyTm9kZVJlbmRlcmVyKCkgOiBudWxsO1xuICAgICAgICAgIF90aGlzID0gX2NhbGxTdXBlciRrKHRoaXMsIEJpcXVhZEZpbHRlck5vZGUsIFtjb250ZXh0LCBmYWxzZSwgbmF0aXZlQmlxdWFkRmlsdGVyTm9kZSwgYmlxdWFkRmlsdGVyTm9kZVJlbmRlcmVyXSk7XG4gICAgICAgICAgLy8gQnVnICM4MDogU2FmYXJpIGRvZXMgbm90IGV4cG9ydCB0aGUgY29ycmVjdCB2YWx1ZXMgZm9yIG1heFZhbHVlIGFuZCBtaW5WYWx1ZS5cbiAgICAgICAgICBfdGhpcy5fUSA9IGNyZWF0ZUF1ZGlvUGFyYW0oX3RoaXMsIGlzT2ZmbGluZSwgbmF0aXZlQmlxdWFkRmlsdGVyTm9kZS5RLCBNT1NUX1BPU0lUSVZFX1NJTkdMRV9GTE9BVCwgTU9TVF9ORUdBVElWRV9TSU5HTEVfRkxPQVQpO1xuICAgICAgICAgIC8vIEJ1ZyAjNzg6IEZpcmVmb3ggJiBTYWZhcmkgZG8gbm90IGV4cG9ydCB0aGUgY29ycmVjdCB2YWx1ZXMgZm9yIG1heFZhbHVlIGFuZCBtaW5WYWx1ZS5cbiAgICAgICAgICBfdGhpcy5fZGV0dW5lID0gY3JlYXRlQXVkaW9QYXJhbShfdGhpcywgaXNPZmZsaW5lLCBuYXRpdmVCaXF1YWRGaWx0ZXJOb2RlLmRldHVuZSwgMTIwMCAqIE1hdGgubG9nMihNT1NUX1BPU0lUSVZFX1NJTkdMRV9GTE9BVCksIC0xMjAwICogTWF0aC5sb2cyKE1PU1RfUE9TSVRJVkVfU0lOR0xFX0ZMT0FUKSk7XG4gICAgICAgICAgLy8gQnVnICM3NzogRmlyZWZveCAmIFNhZmFyaSBkbyBub3QgZXhwb3J0IHRoZSBjb3JyZWN0IHZhbHVlIGZvciBtaW5WYWx1ZS5cbiAgICAgICAgICBfdGhpcy5fZnJlcXVlbmN5ID0gY3JlYXRlQXVkaW9QYXJhbShfdGhpcywgaXNPZmZsaW5lLCBuYXRpdmVCaXF1YWRGaWx0ZXJOb2RlLmZyZXF1ZW5jeSwgY29udGV4dC5zYW1wbGVSYXRlIC8gMiwgMCk7XG4gICAgICAgICAgLy8gQnVnICM3OTogRmlyZWZveCAmIFNhZmFyaSBkbyBub3QgZXhwb3J0IHRoZSBjb3JyZWN0IHZhbHVlcyBmb3IgbWF4VmFsdWUgYW5kIG1pblZhbHVlLlxuICAgICAgICAgIF90aGlzLl9nYWluID0gY3JlYXRlQXVkaW9QYXJhbShfdGhpcywgaXNPZmZsaW5lLCBuYXRpdmVCaXF1YWRGaWx0ZXJOb2RlLmdhaW4sIDQwICogTWF0aC5sb2cxMChNT1NUX1BPU0lUSVZFX1NJTkdMRV9GTE9BVCksIE1PU1RfTkVHQVRJVkVfU0lOR0xFX0ZMT0FUKTtcbiAgICAgICAgICBfdGhpcy5fbmF0aXZlQmlxdWFkRmlsdGVyTm9kZSA9IG5hdGl2ZUJpcXVhZEZpbHRlck5vZGU7XG4gICAgICAgICAgLy8gQHRvZG8gRGV0ZXJtaW5lIGEgbWVhbmluZ2Z1bCB0YWlsLXRpbWUgaW5zdGVhZCBvZiBqdXN0IHVzaW5nIG9uZSBzZWNvbmQuXG4gICAgICAgICAgc2V0QXVkaW9Ob2RlVGFpbFRpbWUoX3RoaXMsIDEpO1xuICAgICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgICAgfVxuICAgICAgICBfaW5oZXJpdHMoQmlxdWFkRmlsdGVyTm9kZSwgX2F1ZGlvTm9kZUNvbnN0cnVjdG9yKTtcbiAgICAgICAgcmV0dXJuIF9jcmVhdGVDbGFzcyhCaXF1YWRGaWx0ZXJOb2RlLCBbe1xuICAgICAgICAgIGtleTogXCJkZXR1bmVcIixcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZXR1bmU7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcImZyZXF1ZW5jeVwiLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZyZXF1ZW5jeTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBrZXk6IFwiZ2FpblwiLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dhaW47XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcIlFcIixcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9RO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIGtleTogXCJ0eXBlXCIsXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbmF0aXZlQmlxdWFkRmlsdGVyTm9kZS50eXBlO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX25hdGl2ZUJpcXVhZEZpbHRlck5vZGUudHlwZSA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIGtleTogXCJnZXRGcmVxdWVuY3lSZXNwb25zZVwiLFxuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRGcmVxdWVuY3lSZXNwb25zZShmcmVxdWVuY3lIeiwgbWFnUmVzcG9uc2UsIHBoYXNlUmVzcG9uc2UpIHtcbiAgICAgICAgICAgIC8vIEJ1ZyAjMTg5OiBTYWZhcmkgZG9lcyB0aHJvdyBhbiBJbnZhbGlkU3RhdGVFcnJvci5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHRoaXMuX25hdGl2ZUJpcXVhZEZpbHRlck5vZGUuZ2V0RnJlcXVlbmN5UmVzcG9uc2UoZnJlcXVlbmN5SHosIG1hZ1Jlc3BvbnNlLCBwaGFzZVJlc3BvbnNlKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICBpZiAoZXJyLmNvZGUgPT09IDExKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgY3JlYXRlSW52YWxpZEFjY2Vzc0Vycm9yKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQnVnICM2ODogU2FmYXJpIGRvZXMgbm90IHRocm93IGFuIGVycm9yIGlmIHRoZSBwYXJhbWV0ZXJzIGRpZmZlciBpbiB0aGVpciBsZW5ndGguXG4gICAgICAgICAgICBpZiAoZnJlcXVlbmN5SHoubGVuZ3RoICE9PSBtYWdSZXNwb25zZS5sZW5ndGggfHwgbWFnUmVzcG9uc2UubGVuZ3RoICE9PSBwaGFzZVJlc3BvbnNlLmxlbmd0aCkge1xuICAgICAgICAgICAgICB0aHJvdyBjcmVhdGVJbnZhbGlkQWNjZXNzRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1dKTtcbiAgICAgIH0oYXVkaW9Ob2RlQ29uc3RydWN0b3IpO1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlQmlxdWFkRmlsdGVyTm9kZVJlbmRlcmVyRmFjdG9yeSA9IGZ1bmN0aW9uIGNyZWF0ZUJpcXVhZEZpbHRlck5vZGVSZW5kZXJlckZhY3RvcnkoY29ubmVjdEF1ZGlvUGFyYW0sIGNyZWF0ZU5hdGl2ZUJpcXVhZEZpbHRlck5vZGUsIGdldE5hdGl2ZUF1ZGlvTm9kZSwgcmVuZGVyQXV0b21hdGlvbiwgcmVuZGVySW5wdXRzT2ZBdWRpb05vZGUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZW5kZXJlZE5hdGl2ZUJpcXVhZEZpbHRlck5vZGVzID0gbmV3IFdlYWtNYXAoKTtcbiAgICAgICAgdmFyIGNyZWF0ZUJpcXVhZEZpbHRlck5vZGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBfcmVmID0gX2FzeW5jVG9HZW5lcmF0b3IoLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlKHByb3h5LCBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KSB7XG4gICAgICAgICAgICB2YXIgbmF0aXZlQmlxdWFkRmlsdGVyTm9kZSwgbmF0aXZlQmlxdWFkRmlsdGVyTm9kZUlzT3duZWRCeUNvbnRleHQsIG9wdGlvbnM7XG4gICAgICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICAgICAgICAgIHdoaWxlICgxKSBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgbmF0aXZlQmlxdWFkRmlsdGVyTm9kZSA9IGdldE5hdGl2ZUF1ZGlvTm9kZShwcm94eSk7XG4gICAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAgICogSWYgdGhlIGluaXRpYWxseSB1c2VkIG5hdGl2ZUJpcXVhZEZpbHRlck5vZGUgd2FzIG5vdCBjb25zdHJ1Y3RlZCBvbiB0aGUgc2FtZSBPZmZsaW5lQXVkaW9Db250ZXh0IGl0IG5lZWRzIHRvIGJlIGNyZWF0ZWRcbiAgICAgICAgICAgICAgICAgICAqIGFnYWluLlxuICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICBuYXRpdmVCaXF1YWRGaWx0ZXJOb2RlSXNPd25lZEJ5Q29udGV4dCA9IGlzT3duZWRCeUNvbnRleHQobmF0aXZlQmlxdWFkRmlsdGVyTm9kZSwgbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCk7XG4gICAgICAgICAgICAgICAgICBpZiAoIW5hdGl2ZUJpcXVhZEZpbHRlck5vZGVJc093bmVkQnlDb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgUTogbmF0aXZlQmlxdWFkRmlsdGVyTm9kZS5RLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWxDb3VudDogbmF0aXZlQmlxdWFkRmlsdGVyTm9kZS5jaGFubmVsQ291bnQsXG4gICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbENvdW50TW9kZTogbmF0aXZlQmlxdWFkRmlsdGVyTm9kZS5jaGFubmVsQ291bnRNb2RlLFxuICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWxJbnRlcnByZXRhdGlvbjogbmF0aXZlQmlxdWFkRmlsdGVyTm9kZS5jaGFubmVsSW50ZXJwcmV0YXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgZGV0dW5lOiBuYXRpdmVCaXF1YWRGaWx0ZXJOb2RlLmRldHVuZS52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICBmcmVxdWVuY3k6IG5hdGl2ZUJpcXVhZEZpbHRlck5vZGUuZnJlcXVlbmN5LnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgIGdhaW46IG5hdGl2ZUJpcXVhZEZpbHRlck5vZGUuZ2Fpbi52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBuYXRpdmVCaXF1YWRGaWx0ZXJOb2RlLnR5cGVcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgbmF0aXZlQmlxdWFkRmlsdGVyTm9kZSA9IGNyZWF0ZU5hdGl2ZUJpcXVhZEZpbHRlck5vZGUobmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICByZW5kZXJlZE5hdGl2ZUJpcXVhZEZpbHRlck5vZGVzLnNldChuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LCBuYXRpdmVCaXF1YWRGaWx0ZXJOb2RlKTtcbiAgICAgICAgICAgICAgICAgIGlmIChuYXRpdmVCaXF1YWRGaWx0ZXJOb2RlSXNPd25lZEJ5Q29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDc7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcmVuZGVyQXV0b21hdGlvbihuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LCBwcm94eS5RLCBuYXRpdmVCaXF1YWRGaWx0ZXJOb2RlLlEpO1xuICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA5O1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlbmRlckF1dG9tYXRpb24obmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCwgcHJveHkuZGV0dW5lLCBuYXRpdmVCaXF1YWRGaWx0ZXJOb2RlLmRldHVuZSk7XG4gICAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDExO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlbmRlckF1dG9tYXRpb24obmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCwgcHJveHkuZnJlcXVlbmN5LCBuYXRpdmVCaXF1YWRGaWx0ZXJOb2RlLmZyZXF1ZW5jeSk7XG4gICAgICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxMztcbiAgICAgICAgICAgICAgICAgIHJldHVybiByZW5kZXJBdXRvbWF0aW9uKG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQsIHByb3h5LmdhaW4sIG5hdGl2ZUJpcXVhZEZpbHRlck5vZGUuZ2Fpbik7XG4gICAgICAgICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAyMztcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTc7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gY29ubmVjdEF1ZGlvUGFyYW0obmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCwgcHJveHkuUSwgbmF0aXZlQmlxdWFkRmlsdGVyTm9kZS5RKTtcbiAgICAgICAgICAgICAgICBjYXNlIDE3OlxuICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDE5O1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbm5lY3RBdWRpb1BhcmFtKG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQsIHByb3h5LmRldHVuZSwgbmF0aXZlQmlxdWFkRmlsdGVyTm9kZS5kZXR1bmUpO1xuICAgICAgICAgICAgICAgIGNhc2UgMTk6XG4gICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjE7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gY29ubmVjdEF1ZGlvUGFyYW0obmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCwgcHJveHkuZnJlcXVlbmN5LCBuYXRpdmVCaXF1YWRGaWx0ZXJOb2RlLmZyZXF1ZW5jeSk7XG4gICAgICAgICAgICAgICAgY2FzZSAyMTpcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAyMztcbiAgICAgICAgICAgICAgICAgIHJldHVybiBjb25uZWN0QXVkaW9QYXJhbShuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LCBwcm94eS5nYWluLCBuYXRpdmVCaXF1YWRGaWx0ZXJOb2RlLmdhaW4pO1xuICAgICAgICAgICAgICAgIGNhc2UgMjM6XG4gICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjU7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcmVuZGVySW5wdXRzT2ZBdWRpb05vZGUocHJveHksIG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQsIG5hdGl2ZUJpcXVhZEZpbHRlck5vZGUpO1xuICAgICAgICAgICAgICAgIGNhc2UgMjU6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIG5hdGl2ZUJpcXVhZEZpbHRlck5vZGUpO1xuICAgICAgICAgICAgICAgIGNhc2UgMjY6XG4gICAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgX2NhbGxlZSk7XG4gICAgICAgICAgfSkpO1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiBjcmVhdGVCaXF1YWRGaWx0ZXJOb2RlKF94LCBfeDIpIHtcbiAgICAgICAgICAgIHJldHVybiBfcmVmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKHByb3h5LCBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KSB7XG4gICAgICAgICAgICB2YXIgcmVuZGVyZWROYXRpdmVCaXF1YWRGaWx0ZXJOb2RlID0gcmVuZGVyZWROYXRpdmVCaXF1YWRGaWx0ZXJOb2Rlcy5nZXQobmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCk7XG4gICAgICAgICAgICBpZiAocmVuZGVyZWROYXRpdmVCaXF1YWRGaWx0ZXJOb2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZW5kZXJlZE5hdGl2ZUJpcXVhZEZpbHRlck5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUJpcXVhZEZpbHRlck5vZGUocHJveHksIG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVDYWNoZVRlc3RSZXN1bHQgPSBmdW5jdGlvbiBjcmVhdGVDYWNoZVRlc3RSZXN1bHQob25nb2luZ1Rlc3RzLCB0ZXN0UmVzdWx0cykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICh0ZXN0ZXIsIHRlc3QpIHtcbiAgICAgICAgdmFyIGNhY2hlZFRlc3RSZXN1bHQgPSB0ZXN0UmVzdWx0cy5nZXQodGVzdGVyKTtcbiAgICAgICAgaWYgKGNhY2hlZFRlc3RSZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiBjYWNoZWRUZXN0UmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHZhciBvbmdvaW5nVGVzdCA9IG9uZ29pbmdUZXN0cy5nZXQodGVzdGVyKTtcbiAgICAgICAgaWYgKG9uZ29pbmdUZXN0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gb25nb2luZ1Rlc3Q7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgc3luY2hyb25vdXNUZXN0UmVzdWx0ID0gdGVzdCgpO1xuICAgICAgICAgIGlmIChzeW5jaHJvbm91c1Rlc3RSZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICBvbmdvaW5nVGVzdHMuc2V0KHRlc3Rlciwgc3luY2hyb25vdXNUZXN0UmVzdWx0KTtcbiAgICAgICAgICAgIHJldHVybiBzeW5jaHJvbm91c1Rlc3RSZXN1bHRbXCJjYXRjaFwiXShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKGZpbmFsVGVzdFJlc3VsdCkge1xuICAgICAgICAgICAgICBvbmdvaW5nVGVzdHNbXCJkZWxldGVcIl0odGVzdGVyKTtcbiAgICAgICAgICAgICAgdGVzdFJlc3VsdHMuc2V0KHRlc3RlciwgZmluYWxUZXN0UmVzdWx0KTtcbiAgICAgICAgICAgICAgcmV0dXJuIGZpbmFsVGVzdFJlc3VsdDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0ZXN0UmVzdWx0cy5zZXQodGVzdGVyLCBzeW5jaHJvbm91c1Rlc3RSZXN1bHQpO1xuICAgICAgICAgIHJldHVybiBzeW5jaHJvbm91c1Rlc3RSZXN1bHQ7XG4gICAgICAgIH0gY2F0Y2ggKF91bnVzZWQpIHtcbiAgICAgICAgICB0ZXN0UmVzdWx0cy5zZXQodGVzdGVyLCBmYWxzZSk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBvd25LZXlzJHAoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuICAgIGZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkcChlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzJHAoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzJHAoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTsgfSk7IH0gcmV0dXJuIGU7IH1cbiAgICBmdW5jdGlvbiBfY2FsbFN1cGVyJGoodCwgbywgZSkgeyByZXR1cm4gbyA9IF9nZXRQcm90b3R5cGVPZihvKSwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odCwgX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRqKCkgPyBSZWZsZWN0LmNvbnN0cnVjdChvLCBlIHx8IFtdLCBfZ2V0UHJvdG90eXBlT2YodCkuY29uc3RydWN0b3IpIDogby5hcHBseSh0LCBlKSk7IH1cbiAgICBmdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JGooKSB7IHRyeSB7IHZhciB0ID0gIUJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgfSBjYXRjaCAodCkge30gcmV0dXJuIChfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JGogPSBmdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyByZXR1cm4gISF0OyB9KSgpOyB9XG4gICAgdmFyIERFRkFVTFRfT1BUSU9OUyRmID0ge1xuICAgICAgY2hhbm5lbENvdW50OiAxLFxuICAgICAgY2hhbm5lbENvdW50TW9kZTogJ2V4cGxpY2l0JyxcbiAgICAgIGNoYW5uZWxJbnRlcnByZXRhdGlvbjogJ3NwZWFrZXJzJyxcbiAgICAgIG51bWJlck9mSW5wdXRzOiA2XG4gICAgfTtcbiAgICB2YXIgY3JlYXRlQ2hhbm5lbE1lcmdlck5vZGVDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uIGNyZWF0ZUNoYW5uZWxNZXJnZXJOb2RlQ29uc3RydWN0b3IoYXVkaW9Ob2RlQ29uc3RydWN0b3IsIGNyZWF0ZUNoYW5uZWxNZXJnZXJOb2RlUmVuZGVyZXIsIGNyZWF0ZU5hdGl2ZUNoYW5uZWxNZXJnZXJOb2RlLCBnZXROYXRpdmVDb250ZXh0LCBpc05hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQpIHtcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9hdWRpb05vZGVDb25zdHJ1Y3Rvcikge1xuICAgICAgICBmdW5jdGlvbiBDaGFubmVsTWVyZ2VyTm9kZShjb250ZXh0LCBvcHRpb25zKSB7XG4gICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENoYW5uZWxNZXJnZXJOb2RlKTtcbiAgICAgICAgICB2YXIgbmF0aXZlQ29udGV4dCA9IGdldE5hdGl2ZUNvbnRleHQoY29udGV4dCk7XG4gICAgICAgICAgdmFyIG1lcmdlZE9wdGlvbnMgPSBfb2JqZWN0U3ByZWFkJHAoX29iamVjdFNwcmVhZCRwKHt9LCBERUZBVUxUX09QVElPTlMkZiksIG9wdGlvbnMpO1xuICAgICAgICAgIHZhciBuYXRpdmVDaGFubmVsTWVyZ2VyTm9kZSA9IGNyZWF0ZU5hdGl2ZUNoYW5uZWxNZXJnZXJOb2RlKG5hdGl2ZUNvbnRleHQsIG1lcmdlZE9wdGlvbnMpO1xuICAgICAgICAgIHZhciBjaGFubmVsTWVyZ2VyTm9kZVJlbmRlcmVyID0gaXNOYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KG5hdGl2ZUNvbnRleHQpID8gY3JlYXRlQ2hhbm5lbE1lcmdlck5vZGVSZW5kZXJlcigpIDogbnVsbDtcbiAgICAgICAgICByZXR1cm4gX2NhbGxTdXBlciRqKHRoaXMsIENoYW5uZWxNZXJnZXJOb2RlLCBbY29udGV4dCwgZmFsc2UsIG5hdGl2ZUNoYW5uZWxNZXJnZXJOb2RlLCBjaGFubmVsTWVyZ2VyTm9kZVJlbmRlcmVyXSk7XG4gICAgICAgIH1cbiAgICAgICAgX2luaGVyaXRzKENoYW5uZWxNZXJnZXJOb2RlLCBfYXVkaW9Ob2RlQ29uc3RydWN0b3IpO1xuICAgICAgICByZXR1cm4gX2NyZWF0ZUNsYXNzKENoYW5uZWxNZXJnZXJOb2RlKTtcbiAgICAgIH0oYXVkaW9Ob2RlQ29uc3RydWN0b3IpO1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlQ2hhbm5lbE1lcmdlck5vZGVSZW5kZXJlckZhY3RvcnkgPSBmdW5jdGlvbiBjcmVhdGVDaGFubmVsTWVyZ2VyTm9kZVJlbmRlcmVyRmFjdG9yeShjcmVhdGVOYXRpdmVDaGFubmVsTWVyZ2VyTm9kZSwgZ2V0TmF0aXZlQXVkaW9Ob2RlLCByZW5kZXJJbnB1dHNPZkF1ZGlvTm9kZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlbmRlcmVkTmF0aXZlQXVkaW9Ob2RlcyA9IG5ldyBXZWFrTWFwKCk7XG4gICAgICAgIHZhciBjcmVhdGVBdWRpb05vZGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBfcmVmID0gX2FzeW5jVG9HZW5lcmF0b3IoLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlKHByb3h5LCBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KSB7XG4gICAgICAgICAgICB2YXIgbmF0aXZlQXVkaW9Ob2RlLCBuYXRpdmVBdWRpb05vZGVJc093bmVkQnlDb250ZXh0LCBvcHRpb25zO1xuICAgICAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgICAgICAgICB3aGlsZSAoMSkgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgIG5hdGl2ZUF1ZGlvTm9kZSA9IGdldE5hdGl2ZUF1ZGlvTm9kZShwcm94eSk7IC8vIElmIHRoZSBpbml0aWFsbHkgdXNlZCBuYXRpdmVBdWRpb05vZGUgd2FzIG5vdCBjb25zdHJ1Y3RlZCBvbiB0aGUgc2FtZSBPZmZsaW5lQXVkaW9Db250ZXh0IGl0IG5lZWRzIHRvIGJlIGNyZWF0ZWQgYWdhaW4uXG4gICAgICAgICAgICAgICAgICBuYXRpdmVBdWRpb05vZGVJc093bmVkQnlDb250ZXh0ID0gaXNPd25lZEJ5Q29udGV4dChuYXRpdmVBdWRpb05vZGUsIG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgaWYgKCFuYXRpdmVBdWRpb05vZGVJc093bmVkQnlDb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbENvdW50OiBuYXRpdmVBdWRpb05vZGUuY2hhbm5lbENvdW50LFxuICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWxDb3VudE1vZGU6IG5hdGl2ZUF1ZGlvTm9kZS5jaGFubmVsQ291bnRNb2RlLFxuICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWxJbnRlcnByZXRhdGlvbjogbmF0aXZlQXVkaW9Ob2RlLmNoYW5uZWxJbnRlcnByZXRhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICBudW1iZXJPZklucHV0czogbmF0aXZlQXVkaW9Ob2RlLm51bWJlck9mSW5wdXRzXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIG5hdGl2ZUF1ZGlvTm9kZSA9IGNyZWF0ZU5hdGl2ZUNoYW5uZWxNZXJnZXJOb2RlKG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgcmVuZGVyZWROYXRpdmVBdWRpb05vZGVzLnNldChuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LCBuYXRpdmVBdWRpb05vZGUpO1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDY7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcmVuZGVySW5wdXRzT2ZBdWRpb05vZGUocHJveHksIG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQsIG5hdGl2ZUF1ZGlvTm9kZSk7XG4gICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCBuYXRpdmVBdWRpb05vZGUpO1xuICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBfY2FsbGVlKTtcbiAgICAgICAgICB9KSk7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZUF1ZGlvTm9kZShfeCwgX3gyKSB7XG4gICAgICAgICAgICByZXR1cm4gX3JlZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgIH07XG4gICAgICAgIH0oKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihwcm94eSwgbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCkge1xuICAgICAgICAgICAgdmFyIHJlbmRlcmVkTmF0aXZlQXVkaW9Ob2RlID0gcmVuZGVyZWROYXRpdmVBdWRpb05vZGVzLmdldChuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KTtcbiAgICAgICAgICAgIGlmIChyZW5kZXJlZE5hdGl2ZUF1ZGlvTm9kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVuZGVyZWROYXRpdmVBdWRpb05vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUF1ZGlvTm9kZShwcm94eSwgbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gb3duS2V5cyRvKGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cbiAgICBmdW5jdGlvbiBfb2JqZWN0U3ByZWFkJG8oZSkgeyBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykgeyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gb3duS2V5cyRvKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyRvKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XG4gICAgZnVuY3Rpb24gX2NhbGxTdXBlciRpKHQsIG8sIGUpIHsgcmV0dXJuIG8gPSBfZ2V0UHJvdG90eXBlT2YobyksIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHQsIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkaSgpID8gUmVmbGVjdC5jb25zdHJ1Y3QobywgZSB8fCBbXSwgX2dldFByb3RvdHlwZU9mKHQpLmNvbnN0cnVjdG9yKSA6IG8uYXBwbHkodCwgZSkpOyB9XG4gICAgZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRpKCkgeyB0cnkgeyB2YXIgdCA9ICFCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IH0gY2F0Y2ggKHQpIHt9IHJldHVybiAoX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRpID0gZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgcmV0dXJuICEhdDsgfSkoKTsgfVxuICAgIHZhciBERUZBVUxUX09QVElPTlMkZSA9IHtcbiAgICAgIGNoYW5uZWxDb3VudDogNixcbiAgICAgIGNoYW5uZWxDb3VudE1vZGU6ICdleHBsaWNpdCcsXG4gICAgICBjaGFubmVsSW50ZXJwcmV0YXRpb246ICdkaXNjcmV0ZScsXG4gICAgICBudW1iZXJPZk91dHB1dHM6IDZcbiAgICB9O1xuICAgIHZhciBjcmVhdGVDaGFubmVsU3BsaXR0ZXJOb2RlQ29uc3RydWN0b3IgPSBmdW5jdGlvbiBjcmVhdGVDaGFubmVsU3BsaXR0ZXJOb2RlQ29uc3RydWN0b3IoYXVkaW9Ob2RlQ29uc3RydWN0b3IsIGNyZWF0ZUNoYW5uZWxTcGxpdHRlck5vZGVSZW5kZXJlciwgY3JlYXRlTmF0aXZlQ2hhbm5lbFNwbGl0dGVyTm9kZSwgZ2V0TmF0aXZlQ29udGV4dCwgaXNOYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LCBzYW5pdGl6ZUNoYW5uZWxTcGxpdHRlck9wdGlvbnMpIHtcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9hdWRpb05vZGVDb25zdHJ1Y3Rvcikge1xuICAgICAgICBmdW5jdGlvbiBDaGFubmVsU3BsaXR0ZXJOb2RlKGNvbnRleHQsIG9wdGlvbnMpIHtcbiAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2hhbm5lbFNwbGl0dGVyTm9kZSk7XG4gICAgICAgICAgdmFyIG5hdGl2ZUNvbnRleHQgPSBnZXROYXRpdmVDb250ZXh0KGNvbnRleHQpO1xuICAgICAgICAgIHZhciBtZXJnZWRPcHRpb25zID0gc2FuaXRpemVDaGFubmVsU3BsaXR0ZXJPcHRpb25zKF9vYmplY3RTcHJlYWQkbyhfb2JqZWN0U3ByZWFkJG8oe30sIERFRkFVTFRfT1BUSU9OUyRlKSwgb3B0aW9ucykpO1xuICAgICAgICAgIHZhciBuYXRpdmVDaGFubmVsU3BsaXR0ZXJOb2RlID0gY3JlYXRlTmF0aXZlQ2hhbm5lbFNwbGl0dGVyTm9kZShuYXRpdmVDb250ZXh0LCBtZXJnZWRPcHRpb25zKTtcbiAgICAgICAgICB2YXIgY2hhbm5lbFNwbGl0dGVyTm9kZVJlbmRlcmVyID0gaXNOYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KG5hdGl2ZUNvbnRleHQpID8gY3JlYXRlQ2hhbm5lbFNwbGl0dGVyTm9kZVJlbmRlcmVyKCkgOiBudWxsO1xuICAgICAgICAgIHJldHVybiBfY2FsbFN1cGVyJGkodGhpcywgQ2hhbm5lbFNwbGl0dGVyTm9kZSwgW2NvbnRleHQsIGZhbHNlLCBuYXRpdmVDaGFubmVsU3BsaXR0ZXJOb2RlLCBjaGFubmVsU3BsaXR0ZXJOb2RlUmVuZGVyZXJdKTtcbiAgICAgICAgfVxuICAgICAgICBfaW5oZXJpdHMoQ2hhbm5lbFNwbGl0dGVyTm9kZSwgX2F1ZGlvTm9kZUNvbnN0cnVjdG9yKTtcbiAgICAgICAgcmV0dXJuIF9jcmVhdGVDbGFzcyhDaGFubmVsU3BsaXR0ZXJOb2RlKTtcbiAgICAgIH0oYXVkaW9Ob2RlQ29uc3RydWN0b3IpO1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlQ2hhbm5lbFNwbGl0dGVyTm9kZVJlbmRlcmVyRmFjdG9yeSA9IGZ1bmN0aW9uIGNyZWF0ZUNoYW5uZWxTcGxpdHRlck5vZGVSZW5kZXJlckZhY3RvcnkoY3JlYXRlTmF0aXZlQ2hhbm5lbFNwbGl0dGVyTm9kZSwgZ2V0TmF0aXZlQXVkaW9Ob2RlLCByZW5kZXJJbnB1dHNPZkF1ZGlvTm9kZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlbmRlcmVkTmF0aXZlQXVkaW9Ob2RlcyA9IG5ldyBXZWFrTWFwKCk7XG4gICAgICAgIHZhciBjcmVhdGVBdWRpb05vZGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBfcmVmID0gX2FzeW5jVG9HZW5lcmF0b3IoLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlKHByb3h5LCBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KSB7XG4gICAgICAgICAgICB2YXIgbmF0aXZlQXVkaW9Ob2RlLCBuYXRpdmVBdWRpb05vZGVJc093bmVkQnlDb250ZXh0LCBvcHRpb25zO1xuICAgICAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgICAgICAgICB3aGlsZSAoMSkgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgIG5hdGl2ZUF1ZGlvTm9kZSA9IGdldE5hdGl2ZUF1ZGlvTm9kZShwcm94eSk7IC8vIElmIHRoZSBpbml0aWFsbHkgdXNlZCBuYXRpdmVBdWRpb05vZGUgd2FzIG5vdCBjb25zdHJ1Y3RlZCBvbiB0aGUgc2FtZSBPZmZsaW5lQXVkaW9Db250ZXh0IGl0IG5lZWRzIHRvIGJlIGNyZWF0ZWQgYWdhaW4uXG4gICAgICAgICAgICAgICAgICBuYXRpdmVBdWRpb05vZGVJc093bmVkQnlDb250ZXh0ID0gaXNPd25lZEJ5Q29udGV4dChuYXRpdmVBdWRpb05vZGUsIG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgaWYgKCFuYXRpdmVBdWRpb05vZGVJc093bmVkQnlDb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbENvdW50OiBuYXRpdmVBdWRpb05vZGUuY2hhbm5lbENvdW50LFxuICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWxDb3VudE1vZGU6IG5hdGl2ZUF1ZGlvTm9kZS5jaGFubmVsQ291bnRNb2RlLFxuICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWxJbnRlcnByZXRhdGlvbjogbmF0aXZlQXVkaW9Ob2RlLmNoYW5uZWxJbnRlcnByZXRhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICBudW1iZXJPZk91dHB1dHM6IG5hdGl2ZUF1ZGlvTm9kZS5udW1iZXJPZk91dHB1dHNcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgbmF0aXZlQXVkaW9Ob2RlID0gY3JlYXRlTmF0aXZlQ2hhbm5lbFNwbGl0dGVyTm9kZShuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHJlbmRlcmVkTmF0aXZlQXVkaW9Ob2Rlcy5zZXQobmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCwgbmF0aXZlQXVkaW9Ob2RlKTtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA2O1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlbmRlcklucHV0c09mQXVkaW9Ob2RlKHByb3h5LCBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LCBuYXRpdmVBdWRpb05vZGUpO1xuICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgbmF0aXZlQXVkaW9Ob2RlKTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgX2NhbGxlZSk7XG4gICAgICAgICAgfSkpO1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiBjcmVhdGVBdWRpb05vZGUoX3gsIF94Mikge1xuICAgICAgICAgICAgcmV0dXJuIF9yZWYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9KCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIocHJveHksIG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciByZW5kZXJlZE5hdGl2ZUF1ZGlvTm9kZSA9IHJlbmRlcmVkTmF0aXZlQXVkaW9Ob2Rlcy5nZXQobmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCk7XG4gICAgICAgICAgICBpZiAocmVuZGVyZWROYXRpdmVBdWRpb05vZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlbmRlcmVkTmF0aXZlQXVkaW9Ob2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVBdWRpb05vZGUocHJveHksIG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVDb25uZWN0QXVkaW9QYXJhbSA9IGZ1bmN0aW9uIGNyZWF0ZUNvbm5lY3RBdWRpb1BhcmFtKHJlbmRlcklucHV0c09mQXVkaW9QYXJhbSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LCBhdWRpb1BhcmFtLCBuYXRpdmVBdWRpb1BhcmFtKSB7XG4gICAgICAgIHJldHVybiByZW5kZXJJbnB1dHNPZkF1ZGlvUGFyYW0oYXVkaW9QYXJhbSwgbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCwgbmF0aXZlQXVkaW9QYXJhbSk7XG4gICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlQ29ubmVjdE11bHRpcGxlT3V0cHV0cyA9IGZ1bmN0aW9uIGNyZWF0ZUNvbm5lY3RNdWx0aXBsZU91dHB1dHMoY3JlYXRlSW5kZXhTaXplRXJyb3IpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAob3V0cHV0QXVkaW9Ob2RlcywgZGVzdGluYXRpb24pIHtcbiAgICAgICAgdmFyIG91dHB1dCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMDtcbiAgICAgICAgdmFyIGlucHV0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiAwO1xuICAgICAgICB2YXIgb3V0cHV0QXVkaW9Ob2RlID0gb3V0cHV0QXVkaW9Ob2Rlc1tvdXRwdXRdO1xuICAgICAgICBpZiAob3V0cHV0QXVkaW9Ob2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aHJvdyBjcmVhdGVJbmRleFNpemVFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc05hdGl2ZUF1ZGlvTm9kZSQxKGRlc3RpbmF0aW9uKSkge1xuICAgICAgICAgIHJldHVybiBvdXRwdXRBdWRpb05vZGUuY29ubmVjdChkZXN0aW5hdGlvbiwgMCwgaW5wdXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXRwdXRBdWRpb05vZGUuY29ubmVjdChkZXN0aW5hdGlvbiwgMCk7XG4gICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlQ29ubmVjdGVkTmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2RlRmFjdG9yeSA9IGZ1bmN0aW9uIGNyZWF0ZUNvbm5lY3RlZE5hdGl2ZUF1ZGlvQnVmZmVyU291cmNlTm9kZUZhY3RvcnkoY3JlYXRlTmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2RlKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKG5hdGl2ZUNvbnRleHQsIG5hdGl2ZUF1ZGlvTm9kZSkge1xuICAgICAgICB2YXIgbmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2RlID0gY3JlYXRlTmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2RlKG5hdGl2ZUNvbnRleHQsIHtcbiAgICAgICAgICBidWZmZXI6IG51bGwsXG4gICAgICAgICAgY2hhbm5lbENvdW50OiAyLFxuICAgICAgICAgIGNoYW5uZWxDb3VudE1vZGU6ICdtYXgnLFxuICAgICAgICAgIGNoYW5uZWxJbnRlcnByZXRhdGlvbjogJ3NwZWFrZXJzJyxcbiAgICAgICAgICBsb29wOiBmYWxzZSxcbiAgICAgICAgICBsb29wRW5kOiAwLFxuICAgICAgICAgIGxvb3BTdGFydDogMCxcbiAgICAgICAgICBwbGF5YmFja1JhdGU6IDFcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBuYXRpdmVBdWRpb0J1ZmZlciA9IG5hdGl2ZUNvbnRleHQuY3JlYXRlQnVmZmVyKDEsIDIsIDQ0MTAwKTtcbiAgICAgICAgbmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2RlLmJ1ZmZlciA9IG5hdGl2ZUF1ZGlvQnVmZmVyO1xuICAgICAgICBuYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGUubG9vcCA9IHRydWU7XG4gICAgICAgIG5hdGl2ZUF1ZGlvQnVmZmVyU291cmNlTm9kZS5jb25uZWN0KG5hdGl2ZUF1ZGlvTm9kZSk7XG4gICAgICAgIG5hdGl2ZUF1ZGlvQnVmZmVyU291cmNlTm9kZS5zdGFydCgpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIG5hdGl2ZUF1ZGlvQnVmZmVyU291cmNlTm9kZS5zdG9wKCk7XG4gICAgICAgICAgbmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2RlLmRpc2Nvbm5lY3QobmF0aXZlQXVkaW9Ob2RlKTtcbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIG93bktleXMkbihlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XG4gICAgZnVuY3Rpb24gX29iamVjdFNwcmVhZCRuKGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMkbihPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMkbihPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxuICAgIGZ1bmN0aW9uIF9jYWxsU3VwZXIkaCh0LCBvLCBlKSB7IHJldHVybiBvID0gX2dldFByb3RvdHlwZU9mKG8pLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0LCBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JGgoKSA/IFJlZmxlY3QuY29uc3RydWN0KG8sIGUgfHwgW10sIF9nZXRQcm90b3R5cGVPZih0KS5jb25zdHJ1Y3RvcikgOiBvLmFwcGx5KHQsIGUpKTsgfVxuICAgIGZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkaCgpIHsgdHJ5IHsgdmFyIHQgPSAhQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyB9IGNhdGNoICh0KSB7fSByZXR1cm4gKF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkaCA9IGZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IHJldHVybiAhIXQ7IH0pKCk7IH1cbiAgICB2YXIgREVGQVVMVF9PUFRJT05TJGQgPSB7XG4gICAgICBjaGFubmVsQ291bnQ6IDIsXG4gICAgICBjaGFubmVsQ291bnRNb2RlOiAnbWF4JyxcbiAgICAgIGNoYW5uZWxJbnRlcnByZXRhdGlvbjogJ3NwZWFrZXJzJyxcbiAgICAgIG9mZnNldDogMVxuICAgIH07XG4gICAgdmFyIGNyZWF0ZUNvbnN0YW50U291cmNlTm9kZUNvbnN0cnVjdG9yID0gZnVuY3Rpb24gY3JlYXRlQ29uc3RhbnRTb3VyY2VOb2RlQ29uc3RydWN0b3IoYXVkaW9Ob2RlQ29uc3RydWN0b3IsIGNyZWF0ZUF1ZGlvUGFyYW0sIGNyZWF0ZUNvbnN0YW50U291cmNlTm9kZVJlbmRlcmVyRmFjdG9yeSwgY3JlYXRlTmF0aXZlQ29uc3RhbnRTb3VyY2VOb2RlLCBnZXROYXRpdmVDb250ZXh0LCBpc05hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQsIHdyYXBFdmVudExpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfYXVkaW9Ob2RlQ29uc3RydWN0b3IpIHtcbiAgICAgICAgZnVuY3Rpb24gQ29uc3RhbnRTb3VyY2VOb2RlKGNvbnRleHQsIG9wdGlvbnMpIHtcbiAgICAgICAgICB2YXIgX3RoaXM7XG4gICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENvbnN0YW50U291cmNlTm9kZSk7XG4gICAgICAgICAgdmFyIG5hdGl2ZUNvbnRleHQgPSBnZXROYXRpdmVDb250ZXh0KGNvbnRleHQpO1xuICAgICAgICAgIHZhciBtZXJnZWRPcHRpb25zID0gX29iamVjdFNwcmVhZCRuKF9vYmplY3RTcHJlYWQkbih7fSwgREVGQVVMVF9PUFRJT05TJGQpLCBvcHRpb25zKTtcbiAgICAgICAgICB2YXIgbmF0aXZlQ29uc3RhbnRTb3VyY2VOb2RlID0gY3JlYXRlTmF0aXZlQ29uc3RhbnRTb3VyY2VOb2RlKG5hdGl2ZUNvbnRleHQsIG1lcmdlZE9wdGlvbnMpO1xuICAgICAgICAgIHZhciBpc09mZmxpbmUgPSBpc05hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQobmF0aXZlQ29udGV4dCk7XG4gICAgICAgICAgdmFyIGNvbnN0YW50U291cmNlTm9kZVJlbmRlcmVyID0gaXNPZmZsaW5lID8gY3JlYXRlQ29uc3RhbnRTb3VyY2VOb2RlUmVuZGVyZXJGYWN0b3J5KCkgOiBudWxsO1xuICAgICAgICAgIF90aGlzID0gX2NhbGxTdXBlciRoKHRoaXMsIENvbnN0YW50U291cmNlTm9kZSwgW2NvbnRleHQsIGZhbHNlLCBuYXRpdmVDb25zdGFudFNvdXJjZU5vZGUsIGNvbnN0YW50U291cmNlTm9kZVJlbmRlcmVyXSk7XG4gICAgICAgICAgX3RoaXMuX2NvbnN0YW50U291cmNlTm9kZVJlbmRlcmVyID0gY29uc3RhbnRTb3VyY2VOb2RlUmVuZGVyZXI7XG4gICAgICAgICAgX3RoaXMuX25hdGl2ZUNvbnN0YW50U291cmNlTm9kZSA9IG5hdGl2ZUNvbnN0YW50U291cmNlTm9kZTtcbiAgICAgICAgICAvKlxuICAgICAgICAgICAqIEJ1ZyAjNjIgJiAjNzQ6IFNhZmFyaSBkb2VzIG5vdCBzdXBwb3J0IENvbnN0YW50U291cmNlTm9kZXMgYW5kIGRvZXMgbm90IGV4cG9ydCB0aGUgY29ycmVjdCB2YWx1ZXMgZm9yIG1heFZhbHVlIGFuZCBtaW5WYWx1ZVxuICAgICAgICAgICAqIGZvciBHYWluTm9kZXMuXG4gICAgICAgICAgICovXG4gICAgICAgICAgX3RoaXMuX29mZnNldCA9IGNyZWF0ZUF1ZGlvUGFyYW0oX3RoaXMsIGlzT2ZmbGluZSwgbmF0aXZlQ29uc3RhbnRTb3VyY2VOb2RlLm9mZnNldCwgTU9TVF9QT1NJVElWRV9TSU5HTEVfRkxPQVQsIE1PU1RfTkVHQVRJVkVfU0lOR0xFX0ZMT0FUKTtcbiAgICAgICAgICBfdGhpcy5fb25lbmRlZCA9IG51bGw7XG4gICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICB9XG4gICAgICAgIF9pbmhlcml0cyhDb25zdGFudFNvdXJjZU5vZGUsIF9hdWRpb05vZGVDb25zdHJ1Y3Rvcik7XG4gICAgICAgIHJldHVybiBfY3JlYXRlQ2xhc3MoQ29uc3RhbnRTb3VyY2VOb2RlLCBbe1xuICAgICAgICAgIGtleTogXCJvZmZzZXRcIixcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9vZmZzZXQ7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcIm9uZW5kZWRcIixcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9vbmVuZGVkO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgICAgIHZhciB3cmFwcGVkTGlzdGVuZXIgPSB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgPyB3cmFwRXZlbnRMaXN0ZW5lcih0aGlzLCB2YWx1ZSkgOiBudWxsO1xuICAgICAgICAgICAgdGhpcy5fbmF0aXZlQ29uc3RhbnRTb3VyY2VOb2RlLm9uZW5kZWQgPSB3cmFwcGVkTGlzdGVuZXI7XG4gICAgICAgICAgICB2YXIgbmF0aXZlT25FbmRlZCA9IHRoaXMuX25hdGl2ZUNvbnN0YW50U291cmNlTm9kZS5vbmVuZGVkO1xuICAgICAgICAgICAgdGhpcy5fb25lbmRlZCA9IG5hdGl2ZU9uRW5kZWQgIT09IG51bGwgJiYgbmF0aXZlT25FbmRlZCA9PT0gd3JhcHBlZExpc3RlbmVyID8gdmFsdWUgOiBuYXRpdmVPbkVuZGVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIGtleTogXCJzdGFydFwiLFxuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzdGFydCgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIHdoZW4gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDA7XG4gICAgICAgICAgICB0aGlzLl9uYXRpdmVDb25zdGFudFNvdXJjZU5vZGUuc3RhcnQod2hlbik7XG4gICAgICAgICAgICBpZiAodGhpcy5fY29uc3RhbnRTb3VyY2VOb2RlUmVuZGVyZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgdGhpcy5fY29uc3RhbnRTb3VyY2VOb2RlUmVuZGVyZXIuc3RhcnQgPSB3aGVuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29udGV4dC5zdGF0ZSAhPT0gJ2Nsb3NlZCcpIHtcbiAgICAgICAgICAgICAgc2V0SW50ZXJuYWxTdGF0ZVRvQWN0aXZlKHRoaXMpO1xuICAgICAgICAgICAgICB2YXIgX3Jlc2V0SW50ZXJuYWxTdGF0ZVRvUGFzc2l2ZSA9IGZ1bmN0aW9uIHJlc2V0SW50ZXJuYWxTdGF0ZVRvUGFzc2l2ZSgpIHtcbiAgICAgICAgICAgICAgICBfdGhpczIuX25hdGl2ZUNvbnN0YW50U291cmNlTm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCdlbmRlZCcsIF9yZXNldEludGVybmFsU3RhdGVUb1Bhc3NpdmUpO1xuICAgICAgICAgICAgICAgIGlmIChpc0FjdGl2ZUF1ZGlvTm9kZShfdGhpczIpKSB7XG4gICAgICAgICAgICAgICAgICBzZXRJbnRlcm5hbFN0YXRlVG9QYXNzaXZlKF90aGlzMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB0aGlzLl9uYXRpdmVDb25zdGFudFNvdXJjZU5vZGUuYWRkRXZlbnRMaXN0ZW5lcignZW5kZWQnLCBfcmVzZXRJbnRlcm5hbFN0YXRlVG9QYXNzaXZlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBrZXk6IFwic3RvcFwiLFxuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzdG9wKCkge1xuICAgICAgICAgICAgdmFyIHdoZW4gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDA7XG4gICAgICAgICAgICB0aGlzLl9uYXRpdmVDb25zdGFudFNvdXJjZU5vZGUuc3RvcCh3aGVuKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jb25zdGFudFNvdXJjZU5vZGVSZW5kZXJlciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICB0aGlzLl9jb25zdGFudFNvdXJjZU5vZGVSZW5kZXJlci5zdG9wID0gd2hlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1dKTtcbiAgICAgIH0oYXVkaW9Ob2RlQ29uc3RydWN0b3IpO1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlQ29uc3RhbnRTb3VyY2VOb2RlUmVuZGVyZXJGYWN0b3J5ID0gZnVuY3Rpb24gY3JlYXRlQ29uc3RhbnRTb3VyY2VOb2RlUmVuZGVyZXJGYWN0b3J5KGNvbm5lY3RBdWRpb1BhcmFtLCBjcmVhdGVOYXRpdmVDb25zdGFudFNvdXJjZU5vZGUsIGdldE5hdGl2ZUF1ZGlvTm9kZSwgcmVuZGVyQXV0b21hdGlvbiwgcmVuZGVySW5wdXRzT2ZBdWRpb05vZGUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZW5kZXJlZE5hdGl2ZUNvbnN0YW50U291cmNlTm9kZXMgPSBuZXcgV2Vha01hcCgpO1xuICAgICAgICB2YXIgc3RhcnQgPSBudWxsO1xuICAgICAgICB2YXIgc3RvcCA9IG51bGw7XG4gICAgICAgIHZhciBjcmVhdGVDb25zdGFudFNvdXJjZU5vZGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBfcmVmID0gX2FzeW5jVG9HZW5lcmF0b3IoLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlKHByb3h5LCBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KSB7XG4gICAgICAgICAgICB2YXIgbmF0aXZlQ29uc3RhbnRTb3VyY2VOb2RlLCBuYXRpdmVDb25zdGFudFNvdXJjZU5vZGVJc093bmVkQnlDb250ZXh0LCBvcHRpb25zO1xuICAgICAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgICAgICAgICB3aGlsZSAoMSkgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgIG5hdGl2ZUNvbnN0YW50U291cmNlTm9kZSA9IGdldE5hdGl2ZUF1ZGlvTm9kZShwcm94eSk7XG4gICAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAgICogSWYgdGhlIGluaXRpYWxseSB1c2VkIG5hdGl2ZUNvbnN0YW50U291cmNlTm9kZSB3YXMgbm90IGNvbnN0cnVjdGVkIG9uIHRoZSBzYW1lIE9mZmxpbmVBdWRpb0NvbnRleHQgaXQgbmVlZHMgdG8gYmUgY3JlYXRlZFxuICAgICAgICAgICAgICAgICAgICogYWdhaW4uXG4gICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgIG5hdGl2ZUNvbnN0YW50U291cmNlTm9kZUlzT3duZWRCeUNvbnRleHQgPSBpc093bmVkQnlDb250ZXh0KG5hdGl2ZUNvbnN0YW50U291cmNlTm9kZSwgbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCk7XG4gICAgICAgICAgICAgICAgICBpZiAoIW5hdGl2ZUNvbnN0YW50U291cmNlTm9kZUlzT3duZWRCeUNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICBjaGFubmVsQ291bnQ6IG5hdGl2ZUNvbnN0YW50U291cmNlTm9kZS5jaGFubmVsQ291bnQsXG4gICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbENvdW50TW9kZTogbmF0aXZlQ29uc3RhbnRTb3VyY2VOb2RlLmNoYW5uZWxDb3VudE1vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbEludGVycHJldGF0aW9uOiBuYXRpdmVDb25zdGFudFNvdXJjZU5vZGUuY2hhbm5lbEludGVycHJldGF0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgIG9mZnNldDogbmF0aXZlQ29uc3RhbnRTb3VyY2VOb2RlLm9mZnNldC52YWx1ZVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBuYXRpdmVDb25zdGFudFNvdXJjZU5vZGUgPSBjcmVhdGVOYXRpdmVDb25zdGFudFNvdXJjZU5vZGUobmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGFydCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgIG5hdGl2ZUNvbnN0YW50U291cmNlTm9kZS5zdGFydChzdGFydCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0b3AgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICBuYXRpdmVDb25zdGFudFNvdXJjZU5vZGUuc3RvcChzdG9wKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgcmVuZGVyZWROYXRpdmVDb25zdGFudFNvdXJjZU5vZGVzLnNldChuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LCBuYXRpdmVDb25zdGFudFNvdXJjZU5vZGUpO1xuICAgICAgICAgICAgICAgICAgaWYgKG5hdGl2ZUNvbnN0YW50U291cmNlTm9kZUlzT3duZWRCeUNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDc7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcmVuZGVyQXV0b21hdGlvbihuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LCBwcm94eS5vZmZzZXQsIG5hdGl2ZUNvbnN0YW50U291cmNlTm9kZS5vZmZzZXQpO1xuICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxMTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxMTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBjb25uZWN0QXVkaW9QYXJhbShuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LCBwcm94eS5vZmZzZXQsIG5hdGl2ZUNvbnN0YW50U291cmNlTm9kZS5vZmZzZXQpO1xuICAgICAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTM7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcmVuZGVySW5wdXRzT2ZBdWRpb05vZGUocHJveHksIG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQsIG5hdGl2ZUNvbnN0YW50U291cmNlTm9kZSk7XG4gICAgICAgICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgbmF0aXZlQ29uc3RhbnRTb3VyY2VOb2RlKTtcbiAgICAgICAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIF9jYWxsZWUpO1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlQ29uc3RhbnRTb3VyY2VOb2RlKF94LCBfeDIpIHtcbiAgICAgICAgICAgIHJldHVybiBfcmVmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHNldCBzdGFydCh2YWx1ZSkge1xuICAgICAgICAgICAgc3RhcnQgPSB2YWx1ZTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNldCBzdG9wKHZhbHVlKSB7XG4gICAgICAgICAgICBzdG9wID0gdmFsdWU7XG4gICAgICAgICAgfSxcbiAgICAgICAgICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihwcm94eSwgbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCkge1xuICAgICAgICAgICAgdmFyIHJlbmRlcmVkTmF0aXZlQ29uc3RhbnRTb3VyY2VOb2RlID0gcmVuZGVyZWROYXRpdmVDb25zdGFudFNvdXJjZU5vZGVzLmdldChuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KTtcbiAgICAgICAgICAgIGlmIChyZW5kZXJlZE5hdGl2ZUNvbnN0YW50U291cmNlTm9kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVuZGVyZWROYXRpdmVDb25zdGFudFNvdXJjZU5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbnN0YW50U291cmNlTm9kZShwcm94eSwgbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZUNvbnZlcnROdW1iZXJUb1Vuc2lnbmVkTG9uZyA9IGZ1bmN0aW9uIGNyZWF0ZUNvbnZlcnROdW1iZXJUb1Vuc2lnbmVkTG9uZyh1bml0MzJBcnJheSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB1bml0MzJBcnJheVswXSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gdW5pdDMyQXJyYXlbMF07XG4gICAgICB9O1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBvd25LZXlzJG0oZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuICAgIGZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkbShlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzJG0oT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzJG0oT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTsgfSk7IH0gcmV0dXJuIGU7IH1cbiAgICBmdW5jdGlvbiBfY2FsbFN1cGVyJGcodCwgbywgZSkgeyByZXR1cm4gbyA9IF9nZXRQcm90b3R5cGVPZihvKSwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odCwgX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRnKCkgPyBSZWZsZWN0LmNvbnN0cnVjdChvLCBlIHx8IFtdLCBfZ2V0UHJvdG90eXBlT2YodCkuY29uc3RydWN0b3IpIDogby5hcHBseSh0LCBlKSk7IH1cbiAgICBmdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JGcoKSB7IHRyeSB7IHZhciB0ID0gIUJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgfSBjYXRjaCAodCkge30gcmV0dXJuIChfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JGcgPSBmdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyByZXR1cm4gISF0OyB9KSgpOyB9XG4gICAgdmFyIERFRkFVTFRfT1BUSU9OUyRjID0ge1xuICAgICAgYnVmZmVyOiBudWxsLFxuICAgICAgY2hhbm5lbENvdW50OiAyLFxuICAgICAgY2hhbm5lbENvdW50TW9kZTogJ2NsYW1wZWQtbWF4JyxcbiAgICAgIGNoYW5uZWxJbnRlcnByZXRhdGlvbjogJ3NwZWFrZXJzJyxcbiAgICAgIGRpc2FibGVOb3JtYWxpemF0aW9uOiBmYWxzZVxuICAgIH07XG4gICAgdmFyIGNyZWF0ZUNvbnZvbHZlck5vZGVDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uIGNyZWF0ZUNvbnZvbHZlck5vZGVDb25zdHJ1Y3RvcihhdWRpb05vZGVDb25zdHJ1Y3RvciwgY3JlYXRlQ29udm9sdmVyTm9kZVJlbmRlcmVyLCBjcmVhdGVOYXRpdmVDb252b2x2ZXJOb2RlLCBnZXROYXRpdmVDb250ZXh0LCBpc05hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQsIHNldEF1ZGlvTm9kZVRhaWxUaW1lKSB7XG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfYXVkaW9Ob2RlQ29uc3RydWN0b3IpIHtcbiAgICAgICAgZnVuY3Rpb24gQ29udm9sdmVyTm9kZShjb250ZXh0LCBvcHRpb25zKSB7XG4gICAgICAgICAgdmFyIF90aGlzO1xuICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDb252b2x2ZXJOb2RlKTtcbiAgICAgICAgICB2YXIgbmF0aXZlQ29udGV4dCA9IGdldE5hdGl2ZUNvbnRleHQoY29udGV4dCk7XG4gICAgICAgICAgdmFyIG1lcmdlZE9wdGlvbnMgPSBfb2JqZWN0U3ByZWFkJG0oX29iamVjdFNwcmVhZCRtKHt9LCBERUZBVUxUX09QVElPTlMkYyksIG9wdGlvbnMpO1xuICAgICAgICAgIHZhciBuYXRpdmVDb252b2x2ZXJOb2RlID0gY3JlYXRlTmF0aXZlQ29udm9sdmVyTm9kZShuYXRpdmVDb250ZXh0LCBtZXJnZWRPcHRpb25zKTtcbiAgICAgICAgICB2YXIgaXNPZmZsaW5lID0gaXNOYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KG5hdGl2ZUNvbnRleHQpO1xuICAgICAgICAgIHZhciBjb252b2x2ZXJOb2RlUmVuZGVyZXIgPSBpc09mZmxpbmUgPyBjcmVhdGVDb252b2x2ZXJOb2RlUmVuZGVyZXIoKSA6IG51bGw7XG4gICAgICAgICAgX3RoaXMgPSBfY2FsbFN1cGVyJGcodGhpcywgQ29udm9sdmVyTm9kZSwgW2NvbnRleHQsIGZhbHNlLCBuYXRpdmVDb252b2x2ZXJOb2RlLCBjb252b2x2ZXJOb2RlUmVuZGVyZXJdKTtcbiAgICAgICAgICBfdGhpcy5faXNCdWZmZXJOdWxsaWZpZWQgPSBmYWxzZTtcbiAgICAgICAgICBfdGhpcy5fbmF0aXZlQ29udm9sdmVyTm9kZSA9IG5hdGl2ZUNvbnZvbHZlck5vZGU7XG4gICAgICAgICAgaWYgKG1lcmdlZE9wdGlvbnMuYnVmZmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICBzZXRBdWRpb05vZGVUYWlsVGltZShfdGhpcywgbWVyZ2VkT3B0aW9ucy5idWZmZXIuZHVyYXRpb24pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgIH1cbiAgICAgICAgX2luaGVyaXRzKENvbnZvbHZlck5vZGUsIF9hdWRpb05vZGVDb25zdHJ1Y3Rvcik7XG4gICAgICAgIHJldHVybiBfY3JlYXRlQ2xhc3MoQ29udm9sdmVyTm9kZSwgW3tcbiAgICAgICAgICBrZXk6IFwiYnVmZmVyXCIsXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5faXNCdWZmZXJOdWxsaWZpZWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbmF0aXZlQ29udm9sdmVyTm9kZS5idWZmZXI7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fbmF0aXZlQ29udm9sdmVyTm9kZS5idWZmZXIgPSB2YWx1ZTtcbiAgICAgICAgICAgIC8vIEJ1ZyAjMTE1OiBTYWZhcmkgZG9lcyBub3QgYWxsb3cgdG8gc2V0IHRoZSBidWZmZXIgdG8gbnVsbC5cbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCAmJiB0aGlzLl9uYXRpdmVDb252b2x2ZXJOb2RlLmJ1ZmZlciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICB2YXIgbmF0aXZlQ29udGV4dCA9IHRoaXMuX25hdGl2ZUNvbnZvbHZlck5vZGUuY29udGV4dDtcbiAgICAgICAgICAgICAgdGhpcy5fbmF0aXZlQ29udm9sdmVyTm9kZS5idWZmZXIgPSBuYXRpdmVDb250ZXh0LmNyZWF0ZUJ1ZmZlcigxLCAxLCBuYXRpdmVDb250ZXh0LnNhbXBsZVJhdGUpO1xuICAgICAgICAgICAgICB0aGlzLl9pc0J1ZmZlck51bGxpZmllZCA9IHRydWU7XG4gICAgICAgICAgICAgIHNldEF1ZGlvTm9kZVRhaWxUaW1lKHRoaXMsIDApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5faXNCdWZmZXJOdWxsaWZpZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgc2V0QXVkaW9Ob2RlVGFpbFRpbWUodGhpcywgdGhpcy5fbmF0aXZlQ29udm9sdmVyTm9kZS5idWZmZXIgPT09IG51bGwgPyAwIDogdGhpcy5fbmF0aXZlQ29udm9sdmVyTm9kZS5idWZmZXIuZHVyYXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIGtleTogXCJub3JtYWxpemVcIixcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9uYXRpdmVDb252b2x2ZXJOb2RlLm5vcm1hbGl6ZTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9uYXRpdmVDb252b2x2ZXJOb2RlLm5vcm1hbGl6ZSA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfV0pO1xuICAgICAgfShhdWRpb05vZGVDb25zdHJ1Y3Rvcik7XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVDb252b2x2ZXJOb2RlUmVuZGVyZXJGYWN0b3J5ID0gZnVuY3Rpb24gY3JlYXRlQ29udm9sdmVyTm9kZVJlbmRlcmVyRmFjdG9yeShjcmVhdGVOYXRpdmVDb252b2x2ZXJOb2RlLCBnZXROYXRpdmVBdWRpb05vZGUsIHJlbmRlcklucHV0c09mQXVkaW9Ob2RlKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVuZGVyZWROYXRpdmVDb252b2x2ZXJOb2RlcyA9IG5ldyBXZWFrTWFwKCk7XG4gICAgICAgIHZhciBjcmVhdGVDb252b2x2ZXJOb2RlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgX3JlZiA9IF9hc3luY1RvR2VuZXJhdG9yKC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZShwcm94eSwgbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCkge1xuICAgICAgICAgICAgdmFyIG5hdGl2ZUNvbnZvbHZlck5vZGUsIG5hdGl2ZUNvbnZvbHZlck5vZGVJc093bmVkQnlDb250ZXh0LCBvcHRpb25zO1xuICAgICAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgICAgICAgICB3aGlsZSAoMSkgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgIG5hdGl2ZUNvbnZvbHZlck5vZGUgPSBnZXROYXRpdmVBdWRpb05vZGUocHJveHkpOyAvLyBJZiB0aGUgaW5pdGlhbGx5IHVzZWQgbmF0aXZlQ29udm9sdmVyTm9kZSB3YXMgbm90IGNvbnN0cnVjdGVkIG9uIHRoZSBzYW1lIE9mZmxpbmVBdWRpb0NvbnRleHQgaXQgbmVlZHMgdG8gYmUgY3JlYXRlZCBhZ2Fpbi5cbiAgICAgICAgICAgICAgICAgIG5hdGl2ZUNvbnZvbHZlck5vZGVJc093bmVkQnlDb250ZXh0ID0gaXNPd25lZEJ5Q29udGV4dChuYXRpdmVDb252b2x2ZXJOb2RlLCBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KTtcbiAgICAgICAgICAgICAgICAgIGlmICghbmF0aXZlQ29udm9sdmVyTm9kZUlzT3duZWRCeUNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICBidWZmZXI6IG5hdGl2ZUNvbnZvbHZlck5vZGUuYnVmZmVyLFxuICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWxDb3VudDogbmF0aXZlQ29udm9sdmVyTm9kZS5jaGFubmVsQ291bnQsXG4gICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbENvdW50TW9kZTogbmF0aXZlQ29udm9sdmVyTm9kZS5jaGFubmVsQ291bnRNb2RlLFxuICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWxJbnRlcnByZXRhdGlvbjogbmF0aXZlQ29udm9sdmVyTm9kZS5jaGFubmVsSW50ZXJwcmV0YXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgZGlzYWJsZU5vcm1hbGl6YXRpb246ICFuYXRpdmVDb252b2x2ZXJOb2RlLm5vcm1hbGl6ZVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBuYXRpdmVDb252b2x2ZXJOb2RlID0gY3JlYXRlTmF0aXZlQ29udm9sdmVyTm9kZShuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHJlbmRlcmVkTmF0aXZlQ29udm9sdmVyTm9kZXMuc2V0KG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQsIG5hdGl2ZUNvbnZvbHZlck5vZGUpO1xuICAgICAgICAgICAgICAgICAgaWYgKCFpc05hdGl2ZUF1ZGlvTm9kZUZha2VyKG5hdGl2ZUNvbnZvbHZlck5vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA5O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA3O1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlbmRlcklucHV0c09mQXVkaW9Ob2RlKHByb3h5LCBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LCBuYXRpdmVDb252b2x2ZXJOb2RlLmlucHV0c1swXSk7XG4gICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDExO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDExO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlbmRlcklucHV0c09mQXVkaW9Ob2RlKHByb3h5LCBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LCBuYXRpdmVDb252b2x2ZXJOb2RlKTtcbiAgICAgICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCBuYXRpdmVDb252b2x2ZXJOb2RlKTtcbiAgICAgICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIF9jYWxsZWUpO1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlQ29udm9sdmVyTm9kZShfeCwgX3gyKSB7XG4gICAgICAgICAgICByZXR1cm4gX3JlZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgIH07XG4gICAgICAgIH0oKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihwcm94eSwgbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCkge1xuICAgICAgICAgICAgdmFyIHJlbmRlcmVkTmF0aXZlQ29udm9sdmVyTm9kZSA9IHJlbmRlcmVkTmF0aXZlQ29udm9sdmVyTm9kZXMuZ2V0KG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQpO1xuICAgICAgICAgICAgaWYgKHJlbmRlcmVkTmF0aXZlQ29udm9sdmVyTm9kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVuZGVyZWROYXRpdmVDb252b2x2ZXJOb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVDb252b2x2ZXJOb2RlKHByb3h5LCBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlQ3JlYXRlTmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCA9IGZ1bmN0aW9uIGNyZWF0ZUNyZWF0ZU5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQoY3JlYXRlTm90U3VwcG9ydGVkRXJyb3IsIG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHRDb25zdHJ1Y3Rvcikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChudW1iZXJPZkNoYW5uZWxzLCBsZW5ndGgsIHNhbXBsZVJhdGUpIHtcbiAgICAgICAgaWYgKG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHRDb25zdHJ1Y3RvciA9PT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyB0aGUgbmF0aXZlIE9mZmxpbmVBdWRpb0NvbnRleHQgY29uc3RydWN0b3IuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gbmV3IG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHRDb25zdHJ1Y3RvcihudW1iZXJPZkNoYW5uZWxzLCBsZW5ndGgsIHNhbXBsZVJhdGUpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAvLyBCdWcgIzE0MywgIzE0NCAmICMxNDY6IFNhZmFyaSB0aHJvd3MgYSBTeW50YXhFcnJvciB3aGVuIG51bWJlck9mQ2hhbm5lbHMsIGxlbmd0aCBvciBzYW1wbGVSYXRlIGFyZSBpbnZhbGlkLlxuICAgICAgICAgIGlmIChlcnIubmFtZSA9PT0gJ1N5bnRheEVycm9yJykge1xuICAgICAgICAgICAgdGhyb3cgY3JlYXRlTm90U3VwcG9ydGVkRXJyb3IoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlRGF0YUNsb25lRXJyb3IgPSBmdW5jdGlvbiBjcmVhdGVEYXRhQ2xvbmVFcnJvcigpIHtcbiAgICAgIHJldHVybiBuZXcgRE9NRXhjZXB0aW9uKCcnLCAnRGF0YUNsb25lRXJyb3InKTtcbiAgICB9O1xuXG4gICAgdmFyIGRldGFjaEFycmF5QnVmZmVyID0gZnVuY3Rpb24gZGV0YWNoQXJyYXlCdWZmZXIoYXJyYXlCdWZmZXIpIHtcbiAgICAgIHZhciBfTWVzc2FnZUNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKSxcbiAgICAgICAgcG9ydDEgPSBfTWVzc2FnZUNoYW5uZWwucG9ydDEsXG4gICAgICAgIHBvcnQyID0gX01lc3NhZ2VDaGFubmVsLnBvcnQyO1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgIHZhciBjbG9zZUFuZFJlc29sdmUgPSBmdW5jdGlvbiBjbG9zZUFuZFJlc29sdmUoKSB7XG4gICAgICAgICAgcG9ydDIub25tZXNzYWdlID0gbnVsbDtcbiAgICAgICAgICBwb3J0MS5jbG9zZSgpO1xuICAgICAgICAgIHBvcnQyLmNsb3NlKCk7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9O1xuICAgICAgICBwb3J0Mi5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGNsb3NlQW5kUmVzb2x2ZSgpO1xuICAgICAgICB9O1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHBvcnQxLnBvc3RNZXNzYWdlKGFycmF5QnVmZmVyLCBbYXJyYXlCdWZmZXJdKTtcbiAgICAgICAgfSBjYXRjaCAoX3VudXNlZCkge1xuICAgICAgICAgIC8vIElnbm9yZSBlcnJvcnMuXG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgY2xvc2VBbmRSZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlRGVjb2RlQXVkaW9EYXRhID0gZnVuY3Rpb24gY3JlYXRlRGVjb2RlQXVkaW9EYXRhKGF1ZGlvQnVmZmVyU3RvcmUsIGNhY2hlVGVzdFJlc3VsdCwgY3JlYXRlRGF0YUNsb25lRXJyb3IsIGNyZWF0ZUVuY29kaW5nRXJyb3IsIGRldGFjaGVkQXJyYXlCdWZmZXJzLCBnZXROYXRpdmVDb250ZXh0LCBpc05hdGl2ZUNvbnRleHQsIHRlc3RBdWRpb0J1ZmZlckNvcHlDaGFubmVsTWV0aG9kc091dE9mQm91bmRzU3VwcG9ydCwgdGVzdFByb21pc2VTdXBwb3J0LCB3cmFwQXVkaW9CdWZmZXJDb3B5Q2hhbm5lbE1ldGhvZHMsIHdyYXBBdWRpb0J1ZmZlckNvcHlDaGFubmVsTWV0aG9kc091dE9mQm91bmRzKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGFueUNvbnRleHQsIGF1ZGlvRGF0YSkge1xuICAgICAgICB2YXIgbmF0aXZlQ29udGV4dCA9IGlzTmF0aXZlQ29udGV4dChhbnlDb250ZXh0KSA/IGFueUNvbnRleHQgOiBnZXROYXRpdmVDb250ZXh0KGFueUNvbnRleHQpO1xuICAgICAgICAvLyBCdWcgIzQzOiBPbmx5IENocm9tZSBhbmQgRWRnZSBkbyB0aHJvdyBhIERhdGFDbG9uZUVycm9yLlxuICAgICAgICBpZiAoZGV0YWNoZWRBcnJheUJ1ZmZlcnMuaGFzKGF1ZGlvRGF0YSkpIHtcbiAgICAgICAgICB2YXIgZXJyID0gY3JlYXRlRGF0YUNsb25lRXJyb3IoKTtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGUgYXVkaW9EYXRhIHBhcmFtZXRlciBtYXliZSBvZiBhIHR5cGUgd2hpY2ggY2FuJ3QgYmUgYWRkZWQgdG8gYSBXZWFrU2V0LlxuICAgICAgICB0cnkge1xuICAgICAgICAgIGRldGFjaGVkQXJyYXlCdWZmZXJzLmFkZChhdWRpb0RhdGEpO1xuICAgICAgICB9IGNhdGNoIChfdW51c2VkKSB7XG4gICAgICAgICAgLy8gSWdub3JlIGVycm9ycy5cbiAgICAgICAgfVxuICAgICAgICAvLyBCdWcgIzIxOiBTYWZhcmkgZG9lcyBub3Qgc3VwcG9ydCBwcm9taXNlcyB5ZXQuXG4gICAgICAgIGlmIChjYWNoZVRlc3RSZXN1bHQodGVzdFByb21pc2VTdXBwb3J0LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHRlc3RQcm9taXNlU3VwcG9ydChuYXRpdmVDb250ZXh0KTtcbiAgICAgICAgfSkpIHtcbiAgICAgICAgICByZXR1cm4gbmF0aXZlQ29udGV4dC5kZWNvZGVBdWRpb0RhdGEoYXVkaW9EYXRhKS50aGVuKGZ1bmN0aW9uIChhdWRpb0J1ZmZlcikge1xuICAgICAgICAgICAgLy8gQnVnICMxMzM6IFNhZmFyaSBkb2VzIG5ldXRlciB0aGUgQXJyYXlCdWZmZXIuXG4gICAgICAgICAgICBkZXRhY2hBcnJheUJ1ZmZlcihhdWRpb0RhdGEpW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAvLyBJZ25vcmUgZXJyb3JzLlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBCdWcgIzE1NzogRmlyZWZveCBkb2VzIG5vdCBhbGxvdyB0aGUgYnVmZmVyT2Zmc2V0IHRvIGJlIG91dC1vZi1ib3VuZHMuXG4gICAgICAgICAgICBpZiAoIWNhY2hlVGVzdFJlc3VsdCh0ZXN0QXVkaW9CdWZmZXJDb3B5Q2hhbm5lbE1ldGhvZHNPdXRPZkJvdW5kc1N1cHBvcnQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRlc3RBdWRpb0J1ZmZlckNvcHlDaGFubmVsTWV0aG9kc091dE9mQm91bmRzU3VwcG9ydChhdWRpb0J1ZmZlcik7XG4gICAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgICB3cmFwQXVkaW9CdWZmZXJDb3B5Q2hhbm5lbE1ldGhvZHNPdXRPZkJvdW5kcyhhdWRpb0J1ZmZlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhdWRpb0J1ZmZlclN0b3JlLmFkZChhdWRpb0J1ZmZlcik7XG4gICAgICAgICAgICByZXR1cm4gYXVkaW9CdWZmZXI7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQnVnICMyMTogU2FmYXJpIGRvZXMgbm90IHJldHVybiBhIFByb21pc2UgeWV0LlxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIHZhciBjb21wbGV0ZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX3JlZiA9IF9hc3luY1RvR2VuZXJhdG9yKC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZSgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgICAgICAgICAgIHdoaWxlICgxKSBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAwO1xuICAgICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRldGFjaEFycmF5QnVmZmVyKGF1ZGlvRGF0YSk7XG4gICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA3O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDU7XG4gICAgICAgICAgICAgICAgICAgIF9jb250ZXh0LnQwID0gX2NvbnRleHRbXCJjYXRjaFwiXSgwKTtcbiAgICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0sIF9jYWxsZWUsIG51bGwsIFtbMCwgNV1dKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiBjb21wbGV0ZSgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIF9yZWYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSgpO1xuICAgICAgICAgIHZhciBmYWlsID0gZnVuY3Rpb24gZmFpbChlcnIpIHtcbiAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgY29tcGxldGUoKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIC8vIEJ1ZyAjMjY6IFNhZmFyaSB0aHJvd3MgYSBzeW5jaHJvbm91cyBlcnJvci5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gQnVnICMxOiBTYWZhcmkgcmVxdWlyZXMgYSBzdWNjZXNzQ2FsbGJhY2suXG4gICAgICAgICAgICBuYXRpdmVDb250ZXh0LmRlY29kZUF1ZGlvRGF0YShhdWRpb0RhdGEsIGZ1bmN0aW9uIChhdWRpb0J1ZmZlcikge1xuICAgICAgICAgICAgICAvLyBCdWcgIzU6IFNhZmFyaSBkb2VzIG5vdCBzdXBwb3J0IGNvcHlGcm9tQ2hhbm5lbCgpIGFuZCBjb3B5VG9DaGFubmVsKCkuXG4gICAgICAgICAgICAgIC8vIEJ1ZyAjMTAwOiBTYWZhcmkgZG9lcyB0aHJvdyBhIHdyb25nIGVycm9yIHdoZW4gY2FsbGluZyBnZXRDaGFubmVsRGF0YSgpIHdpdGggYW4gb3V0LW9mLWJvdW5kcyB2YWx1ZS5cbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBhdWRpb0J1ZmZlci5jb3B5RnJvbUNoYW5uZWwgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB3cmFwQXVkaW9CdWZmZXJDb3B5Q2hhbm5lbE1ldGhvZHMoYXVkaW9CdWZmZXIpO1xuICAgICAgICAgICAgICAgIHdyYXBBdWRpb0J1ZmZlckdldENoYW5uZWxEYXRhTWV0aG9kKGF1ZGlvQnVmZmVyKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBhdWRpb0J1ZmZlclN0b3JlLmFkZChhdWRpb0J1ZmZlcik7XG4gICAgICAgICAgICAgIGNvbXBsZXRlKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoYXVkaW9CdWZmZXIpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgLy8gQnVnICM0OiBTYWZhcmkgcmV0dXJucyBudWxsIGluc3RlYWQgb2YgYW4gZXJyb3IuXG4gICAgICAgICAgICAgIGlmIChlcnIgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBmYWlsKGNyZWF0ZUVuY29kaW5nRXJyb3IoKSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZmFpbChlcnIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGZhaWwoZXJyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkMyhyLCBlKSB7IHZhciB0ID0gXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgU3ltYm9sICYmIHJbU3ltYm9sLml0ZXJhdG9yXSB8fCByW1wiQEBpdGVyYXRvclwiXTsgaWYgKCF0KSB7IGlmIChBcnJheS5pc0FycmF5KHIpIHx8ICh0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5JDMocikpIHx8IGUpIHsgdCAmJiAociA9IHQpOyB2YXIgX24gPSAwLCBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyByZXR1cm4gX24gPj0gci5sZW5ndGggPyB7IGRvbmU6ICEwIH0gOiB7IGRvbmU6ICExLCB2YWx1ZTogcltfbisrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKHIpIHsgdGhyb3cgcjsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbywgYSA9ICEwLCB1ID0gITE7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IHQgPSB0LmNhbGwocik7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciByID0gdC5uZXh0KCk7IHJldHVybiBhID0gci5kb25lLCByOyB9LCBlOiBmdW5jdGlvbiBlKHIpIHsgdSA9ICEwLCBvID0gcjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgYSB8fCBudWxsID09IHRbXCJyZXR1cm5cIl0gfHwgdFtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAodSkgdGhyb3cgbzsgfSB9IH07IH1cbiAgICBmdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkMyhyLCBhKSB7IGlmIChyKSB7IGlmIChcInN0cmluZ1wiID09IHR5cGVvZiByKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkkMyhyLCBhKTsgdmFyIHQgPSB7fS50b1N0cmluZy5jYWxsKHIpLnNsaWNlKDgsIC0xKTsgcmV0dXJuIFwiT2JqZWN0XCIgPT09IHQgJiYgci5jb25zdHJ1Y3RvciAmJiAodCA9IHIuY29uc3RydWN0b3IubmFtZSksIFwiTWFwXCIgPT09IHQgfHwgXCJTZXRcIiA9PT0gdCA/IEFycmF5LmZyb20ocikgOiBcIkFyZ3VtZW50c1wiID09PSB0IHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KHQpID8gX2FycmF5TGlrZVRvQXJyYXkkMyhyLCBhKSA6IHZvaWQgMDsgfSB9XG4gICAgZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkkMyhyLCBhKSB7IChudWxsID09IGEgfHwgYSA+IHIubGVuZ3RoKSAmJiAoYSA9IHIubGVuZ3RoKTsgZm9yICh2YXIgZSA9IDAsIG4gPSBBcnJheShhKTsgZSA8IGE7IGUrKykgbltlXSA9IHJbZV07IHJldHVybiBuOyB9XG4gICAgdmFyIGNyZWF0ZURlY3JlbWVudEN5Y2xlQ291bnRlciA9IGZ1bmN0aW9uIGNyZWF0ZURlY3JlbWVudEN5Y2xlQ291bnRlcihjb25uZWN0TmF0aXZlQXVkaW9Ob2RlVG9OYXRpdmVBdWRpb05vZGUsIGN5Y2xlQ291bnRlcnMsIGdldEF1ZGlvTm9kZUNvbm5lY3Rpb25zLCBnZXROYXRpdmVBdWRpb05vZGUsIGdldE5hdGl2ZUF1ZGlvUGFyYW0sIGdldE5hdGl2ZUNvbnRleHQsIGlzQWN0aXZlQXVkaW9Ob2RlLCBpc05hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoYXVkaW9Ob2RlLCBjb3VudCkge1xuICAgICAgICB2YXIgY3ljbGVDb3VudGVyID0gY3ljbGVDb3VudGVycy5nZXQoYXVkaW9Ob2RlKTtcbiAgICAgICAgaWYgKGN5Y2xlQ291bnRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHRoZSBleHBlY3RlZCBjeWNsZSBjb3VudC4nKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmF0aXZlQ29udGV4dCA9IGdldE5hdGl2ZUNvbnRleHQoYXVkaW9Ob2RlLmNvbnRleHQpO1xuICAgICAgICB2YXIgaXNPZmZsaW5lID0gaXNOYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KG5hdGl2ZUNvbnRleHQpO1xuICAgICAgICBpZiAoY3ljbGVDb3VudGVyID09PSBjb3VudCkge1xuICAgICAgICAgIGN5Y2xlQ291bnRlcnNbXCJkZWxldGVcIl0oYXVkaW9Ob2RlKTtcbiAgICAgICAgICBpZiAoIWlzT2ZmbGluZSAmJiBpc0FjdGl2ZUF1ZGlvTm9kZShhdWRpb05vZGUpKSB7XG4gICAgICAgICAgICB2YXIgbmF0aXZlU291cmNlQXVkaW9Ob2RlID0gZ2V0TmF0aXZlQXVkaW9Ob2RlKGF1ZGlvTm9kZSk7XG4gICAgICAgICAgICB2YXIgX2dldEF1ZGlvTm9kZUNvbm5lY3RpID0gZ2V0QXVkaW9Ob2RlQ29ubmVjdGlvbnMoYXVkaW9Ob2RlKSxcbiAgICAgICAgICAgICAgb3V0cHV0cyA9IF9nZXRBdWRpb05vZGVDb25uZWN0aS5vdXRwdXRzO1xuICAgICAgICAgICAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDMob3V0cHV0cyksXG4gICAgICAgICAgICAgIF9zdGVwO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICAgICAgICB2YXIgb3V0cHV0ID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKGlzQXVkaW9Ob2RlT3V0cHV0Q29ubmVjdGlvbihvdXRwdXQpKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgbmF0aXZlRGVzdGluYXRpb25BdWRpb05vZGUgPSBnZXROYXRpdmVBdWRpb05vZGUob3V0cHV0WzBdKTtcbiAgICAgICAgICAgICAgICAgIGNvbm5lY3ROYXRpdmVBdWRpb05vZGVUb05hdGl2ZUF1ZGlvTm9kZShuYXRpdmVTb3VyY2VBdWRpb05vZGUsIG5hdGl2ZURlc3RpbmF0aW9uQXVkaW9Ob2RlLCBvdXRwdXRbMV0sIG91dHB1dFsyXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHZhciBuYXRpdmVEZXN0aW5hdGlvbkF1ZGlvUGFyYW0gPSBnZXROYXRpdmVBdWRpb1BhcmFtKG91dHB1dFswXSk7XG4gICAgICAgICAgICAgICAgICBuYXRpdmVTb3VyY2VBdWRpb05vZGUuY29ubmVjdChuYXRpdmVEZXN0aW5hdGlvbkF1ZGlvUGFyYW0sIG91dHB1dFsxXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgIF9pdGVyYXRvci5mKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN5Y2xlQ291bnRlcnMuc2V0KGF1ZGlvTm9kZSwgY3ljbGVDb3VudGVyIC0gY291bnQpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBvd25LZXlzJGwoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuICAgIGZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkbChlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzJGwoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzJGwoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTsgfSk7IH0gcmV0dXJuIGU7IH1cbiAgICBmdW5jdGlvbiBfY2FsbFN1cGVyJGYodCwgbywgZSkgeyByZXR1cm4gbyA9IF9nZXRQcm90b3R5cGVPZihvKSwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odCwgX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRmKCkgPyBSZWZsZWN0LmNvbnN0cnVjdChvLCBlIHx8IFtdLCBfZ2V0UHJvdG90eXBlT2YodCkuY29uc3RydWN0b3IpIDogby5hcHBseSh0LCBlKSk7IH1cbiAgICBmdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JGYoKSB7IHRyeSB7IHZhciB0ID0gIUJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgfSBjYXRjaCAodCkge30gcmV0dXJuIChfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JGYgPSBmdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyByZXR1cm4gISF0OyB9KSgpOyB9XG4gICAgdmFyIERFRkFVTFRfT1BUSU9OUyRiID0ge1xuICAgICAgY2hhbm5lbENvdW50OiAyLFxuICAgICAgY2hhbm5lbENvdW50TW9kZTogJ21heCcsXG4gICAgICBjaGFubmVsSW50ZXJwcmV0YXRpb246ICdzcGVha2VycycsXG4gICAgICBkZWxheVRpbWU6IDAsXG4gICAgICBtYXhEZWxheVRpbWU6IDFcbiAgICB9O1xuICAgIHZhciBjcmVhdGVEZWxheU5vZGVDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uIGNyZWF0ZURlbGF5Tm9kZUNvbnN0cnVjdG9yKGF1ZGlvTm9kZUNvbnN0cnVjdG9yLCBjcmVhdGVBdWRpb1BhcmFtLCBjcmVhdGVEZWxheU5vZGVSZW5kZXJlciwgY3JlYXRlTmF0aXZlRGVsYXlOb2RlLCBnZXROYXRpdmVDb250ZXh0LCBpc05hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQsIHNldEF1ZGlvTm9kZVRhaWxUaW1lKSB7XG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfYXVkaW9Ob2RlQ29uc3RydWN0b3IpIHtcbiAgICAgICAgZnVuY3Rpb24gRGVsYXlOb2RlKGNvbnRleHQsIG9wdGlvbnMpIHtcbiAgICAgICAgICB2YXIgX3RoaXM7XG4gICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERlbGF5Tm9kZSk7XG4gICAgICAgICAgdmFyIG5hdGl2ZUNvbnRleHQgPSBnZXROYXRpdmVDb250ZXh0KGNvbnRleHQpO1xuICAgICAgICAgIHZhciBtZXJnZWRPcHRpb25zID0gX29iamVjdFNwcmVhZCRsKF9vYmplY3RTcHJlYWQkbCh7fSwgREVGQVVMVF9PUFRJT05TJGIpLCBvcHRpb25zKTtcbiAgICAgICAgICB2YXIgbmF0aXZlRGVsYXlOb2RlID0gY3JlYXRlTmF0aXZlRGVsYXlOb2RlKG5hdGl2ZUNvbnRleHQsIG1lcmdlZE9wdGlvbnMpO1xuICAgICAgICAgIHZhciBpc09mZmxpbmUgPSBpc05hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQobmF0aXZlQ29udGV4dCk7XG4gICAgICAgICAgdmFyIGRlbGF5Tm9kZVJlbmRlcmVyID0gaXNPZmZsaW5lID8gY3JlYXRlRGVsYXlOb2RlUmVuZGVyZXIobWVyZ2VkT3B0aW9ucy5tYXhEZWxheVRpbWUpIDogbnVsbDtcbiAgICAgICAgICBfdGhpcyA9IF9jYWxsU3VwZXIkZih0aGlzLCBEZWxheU5vZGUsIFtjb250ZXh0LCBmYWxzZSwgbmF0aXZlRGVsYXlOb2RlLCBkZWxheU5vZGVSZW5kZXJlcl0pO1xuICAgICAgICAgIF90aGlzLl9kZWxheVRpbWUgPSBjcmVhdGVBdWRpb1BhcmFtKF90aGlzLCBpc09mZmxpbmUsIG5hdGl2ZURlbGF5Tm9kZS5kZWxheVRpbWUpO1xuICAgICAgICAgIHNldEF1ZGlvTm9kZVRhaWxUaW1lKF90aGlzLCBtZXJnZWRPcHRpb25zLm1heERlbGF5VGltZSk7XG4gICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICB9XG4gICAgICAgIF9pbmhlcml0cyhEZWxheU5vZGUsIF9hdWRpb05vZGVDb25zdHJ1Y3Rvcik7XG4gICAgICAgIHJldHVybiBfY3JlYXRlQ2xhc3MoRGVsYXlOb2RlLCBbe1xuICAgICAgICAgIGtleTogXCJkZWxheVRpbWVcIixcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZWxheVRpbWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XSk7XG4gICAgICB9KGF1ZGlvTm9kZUNvbnN0cnVjdG9yKTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZURlbGF5Tm9kZVJlbmRlcmVyRmFjdG9yeSA9IGZ1bmN0aW9uIGNyZWF0ZURlbGF5Tm9kZVJlbmRlcmVyRmFjdG9yeShjb25uZWN0QXVkaW9QYXJhbSwgY3JlYXRlTmF0aXZlRGVsYXlOb2RlLCBnZXROYXRpdmVBdWRpb05vZGUsIHJlbmRlckF1dG9tYXRpb24sIHJlbmRlcklucHV0c09mQXVkaW9Ob2RlKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKG1heERlbGF5VGltZSkge1xuICAgICAgICB2YXIgcmVuZGVyZWROYXRpdmVEZWxheU5vZGVzID0gbmV3IFdlYWtNYXAoKTtcbiAgICAgICAgdmFyIGNyZWF0ZURlbGF5Tm9kZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIF9yZWYgPSBfYXN5bmNUb0dlbmVyYXRvcigvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUocHJveHksIG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciBuYXRpdmVEZWxheU5vZGUsIG5hdGl2ZURlbGF5Tm9kZUlzT3duZWRCeUNvbnRleHQsIG9wdGlvbnM7XG4gICAgICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICAgICAgICAgIHdoaWxlICgxKSBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgbmF0aXZlRGVsYXlOb2RlID0gZ2V0TmF0aXZlQXVkaW9Ob2RlKHByb3h5KTsgLy8gSWYgdGhlIGluaXRpYWxseSB1c2VkIG5hdGl2ZURlbGF5Tm9kZSB3YXMgbm90IGNvbnN0cnVjdGVkIG9uIHRoZSBzYW1lIE9mZmxpbmVBdWRpb0NvbnRleHQgaXQgbmVlZHMgdG8gYmUgY3JlYXRlZCBhZ2Fpbi5cbiAgICAgICAgICAgICAgICAgIG5hdGl2ZURlbGF5Tm9kZUlzT3duZWRCeUNvbnRleHQgPSBpc093bmVkQnlDb250ZXh0KG5hdGl2ZURlbGF5Tm9kZSwgbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCk7XG4gICAgICAgICAgICAgICAgICBpZiAoIW5hdGl2ZURlbGF5Tm9kZUlzT3duZWRCeUNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICBjaGFubmVsQ291bnQ6IG5hdGl2ZURlbGF5Tm9kZS5jaGFubmVsQ291bnQsXG4gICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbENvdW50TW9kZTogbmF0aXZlRGVsYXlOb2RlLmNoYW5uZWxDb3VudE1vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbEludGVycHJldGF0aW9uOiBuYXRpdmVEZWxheU5vZGUuY2hhbm5lbEludGVycHJldGF0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgIGRlbGF5VGltZTogbmF0aXZlRGVsYXlOb2RlLmRlbGF5VGltZS52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICBtYXhEZWxheVRpbWU6IG1heERlbGF5VGltZVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBuYXRpdmVEZWxheU5vZGUgPSBjcmVhdGVOYXRpdmVEZWxheU5vZGUobmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICByZW5kZXJlZE5hdGl2ZURlbGF5Tm9kZXMuc2V0KG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQsIG5hdGl2ZURlbGF5Tm9kZSk7XG4gICAgICAgICAgICAgICAgICBpZiAobmF0aXZlRGVsYXlOb2RlSXNPd25lZEJ5Q29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gOTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNztcbiAgICAgICAgICAgICAgICAgIHJldHVybiByZW5kZXJBdXRvbWF0aW9uKG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQsIHByb3h5LmRlbGF5VGltZSwgbmF0aXZlRGVsYXlOb2RlLmRlbGF5VGltZSk7XG4gICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDExO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDExO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbm5lY3RBdWRpb1BhcmFtKG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQsIHByb3h5LmRlbGF5VGltZSwgbmF0aXZlRGVsYXlOb2RlLmRlbGF5VGltZSk7XG4gICAgICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxMztcbiAgICAgICAgICAgICAgICAgIHJldHVybiByZW5kZXJJbnB1dHNPZkF1ZGlvTm9kZShwcm94eSwgbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCwgbmF0aXZlRGVsYXlOb2RlKTtcbiAgICAgICAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCBuYXRpdmVEZWxheU5vZGUpO1xuICAgICAgICAgICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgX2NhbGxlZSk7XG4gICAgICAgICAgfSkpO1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiBjcmVhdGVEZWxheU5vZGUoX3gsIF94Mikge1xuICAgICAgICAgICAgcmV0dXJuIF9yZWYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9KCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIocHJveHksIG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciByZW5kZXJlZE5hdGl2ZURlbGF5Tm9kZSA9IHJlbmRlcmVkTmF0aXZlRGVsYXlOb2Rlcy5nZXQobmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCk7XG4gICAgICAgICAgICBpZiAocmVuZGVyZWROYXRpdmVEZWxheU5vZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlbmRlcmVkTmF0aXZlRGVsYXlOb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVEZWxheU5vZGUocHJveHksIG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVEZWxldGVBY3RpdmVJbnB1dENvbm5lY3Rpb25Ub0F1ZGlvTm9kZSA9IGZ1bmN0aW9uIGNyZWF0ZURlbGV0ZUFjdGl2ZUlucHV0Q29ubmVjdGlvblRvQXVkaW9Ob2RlKHBpY2tFbGVtZW50RnJvbVNldCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhY3RpdmVJbnB1dHMsIHNvdXJjZSwgb3V0cHV0LCBpbnB1dCkge1xuICAgICAgICByZXR1cm4gcGlja0VsZW1lbnRGcm9tU2V0KGFjdGl2ZUlucHV0c1tpbnB1dF0sIGZ1bmN0aW9uIChhY3RpdmVJbnB1dENvbm5lY3Rpb24pIHtcbiAgICAgICAgICByZXR1cm4gYWN0aXZlSW5wdXRDb25uZWN0aW9uWzBdID09PSBzb3VyY2UgJiYgYWN0aXZlSW5wdXRDb25uZWN0aW9uWzFdID09PSBvdXRwdXQ7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZURlbGV0ZVVucmVuZGVyZWRBdWRpb1dvcmtsZXROb2RlID0gZnVuY3Rpb24gY3JlYXRlRGVsZXRlVW5yZW5kZXJlZEF1ZGlvV29ya2xldE5vZGUoZ2V0VW5yZW5kZXJlZEF1ZGlvV29ya2xldE5vZGVzKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKG5hdGl2ZUNvbnRleHQsIGF1ZGlvV29ya2xldE5vZGUpIHtcbiAgICAgICAgZ2V0VW5yZW5kZXJlZEF1ZGlvV29ya2xldE5vZGVzKG5hdGl2ZUNvbnRleHQpW1wiZGVsZXRlXCJdKGF1ZGlvV29ya2xldE5vZGUpO1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIGlzRGVsYXlOb2RlID0gZnVuY3Rpb24gaXNEZWxheU5vZGUoYXVkaW9Ob2RlKSB7XG4gICAgICByZXR1cm4gJ2RlbGF5VGltZScgaW4gYXVkaW9Ob2RlO1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlRGV0ZWN0Q3ljbGVzID0gZnVuY3Rpb24gY3JlYXRlRGV0ZWN0Q3ljbGVzKGF1ZGlvUGFyYW1BdWRpb05vZGVTdG9yZSwgZ2V0QXVkaW9Ob2RlQ29ubmVjdGlvbnMsIGdldFZhbHVlRm9yS2V5KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gZGV0ZWN0Q3ljbGVzKGNoYWluLCBuZXh0TGluaykge1xuICAgICAgICB2YXIgYXVkaW9Ob2RlID0gaXNBdWRpb05vZGUobmV4dExpbmspID8gbmV4dExpbmsgOiBnZXRWYWx1ZUZvcktleShhdWRpb1BhcmFtQXVkaW9Ob2RlU3RvcmUsIG5leHRMaW5rKTtcbiAgICAgICAgaWYgKGlzRGVsYXlOb2RlKGF1ZGlvTm9kZSkpIHtcbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYWluWzBdID09PSBhdWRpb05vZGUpIHtcbiAgICAgICAgICByZXR1cm4gW2NoYWluXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhaW4uaW5jbHVkZXMoYXVkaW9Ob2RlKSkge1xuICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgX2dldEF1ZGlvTm9kZUNvbm5lY3RpID0gZ2V0QXVkaW9Ob2RlQ29ubmVjdGlvbnMoYXVkaW9Ob2RlKSxcbiAgICAgICAgICBvdXRwdXRzID0gX2dldEF1ZGlvTm9kZUNvbm5lY3RpLm91dHB1dHM7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKG91dHB1dHMpLm1hcChmdW5jdGlvbiAob3V0cHV0Q29ubmVjdGlvbikge1xuICAgICAgICAgIHJldHVybiBkZXRlY3RDeWNsZXMoW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShjaGFpbiksIFthdWRpb05vZGVdKSwgb3V0cHV0Q29ubmVjdGlvblswXSk7XG4gICAgICAgIH0pLnJlZHVjZShmdW5jdGlvbiAobWVyZ2VkQ3ljbGVzLCBuZXN0ZWRDeWNsZXMpIHtcbiAgICAgICAgICByZXR1cm4gbWVyZ2VkQ3ljbGVzLmNvbmNhdChuZXN0ZWRDeWNsZXMpO1xuICAgICAgICB9LCBbXSk7XG4gICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgZ2V0T3V0cHV0QXVkaW9Ob2RlQXRJbmRleCA9IGZ1bmN0aW9uIGdldE91dHB1dEF1ZGlvTm9kZUF0SW5kZXgoY3JlYXRlSW5kZXhTaXplRXJyb3IsIG91dHB1dEF1ZGlvTm9kZXMsIG91dHB1dCkge1xuICAgICAgdmFyIG91dHB1dEF1ZGlvTm9kZSA9IG91dHB1dEF1ZGlvTm9kZXNbb3V0cHV0XTtcbiAgICAgIGlmIChvdXRwdXRBdWRpb05vZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBjcmVhdGVJbmRleFNpemVFcnJvcigpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG91dHB1dEF1ZGlvTm9kZTtcbiAgICB9O1xuICAgIHZhciBjcmVhdGVEaXNjb25uZWN0TXVsdGlwbGVPdXRwdXRzID0gZnVuY3Rpb24gY3JlYXRlRGlzY29ubmVjdE11bHRpcGxlT3V0cHV0cyhjcmVhdGVJbmRleFNpemVFcnJvcikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChvdXRwdXRBdWRpb05vZGVzKSB7XG4gICAgICAgIHZhciBkZXN0aW5hdGlvbk9yT3V0cHV0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQ7XG4gICAgICAgIHZhciBvdXRwdXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIGlucHV0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiAwO1xuICAgICAgICBpZiAoZGVzdGluYXRpb25Pck91dHB1dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIG91dHB1dEF1ZGlvTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAob3V0cHV0QXVkaW9Ob2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0QXVkaW9Ob2RlLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGRlc3RpbmF0aW9uT3JPdXRwdXQgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgcmV0dXJuIGdldE91dHB1dEF1ZGlvTm9kZUF0SW5kZXgoY3JlYXRlSW5kZXhTaXplRXJyb3IsIG91dHB1dEF1ZGlvTm9kZXMsIGRlc3RpbmF0aW9uT3JPdXRwdXQpLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNOYXRpdmVBdWRpb05vZGUkMShkZXN0aW5hdGlvbk9yT3V0cHV0KSkge1xuICAgICAgICAgIGlmIChvdXRwdXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIG91dHB1dEF1ZGlvTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAob3V0cHV0QXVkaW9Ob2RlKSB7XG4gICAgICAgICAgICAgIHJldHVybiBvdXRwdXRBdWRpb05vZGUuZGlzY29ubmVjdChkZXN0aW5hdGlvbk9yT3V0cHV0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaW5wdXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGdldE91dHB1dEF1ZGlvTm9kZUF0SW5kZXgoY3JlYXRlSW5kZXhTaXplRXJyb3IsIG91dHB1dEF1ZGlvTm9kZXMsIG91dHB1dCkuZGlzY29ubmVjdChkZXN0aW5hdGlvbk9yT3V0cHV0LCAwKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGdldE91dHB1dEF1ZGlvTm9kZUF0SW5kZXgoY3JlYXRlSW5kZXhTaXplRXJyb3IsIG91dHB1dEF1ZGlvTm9kZXMsIG91dHB1dCkuZGlzY29ubmVjdChkZXN0aW5hdGlvbk9yT3V0cHV0LCAwLCBpbnB1dCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG91dHB1dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIG91dHB1dEF1ZGlvTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAob3V0cHV0QXVkaW9Ob2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0QXVkaW9Ob2RlLmRpc2Nvbm5lY3QoZGVzdGluYXRpb25Pck91dHB1dCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdldE91dHB1dEF1ZGlvTm9kZUF0SW5kZXgoY3JlYXRlSW5kZXhTaXplRXJyb3IsIG91dHB1dEF1ZGlvTm9kZXMsIG91dHB1dCkuZGlzY29ubmVjdChkZXN0aW5hdGlvbk9yT3V0cHV0LCAwKTtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIG93bktleXMkayhlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XG4gICAgZnVuY3Rpb24gX29iamVjdFNwcmVhZCRrKGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMkayhPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMkayhPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxuICAgIGZ1bmN0aW9uIF9jYWxsU3VwZXIkZSh0LCBvLCBlKSB7IHJldHVybiBvID0gX2dldFByb3RvdHlwZU9mKG8pLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0LCBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JGUoKSA/IFJlZmxlY3QuY29uc3RydWN0KG8sIGUgfHwgW10sIF9nZXRQcm90b3R5cGVPZih0KS5jb25zdHJ1Y3RvcikgOiBvLmFwcGx5KHQsIGUpKTsgfVxuICAgIGZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkZSgpIHsgdHJ5IHsgdmFyIHQgPSAhQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyB9IGNhdGNoICh0KSB7fSByZXR1cm4gKF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkZSA9IGZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IHJldHVybiAhIXQ7IH0pKCk7IH1cbiAgICB2YXIgREVGQVVMVF9PUFRJT05TJGEgPSB7XG4gICAgICBhdHRhY2s6IDAuMDAzLFxuICAgICAgY2hhbm5lbENvdW50OiAyLFxuICAgICAgY2hhbm5lbENvdW50TW9kZTogJ2NsYW1wZWQtbWF4JyxcbiAgICAgIGNoYW5uZWxJbnRlcnByZXRhdGlvbjogJ3NwZWFrZXJzJyxcbiAgICAgIGtuZWU6IDMwLFxuICAgICAgcmF0aW86IDEyLFxuICAgICAgcmVsZWFzZTogMC4yNSxcbiAgICAgIHRocmVzaG9sZDogLTI0XG4gICAgfTtcbiAgICB2YXIgY3JlYXRlRHluYW1pY3NDb21wcmVzc29yTm9kZUNvbnN0cnVjdG9yID0gZnVuY3Rpb24gY3JlYXRlRHluYW1pY3NDb21wcmVzc29yTm9kZUNvbnN0cnVjdG9yKGF1ZGlvTm9kZUNvbnN0cnVjdG9yLCBjcmVhdGVBdWRpb1BhcmFtLCBjcmVhdGVEeW5hbWljc0NvbXByZXNzb3JOb2RlUmVuZGVyZXIsIGNyZWF0ZU5hdGl2ZUR5bmFtaWNzQ29tcHJlc3Nvck5vZGUsIGNyZWF0ZU5vdFN1cHBvcnRlZEVycm9yLCBnZXROYXRpdmVDb250ZXh0LCBpc05hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQsIHNldEF1ZGlvTm9kZVRhaWxUaW1lKSB7XG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfYXVkaW9Ob2RlQ29uc3RydWN0b3IpIHtcbiAgICAgICAgZnVuY3Rpb24gRHluYW1pY3NDb21wcmVzc29yTm9kZShjb250ZXh0LCBvcHRpb25zKSB7XG4gICAgICAgICAgdmFyIF90aGlzO1xuICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEeW5hbWljc0NvbXByZXNzb3JOb2RlKTtcbiAgICAgICAgICB2YXIgbmF0aXZlQ29udGV4dCA9IGdldE5hdGl2ZUNvbnRleHQoY29udGV4dCk7XG4gICAgICAgICAgdmFyIG1lcmdlZE9wdGlvbnMgPSBfb2JqZWN0U3ByZWFkJGsoX29iamVjdFNwcmVhZCRrKHt9LCBERUZBVUxUX09QVElPTlMkYSksIG9wdGlvbnMpO1xuICAgICAgICAgIHZhciBuYXRpdmVEeW5hbWljc0NvbXByZXNzb3JOb2RlID0gY3JlYXRlTmF0aXZlRHluYW1pY3NDb21wcmVzc29yTm9kZShuYXRpdmVDb250ZXh0LCBtZXJnZWRPcHRpb25zKTtcbiAgICAgICAgICB2YXIgaXNPZmZsaW5lID0gaXNOYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KG5hdGl2ZUNvbnRleHQpO1xuICAgICAgICAgIHZhciBkeW5hbWljc0NvbXByZXNzb3JOb2RlUmVuZGVyZXIgPSBpc09mZmxpbmUgPyBjcmVhdGVEeW5hbWljc0NvbXByZXNzb3JOb2RlUmVuZGVyZXIoKSA6IG51bGw7XG4gICAgICAgICAgX3RoaXMgPSBfY2FsbFN1cGVyJGUodGhpcywgRHluYW1pY3NDb21wcmVzc29yTm9kZSwgW2NvbnRleHQsIGZhbHNlLCBuYXRpdmVEeW5hbWljc0NvbXByZXNzb3JOb2RlLCBkeW5hbWljc0NvbXByZXNzb3JOb2RlUmVuZGVyZXJdKTtcbiAgICAgICAgICBfdGhpcy5fYXR0YWNrID0gY3JlYXRlQXVkaW9QYXJhbShfdGhpcywgaXNPZmZsaW5lLCBuYXRpdmVEeW5hbWljc0NvbXByZXNzb3JOb2RlLmF0dGFjayk7XG4gICAgICAgICAgX3RoaXMuX2tuZWUgPSBjcmVhdGVBdWRpb1BhcmFtKF90aGlzLCBpc09mZmxpbmUsIG5hdGl2ZUR5bmFtaWNzQ29tcHJlc3Nvck5vZGUua25lZSk7XG4gICAgICAgICAgX3RoaXMuX25hdGl2ZUR5bmFtaWNzQ29tcHJlc3Nvck5vZGUgPSBuYXRpdmVEeW5hbWljc0NvbXByZXNzb3JOb2RlO1xuICAgICAgICAgIF90aGlzLl9yYXRpbyA9IGNyZWF0ZUF1ZGlvUGFyYW0oX3RoaXMsIGlzT2ZmbGluZSwgbmF0aXZlRHluYW1pY3NDb21wcmVzc29yTm9kZS5yYXRpbyk7XG4gICAgICAgICAgX3RoaXMuX3JlbGVhc2UgPSBjcmVhdGVBdWRpb1BhcmFtKF90aGlzLCBpc09mZmxpbmUsIG5hdGl2ZUR5bmFtaWNzQ29tcHJlc3Nvck5vZGUucmVsZWFzZSk7XG4gICAgICAgICAgX3RoaXMuX3RocmVzaG9sZCA9IGNyZWF0ZUF1ZGlvUGFyYW0oX3RoaXMsIGlzT2ZmbGluZSwgbmF0aXZlRHluYW1pY3NDb21wcmVzc29yTm9kZS50aHJlc2hvbGQpO1xuICAgICAgICAgIHNldEF1ZGlvTm9kZVRhaWxUaW1lKF90aGlzLCAwLjAwNik7XG4gICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICB9XG4gICAgICAgIF9pbmhlcml0cyhEeW5hbWljc0NvbXByZXNzb3JOb2RlLCBfYXVkaW9Ob2RlQ29uc3RydWN0b3IpO1xuICAgICAgICByZXR1cm4gX2NyZWF0ZUNsYXNzKER5bmFtaWNzQ29tcHJlc3Nvck5vZGUsIFt7XG4gICAgICAgICAga2V5OiBcImF0dGFja1wiLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2F0dGFjaztcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gQnVnICMxMDg6IFNhZmFyaSBhbGxvd3MgYSBjaGFubmVsQ291bnQgb2YgdGhyZWUgYW5kIGFib3ZlIHdoaWNoIGlzIHdoeSB0aGUgZ2V0dGVyIGFuZCBzZXR0ZXIgbmVlZHMgdG8gYmUgb3ZlcndyaXR0ZW4gaGVyZS5cbiAgICAgICAgfSwge1xuICAgICAgICAgIGtleTogXCJjaGFubmVsQ291bnRcIixcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9uYXRpdmVEeW5hbWljc0NvbXByZXNzb3JOb2RlLmNoYW5uZWxDb3VudDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgcHJldmlvdXNDaGFubmVsQ291bnQgPSB0aGlzLl9uYXRpdmVEeW5hbWljc0NvbXByZXNzb3JOb2RlLmNoYW5uZWxDb3VudDtcbiAgICAgICAgICAgIHRoaXMuX25hdGl2ZUR5bmFtaWNzQ29tcHJlc3Nvck5vZGUuY2hhbm5lbENvdW50ID0gdmFsdWU7XG4gICAgICAgICAgICBpZiAodmFsdWUgPiAyKSB7XG4gICAgICAgICAgICAgIHRoaXMuX25hdGl2ZUR5bmFtaWNzQ29tcHJlc3Nvck5vZGUuY2hhbm5lbENvdW50ID0gcHJldmlvdXNDaGFubmVsQ291bnQ7XG4gICAgICAgICAgICAgIHRocm93IGNyZWF0ZU5vdFN1cHBvcnRlZEVycm9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8qXG4gICAgICAgICAgICogQnVnICMxMDk6IE9ubHkgQ2hyb21lIGFuZCBGaXJlZm94IGRpc2FsbG93IGEgY2hhbm5lbENvdW50TW9kZSBvZiAnbWF4JyB5ZXQgd2hpY2ggaXMgd2h5IHRoZSBnZXR0ZXIgYW5kIHNldHRlciBuZWVkcyB0byBiZVxuICAgICAgICAgICAqIG92ZXJ3cml0dGVuIGhlcmUuXG4gICAgICAgICAgICovXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBrZXk6IFwiY2hhbm5lbENvdW50TW9kZVwiLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25hdGl2ZUR5bmFtaWNzQ29tcHJlc3Nvck5vZGUuY2hhbm5lbENvdW50TW9kZTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgcHJldmlvdXNDaGFubmVsQ291bnQgPSB0aGlzLl9uYXRpdmVEeW5hbWljc0NvbXByZXNzb3JOb2RlLmNoYW5uZWxDb3VudE1vZGU7XG4gICAgICAgICAgICB0aGlzLl9uYXRpdmVEeW5hbWljc0NvbXByZXNzb3JOb2RlLmNoYW5uZWxDb3VudE1vZGUgPSB2YWx1ZTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gJ21heCcpIHtcbiAgICAgICAgICAgICAgdGhpcy5fbmF0aXZlRHluYW1pY3NDb21wcmVzc29yTm9kZS5jaGFubmVsQ291bnRNb2RlID0gcHJldmlvdXNDaGFubmVsQ291bnQ7XG4gICAgICAgICAgICAgIHRocm93IGNyZWF0ZU5vdFN1cHBvcnRlZEVycm9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcImtuZWVcIixcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9rbmVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIGtleTogXCJyYXRpb1wiLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JhdGlvO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIGtleTogXCJyZWR1Y3Rpb25cIixcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIC8vIEJ1ZyAjMTExOiBTYWZhcmkgcmV0dXJucyBhbiBBdWRpb1BhcmFtIGluc3RlYWQgb2YgYSBudW1iZXIuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuX25hdGl2ZUR5bmFtaWNzQ29tcHJlc3Nvck5vZGUucmVkdWN0aW9uLnZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbmF0aXZlRHluYW1pY3NDb21wcmVzc29yTm9kZS5yZWR1Y3Rpb24udmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbmF0aXZlRHluYW1pY3NDb21wcmVzc29yTm9kZS5yZWR1Y3Rpb247XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcInJlbGVhc2VcIixcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZWxlYXNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIGtleTogXCJ0aHJlc2hvbGRcIixcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90aHJlc2hvbGQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XSk7XG4gICAgICB9KGF1ZGlvTm9kZUNvbnN0cnVjdG9yKTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZUR5bmFtaWNzQ29tcHJlc3Nvck5vZGVSZW5kZXJlckZhY3RvcnkgPSBmdW5jdGlvbiBjcmVhdGVEeW5hbWljc0NvbXByZXNzb3JOb2RlUmVuZGVyZXJGYWN0b3J5KGNvbm5lY3RBdWRpb1BhcmFtLCBjcmVhdGVOYXRpdmVEeW5hbWljc0NvbXByZXNzb3JOb2RlLCBnZXROYXRpdmVBdWRpb05vZGUsIHJlbmRlckF1dG9tYXRpb24sIHJlbmRlcklucHV0c09mQXVkaW9Ob2RlKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVuZGVyZWROYXRpdmVEeW5hbWljc0NvbXByZXNzb3JOb2RlcyA9IG5ldyBXZWFrTWFwKCk7XG4gICAgICAgIHZhciBjcmVhdGVEeW5hbWljc0NvbXByZXNzb3JOb2RlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgX3JlZiA9IF9hc3luY1RvR2VuZXJhdG9yKC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZShwcm94eSwgbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCkge1xuICAgICAgICAgICAgdmFyIG5hdGl2ZUR5bmFtaWNzQ29tcHJlc3Nvck5vZGUsIG5hdGl2ZUR5bmFtaWNzQ29tcHJlc3Nvck5vZGVJc093bmVkQnlDb250ZXh0LCBvcHRpb25zO1xuICAgICAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgICAgICAgICB3aGlsZSAoMSkgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgIG5hdGl2ZUR5bmFtaWNzQ29tcHJlc3Nvck5vZGUgPSBnZXROYXRpdmVBdWRpb05vZGUocHJveHkpO1xuICAgICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgICAqIElmIHRoZSBpbml0aWFsbHkgdXNlZCBuYXRpdmVEeW5hbWljc0NvbXByZXNzb3JOb2RlIHdhcyBub3QgY29uc3RydWN0ZWQgb24gdGhlIHNhbWUgT2ZmbGluZUF1ZGlvQ29udGV4dCBpdCBuZWVkcyB0byBiZVxuICAgICAgICAgICAgICAgICAgICogY3JlYXRlZCBhZ2Fpbi5cbiAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgbmF0aXZlRHluYW1pY3NDb21wcmVzc29yTm9kZUlzT3duZWRCeUNvbnRleHQgPSBpc093bmVkQnlDb250ZXh0KG5hdGl2ZUR5bmFtaWNzQ29tcHJlc3Nvck5vZGUsIG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgaWYgKCFuYXRpdmVEeW5hbWljc0NvbXByZXNzb3JOb2RlSXNPd25lZEJ5Q29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zID0ge1xuICAgICAgICAgICAgICAgICAgICAgIGF0dGFjazogbmF0aXZlRHluYW1pY3NDb21wcmVzc29yTm9kZS5hdHRhY2sudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbENvdW50OiBuYXRpdmVEeW5hbWljc0NvbXByZXNzb3JOb2RlLmNoYW5uZWxDb3VudCxcbiAgICAgICAgICAgICAgICAgICAgICBjaGFubmVsQ291bnRNb2RlOiBuYXRpdmVEeW5hbWljc0NvbXByZXNzb3JOb2RlLmNoYW5uZWxDb3VudE1vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbEludGVycHJldGF0aW9uOiBuYXRpdmVEeW5hbWljc0NvbXByZXNzb3JOb2RlLmNoYW5uZWxJbnRlcnByZXRhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICBrbmVlOiBuYXRpdmVEeW5hbWljc0NvbXByZXNzb3JOb2RlLmtuZWUudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgcmF0aW86IG5hdGl2ZUR5bmFtaWNzQ29tcHJlc3Nvck5vZGUucmF0aW8udmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgcmVsZWFzZTogbmF0aXZlRHluYW1pY3NDb21wcmVzc29yTm9kZS5yZWxlYXNlLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgIHRocmVzaG9sZDogbmF0aXZlRHluYW1pY3NDb21wcmVzc29yTm9kZS50aHJlc2hvbGQudmFsdWVcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgbmF0aXZlRHluYW1pY3NDb21wcmVzc29yTm9kZSA9IGNyZWF0ZU5hdGl2ZUR5bmFtaWNzQ29tcHJlc3Nvck5vZGUobmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICByZW5kZXJlZE5hdGl2ZUR5bmFtaWNzQ29tcHJlc3Nvck5vZGVzLnNldChuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LCBuYXRpdmVEeW5hbWljc0NvbXByZXNzb3JOb2RlKTtcbiAgICAgICAgICAgICAgICAgIGlmIChuYXRpdmVEeW5hbWljc0NvbXByZXNzb3JOb2RlSXNPd25lZEJ5Q29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDc7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcmVuZGVyQXV0b21hdGlvbihuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LCBwcm94eS5hdHRhY2ssIG5hdGl2ZUR5bmFtaWNzQ29tcHJlc3Nvck5vZGUuYXR0YWNrKTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gOTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiByZW5kZXJBdXRvbWF0aW9uKG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQsIHByb3h5LmtuZWUsIG5hdGl2ZUR5bmFtaWNzQ29tcHJlc3Nvck5vZGUua25lZSk7XG4gICAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDExO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlbmRlckF1dG9tYXRpb24obmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCwgcHJveHkucmF0aW8sIG5hdGl2ZUR5bmFtaWNzQ29tcHJlc3Nvck5vZGUucmF0aW8pO1xuICAgICAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTM7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcmVuZGVyQXV0b21hdGlvbihuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LCBwcm94eS5yZWxlYXNlLCBuYXRpdmVEeW5hbWljc0NvbXByZXNzb3JOb2RlLnJlbGVhc2UpO1xuICAgICAgICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTU7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcmVuZGVyQXV0b21hdGlvbihuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LCBwcm94eS50aHJlc2hvbGQsIG5hdGl2ZUR5bmFtaWNzQ29tcHJlc3Nvck5vZGUudGhyZXNob2xkKTtcbiAgICAgICAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDI3O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxNzpcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxOTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBjb25uZWN0QXVkaW9QYXJhbShuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LCBwcm94eS5hdHRhY2ssIG5hdGl2ZUR5bmFtaWNzQ29tcHJlc3Nvck5vZGUuYXR0YWNrKTtcbiAgICAgICAgICAgICAgICBjYXNlIDE5OlxuICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDIxO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbm5lY3RBdWRpb1BhcmFtKG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQsIHByb3h5LmtuZWUsIG5hdGl2ZUR5bmFtaWNzQ29tcHJlc3Nvck5vZGUua25lZSk7XG4gICAgICAgICAgICAgICAgY2FzZSAyMTpcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAyMztcbiAgICAgICAgICAgICAgICAgIHJldHVybiBjb25uZWN0QXVkaW9QYXJhbShuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LCBwcm94eS5yYXRpbywgbmF0aXZlRHluYW1pY3NDb21wcmVzc29yTm9kZS5yYXRpbyk7XG4gICAgICAgICAgICAgICAgY2FzZSAyMzpcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAyNTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBjb25uZWN0QXVkaW9QYXJhbShuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LCBwcm94eS5yZWxlYXNlLCBuYXRpdmVEeW5hbWljc0NvbXByZXNzb3JOb2RlLnJlbGVhc2UpO1xuICAgICAgICAgICAgICAgIGNhc2UgMjU6XG4gICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjc7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gY29ubmVjdEF1ZGlvUGFyYW0obmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCwgcHJveHkudGhyZXNob2xkLCBuYXRpdmVEeW5hbWljc0NvbXByZXNzb3JOb2RlLnRocmVzaG9sZCk7XG4gICAgICAgICAgICAgICAgY2FzZSAyNzpcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAyOTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiByZW5kZXJJbnB1dHNPZkF1ZGlvTm9kZShwcm94eSwgbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCwgbmF0aXZlRHluYW1pY3NDb21wcmVzc29yTm9kZSk7XG4gICAgICAgICAgICAgICAgY2FzZSAyOTpcbiAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgbmF0aXZlRHluYW1pY3NDb21wcmVzc29yTm9kZSk7XG4gICAgICAgICAgICAgICAgY2FzZSAzMDpcbiAgICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBfY2FsbGVlKTtcbiAgICAgICAgICB9KSk7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZUR5bmFtaWNzQ29tcHJlc3Nvck5vZGUoX3gsIF94Mikge1xuICAgICAgICAgICAgcmV0dXJuIF9yZWYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9KCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIocHJveHksIG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciByZW5kZXJlZE5hdGl2ZUR5bmFtaWNzQ29tcHJlc3Nvck5vZGUgPSByZW5kZXJlZE5hdGl2ZUR5bmFtaWNzQ29tcHJlc3Nvck5vZGVzLmdldChuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KTtcbiAgICAgICAgICAgIGlmIChyZW5kZXJlZE5hdGl2ZUR5bmFtaWNzQ29tcHJlc3Nvck5vZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlbmRlcmVkTmF0aXZlRHluYW1pY3NDb21wcmVzc29yTm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlRHluYW1pY3NDb21wcmVzc29yTm9kZShwcm94eSwgbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZUVuY29kaW5nRXJyb3IgPSBmdW5jdGlvbiBjcmVhdGVFbmNvZGluZ0Vycm9yKCkge1xuICAgICAgcmV0dXJuIG5ldyBET01FeGNlcHRpb24oJycsICdFbmNvZGluZ0Vycm9yJyk7XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVFdmFsdWF0ZVNvdXJjZSA9IGZ1bmN0aW9uIGNyZWF0ZUV2YWx1YXRlU291cmNlKHdpbmRvdykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICBpZiAod2luZG93ID09PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBCdWcgIzE4MiBDaHJvbWUgYW5kIEVkZ2UgZG8gdGhyb3cgYW4gaW5zdGFuY2Ugb2YgYSBTeW50YXhFcnJvciBpbnN0ZWFkIG9mIGEgRE9NRXhjZXB0aW9uLlxuICAgICAgICAgICAgcmVqZWN0KG5ldyBTeW50YXhFcnJvcigpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGhlYWQgPSB3aW5kb3cuZG9jdW1lbnQuaGVhZDtcbiAgICAgICAgICBpZiAoaGVhZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gQnVnICMxODIgQ2hyb21lIGFuZCBFZGdlIGRvIHRocm93IGFuIGluc3RhbmNlIG9mIGEgU3ludGF4RXJyb3IgaW5zdGVhZCBvZiBhIERPTUV4Y2VwdGlvbi5cbiAgICAgICAgICAgIHJlamVjdChuZXcgU3ludGF4RXJyb3IoKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBzY3JpcHQgPSB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgICAgICAgICAvLyBAdG9kbyBTYWZhcmkgZG9lc24ndCBsaWtlIFVSTHMgd2l0aCBhIHR5cGUgb2YgJ2FwcGxpY2F0aW9uL2phdmFzY3JpcHQ7IGNoYXJzZXQ9dXRmLTgnLlxuICAgICAgICAgICAgdmFyIGJsb2IgPSBuZXcgQmxvYihbc291cmNlXSwge1xuICAgICAgICAgICAgICB0eXBlOiAnYXBwbGljYXRpb24vamF2YXNjcmlwdCdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIHVybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG4gICAgICAgICAgICB2YXIgb3JpZ2luYWxPbkVycm9ySGFuZGxlciA9IHdpbmRvdy5vbmVycm9yO1xuICAgICAgICAgICAgdmFyIHJlbW92ZUVycm9yRXZlbnRMaXN0ZW5lckFuZFJldm9rZVVybCA9IGZ1bmN0aW9uIHJlbW92ZUVycm9yRXZlbnRMaXN0ZW5lckFuZFJldm9rZVVybCgpIHtcbiAgICAgICAgICAgICAgd2luZG93Lm9uZXJyb3IgPSBvcmlnaW5hbE9uRXJyb3JIYW5kbGVyO1xuICAgICAgICAgICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKHVybCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgd2luZG93Lm9uZXJyb3IgPSBmdW5jdGlvbiAobWVzc2FnZSwgc3JjLCBsaW5lbm8sIGNvbG5vLCBlcnJvcikge1xuICAgICAgICAgICAgICAvLyBAdG9kbyBFZGdlIHRoaW5rcyB0aGUgc291cmNlIGlzIHRoZSBvbmUgb2YgdGhlIGh0bWwgZG9jdW1lbnQuXG4gICAgICAgICAgICAgIGlmIChzcmMgPT09IHVybCB8fCBzcmMgPT09IHdpbmRvdy5sb2NhdGlvbi5ocmVmICYmIGxpbmVubyA9PT0gMSAmJiBjb2xubyA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHJlbW92ZUVycm9yRXZlbnRMaXN0ZW5lckFuZFJldm9rZVVybCgpO1xuICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChvcmlnaW5hbE9uRXJyb3JIYW5kbGVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsT25FcnJvckhhbmRsZXIobWVzc2FnZSwgc3JjLCBsaW5lbm8sIGNvbG5vLCBlcnJvcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBzY3JpcHQub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmVtb3ZlRXJyb3JFdmVudExpc3RlbmVyQW5kUmV2b2tlVXJsKCk7XG4gICAgICAgICAgICAgIC8vIEJ1ZyAjMTgyIENocm9tZSBhbmQgRWRnZSBkbyB0aHJvdyBhbiBpbnN0YW5jZSBvZiBhIFN5bnRheEVycm9yIGluc3RlYWQgb2YgYSBET01FeGNlcHRpb24uXG4gICAgICAgICAgICAgIHJlamVjdChuZXcgU3ludGF4RXJyb3IoKSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgc2NyaXB0Lm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmVtb3ZlRXJyb3JFdmVudExpc3RlbmVyQW5kUmV2b2tlVXJsKCk7XG4gICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBzY3JpcHQuc3JjID0gdXJsO1xuICAgICAgICAgICAgc2NyaXB0LnR5cGUgPSAnbW9kdWxlJztcbiAgICAgICAgICAgIGhlYWQuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZUV2ZW50VGFyZ2V0Q29uc3RydWN0b3IgPSBmdW5jdGlvbiBjcmVhdGVFdmVudFRhcmdldENvbnN0cnVjdG9yKHdyYXBFdmVudExpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gRXZlbnRUYXJnZXQoX25hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEV2ZW50VGFyZ2V0KTtcbiAgICAgICAgICB0aGlzLl9uYXRpdmVFdmVudFRhcmdldCA9IF9uYXRpdmVFdmVudFRhcmdldDtcbiAgICAgICAgICB0aGlzLl9saXN0ZW5lcnMgPSBuZXcgV2Vha01hcCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfY3JlYXRlQ2xhc3MoRXZlbnRUYXJnZXQsIFt7XG4gICAgICAgICAga2V5OiBcImFkZEV2ZW50TGlzdGVuZXJcIixcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgb3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKGxpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHZhciB3cmFwcGVkRXZlbnRMaXN0ZW5lciA9IHRoaXMuX2xpc3RlbmVycy5nZXQobGlzdGVuZXIpO1xuICAgICAgICAgICAgICBpZiAod3JhcHBlZEV2ZW50TGlzdGVuZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHdyYXBwZWRFdmVudExpc3RlbmVyID0gd3JhcEV2ZW50TGlzdGVuZXIodGhpcywgbGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2xpc3RlbmVycy5zZXQobGlzdGVuZXIsIHdyYXBwZWRFdmVudExpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhpcy5fbmF0aXZlRXZlbnRUYXJnZXQuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCB3cmFwcGVkRXZlbnRMaXN0ZW5lciwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcImRpc3BhdGNoRXZlbnRcIixcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZGlzcGF0Y2hFdmVudChldmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25hdGl2ZUV2ZW50VGFyZ2V0LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIGtleTogXCJyZW1vdmVFdmVudExpc3RlbmVyXCIsXG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciB3cmFwcGVkRXZlbnRMaXN0ZW5lciA9IGxpc3RlbmVyID09PSBudWxsID8gdW5kZWZpbmVkIDogdGhpcy5fbGlzdGVuZXJzLmdldChsaXN0ZW5lcik7XG4gICAgICAgICAgICB0aGlzLl9uYXRpdmVFdmVudFRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIHdyYXBwZWRFdmVudExpc3RlbmVyID09PSB1bmRlZmluZWQgPyBudWxsIDogd3JhcHBlZEV2ZW50TGlzdGVuZXIsIG9wdGlvbnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfV0pO1xuICAgICAgfSgpO1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlRXhwb3NlQ3VycmVudEZyYW1lQW5kQ3VycmVudFRpbWUgPSBmdW5jdGlvbiBjcmVhdGVFeHBvc2VDdXJyZW50RnJhbWVBbmRDdXJyZW50VGltZSh3aW5kb3cpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoY3VycmVudFRpbWUsIHNhbXBsZVJhdGUsIGZuKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHdpbmRvdywge1xuICAgICAgICAgIGN1cnJlbnRGcmFtZToge1xuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBNYXRoLnJvdW5kKGN1cnJlbnRUaW1lICogc2FtcGxlUmF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBjdXJyZW50VGltZToge1xuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjdXJyZW50VGltZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBmbigpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlmICh3aW5kb3cgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB3aW5kb3cuY3VycmVudEZyYW1lO1xuICAgICAgICAgICAgZGVsZXRlIHdpbmRvdy5jdXJyZW50VGltZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVGZXRjaFNvdXJjZSA9IGZ1bmN0aW9uIGNyZWF0ZUZldGNoU291cmNlKGNyZWF0ZUFib3J0RXJyb3IpIHtcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3JlZiA9IF9hc3luY1RvR2VuZXJhdG9yKC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZSh1cmwpIHtcbiAgICAgICAgICB2YXIgcmVzcG9uc2U7XG4gICAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgICAgICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAwO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAzO1xuICAgICAgICAgICAgICAgIHJldHVybiBmZXRjaCh1cmwpO1xuICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBfY29udGV4dC5zZW50O1xuICAgICAgICAgICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxMDtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNztcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGV4dCgpO1xuICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQudDAgPSBfY29udGV4dC5zZW50O1xuICAgICAgICAgICAgICAgIF9jb250ZXh0LnQxID0gcmVzcG9uc2UudXJsO1xuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgW19jb250ZXh0LnQwLCBfY29udGV4dC50MV0pO1xuICAgICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxNDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMTI7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQudDIgPSBfY29udGV4dFtcImNhdGNoXCJdKDApO1xuICAgICAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgICAgIHRocm93IGNyZWF0ZUFib3J0RXJyb3IoKTtcbiAgICAgICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgX2NhbGxlZSwgbnVsbCwgW1swLCAxMl1dKTtcbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKF94KSB7XG4gICAgICAgICAgcmV0dXJuIF9yZWYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICAgIH0oKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gb3duS2V5cyRqKGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cbiAgICBmdW5jdGlvbiBfb2JqZWN0U3ByZWFkJGooZSkgeyBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykgeyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gb3duS2V5cyRqKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyRqKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XG4gICAgZnVuY3Rpb24gX2NhbGxTdXBlciRkKHQsIG8sIGUpIHsgcmV0dXJuIG8gPSBfZ2V0UHJvdG90eXBlT2YobyksIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHQsIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkZCgpID8gUmVmbGVjdC5jb25zdHJ1Y3QobywgZSB8fCBbXSwgX2dldFByb3RvdHlwZU9mKHQpLmNvbnN0cnVjdG9yKSA6IG8uYXBwbHkodCwgZSkpOyB9XG4gICAgZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRkKCkgeyB0cnkgeyB2YXIgdCA9ICFCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IH0gY2F0Y2ggKHQpIHt9IHJldHVybiAoX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRkID0gZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgcmV0dXJuICEhdDsgfSkoKTsgfVxuICAgIHZhciBERUZBVUxUX09QVElPTlMkOSA9IHtcbiAgICAgIGNoYW5uZWxDb3VudDogMixcbiAgICAgIGNoYW5uZWxDb3VudE1vZGU6ICdtYXgnLFxuICAgICAgY2hhbm5lbEludGVycHJldGF0aW9uOiAnc3BlYWtlcnMnLFxuICAgICAgZ2FpbjogMVxuICAgIH07XG4gICAgdmFyIGNyZWF0ZUdhaW5Ob2RlQ29uc3RydWN0b3IgPSBmdW5jdGlvbiBjcmVhdGVHYWluTm9kZUNvbnN0cnVjdG9yKGF1ZGlvTm9kZUNvbnN0cnVjdG9yLCBjcmVhdGVBdWRpb1BhcmFtLCBjcmVhdGVHYWluTm9kZVJlbmRlcmVyLCBjcmVhdGVOYXRpdmVHYWluTm9kZSwgZ2V0TmF0aXZlQ29udGV4dCwgaXNOYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KSB7XG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfYXVkaW9Ob2RlQ29uc3RydWN0b3IpIHtcbiAgICAgICAgZnVuY3Rpb24gR2Fpbk5vZGUoY29udGV4dCwgb3B0aW9ucykge1xuICAgICAgICAgIHZhciBfdGhpcztcbiAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgR2Fpbk5vZGUpO1xuICAgICAgICAgIHZhciBuYXRpdmVDb250ZXh0ID0gZ2V0TmF0aXZlQ29udGV4dChjb250ZXh0KTtcbiAgICAgICAgICB2YXIgbWVyZ2VkT3B0aW9ucyA9IF9vYmplY3RTcHJlYWQkaihfb2JqZWN0U3ByZWFkJGooe30sIERFRkFVTFRfT1BUSU9OUyQ5KSwgb3B0aW9ucyk7XG4gICAgICAgICAgdmFyIG5hdGl2ZUdhaW5Ob2RlID0gY3JlYXRlTmF0aXZlR2Fpbk5vZGUobmF0aXZlQ29udGV4dCwgbWVyZ2VkT3B0aW9ucyk7XG4gICAgICAgICAgdmFyIGlzT2ZmbGluZSA9IGlzTmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dChuYXRpdmVDb250ZXh0KTtcbiAgICAgICAgICB2YXIgZ2Fpbk5vZGVSZW5kZXJlciA9IGlzT2ZmbGluZSA/IGNyZWF0ZUdhaW5Ob2RlUmVuZGVyZXIoKSA6IG51bGw7XG4gICAgICAgICAgX3RoaXMgPSBfY2FsbFN1cGVyJGQodGhpcywgR2Fpbk5vZGUsIFtjb250ZXh0LCBmYWxzZSwgbmF0aXZlR2Fpbk5vZGUsIGdhaW5Ob2RlUmVuZGVyZXJdKTtcbiAgICAgICAgICAvLyBCdWcgIzc0OiBTYWZhcmkgZG9lcyBub3QgZXhwb3J0IHRoZSBjb3JyZWN0IHZhbHVlcyBmb3IgbWF4VmFsdWUgYW5kIG1pblZhbHVlLlxuICAgICAgICAgIF90aGlzLl9nYWluID0gY3JlYXRlQXVkaW9QYXJhbShfdGhpcywgaXNPZmZsaW5lLCBuYXRpdmVHYWluTm9kZS5nYWluLCBNT1NUX1BPU0lUSVZFX1NJTkdMRV9GTE9BVCwgTU9TVF9ORUdBVElWRV9TSU5HTEVfRkxPQVQpO1xuICAgICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgICAgfVxuICAgICAgICBfaW5oZXJpdHMoR2Fpbk5vZGUsIF9hdWRpb05vZGVDb25zdHJ1Y3Rvcik7XG4gICAgICAgIHJldHVybiBfY3JlYXRlQ2xhc3MoR2Fpbk5vZGUsIFt7XG4gICAgICAgICAga2V5OiBcImdhaW5cIixcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9nYWluO1xuICAgICAgICAgIH1cbiAgICAgICAgfV0pO1xuICAgICAgfShhdWRpb05vZGVDb25zdHJ1Y3Rvcik7XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVHYWluTm9kZVJlbmRlcmVyRmFjdG9yeSA9IGZ1bmN0aW9uIGNyZWF0ZUdhaW5Ob2RlUmVuZGVyZXJGYWN0b3J5KGNvbm5lY3RBdWRpb1BhcmFtLCBjcmVhdGVOYXRpdmVHYWluTm9kZSwgZ2V0TmF0aXZlQXVkaW9Ob2RlLCByZW5kZXJBdXRvbWF0aW9uLCByZW5kZXJJbnB1dHNPZkF1ZGlvTm9kZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlbmRlcmVkTmF0aXZlR2Fpbk5vZGVzID0gbmV3IFdlYWtNYXAoKTtcbiAgICAgICAgdmFyIGNyZWF0ZUdhaW5Ob2RlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgX3JlZiA9IF9hc3luY1RvR2VuZXJhdG9yKC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZShwcm94eSwgbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCkge1xuICAgICAgICAgICAgdmFyIG5hdGl2ZUdhaW5Ob2RlLCBuYXRpdmVHYWluTm9kZUlzT3duZWRCeUNvbnRleHQsIG9wdGlvbnM7XG4gICAgICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICAgICAgICAgIHdoaWxlICgxKSBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgbmF0aXZlR2Fpbk5vZGUgPSBnZXROYXRpdmVBdWRpb05vZGUocHJveHkpOyAvLyBJZiB0aGUgaW5pdGlhbGx5IHVzZWQgbmF0aXZlR2Fpbk5vZGUgd2FzIG5vdCBjb25zdHJ1Y3RlZCBvbiB0aGUgc2FtZSBPZmZsaW5lQXVkaW9Db250ZXh0IGl0IG5lZWRzIHRvIGJlIGNyZWF0ZWQgYWdhaW4uXG4gICAgICAgICAgICAgICAgICBuYXRpdmVHYWluTm9kZUlzT3duZWRCeUNvbnRleHQgPSBpc093bmVkQnlDb250ZXh0KG5hdGl2ZUdhaW5Ob2RlLCBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KTtcbiAgICAgICAgICAgICAgICAgIGlmICghbmF0aXZlR2Fpbk5vZGVJc093bmVkQnlDb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbENvdW50OiBuYXRpdmVHYWluTm9kZS5jaGFubmVsQ291bnQsXG4gICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbENvdW50TW9kZTogbmF0aXZlR2Fpbk5vZGUuY2hhbm5lbENvdW50TW9kZSxcbiAgICAgICAgICAgICAgICAgICAgICBjaGFubmVsSW50ZXJwcmV0YXRpb246IG5hdGl2ZUdhaW5Ob2RlLmNoYW5uZWxJbnRlcnByZXRhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICBnYWluOiBuYXRpdmVHYWluTm9kZS5nYWluLnZhbHVlXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIG5hdGl2ZUdhaW5Ob2RlID0gY3JlYXRlTmF0aXZlR2Fpbk5vZGUobmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICByZW5kZXJlZE5hdGl2ZUdhaW5Ob2Rlcy5zZXQobmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCwgbmF0aXZlR2Fpbk5vZGUpO1xuICAgICAgICAgICAgICAgICAgaWYgKG5hdGl2ZUdhaW5Ob2RlSXNPd25lZEJ5Q29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gOTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNztcbiAgICAgICAgICAgICAgICAgIHJldHVybiByZW5kZXJBdXRvbWF0aW9uKG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQsIHByb3h5LmdhaW4sIG5hdGl2ZUdhaW5Ob2RlLmdhaW4pO1xuICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxMTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxMTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBjb25uZWN0QXVkaW9QYXJhbShuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LCBwcm94eS5nYWluLCBuYXRpdmVHYWluTm9kZS5nYWluKTtcbiAgICAgICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDEzO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlbmRlcklucHV0c09mQXVkaW9Ob2RlKHByb3h5LCBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LCBuYXRpdmVHYWluTm9kZSk7XG4gICAgICAgICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgbmF0aXZlR2Fpbk5vZGUpO1xuICAgICAgICAgICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgX2NhbGxlZSk7XG4gICAgICAgICAgfSkpO1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiBjcmVhdGVHYWluTm9kZShfeCwgX3gyKSB7XG4gICAgICAgICAgICByZXR1cm4gX3JlZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgIH07XG4gICAgICAgIH0oKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihwcm94eSwgbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCkge1xuICAgICAgICAgICAgdmFyIHJlbmRlcmVkTmF0aXZlR2Fpbk5vZGUgPSByZW5kZXJlZE5hdGl2ZUdhaW5Ob2Rlcy5nZXQobmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCk7XG4gICAgICAgICAgICBpZiAocmVuZGVyZWROYXRpdmVHYWluTm9kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVuZGVyZWROYXRpdmVHYWluTm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlR2Fpbk5vZGUocHJveHksIG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVHZXRBY3RpdmVBdWRpb1dvcmtsZXROb2RlSW5wdXRzID0gZnVuY3Rpb24gY3JlYXRlR2V0QWN0aXZlQXVkaW9Xb3JrbGV0Tm9kZUlucHV0cyhhY3RpdmVBdWRpb1dvcmtsZXROb2RlSW5wdXRzU3RvcmUsIGdldFZhbHVlRm9yS2V5KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKG5hdGl2ZUF1ZGlvV29ya2xldE5vZGUpIHtcbiAgICAgICAgcmV0dXJuIGdldFZhbHVlRm9yS2V5KGFjdGl2ZUF1ZGlvV29ya2xldE5vZGVJbnB1dHNTdG9yZSwgbmF0aXZlQXVkaW9Xb3JrbGV0Tm9kZSk7XG4gICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlR2V0QXVkaW9Ob2RlUmVuZGVyZXIgPSBmdW5jdGlvbiBjcmVhdGVHZXRBdWRpb05vZGVSZW5kZXJlcihnZXRBdWRpb05vZGVDb25uZWN0aW9ucykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhdWRpb05vZGUpIHtcbiAgICAgICAgdmFyIGF1ZGlvTm9kZUNvbm5lY3Rpb25zID0gZ2V0QXVkaW9Ob2RlQ29ubmVjdGlvbnMoYXVkaW9Ob2RlKTtcbiAgICAgICAgaWYgKGF1ZGlvTm9kZUNvbm5lY3Rpb25zLnJlbmRlcmVyID09PSBudWxsKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHRoZSByZW5kZXJlciBvZiB0aGUgZ2l2ZW4gQXVkaW9Ob2RlIGluIHRoZSBhdWRpbyBncmFwaC4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXVkaW9Ob2RlQ29ubmVjdGlvbnMucmVuZGVyZXI7XG4gICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlR2V0QXVkaW9Ob2RlVGFpbFRpbWUgPSBmdW5jdGlvbiBjcmVhdGVHZXRBdWRpb05vZGVUYWlsVGltZShhdWRpb05vZGVUYWlsVGltZVN0b3JlKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGF1ZGlvTm9kZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoX2EgPSBhdWRpb05vZGVUYWlsVGltZVN0b3JlLmdldChhdWRpb05vZGUpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwO1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZUdldEF1ZGlvUGFyYW1SZW5kZXJlciA9IGZ1bmN0aW9uIGNyZWF0ZUdldEF1ZGlvUGFyYW1SZW5kZXJlcihnZXRBdWRpb1BhcmFtQ29ubmVjdGlvbnMpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoYXVkaW9QYXJhbSkge1xuICAgICAgICB2YXIgYXVkaW9QYXJhbUNvbm5lY3Rpb25zID0gZ2V0QXVkaW9QYXJhbUNvbm5lY3Rpb25zKGF1ZGlvUGFyYW0pO1xuICAgICAgICBpZiAoYXVkaW9QYXJhbUNvbm5lY3Rpb25zLnJlbmRlcmVyID09PSBudWxsKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHRoZSByZW5kZXJlciBvZiB0aGUgZ2l2ZW4gQXVkaW9QYXJhbSBpbiB0aGUgYXVkaW8gZ3JhcGguJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF1ZGlvUGFyYW1Db25uZWN0aW9ucy5yZW5kZXJlcjtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVHZXRCYWNrdXBPZmZsaW5lQXVkaW9Db250ZXh0ID0gZnVuY3Rpb24gY3JlYXRlR2V0QmFja3VwT2ZmbGluZUF1ZGlvQ29udGV4dChiYWNrdXBPZmZsaW5lQXVkaW9Db250ZXh0U3RvcmUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAobmF0aXZlQ29udGV4dCkge1xuICAgICAgICByZXR1cm4gYmFja3VwT2ZmbGluZUF1ZGlvQ29udGV4dFN0b3JlLmdldChuYXRpdmVDb250ZXh0KTtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVJbnZhbGlkU3RhdGVFcnJvciA9IGZ1bmN0aW9uIGNyZWF0ZUludmFsaWRTdGF0ZUVycm9yKCkge1xuICAgICAgcmV0dXJuIG5ldyBET01FeGNlcHRpb24oJycsICdJbnZhbGlkU3RhdGVFcnJvcicpO1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlR2V0TmF0aXZlQ29udGV4dCA9IGZ1bmN0aW9uIGNyZWF0ZUdldE5hdGl2ZUNvbnRleHQoY29udGV4dFN0b3JlKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgdmFyIG5hdGl2ZUNvbnRleHQgPSBjb250ZXh0U3RvcmUuZ2V0KGNvbnRleHQpO1xuICAgICAgICBpZiAobmF0aXZlQ29udGV4dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhyb3cgY3JlYXRlSW52YWxpZFN0YXRlRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmF0aXZlQ29udGV4dDtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVHZXRPckNyZWF0ZUJhY2t1cE9mZmxpbmVBdWRpb0NvbnRleHQgPSBmdW5jdGlvbiBjcmVhdGVHZXRPckNyZWF0ZUJhY2t1cE9mZmxpbmVBdWRpb0NvbnRleHQoYmFja3VwT2ZmbGluZUF1ZGlvQ29udGV4dFN0b3JlLCBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0Q29uc3RydWN0b3IpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAobmF0aXZlQ29udGV4dCkge1xuICAgICAgICB2YXIgYmFja3VwT2ZmbGluZUF1ZGlvQ29udGV4dCA9IGJhY2t1cE9mZmxpbmVBdWRpb0NvbnRleHRTdG9yZS5nZXQobmF0aXZlQ29udGV4dCk7XG4gICAgICAgIGlmIChiYWNrdXBPZmZsaW5lQXVkaW9Db250ZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gYmFja3VwT2ZmbGluZUF1ZGlvQ29udGV4dDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dENvbnN0cnVjdG9yID09PSBudWxsKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHRoZSBuYXRpdmUgT2ZmbGluZUF1ZGlvQ29udGV4dCBjb25zdHJ1Y3Rvci4nKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBCdWcgIzE0MTogU2FmYXJpIGRvZXMgbm90IHN1cHBvcnQgY3JlYXRpbmcgYW4gT2ZmbGluZUF1ZGlvQ29udGV4dCB3aXRoIGxlc3MgdGhhbiA0NDEwMCBIei5cbiAgICAgICAgYmFja3VwT2ZmbGluZUF1ZGlvQ29udGV4dCA9IG5ldyBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0Q29uc3RydWN0b3IoMSwgMSwgNDQxMDApO1xuICAgICAgICBiYWNrdXBPZmZsaW5lQXVkaW9Db250ZXh0U3RvcmUuc2V0KG5hdGl2ZUNvbnRleHQsIGJhY2t1cE9mZmxpbmVBdWRpb0NvbnRleHQpO1xuICAgICAgICByZXR1cm4gYmFja3VwT2ZmbGluZUF1ZGlvQ29udGV4dDtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVHZXRVbnJlbmRlcmVkQXVkaW9Xb3JrbGV0Tm9kZXMgPSBmdW5jdGlvbiBjcmVhdGVHZXRVbnJlbmRlcmVkQXVkaW9Xb3JrbGV0Tm9kZXModW5yZW5kZXJlZEF1ZGlvV29ya2xldE5vZGVTdG9yZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChuYXRpdmVDb250ZXh0KSB7XG4gICAgICAgIHZhciB1bnJlbmRlcmVkQXVkaW9Xb3JrbGV0Tm9kZXMgPSB1bnJlbmRlcmVkQXVkaW9Xb3JrbGV0Tm9kZVN0b3JlLmdldChuYXRpdmVDb250ZXh0KTtcbiAgICAgICAgaWYgKHVucmVuZGVyZWRBdWRpb1dvcmtsZXROb2RlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgY29udGV4dCBoYXMgbm8gc2V0IG9mIEF1ZGlvV29ya2xldE5vZGVzLicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bnJlbmRlcmVkQXVkaW9Xb3JrbGV0Tm9kZXM7XG4gICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlSW52YWxpZEFjY2Vzc0Vycm9yID0gZnVuY3Rpb24gY3JlYXRlSW52YWxpZEFjY2Vzc0Vycm9yKCkge1xuICAgICAgcmV0dXJuIG5ldyBET01FeGNlcHRpb24oJycsICdJbnZhbGlkQWNjZXNzRXJyb3InKTtcbiAgICB9O1xuXG4gICAgdmFyIHdyYXBJSVJGaWx0ZXJOb2RlR2V0RnJlcXVlbmN5UmVzcG9uc2VNZXRob2QgPSBmdW5jdGlvbiB3cmFwSUlSRmlsdGVyTm9kZUdldEZyZXF1ZW5jeVJlc3BvbnNlTWV0aG9kKG5hdGl2ZUlJUkZpbHRlck5vZGUpIHtcbiAgICAgIG5hdGl2ZUlJUkZpbHRlck5vZGUuZ2V0RnJlcXVlbmN5UmVzcG9uc2UgPSBmdW5jdGlvbiAoZ2V0RnJlcXVlbmN5UmVzcG9uc2UpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChmcmVxdWVuY3lIeiwgbWFnUmVzcG9uc2UsIHBoYXNlUmVzcG9uc2UpIHtcbiAgICAgICAgICBpZiAoZnJlcXVlbmN5SHoubGVuZ3RoICE9PSBtYWdSZXNwb25zZS5sZW5ndGggfHwgbWFnUmVzcG9uc2UubGVuZ3RoICE9PSBwaGFzZVJlc3BvbnNlLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgY3JlYXRlSW52YWxpZEFjY2Vzc0Vycm9yKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBnZXRGcmVxdWVuY3lSZXNwb25zZS5jYWxsKG5hdGl2ZUlJUkZpbHRlck5vZGUsIGZyZXF1ZW5jeUh6LCBtYWdSZXNwb25zZSwgcGhhc2VSZXNwb25zZSk7XG4gICAgICAgIH07XG4gICAgICB9KG5hdGl2ZUlJUkZpbHRlck5vZGUuZ2V0RnJlcXVlbmN5UmVzcG9uc2UpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBvd25LZXlzJGkoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuICAgIGZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkaShlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzJGkoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzJGkoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTsgfSk7IH0gcmV0dXJuIGU7IH1cbiAgICBmdW5jdGlvbiBfY2FsbFN1cGVyJGModCwgbywgZSkgeyByZXR1cm4gbyA9IF9nZXRQcm90b3R5cGVPZihvKSwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odCwgX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRjKCkgPyBSZWZsZWN0LmNvbnN0cnVjdChvLCBlIHx8IFtdLCBfZ2V0UHJvdG90eXBlT2YodCkuY29uc3RydWN0b3IpIDogby5hcHBseSh0LCBlKSk7IH1cbiAgICBmdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JGMoKSB7IHRyeSB7IHZhciB0ID0gIUJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgfSBjYXRjaCAodCkge30gcmV0dXJuIChfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JGMgPSBmdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyByZXR1cm4gISF0OyB9KSgpOyB9XG4gICAgdmFyIERFRkFVTFRfT1BUSU9OUyQ4ID0ge1xuICAgICAgY2hhbm5lbENvdW50OiAyLFxuICAgICAgY2hhbm5lbENvdW50TW9kZTogJ21heCcsXG4gICAgICBjaGFubmVsSW50ZXJwcmV0YXRpb246ICdzcGVha2VycydcbiAgICB9O1xuICAgIHZhciBjcmVhdGVJSVJGaWx0ZXJOb2RlQ29uc3RydWN0b3IgPSBmdW5jdGlvbiBjcmVhdGVJSVJGaWx0ZXJOb2RlQ29uc3RydWN0b3IoYXVkaW9Ob2RlQ29uc3RydWN0b3IsIGNyZWF0ZU5hdGl2ZUlJUkZpbHRlck5vZGUsIGNyZWF0ZUlJUkZpbHRlck5vZGVSZW5kZXJlciwgZ2V0TmF0aXZlQ29udGV4dCwgaXNOYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LCBzZXRBdWRpb05vZGVUYWlsVGltZSkge1xuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX2F1ZGlvTm9kZUNvbnN0cnVjdG9yKSB7XG4gICAgICAgIGZ1bmN0aW9uIElJUkZpbHRlck5vZGUoY29udGV4dCwgb3B0aW9ucykge1xuICAgICAgICAgIHZhciBfdGhpcztcbiAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSUlSRmlsdGVyTm9kZSk7XG4gICAgICAgICAgdmFyIG5hdGl2ZUNvbnRleHQgPSBnZXROYXRpdmVDb250ZXh0KGNvbnRleHQpO1xuICAgICAgICAgIHZhciBpc09mZmxpbmUgPSBpc05hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQobmF0aXZlQ29udGV4dCk7XG4gICAgICAgICAgdmFyIG1lcmdlZE9wdGlvbnMgPSBfb2JqZWN0U3ByZWFkJGkoX29iamVjdFNwcmVhZCRpKHt9LCBERUZBVUxUX09QVElPTlMkOCksIG9wdGlvbnMpO1xuICAgICAgICAgIHZhciBuYXRpdmVJSVJGaWx0ZXJOb2RlID0gY3JlYXRlTmF0aXZlSUlSRmlsdGVyTm9kZShuYXRpdmVDb250ZXh0LCBpc09mZmxpbmUgPyBudWxsIDogY29udGV4dC5iYXNlTGF0ZW5jeSwgbWVyZ2VkT3B0aW9ucyk7XG4gICAgICAgICAgdmFyIGlpckZpbHRlck5vZGVSZW5kZXJlciA9IGlzT2ZmbGluZSA/IGNyZWF0ZUlJUkZpbHRlck5vZGVSZW5kZXJlcihtZXJnZWRPcHRpb25zLmZlZWRiYWNrLCBtZXJnZWRPcHRpb25zLmZlZWRmb3J3YXJkKSA6IG51bGw7XG4gICAgICAgICAgX3RoaXMgPSBfY2FsbFN1cGVyJGModGhpcywgSUlSRmlsdGVyTm9kZSwgW2NvbnRleHQsIGZhbHNlLCBuYXRpdmVJSVJGaWx0ZXJOb2RlLCBpaXJGaWx0ZXJOb2RlUmVuZGVyZXJdKTtcbiAgICAgICAgICAvLyBCdWcgIzIzICYgIzI0OiBGaXJlZm94RGV2ZWxvcGVyIGRvZXMgbm90IHRocm93IGFuIEludmFsaWRBY2Nlc3NFcnJvci5cbiAgICAgICAgICAvLyBAdG9kbyBXcml0ZSBhIHRlc3Qgd2hpY2ggYWxsb3dzIG90aGVyIGJyb3dzZXJzIHRvIHJlbWFpbiB1bnBhdGNoZWQuXG4gICAgICAgICAgd3JhcElJUkZpbHRlck5vZGVHZXRGcmVxdWVuY3lSZXNwb25zZU1ldGhvZChuYXRpdmVJSVJGaWx0ZXJOb2RlKTtcbiAgICAgICAgICBfdGhpcy5fbmF0aXZlSUlSRmlsdGVyTm9kZSA9IG5hdGl2ZUlJUkZpbHRlck5vZGU7XG4gICAgICAgICAgLy8gQHRvZG8gRGV0ZXJtaW5lIGEgbWVhbmluZ2Z1bCB0YWlsLXRpbWUgaW5zdGVhZCBvZiBqdXN0IHVzaW5nIG9uZSBzZWNvbmQuXG4gICAgICAgICAgc2V0QXVkaW9Ob2RlVGFpbFRpbWUoX3RoaXMsIDEpO1xuICAgICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgICAgfVxuICAgICAgICBfaW5oZXJpdHMoSUlSRmlsdGVyTm9kZSwgX2F1ZGlvTm9kZUNvbnN0cnVjdG9yKTtcbiAgICAgICAgcmV0dXJuIF9jcmVhdGVDbGFzcyhJSVJGaWx0ZXJOb2RlLCBbe1xuICAgICAgICAgIGtleTogXCJnZXRGcmVxdWVuY3lSZXNwb25zZVwiLFxuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRGcmVxdWVuY3lSZXNwb25zZShmcmVxdWVuY3lIeiwgbWFnUmVzcG9uc2UsIHBoYXNlUmVzcG9uc2UpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9uYXRpdmVJSVJGaWx0ZXJOb2RlLmdldEZyZXF1ZW5jeVJlc3BvbnNlKGZyZXF1ZW5jeUh6LCBtYWdSZXNwb25zZSwgcGhhc2VSZXNwb25zZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XSk7XG4gICAgICB9KGF1ZGlvTm9kZUNvbnN0cnVjdG9yKTtcbiAgICB9O1xuXG4gICAgLy8gVGhpcyBpbXBsZW1lbnRhdGlvbiBhcyBzaGFtZWxlc3NseSBpbnNwaXJlZCBieSBzb3VyY2UgY29kZSBvZlxuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTptYXgtbGluZS1sZW5ndGhcbiAgICAvLyB7QGxpbmsgaHR0cHM6Ly9jaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYy5naXQvKy9tYXN0ZXIvdGhpcmRfcGFydHkvV2ViS2l0L1NvdXJjZS9wbGF0Zm9ybS9hdWRpby9JSVJGaWx0ZXIuY3BwfENocm9taXVtJ3MgSUlSRmlsdGVyfS5cbiAgICB2YXIgZmlsdGVyQnVmZmVyID0gZnVuY3Rpb24gZmlsdGVyQnVmZmVyKGZlZWRiYWNrLCBmZWVkYmFja0xlbmd0aCwgZmVlZGZvcndhcmQsIGZlZWRmb3J3YXJkTGVuZ3RoLCBtaW5MZW5ndGgsIHhCdWZmZXIsIHlCdWZmZXIsIGJ1ZmZlckluZGV4LCBidWZmZXJMZW5ndGgsIGlucHV0LCBvdXRwdXQpIHtcbiAgICAgIHZhciBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aDtcbiAgICAgIHZhciBpID0gYnVmZmVySW5kZXg7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyBqICs9IDEpIHtcbiAgICAgICAgdmFyIHkgPSBmZWVkZm9yd2FyZFswXSAqIGlucHV0W2pdO1xuICAgICAgICBmb3IgKHZhciBrID0gMTsgayA8IG1pbkxlbmd0aDsgayArPSAxKSB7XG4gICAgICAgICAgdmFyIHggPSBpIC0gayAmIGJ1ZmZlckxlbmd0aCAtIDE7IC8vIHRzbGludDpkaXNhYmxlLWxpbmU6bm8tYml0d2lzZVxuICAgICAgICAgIHkgKz0gZmVlZGZvcndhcmRba10gKiB4QnVmZmVyW3hdO1xuICAgICAgICAgIHkgLT0gZmVlZGJhY2tba10gKiB5QnVmZmVyW3hdO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIF9rID0gbWluTGVuZ3RoOyBfayA8IGZlZWRmb3J3YXJkTGVuZ3RoOyBfayArPSAxKSB7XG4gICAgICAgICAgeSArPSBmZWVkZm9yd2FyZFtfa10gKiB4QnVmZmVyW2kgLSBfayAmIGJ1ZmZlckxlbmd0aCAtIDFdOyAvLyB0c2xpbnQ6ZGlzYWJsZS1saW5lOm5vLWJpdHdpc2VcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBfazIgPSBtaW5MZW5ndGg7IF9rMiA8IGZlZWRiYWNrTGVuZ3RoOyBfazIgKz0gMSkge1xuICAgICAgICAgIHkgLT0gZmVlZGJhY2tbX2syXSAqIHlCdWZmZXJbaSAtIF9rMiAmIGJ1ZmZlckxlbmd0aCAtIDFdOyAvLyB0c2xpbnQ6ZGlzYWJsZS1saW5lOm5vLWJpdHdpc2VcbiAgICAgICAgfVxuICAgICAgICB4QnVmZmVyW2ldID0gaW5wdXRbal07XG4gICAgICAgIHlCdWZmZXJbaV0gPSB5O1xuICAgICAgICBpID0gaSArIDEgJiBidWZmZXJMZW5ndGggLSAxOyAvLyB0c2xpbnQ6ZGlzYWJsZS1saW5lOm5vLWJpdHdpc2VcbiAgICAgICAgb3V0cHV0W2pdID0geTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpO1xuICAgIH07XG5cbiAgICB2YXIgZmlsdGVyRnVsbEJ1ZmZlciA9IGZ1bmN0aW9uIGZpbHRlckZ1bGxCdWZmZXIocmVuZGVyZWRCdWZmZXIsIG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQsIGZlZWRiYWNrLCBmZWVkZm9yd2FyZCkge1xuICAgICAgdmFyIGNvbnZlcnRlZEZlZWRiYWNrID0gZmVlZGJhY2sgaW5zdGFuY2VvZiBGbG9hdDY0QXJyYXkgPyBmZWVkYmFjayA6IG5ldyBGbG9hdDY0QXJyYXkoZmVlZGJhY2spO1xuICAgICAgdmFyIGNvbnZlcnRlZEZlZWRmb3J3YXJkID0gZmVlZGZvcndhcmQgaW5zdGFuY2VvZiBGbG9hdDY0QXJyYXkgPyBmZWVkZm9yd2FyZCA6IG5ldyBGbG9hdDY0QXJyYXkoZmVlZGZvcndhcmQpO1xuICAgICAgdmFyIGZlZWRiYWNrTGVuZ3RoID0gY29udmVydGVkRmVlZGJhY2subGVuZ3RoO1xuICAgICAgdmFyIGZlZWRmb3J3YXJkTGVuZ3RoID0gY29udmVydGVkRmVlZGZvcndhcmQubGVuZ3RoO1xuICAgICAgdmFyIG1pbkxlbmd0aCA9IE1hdGgubWluKGZlZWRiYWNrTGVuZ3RoLCBmZWVkZm9yd2FyZExlbmd0aCk7XG4gICAgICBpZiAoY29udmVydGVkRmVlZGJhY2tbMF0gIT09IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmZWVkYmFja0xlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgY29udmVydGVkRmVlZGZvcndhcmRbaV0gLz0gY29udmVydGVkRmVlZGJhY2tbMF07XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGZlZWRmb3J3YXJkTGVuZ3RoOyBfaSArPSAxKSB7XG4gICAgICAgICAgY29udmVydGVkRmVlZGJhY2tbX2ldIC89IGNvbnZlcnRlZEZlZWRiYWNrWzBdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgYnVmZmVyTGVuZ3RoID0gMzI7XG4gICAgICB2YXIgeEJ1ZmZlciA9IG5ldyBGbG9hdDMyQXJyYXkoYnVmZmVyTGVuZ3RoKTtcbiAgICAgIHZhciB5QnVmZmVyID0gbmV3IEZsb2F0MzJBcnJheShidWZmZXJMZW5ndGgpO1xuICAgICAgdmFyIGZpbHRlcmVkQnVmZmVyID0gbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dC5jcmVhdGVCdWZmZXIocmVuZGVyZWRCdWZmZXIubnVtYmVyT2ZDaGFubmVscywgcmVuZGVyZWRCdWZmZXIubGVuZ3RoLCByZW5kZXJlZEJ1ZmZlci5zYW1wbGVSYXRlKTtcbiAgICAgIHZhciBudW1iZXJPZkNoYW5uZWxzID0gcmVuZGVyZWRCdWZmZXIubnVtYmVyT2ZDaGFubmVscztcbiAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IG51bWJlck9mQ2hhbm5lbHM7IF9pMiArPSAxKSB7XG4gICAgICAgIHZhciBpbnB1dCA9IHJlbmRlcmVkQnVmZmVyLmdldENoYW5uZWxEYXRhKF9pMik7XG4gICAgICAgIHZhciBvdXRwdXQgPSBmaWx0ZXJlZEJ1ZmZlci5nZXRDaGFubmVsRGF0YShfaTIpO1xuICAgICAgICB4QnVmZmVyLmZpbGwoMCk7XG4gICAgICAgIHlCdWZmZXIuZmlsbCgwKTtcbiAgICAgICAgZmlsdGVyQnVmZmVyKGNvbnZlcnRlZEZlZWRiYWNrLCBmZWVkYmFja0xlbmd0aCwgY29udmVydGVkRmVlZGZvcndhcmQsIGZlZWRmb3J3YXJkTGVuZ3RoLCBtaW5MZW5ndGgsIHhCdWZmZXIsIHlCdWZmZXIsIDAsIGJ1ZmZlckxlbmd0aCwgaW5wdXQsIG91dHB1dCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmlsdGVyZWRCdWZmZXI7XG4gICAgfTtcbiAgICB2YXIgY3JlYXRlSUlSRmlsdGVyTm9kZVJlbmRlcmVyRmFjdG9yeSA9IGZ1bmN0aW9uIGNyZWF0ZUlJUkZpbHRlck5vZGVSZW5kZXJlckZhY3RvcnkoY3JlYXRlTmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2RlLCBnZXROYXRpdmVBdWRpb05vZGUsIG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHRDb25zdHJ1Y3RvciwgcmVuZGVySW5wdXRzT2ZBdWRpb05vZGUsIHJlbmRlck5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoZmVlZGJhY2ssIGZlZWRmb3J3YXJkKSB7XG4gICAgICAgIHZhciByZW5kZXJlZE5hdGl2ZUF1ZGlvTm9kZXMgPSBuZXcgV2Vha01hcCgpO1xuICAgICAgICB2YXIgZmlsdGVyZWRCdWZmZXJQcm9taXNlID0gbnVsbDtcbiAgICAgICAgdmFyIGNyZWF0ZUF1ZGlvTm9kZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIF9yZWYgPSBfYXN5bmNUb0dlbmVyYXRvcigvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyKHByb3h5LCBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KSB7XG4gICAgICAgICAgICB2YXIgbmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2RlLCBuYXRpdmVJSVJGaWx0ZXJOb2RlLCBuYXRpdmVJSVJGaWx0ZXJOb2RlSXNPd25lZEJ5Q29udGV4dCwgcGFydGlhbE9mZmxpbmVBdWRpb0NvbnRleHQsIGZpbHRlcmVkQnVmZmVyO1xuICAgICAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlMiQoX2NvbnRleHQyKSB7XG4gICAgICAgICAgICAgIHdoaWxlICgxKSBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICBuYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGUgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgbmF0aXZlSUlSRmlsdGVyTm9kZSA9IGdldE5hdGl2ZUF1ZGlvTm9kZShwcm94eSk7IC8vIElmIHRoZSBpbml0aWFsbHkgdXNlZCBuYXRpdmVJSVJGaWx0ZXJOb2RlIHdhcyBub3QgY29uc3RydWN0ZWQgb24gdGhlIHNhbWUgT2ZmbGluZUF1ZGlvQ29udGV4dCBpdCBuZWVkcyB0byBiZSBjcmVhdGVkIGFnYWluLlxuICAgICAgICAgICAgICAgICAgbmF0aXZlSUlSRmlsdGVyTm9kZUlzT3duZWRCeUNvbnRleHQgPSBpc093bmVkQnlDb250ZXh0KG5hdGl2ZUlJUkZpbHRlck5vZGUsIG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQpOyAvLyBCdWcgIzk6IFNhZmFyaSBkb2VzIG5vdCBzdXBwb3J0IElJUkZpbHRlck5vZGVzLlxuICAgICAgICAgICAgICAgICAgaWYgKG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQuY3JlYXRlSUlSRmlsdGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2RlID0gY3JlYXRlTmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2RlKG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQsIHtcbiAgICAgICAgICAgICAgICAgICAgICBidWZmZXI6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbENvdW50OiAyLFxuICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWxDb3VudE1vZGU6ICdtYXgnLFxuICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWxJbnRlcnByZXRhdGlvbjogJ3NwZWFrZXJzJyxcbiAgICAgICAgICAgICAgICAgICAgICBsb29wOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICBsb29wRW5kOiAwLFxuICAgICAgICAgICAgICAgICAgICAgIGxvb3BTdGFydDogMCxcbiAgICAgICAgICAgICAgICAgICAgICBwbGF5YmFja1JhdGU6IDFcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFuYXRpdmVJSVJGaWx0ZXJOb2RlSXNPd25lZEJ5Q29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBAdG9kbyBUeXBlU2NyaXB0IGRlZmluZXMgdGhlIHBhcmFtZXRlcnMgb2YgY3JlYXRlSUlSRmlsdGVyKCkgYXMgYXJyYXlzIG9mIG51bWJlcnMuXG4gICAgICAgICAgICAgICAgICAgIG5hdGl2ZUlJUkZpbHRlck5vZGUgPSBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LmNyZWF0ZUlJUkZpbHRlcihmZWVkZm9yd2FyZCwgZmVlZGJhY2spO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgcmVuZGVyZWROYXRpdmVBdWRpb05vZGVzLnNldChuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LCBuYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGUgPT09IG51bGwgPyBuYXRpdmVJSVJGaWx0ZXJOb2RlIDogbmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2RlKTtcbiAgICAgICAgICAgICAgICAgIGlmICghKG5hdGl2ZUF1ZGlvQnVmZmVyU291cmNlTm9kZSAhPT0gbnVsbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAxNztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAoIShmaWx0ZXJlZEJ1ZmZlclByb21pc2UgPT09IG51bGwpKSB7XG4gICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTE7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKCEobmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dENvbnN0cnVjdG9yID09PSBudWxsKSkge1xuICAgICAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHRoZSBuYXRpdmUgT2ZmbGluZUF1ZGlvQ29udGV4dCBjb25zdHJ1Y3Rvci4nKTtcbiAgICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgICBwYXJ0aWFsT2ZmbGluZUF1ZGlvQ29udGV4dCA9IG5ldyBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0Q29uc3RydWN0b3IoXG4gICAgICAgICAgICAgICAgICAvLyBCdWcgIzQ3OiBUaGUgQXVkaW9EZXN0aW5hdGlvbk5vZGUgaW4gU2FmYXJpIGdldHMgbm90IGluaXRpYWxpemVkIGNvcnJlY3RseS5cbiAgICAgICAgICAgICAgICAgIHByb3h5LmNvbnRleHQuZGVzdGluYXRpb24uY2hhbm5lbENvdW50LFxuICAgICAgICAgICAgICAgICAgLy8gQnVnICMxNzogU2FmYXJpIGRvZXMgbm90IHlldCBleHBvc2UgdGhlIGxlbmd0aC5cbiAgICAgICAgICAgICAgICAgIHByb3h5LmNvbnRleHQubGVuZ3RoLCBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LnNhbXBsZVJhdGUpO1xuICAgICAgICAgICAgICAgICAgZmlsdGVyZWRCdWZmZXJQcm9taXNlID0gX2FzeW5jVG9HZW5lcmF0b3IoLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVuZGVyZWRCdWZmZXI7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoMSkgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlbmRlcklucHV0c09mQXVkaW9Ob2RlKHByb3h5LCBwYXJ0aWFsT2ZmbGluZUF1ZGlvQ29udGV4dCwgcGFydGlhbE9mZmxpbmVBdWRpb0NvbnRleHQuZGVzdGluYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlbmRlck5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQocGFydGlhbE9mZmxpbmVBdWRpb0NvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJlZEJ1ZmZlciA9IF9jb250ZXh0LnNlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgZmlsdGVyRnVsbEJ1ZmZlcihyZW5kZXJlZEJ1ZmZlciwgbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCwgZmVlZGJhY2ssIGZlZWRmb3J3YXJkKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCBfY2FsbGVlKTtcbiAgICAgICAgICAgICAgICAgIH0pKSgpO1xuICAgICAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDEzO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpbHRlcmVkQnVmZmVyUHJvbWlzZTtcbiAgICAgICAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgICAgICAgZmlsdGVyZWRCdWZmZXIgPSBfY29udGV4dDIuc2VudDtcbiAgICAgICAgICAgICAgICAgIG5hdGl2ZUF1ZGlvQnVmZmVyU291cmNlTm9kZS5idWZmZXIgPSBmaWx0ZXJlZEJ1ZmZlcjtcbiAgICAgICAgICAgICAgICAgIG5hdGl2ZUF1ZGlvQnVmZmVyU291cmNlTm9kZS5zdGFydCgwKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsIG5hdGl2ZUF1ZGlvQnVmZmVyU291cmNlTm9kZSk7XG4gICAgICAgICAgICAgICAgY2FzZSAxNzpcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcmVuZGVySW5wdXRzT2ZBdWRpb05vZGUocHJveHksIG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQsIG5hdGl2ZUlJUkZpbHRlck5vZGUpO1xuICAgICAgICAgICAgICAgIGNhc2UgMTk6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCBuYXRpdmVJSVJGaWx0ZXJOb2RlKTtcbiAgICAgICAgICAgICAgICBjYXNlIDIwOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBfY2FsbGVlMik7XG4gICAgICAgICAgfSkpO1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiBjcmVhdGVBdWRpb05vZGUoX3gsIF94Mikge1xuICAgICAgICAgICAgcmV0dXJuIF9yZWYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9KCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIocHJveHksIG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciByZW5kZXJlZE5hdGl2ZUF1ZGlvTm9kZSA9IHJlbmRlcmVkTmF0aXZlQXVkaW9Ob2Rlcy5nZXQobmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCk7XG4gICAgICAgICAgICBpZiAocmVuZGVyZWROYXRpdmVBdWRpb05vZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlbmRlcmVkTmF0aXZlQXVkaW9Ob2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVBdWRpb05vZGUocHJveHksIG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDIociwgZSkgeyB2YXIgdCA9IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIFN5bWJvbCAmJiByW1N5bWJvbC5pdGVyYXRvcl0gfHwgcltcIkBAaXRlcmF0b3JcIl07IGlmICghdCkgeyBpZiAoQXJyYXkuaXNBcnJheShyKSB8fCAodCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSQyKHIpKSB8fCBlKSB7IHQgJiYgKHIgPSB0KTsgdmFyIF9uID0gMCwgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgcmV0dXJuIF9uID49IHIubGVuZ3RoID8geyBkb25lOiAhMCB9IDogeyBkb25lOiAhMSwgdmFsdWU6IHJbX24rK10gfTsgfSwgZTogZnVuY3Rpb24gZShyKSB7IHRocm93IHI7IH0sIGY6IEYgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH0gdmFyIG8sIGEgPSAhMCwgdSA9ICExOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyB0ID0gdC5jYWxsKHIpOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgciA9IHQubmV4dCgpOyByZXR1cm4gYSA9IHIuZG9uZSwgcjsgfSwgZTogZnVuY3Rpb24gZShyKSB7IHUgPSAhMCwgbyA9IHI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGEgfHwgbnVsbCA9PSB0W1wicmV0dXJuXCJdIHx8IHRbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKHUpIHRocm93IG87IH0gfSB9OyB9XG4gICAgZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5JDIociwgYSkgeyBpZiAocikgeyBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgcikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5JDIociwgYSk7IHZhciB0ID0ge30udG9TdHJpbmcuY2FsbChyKS5zbGljZSg4LCAtMSk7IHJldHVybiBcIk9iamVjdFwiID09PSB0ICYmIHIuY29uc3RydWN0b3IgJiYgKHQgPSByLmNvbnN0cnVjdG9yLm5hbWUpLCBcIk1hcFwiID09PSB0IHx8IFwiU2V0XCIgPT09IHQgPyBBcnJheS5mcm9tKHIpIDogXCJBcmd1bWVudHNcIiA9PT0gdCB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdCh0KSA/IF9hcnJheUxpa2VUb0FycmF5JDIociwgYSkgOiB2b2lkIDA7IH0gfVxuICAgIGZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5JDIociwgYSkgeyAobnVsbCA9PSBhIHx8IGEgPiByLmxlbmd0aCkgJiYgKGEgPSByLmxlbmd0aCk7IGZvciAodmFyIGUgPSAwLCBuID0gQXJyYXkoYSk7IGUgPCBhOyBlKyspIG5bZV0gPSByW2VdOyByZXR1cm4gbjsgfVxuICAgIHZhciBjcmVhdGVJbmNyZW1lbnRDeWNsZUNvdW50ZXJGYWN0b3J5ID0gZnVuY3Rpb24gY3JlYXRlSW5jcmVtZW50Q3ljbGVDb3VudGVyRmFjdG9yeShjeWNsZUNvdW50ZXJzLCBkaXNjb25uZWN0TmF0aXZlQXVkaW9Ob2RlRnJvbU5hdGl2ZUF1ZGlvTm9kZSwgZ2V0QXVkaW9Ob2RlQ29ubmVjdGlvbnMsIGdldE5hdGl2ZUF1ZGlvTm9kZSwgZ2V0TmF0aXZlQXVkaW9QYXJhbSwgaXNBY3RpdmVBdWRpb05vZGUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoaXNPZmZsaW5lKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoYXVkaW9Ob2RlLCBjb3VudCkge1xuICAgICAgICAgIHZhciBjeWNsZUNvdW50ZXIgPSBjeWNsZUNvdW50ZXJzLmdldChhdWRpb05vZGUpO1xuICAgICAgICAgIGlmIChjeWNsZUNvdW50ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKCFpc09mZmxpbmUgJiYgaXNBY3RpdmVBdWRpb05vZGUoYXVkaW9Ob2RlKSkge1xuICAgICAgICAgICAgICB2YXIgbmF0aXZlU291cmNlQXVkaW9Ob2RlID0gZ2V0TmF0aXZlQXVkaW9Ob2RlKGF1ZGlvTm9kZSk7XG4gICAgICAgICAgICAgIHZhciBfZ2V0QXVkaW9Ob2RlQ29ubmVjdGkgPSBnZXRBdWRpb05vZGVDb25uZWN0aW9ucyhhdWRpb05vZGUpLFxuICAgICAgICAgICAgICAgIG91dHB1dHMgPSBfZ2V0QXVkaW9Ob2RlQ29ubmVjdGkub3V0cHV0cztcbiAgICAgICAgICAgICAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDIob3V0cHV0cyksXG4gICAgICAgICAgICAgICAgX3N0ZXA7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICAgICAgICAgIHZhciBvdXRwdXQgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgIGlmIChpc0F1ZGlvTm9kZU91dHB1dENvbm5lY3Rpb24ob3V0cHV0KSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmF0aXZlRGVzdGluYXRpb25BdWRpb05vZGUgPSBnZXROYXRpdmVBdWRpb05vZGUob3V0cHV0WzBdKTtcbiAgICAgICAgICAgICAgICAgICAgZGlzY29ubmVjdE5hdGl2ZUF1ZGlvTm9kZUZyb21OYXRpdmVBdWRpb05vZGUobmF0aXZlU291cmNlQXVkaW9Ob2RlLCBuYXRpdmVEZXN0aW5hdGlvbkF1ZGlvTm9kZSwgb3V0cHV0WzFdLCBvdXRwdXRbMl0pO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5hdGl2ZURlc3RpbmF0aW9uQXVkaW9QYXJhbSA9IGdldE5hdGl2ZUF1ZGlvUGFyYW0ob3V0cHV0WzBdKTtcbiAgICAgICAgICAgICAgICAgICAgbmF0aXZlU291cmNlQXVkaW9Ob2RlLmRpc2Nvbm5lY3QobmF0aXZlRGVzdGluYXRpb25BdWRpb1BhcmFtLCBvdXRwdXRbMV0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICBfaXRlcmF0b3IuZigpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjeWNsZUNvdW50ZXJzLnNldChhdWRpb05vZGUsIGNvdW50KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3ljbGVDb3VudGVycy5zZXQoYXVkaW9Ob2RlLCBjeWNsZUNvdW50ZXIgKyBjb3VudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZUlzQW55QXVkaW9Db250ZXh0ID0gZnVuY3Rpb24gY3JlYXRlSXNBbnlBdWRpb0NvbnRleHQoY29udGV4dFN0b3JlLCBpc05hdGl2ZUF1ZGlvQ29udGV4dCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhbnl0aGluZykge1xuICAgICAgICB2YXIgbmF0aXZlQ29udGV4dCA9IGNvbnRleHRTdG9yZS5nZXQoYW55dGhpbmcpO1xuICAgICAgICByZXR1cm4gaXNOYXRpdmVBdWRpb0NvbnRleHQobmF0aXZlQ29udGV4dCkgfHwgaXNOYXRpdmVBdWRpb0NvbnRleHQoYW55dGhpbmcpO1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZUlzQW55QXVkaW9Ob2RlID0gZnVuY3Rpb24gY3JlYXRlSXNBbnlBdWRpb05vZGUoYXVkaW9Ob2RlU3RvcmUsIGlzTmF0aXZlQXVkaW9Ob2RlKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGFueXRoaW5nKSB7XG4gICAgICAgIHJldHVybiBhdWRpb05vZGVTdG9yZS5oYXMoYW55dGhpbmcpIHx8IGlzTmF0aXZlQXVkaW9Ob2RlKGFueXRoaW5nKTtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVJc0FueUF1ZGlvUGFyYW0gPSBmdW5jdGlvbiBjcmVhdGVJc0FueUF1ZGlvUGFyYW0oYXVkaW9QYXJhbVN0b3JlLCBpc05hdGl2ZUF1ZGlvUGFyYW0pIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoYW55dGhpbmcpIHtcbiAgICAgICAgcmV0dXJuIGF1ZGlvUGFyYW1TdG9yZS5oYXMoYW55dGhpbmcpIHx8IGlzTmF0aXZlQXVkaW9QYXJhbShhbnl0aGluZyk7XG4gICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlSXNBbnlPZmZsaW5lQXVkaW9Db250ZXh0ID0gZnVuY3Rpb24gY3JlYXRlSXNBbnlPZmZsaW5lQXVkaW9Db250ZXh0KGNvbnRleHRTdG9yZSwgaXNOYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGFueXRoaW5nKSB7XG4gICAgICAgIHZhciBuYXRpdmVDb250ZXh0ID0gY29udGV4dFN0b3JlLmdldChhbnl0aGluZyk7XG4gICAgICAgIHJldHVybiBpc05hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQobmF0aXZlQ29udGV4dCkgfHwgaXNOYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KGFueXRoaW5nKTtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVJc05hdGl2ZUF1ZGlvQ29udGV4dCA9IGZ1bmN0aW9uIGNyZWF0ZUlzTmF0aXZlQXVkaW9Db250ZXh0KG5hdGl2ZUF1ZGlvQ29udGV4dENvbnN0cnVjdG9yKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGFueXRoaW5nKSB7XG4gICAgICAgIHJldHVybiBuYXRpdmVBdWRpb0NvbnRleHRDb25zdHJ1Y3RvciAhPT0gbnVsbCAmJiBhbnl0aGluZyBpbnN0YW5jZW9mIG5hdGl2ZUF1ZGlvQ29udGV4dENvbnN0cnVjdG9yO1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZUlzTmF0aXZlQXVkaW9Ob2RlID0gZnVuY3Rpb24gY3JlYXRlSXNOYXRpdmVBdWRpb05vZGUod2luZG93KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGFueXRoaW5nKSB7XG4gICAgICAgIHJldHVybiB3aW5kb3cgIT09IG51bGwgJiYgdHlwZW9mIHdpbmRvdy5BdWRpb05vZGUgPT09ICdmdW5jdGlvbicgJiYgYW55dGhpbmcgaW5zdGFuY2VvZiB3aW5kb3cuQXVkaW9Ob2RlO1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZUlzTmF0aXZlQXVkaW9QYXJhbSA9IGZ1bmN0aW9uIGNyZWF0ZUlzTmF0aXZlQXVkaW9QYXJhbSh3aW5kb3cpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoYW55dGhpbmcpIHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdyAhPT0gbnVsbCAmJiB0eXBlb2Ygd2luZG93LkF1ZGlvUGFyYW0gPT09ICdmdW5jdGlvbicgJiYgYW55dGhpbmcgaW5zdGFuY2VvZiB3aW5kb3cuQXVkaW9QYXJhbTtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVJc05hdGl2ZUNvbnRleHQgPSBmdW5jdGlvbiBjcmVhdGVJc05hdGl2ZUNvbnRleHQoaXNOYXRpdmVBdWRpb0NvbnRleHQsIGlzTmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhbnl0aGluZykge1xuICAgICAgICByZXR1cm4gaXNOYXRpdmVBdWRpb0NvbnRleHQoYW55dGhpbmcpIHx8IGlzTmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dChhbnl0aGluZyk7XG4gICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlSXNOYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0ID0gZnVuY3Rpb24gY3JlYXRlSXNOYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHRDb25zdHJ1Y3Rvcikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhbnl0aGluZykge1xuICAgICAgICByZXR1cm4gbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dENvbnN0cnVjdG9yICE9PSBudWxsICYmIGFueXRoaW5nIGluc3RhbmNlb2YgbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dENvbnN0cnVjdG9yO1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZUlzU2VjdXJlQ29udGV4dCA9IGZ1bmN0aW9uIGNyZWF0ZUlzU2VjdXJlQ29udGV4dCh3aW5kb3cpIHtcbiAgICAgIHJldHVybiB3aW5kb3cgIT09IG51bGwgJiYgd2luZG93LmlzU2VjdXJlQ29udGV4dDtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZUlzU3VwcG9ydGVkUHJvbWlzZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3JlZiA9IF9hc3luY1RvR2VuZXJhdG9yKC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZShjYWNoZVRlc3RSZXN1bHQsIHRlc3RBdWRpb0J1ZmZlckNvcHlDaGFubmVsTWV0aG9kc1N1YmFycmF5U3VwcG9ydCwgdGVzdEF1ZGlvQ29udGV4dENsb3NlTWV0aG9kU3VwcG9ydCwgdGVzdEF1ZGlvQ29udGV4dERlY29kZUF1ZGlvRGF0YU1ldGhvZFR5cGVFcnJvclN1cHBvcnQsIHRlc3RBdWRpb0NvbnRleHRPcHRpb25zU3VwcG9ydCwgdGVzdEF1ZGlvTm9kZUNvbm5lY3RNZXRob2RTdXBwb3J0LCB0ZXN0QXVkaW9Xb3JrbGV0UHJvY2Vzc29yTm9PdXRwdXRzU3VwcG9ydCwgdGVzdENoYW5uZWxNZXJnZXJOb2RlQ2hhbm5lbENvdW50U3VwcG9ydCwgdGVzdENvbnN0YW50U291cmNlTm9kZUFjY3VyYXRlU2NoZWR1bGluZ1N1cHBvcnQsIHRlc3RDb252b2x2ZXJOb2RlQnVmZmVyUmVhc3NpZ25hYmlsaXR5U3VwcG9ydCwgdGVzdENvbnZvbHZlck5vZGVDaGFubmVsQ291bnRTdXBwb3J0LCB0ZXN0RG9tRXhjZXB0aW9uQ29udHJ1Y29yU3VwcG9ydCwgdGVzdElzU2VjdXJlQ29udGV4dFN1cHBvcnQsIHRlc3RNZWRpYVN0cmVhbUF1ZGlvU291cmNlTm9kZU1lZGlhU3RyZWFtV2l0aG91dEF1ZGlvVHJhY2tTdXBwb3J0LCB0ZXN0U3RlcmVvUGFubmVyTm9kZURlZmF1bHRWYWx1ZVN1cHBvcnQsIHRlc3RUcmFuc2ZlcmFibGVzU3VwcG9ydCkge1xuICAgICAgICB2YXIgcmVzdWx0cztcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgICAgIHdoaWxlICgxKSBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIGlmICghKGNhY2hlVGVzdFJlc3VsdCh0ZXN0QXVkaW9CdWZmZXJDb3B5Q2hhbm5lbE1ldGhvZHNTdWJhcnJheVN1cHBvcnQsIHRlc3RBdWRpb0J1ZmZlckNvcHlDaGFubmVsTWV0aG9kc1N1YmFycmF5U3VwcG9ydCkgJiYgY2FjaGVUZXN0UmVzdWx0KHRlc3RBdWRpb0NvbnRleHRDbG9zZU1ldGhvZFN1cHBvcnQsIHRlc3RBdWRpb0NvbnRleHRDbG9zZU1ldGhvZFN1cHBvcnQpICYmIGNhY2hlVGVzdFJlc3VsdCh0ZXN0QXVkaW9Db250ZXh0T3B0aW9uc1N1cHBvcnQsIHRlc3RBdWRpb0NvbnRleHRPcHRpb25zU3VwcG9ydCkgJiYgY2FjaGVUZXN0UmVzdWx0KHRlc3RBdWRpb05vZGVDb25uZWN0TWV0aG9kU3VwcG9ydCwgdGVzdEF1ZGlvTm9kZUNvbm5lY3RNZXRob2RTdXBwb3J0KSAmJiBjYWNoZVRlc3RSZXN1bHQodGVzdENoYW5uZWxNZXJnZXJOb2RlQ2hhbm5lbENvdW50U3VwcG9ydCwgdGVzdENoYW5uZWxNZXJnZXJOb2RlQ2hhbm5lbENvdW50U3VwcG9ydCkgJiYgY2FjaGVUZXN0UmVzdWx0KHRlc3RDb25zdGFudFNvdXJjZU5vZGVBY2N1cmF0ZVNjaGVkdWxpbmdTdXBwb3J0LCB0ZXN0Q29uc3RhbnRTb3VyY2VOb2RlQWNjdXJhdGVTY2hlZHVsaW5nU3VwcG9ydCkgJiYgY2FjaGVUZXN0UmVzdWx0KHRlc3RDb252b2x2ZXJOb2RlQnVmZmVyUmVhc3NpZ25hYmlsaXR5U3VwcG9ydCwgdGVzdENvbnZvbHZlck5vZGVCdWZmZXJSZWFzc2lnbmFiaWxpdHlTdXBwb3J0KSAmJiBjYWNoZVRlc3RSZXN1bHQodGVzdENvbnZvbHZlck5vZGVDaGFubmVsQ291bnRTdXBwb3J0LCB0ZXN0Q29udm9sdmVyTm9kZUNoYW5uZWxDb3VudFN1cHBvcnQpICYmIGNhY2hlVGVzdFJlc3VsdCh0ZXN0RG9tRXhjZXB0aW9uQ29udHJ1Y29yU3VwcG9ydCwgdGVzdERvbUV4Y2VwdGlvbkNvbnRydWNvclN1cHBvcnQpICYmIGNhY2hlVGVzdFJlc3VsdCh0ZXN0SXNTZWN1cmVDb250ZXh0U3VwcG9ydCwgdGVzdElzU2VjdXJlQ29udGV4dFN1cHBvcnQpICYmIGNhY2hlVGVzdFJlc3VsdCh0ZXN0TWVkaWFTdHJlYW1BdWRpb1NvdXJjZU5vZGVNZWRpYVN0cmVhbVdpdGhvdXRBdWRpb1RyYWNrU3VwcG9ydCwgdGVzdE1lZGlhU3RyZWFtQXVkaW9Tb3VyY2VOb2RlTWVkaWFTdHJlYW1XaXRob3V0QXVkaW9UcmFja1N1cHBvcnQpKSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA1O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAzO1xuICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoW2NhY2hlVGVzdFJlc3VsdCh0ZXN0QXVkaW9Db250ZXh0RGVjb2RlQXVkaW9EYXRhTWV0aG9kVHlwZUVycm9yU3VwcG9ydCwgdGVzdEF1ZGlvQ29udGV4dERlY29kZUF1ZGlvRGF0YU1ldGhvZFR5cGVFcnJvclN1cHBvcnQpLCBjYWNoZVRlc3RSZXN1bHQodGVzdEF1ZGlvV29ya2xldFByb2Nlc3Nvck5vT3V0cHV0c1N1cHBvcnQsIHRlc3RBdWRpb1dvcmtsZXRQcm9jZXNzb3JOb091dHB1dHNTdXBwb3J0KSwgY2FjaGVUZXN0UmVzdWx0KHRlc3RTdGVyZW9QYW5uZXJOb2RlRGVmYXVsdFZhbHVlU3VwcG9ydCwgdGVzdFN0ZXJlb1Bhbm5lck5vZGVEZWZhdWx0VmFsdWVTdXBwb3J0KSwgY2FjaGVUZXN0UmVzdWx0KHRlc3RUcmFuc2ZlcmFibGVzU3VwcG9ydCwgdGVzdFRyYW5zZmVyYWJsZXNTdXBwb3J0KV0pO1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICByZXN1bHRzID0gX2NvbnRleHQuc2VudDtcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCByZXN1bHRzLmV2ZXJ5KGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgZmFsc2UpO1xuICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZSk7XG4gICAgICB9KSk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlSXNTdXBwb3J0ZWRQcm9taXNlKF94LCBfeDIsIF94MywgX3g0LCBfeDUsIF94NiwgX3g3LCBfeDgsIF94OSwgX3gxMCwgX3gxMSwgX3gxMiwgX3gxMywgX3gxNCwgX3gxNSwgX3gxNikge1xuICAgICAgICByZXR1cm4gX3JlZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICB9KCk7XG5cbiAgICBmdW5jdGlvbiBfY2FsbFN1cGVyJGIodCwgbywgZSkgeyByZXR1cm4gbyA9IF9nZXRQcm90b3R5cGVPZihvKSwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odCwgX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRiKCkgPyBSZWZsZWN0LmNvbnN0cnVjdChvLCBlIHx8IFtdLCBfZ2V0UHJvdG90eXBlT2YodCkuY29uc3RydWN0b3IpIDogby5hcHBseSh0LCBlKSk7IH1cbiAgICBmdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JGIoKSB7IHRyeSB7IHZhciB0ID0gIUJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgfSBjYXRjaCAodCkge30gcmV0dXJuIChfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JGIgPSBmdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyByZXR1cm4gISF0OyB9KSgpOyB9XG4gICAgdmFyIGNyZWF0ZU1lZGlhRWxlbWVudEF1ZGlvU291cmNlTm9kZUNvbnN0cnVjdG9yID0gZnVuY3Rpb24gY3JlYXRlTWVkaWFFbGVtZW50QXVkaW9Tb3VyY2VOb2RlQ29uc3RydWN0b3IoYXVkaW9Ob2RlQ29uc3RydWN0b3IsIGNyZWF0ZU5hdGl2ZU1lZGlhRWxlbWVudEF1ZGlvU291cmNlTm9kZSwgZ2V0TmF0aXZlQ29udGV4dCwgaXNOYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KSB7XG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfYXVkaW9Ob2RlQ29uc3RydWN0b3IpIHtcbiAgICAgICAgZnVuY3Rpb24gTWVkaWFFbGVtZW50QXVkaW9Tb3VyY2VOb2RlKGNvbnRleHQsIG9wdGlvbnMpIHtcbiAgICAgICAgICB2YXIgX3RoaXM7XG4gICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1lZGlhRWxlbWVudEF1ZGlvU291cmNlTm9kZSk7XG4gICAgICAgICAgdmFyIG5hdGl2ZUNvbnRleHQgPSBnZXROYXRpdmVDb250ZXh0KGNvbnRleHQpO1xuICAgICAgICAgIHZhciBuYXRpdmVNZWRpYUVsZW1lbnRBdWRpb1NvdXJjZU5vZGUgPSBjcmVhdGVOYXRpdmVNZWRpYUVsZW1lbnRBdWRpb1NvdXJjZU5vZGUobmF0aXZlQ29udGV4dCwgb3B0aW9ucyk7XG4gICAgICAgICAgLy8gQnVnICMxNzE6IFNhZmFyaSBhbGxvd3MgdG8gY3JlYXRlIGEgTWVkaWFFbGVtZW50QXVkaW9Tb3VyY2VOb2RlIHdpdGggYW4gT2ZmbGluZUF1ZGlvQ29udGV4dC5cbiAgICAgICAgICBpZiAoaXNOYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KG5hdGl2ZUNvbnRleHQpKSB7XG4gICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgX3RoaXMgPSBfY2FsbFN1cGVyJGIodGhpcywgTWVkaWFFbGVtZW50QXVkaW9Tb3VyY2VOb2RlLCBbY29udGV4dCwgdHJ1ZSwgbmF0aXZlTWVkaWFFbGVtZW50QXVkaW9Tb3VyY2VOb2RlLCBudWxsXSk7XG4gICAgICAgICAgX3RoaXMuX25hdGl2ZU1lZGlhRWxlbWVudEF1ZGlvU291cmNlTm9kZSA9IG5hdGl2ZU1lZGlhRWxlbWVudEF1ZGlvU291cmNlTm9kZTtcbiAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgIH1cbiAgICAgICAgX2luaGVyaXRzKE1lZGlhRWxlbWVudEF1ZGlvU291cmNlTm9kZSwgX2F1ZGlvTm9kZUNvbnN0cnVjdG9yKTtcbiAgICAgICAgcmV0dXJuIF9jcmVhdGVDbGFzcyhNZWRpYUVsZW1lbnRBdWRpb1NvdXJjZU5vZGUsIFt7XG4gICAgICAgICAga2V5OiBcIm1lZGlhRWxlbWVudFwiLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25hdGl2ZU1lZGlhRWxlbWVudEF1ZGlvU291cmNlTm9kZS5tZWRpYUVsZW1lbnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XSk7XG4gICAgICB9KGF1ZGlvTm9kZUNvbnN0cnVjdG9yKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gb3duS2V5cyRoKGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cbiAgICBmdW5jdGlvbiBfb2JqZWN0U3ByZWFkJGgoZSkgeyBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykgeyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gb3duS2V5cyRoKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyRoKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XG4gICAgZnVuY3Rpb24gX2NhbGxTdXBlciRhKHQsIG8sIGUpIHsgcmV0dXJuIG8gPSBfZ2V0UHJvdG90eXBlT2YobyksIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHQsIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkYSgpID8gUmVmbGVjdC5jb25zdHJ1Y3QobywgZSB8fCBbXSwgX2dldFByb3RvdHlwZU9mKHQpLmNvbnN0cnVjdG9yKSA6IG8uYXBwbHkodCwgZSkpOyB9XG4gICAgZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRhKCkgeyB0cnkgeyB2YXIgdCA9ICFCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IH0gY2F0Y2ggKHQpIHt9IHJldHVybiAoX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRhID0gZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgcmV0dXJuICEhdDsgfSkoKTsgfVxuICAgIHZhciBERUZBVUxUX09QVElPTlMkNyA9IHtcbiAgICAgIGNoYW5uZWxDb3VudDogMixcbiAgICAgIGNoYW5uZWxDb3VudE1vZGU6ICdleHBsaWNpdCcsXG4gICAgICBjaGFubmVsSW50ZXJwcmV0YXRpb246ICdzcGVha2VycydcbiAgICB9O1xuICAgIHZhciBjcmVhdGVNZWRpYVN0cmVhbUF1ZGlvRGVzdGluYXRpb25Ob2RlQ29uc3RydWN0b3IgPSBmdW5jdGlvbiBjcmVhdGVNZWRpYVN0cmVhbUF1ZGlvRGVzdGluYXRpb25Ob2RlQ29uc3RydWN0b3IoYXVkaW9Ob2RlQ29uc3RydWN0b3IsIGNyZWF0ZU5hdGl2ZU1lZGlhU3RyZWFtQXVkaW9EZXN0aW5hdGlvbk5vZGUsIGdldE5hdGl2ZUNvbnRleHQsIGlzTmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCkge1xuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX2F1ZGlvTm9kZUNvbnN0cnVjdG9yKSB7XG4gICAgICAgIGZ1bmN0aW9uIE1lZGlhU3RyZWFtQXVkaW9EZXN0aW5hdGlvbk5vZGUoY29udGV4dCwgb3B0aW9ucykge1xuICAgICAgICAgIHZhciBfdGhpcztcbiAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTWVkaWFTdHJlYW1BdWRpb0Rlc3RpbmF0aW9uTm9kZSk7XG4gICAgICAgICAgdmFyIG5hdGl2ZUNvbnRleHQgPSBnZXROYXRpdmVDb250ZXh0KGNvbnRleHQpO1xuICAgICAgICAgIC8vIEJ1ZyAjMTczOiBTYWZhcmkgYWxsb3dzIHRvIGNyZWF0ZSBhIE1lZGlhU3RyZWFtQXVkaW9EZXN0aW5hdGlvbk5vZGUgd2l0aCBhbiBPZmZsaW5lQXVkaW9Db250ZXh0LlxuICAgICAgICAgIGlmIChpc05hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQobmF0aXZlQ29udGV4dCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIG1lcmdlZE9wdGlvbnMgPSBfb2JqZWN0U3ByZWFkJGgoX29iamVjdFNwcmVhZCRoKHt9LCBERUZBVUxUX09QVElPTlMkNyksIG9wdGlvbnMpO1xuICAgICAgICAgIHZhciBuYXRpdmVNZWRpYVN0cmVhbUF1ZGlvRGVzdGluYXRpb25Ob2RlID0gY3JlYXRlTmF0aXZlTWVkaWFTdHJlYW1BdWRpb0Rlc3RpbmF0aW9uTm9kZShuYXRpdmVDb250ZXh0LCBtZXJnZWRPcHRpb25zKTtcbiAgICAgICAgICBfdGhpcyA9IF9jYWxsU3VwZXIkYSh0aGlzLCBNZWRpYVN0cmVhbUF1ZGlvRGVzdGluYXRpb25Ob2RlLCBbY29udGV4dCwgZmFsc2UsIG5hdGl2ZU1lZGlhU3RyZWFtQXVkaW9EZXN0aW5hdGlvbk5vZGUsIG51bGxdKTtcbiAgICAgICAgICBfdGhpcy5fbmF0aXZlTWVkaWFTdHJlYW1BdWRpb0Rlc3RpbmF0aW9uTm9kZSA9IG5hdGl2ZU1lZGlhU3RyZWFtQXVkaW9EZXN0aW5hdGlvbk5vZGU7XG4gICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICB9XG4gICAgICAgIF9pbmhlcml0cyhNZWRpYVN0cmVhbUF1ZGlvRGVzdGluYXRpb25Ob2RlLCBfYXVkaW9Ob2RlQ29uc3RydWN0b3IpO1xuICAgICAgICByZXR1cm4gX2NyZWF0ZUNsYXNzKE1lZGlhU3RyZWFtQXVkaW9EZXN0aW5hdGlvbk5vZGUsIFt7XG4gICAgICAgICAga2V5OiBcInN0cmVhbVwiLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25hdGl2ZU1lZGlhU3RyZWFtQXVkaW9EZXN0aW5hdGlvbk5vZGUuc3RyZWFtO1xuICAgICAgICAgIH1cbiAgICAgICAgfV0pO1xuICAgICAgfShhdWRpb05vZGVDb25zdHJ1Y3Rvcik7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIF9jYWxsU3VwZXIkOSh0LCBvLCBlKSB7IHJldHVybiBvID0gX2dldFByb3RvdHlwZU9mKG8pLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0LCBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JDkoKSA/IFJlZmxlY3QuY29uc3RydWN0KG8sIGUgfHwgW10sIF9nZXRQcm90b3R5cGVPZih0KS5jb25zdHJ1Y3RvcikgOiBvLmFwcGx5KHQsIGUpKTsgfVxuICAgIGZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkOSgpIHsgdHJ5IHsgdmFyIHQgPSAhQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyB9IGNhdGNoICh0KSB7fSByZXR1cm4gKF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkOSA9IGZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IHJldHVybiAhIXQ7IH0pKCk7IH1cbiAgICB2YXIgY3JlYXRlTWVkaWFTdHJlYW1BdWRpb1NvdXJjZU5vZGVDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uIGNyZWF0ZU1lZGlhU3RyZWFtQXVkaW9Tb3VyY2VOb2RlQ29uc3RydWN0b3IoYXVkaW9Ob2RlQ29uc3RydWN0b3IsIGNyZWF0ZU5hdGl2ZU1lZGlhU3RyZWFtQXVkaW9Tb3VyY2VOb2RlLCBnZXROYXRpdmVDb250ZXh0LCBpc05hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQpIHtcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9hdWRpb05vZGVDb25zdHJ1Y3Rvcikge1xuICAgICAgICBmdW5jdGlvbiBNZWRpYVN0cmVhbUF1ZGlvU291cmNlTm9kZShjb250ZXh0LCBvcHRpb25zKSB7XG4gICAgICAgICAgdmFyIF90aGlzO1xuICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBNZWRpYVN0cmVhbUF1ZGlvU291cmNlTm9kZSk7XG4gICAgICAgICAgdmFyIG5hdGl2ZUNvbnRleHQgPSBnZXROYXRpdmVDb250ZXh0KGNvbnRleHQpO1xuICAgICAgICAgIHZhciBuYXRpdmVNZWRpYVN0cmVhbUF1ZGlvU291cmNlTm9kZSA9IGNyZWF0ZU5hdGl2ZU1lZGlhU3RyZWFtQXVkaW9Tb3VyY2VOb2RlKG5hdGl2ZUNvbnRleHQsIG9wdGlvbnMpO1xuICAgICAgICAgIC8vIEJ1ZyAjMTcyOiBTYWZhcmkgYWxsb3dzIHRvIGNyZWF0ZSBhIE1lZGlhU3RyZWFtQXVkaW9Tb3VyY2VOb2RlIHdpdGggYW4gT2ZmbGluZUF1ZGlvQ29udGV4dC5cbiAgICAgICAgICBpZiAoaXNOYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KG5hdGl2ZUNvbnRleHQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIF90aGlzID0gX2NhbGxTdXBlciQ5KHRoaXMsIE1lZGlhU3RyZWFtQXVkaW9Tb3VyY2VOb2RlLCBbY29udGV4dCwgdHJ1ZSwgbmF0aXZlTWVkaWFTdHJlYW1BdWRpb1NvdXJjZU5vZGUsIG51bGxdKTtcbiAgICAgICAgICBfdGhpcy5fbmF0aXZlTWVkaWFTdHJlYW1BdWRpb1NvdXJjZU5vZGUgPSBuYXRpdmVNZWRpYVN0cmVhbUF1ZGlvU291cmNlTm9kZTtcbiAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgIH1cbiAgICAgICAgX2luaGVyaXRzKE1lZGlhU3RyZWFtQXVkaW9Tb3VyY2VOb2RlLCBfYXVkaW9Ob2RlQ29uc3RydWN0b3IpO1xuICAgICAgICByZXR1cm4gX2NyZWF0ZUNsYXNzKE1lZGlhU3RyZWFtQXVkaW9Tb3VyY2VOb2RlLCBbe1xuICAgICAgICAgIGtleTogXCJtZWRpYVN0cmVhbVwiLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25hdGl2ZU1lZGlhU3RyZWFtQXVkaW9Tb3VyY2VOb2RlLm1lZGlhU3RyZWFtO1xuICAgICAgICAgIH1cbiAgICAgICAgfV0pO1xuICAgICAgfShhdWRpb05vZGVDb25zdHJ1Y3Rvcik7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIF9jYWxsU3VwZXIkOCh0LCBvLCBlKSB7IHJldHVybiBvID0gX2dldFByb3RvdHlwZU9mKG8pLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0LCBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JDgoKSA/IFJlZmxlY3QuY29uc3RydWN0KG8sIGUgfHwgW10sIF9nZXRQcm90b3R5cGVPZih0KS5jb25zdHJ1Y3RvcikgOiBvLmFwcGx5KHQsIGUpKTsgfVxuICAgIGZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkOCgpIHsgdHJ5IHsgdmFyIHQgPSAhQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyB9IGNhdGNoICh0KSB7fSByZXR1cm4gKF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkOCA9IGZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IHJldHVybiAhIXQ7IH0pKCk7IH1cbiAgICB2YXIgY3JlYXRlTWVkaWFTdHJlYW1UcmFja0F1ZGlvU291cmNlTm9kZUNvbnN0cnVjdG9yID0gZnVuY3Rpb24gY3JlYXRlTWVkaWFTdHJlYW1UcmFja0F1ZGlvU291cmNlTm9kZUNvbnN0cnVjdG9yKGF1ZGlvTm9kZUNvbnN0cnVjdG9yLCBjcmVhdGVOYXRpdmVNZWRpYVN0cmVhbVRyYWNrQXVkaW9Tb3VyY2VOb2RlLCBnZXROYXRpdmVDb250ZXh0KSB7XG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfYXVkaW9Ob2RlQ29uc3RydWN0b3IpIHtcbiAgICAgICAgZnVuY3Rpb24gTWVkaWFTdHJlYW1UcmFja0F1ZGlvU291cmNlTm9kZShjb250ZXh0LCBvcHRpb25zKSB7XG4gICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1lZGlhU3RyZWFtVHJhY2tBdWRpb1NvdXJjZU5vZGUpO1xuICAgICAgICAgIHZhciBuYXRpdmVDb250ZXh0ID0gZ2V0TmF0aXZlQ29udGV4dChjb250ZXh0KTtcbiAgICAgICAgICB2YXIgbmF0aXZlTWVkaWFTdHJlYW1UcmFja0F1ZGlvU291cmNlTm9kZSA9IGNyZWF0ZU5hdGl2ZU1lZGlhU3RyZWFtVHJhY2tBdWRpb1NvdXJjZU5vZGUobmF0aXZlQ29udGV4dCwgb3B0aW9ucyk7XG4gICAgICAgICAgcmV0dXJuIF9jYWxsU3VwZXIkOCh0aGlzLCBNZWRpYVN0cmVhbVRyYWNrQXVkaW9Tb3VyY2VOb2RlLCBbY29udGV4dCwgdHJ1ZSwgbmF0aXZlTWVkaWFTdHJlYW1UcmFja0F1ZGlvU291cmNlTm9kZSwgbnVsbF0pO1xuICAgICAgICB9XG4gICAgICAgIF9pbmhlcml0cyhNZWRpYVN0cmVhbVRyYWNrQXVkaW9Tb3VyY2VOb2RlLCBfYXVkaW9Ob2RlQ29uc3RydWN0b3IpO1xuICAgICAgICByZXR1cm4gX2NyZWF0ZUNsYXNzKE1lZGlhU3RyZWFtVHJhY2tBdWRpb1NvdXJjZU5vZGUpO1xuICAgICAgfShhdWRpb05vZGVDb25zdHJ1Y3Rvcik7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIF9jYWxsU3VwZXIkNyh0LCBvLCBlKSB7IHJldHVybiBvID0gX2dldFByb3RvdHlwZU9mKG8pLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0LCBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JDcoKSA/IFJlZmxlY3QuY29uc3RydWN0KG8sIGUgfHwgW10sIF9nZXRQcm90b3R5cGVPZih0KS5jb25zdHJ1Y3RvcikgOiBvLmFwcGx5KHQsIGUpKTsgfVxuICAgIGZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkNygpIHsgdHJ5IHsgdmFyIHQgPSAhQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyB9IGNhdGNoICh0KSB7fSByZXR1cm4gKF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkNyA9IGZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IHJldHVybiAhIXQ7IH0pKCk7IH1cbiAgICB2YXIgY3JlYXRlTWluaW1hbEF1ZGlvQ29udGV4dENvbnN0cnVjdG9yID0gZnVuY3Rpb24gY3JlYXRlTWluaW1hbEF1ZGlvQ29udGV4dENvbnN0cnVjdG9yKGNyZWF0ZUludmFsaWRTdGF0ZUVycm9yLCBjcmVhdGVOb3RTdXBwb3J0ZWRFcnJvciwgY3JlYXRlVW5rbm93bkVycm9yLCBtaW5pbWFsQmFzZUF1ZGlvQ29udGV4dENvbnN0cnVjdG9yLCBuYXRpdmVBdWRpb0NvbnRleHRDb25zdHJ1Y3Rvcikge1xuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX21pbmltYWxCYXNlQXVkaW9Db250KSB7XG4gICAgICAgIGZ1bmN0aW9uIE1pbmltYWxBdWRpb0NvbnRleHQoKSB7XG4gICAgICAgICAgdmFyIF90aGlzO1xuICAgICAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTWluaW1hbEF1ZGlvQ29udGV4dCk7XG4gICAgICAgICAgaWYgKG5hdGl2ZUF1ZGlvQ29udGV4dENvbnN0cnVjdG9yID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgdGhlIG5hdGl2ZSBBdWRpb0NvbnRleHQgY29uc3RydWN0b3IuJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBuYXRpdmVBdWRpb0NvbnRleHQ7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG5hdGl2ZUF1ZGlvQ29udGV4dCA9IG5ldyBuYXRpdmVBdWRpb0NvbnRleHRDb25zdHJ1Y3RvcihvcHRpb25zKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIC8vIEJ1ZyAjMTkyIFNhZmFyaSBkb2VzIHRocm93IGEgU3ludGF4RXJyb3IgaWYgdGhlIHNhbXBsZVJhdGUgaXMgbm90IHN1cHBvcnRlZC5cbiAgICAgICAgICAgIGlmIChlcnIuY29kZSA9PT0gMTIgJiYgZXJyLm1lc3NhZ2UgPT09ICdzYW1wbGVSYXRlIGlzIG5vdCBpbiByYW5nZScpIHtcbiAgICAgICAgICAgICAgdGhyb3cgY3JlYXRlTm90U3VwcG9ydGVkRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gQnVnICMxMzEgU2FmYXJpIHJldHVybnMgbnVsbCB3aGVuIHRoZXJlIGFyZSBmb3VyIG90aGVyIEF1ZGlvQ29udGV4dHMgcnVubmluZyBhbHJlYWR5LlxuICAgICAgICAgIGlmIChuYXRpdmVBdWRpb0NvbnRleHQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IGNyZWF0ZVVua25vd25FcnJvcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBCdWcgIzUxIE9ubHkgQ2hyb21lIGFuZCBFZGdlIHRocm93IGFuIGVycm9yIGlmIHRoZSBnaXZlbiBsYXRlbmN5SGludCBpcyBpbnZhbGlkLlxuICAgICAgICAgIGlmICghaXNWYWxpZExhdGVuY3lIaW50KG9wdGlvbnMubGF0ZW5jeUhpbnQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiVGhlIHByb3ZpZGVkIHZhbHVlICdcIi5jb25jYXQob3B0aW9ucy5sYXRlbmN5SGludCwgXCInIGlzIG5vdCBhIHZhbGlkIGVudW0gdmFsdWUgb2YgdHlwZSBBdWRpb0NvbnRleHRMYXRlbmN5Q2F0ZWdvcnkuXCIpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gQnVnICMxNTAgU2FmYXJpIGRvZXMgbm90IHN1cHBvcnQgc2V0dGluZyB0aGUgc2FtcGxlUmF0ZS5cbiAgICAgICAgICBpZiAob3B0aW9ucy5zYW1wbGVSYXRlICE9PSB1bmRlZmluZWQgJiYgbmF0aXZlQXVkaW9Db250ZXh0LnNhbXBsZVJhdGUgIT09IG9wdGlvbnMuc2FtcGxlUmF0ZSkge1xuICAgICAgICAgICAgdGhyb3cgY3JlYXRlTm90U3VwcG9ydGVkRXJyb3IoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgX3RoaXMgPSBfY2FsbFN1cGVyJDcodGhpcywgTWluaW1hbEF1ZGlvQ29udGV4dCwgW25hdGl2ZUF1ZGlvQ29udGV4dCwgMl0pO1xuICAgICAgICAgIHZhciBsYXRlbmN5SGludCA9IG9wdGlvbnMubGF0ZW5jeUhpbnQ7XG4gICAgICAgICAgdmFyIF9uYXRpdmVBdWRpb0NvbnRleHQgPSBuYXRpdmVBdWRpb0NvbnRleHQsXG4gICAgICAgICAgICBzYW1wbGVSYXRlID0gX25hdGl2ZUF1ZGlvQ29udGV4dC5zYW1wbGVSYXRlO1xuICAgICAgICAgIC8vIEB0b2RvIFRoZSB2YWx1ZXMgZm9yICdiYWxhbmNlZCcsICdpbnRlcmFjdGl2ZScgYW5kICdwbGF5YmFjaycgYXJlIGp1c3QgY29waWVkIGZyb20gQ2hyb21lJ3MgaW1wbGVtZW50YXRpb24uXG4gICAgICAgICAgX3RoaXMuX2Jhc2VMYXRlbmN5ID0gdHlwZW9mIG5hdGl2ZUF1ZGlvQ29udGV4dC5iYXNlTGF0ZW5jeSA9PT0gJ251bWJlcicgPyBuYXRpdmVBdWRpb0NvbnRleHQuYmFzZUxhdGVuY3kgOiBsYXRlbmN5SGludCA9PT0gJ2JhbGFuY2VkJyA/IDUxMiAvIHNhbXBsZVJhdGUgOiBsYXRlbmN5SGludCA9PT0gJ2ludGVyYWN0aXZlJyB8fCBsYXRlbmN5SGludCA9PT0gdW5kZWZpbmVkID8gMjU2IC8gc2FtcGxlUmF0ZSA6IGxhdGVuY3lIaW50ID09PSAncGxheWJhY2snID8gMTAyNCAvIHNhbXBsZVJhdGUgOlxuICAgICAgICAgIC8qXG4gICAgICAgICAgICogQHRvZG8gVGhlIG1pbiAoMjU2KSBhbmQgbWF4ICgxNjM4NCkgdmFsdWVzIGFyZSB0YWtlbiBmcm9tIHRoZSBhbGxvd2VkIGJ1ZmZlclNpemUgdmFsdWVzIG9mIGFcbiAgICAgICAgICAgKiBTY3JpcHRQcm9jZXNzb3JOb2RlLlxuICAgICAgICAgICAqL1xuICAgICAgICAgIE1hdGgubWF4KDIsIE1hdGgubWluKDEyOCwgTWF0aC5yb3VuZChsYXRlbmN5SGludCAqIHNhbXBsZVJhdGUgLyAxMjgpKSkgKiAxMjggLyBzYW1wbGVSYXRlO1xuICAgICAgICAgIF90aGlzLl9uYXRpdmVBdWRpb0NvbnRleHQgPSBuYXRpdmVBdWRpb0NvbnRleHQ7XG4gICAgICAgICAgLy8gQnVnICMxODg6IFNhZmFyaSB3aWxsIHNldCB0aGUgY29udGV4dCdzIHN0YXRlIHRvICdpbnRlcnJ1cHRlZCcgaW4gY2FzZSB0aGUgdXNlciBzd2l0Y2hlcyB0YWJzLlxuICAgICAgICAgIGlmIChuYXRpdmVBdWRpb0NvbnRleHRDb25zdHJ1Y3Rvci5uYW1lID09PSAnd2Via2l0QXVkaW9Db250ZXh0Jykge1xuICAgICAgICAgICAgX3RoaXMuX25hdGl2ZUdhaW5Ob2RlID0gbmF0aXZlQXVkaW9Db250ZXh0LmNyZWF0ZUdhaW4oKTtcbiAgICAgICAgICAgIF90aGlzLl9uYXRpdmVPc2NpbGxhdG9yTm9kZSA9IG5hdGl2ZUF1ZGlvQ29udGV4dC5jcmVhdGVPc2NpbGxhdG9yKCk7XG4gICAgICAgICAgICBfdGhpcy5fbmF0aXZlR2Fpbk5vZGUuZ2Fpbi52YWx1ZSA9IDFlLTM3O1xuICAgICAgICAgICAgX3RoaXMuX25hdGl2ZU9zY2lsbGF0b3JOb2RlLmNvbm5lY3QoX3RoaXMuX25hdGl2ZUdhaW5Ob2RlKS5jb25uZWN0KG5hdGl2ZUF1ZGlvQ29udGV4dC5kZXN0aW5hdGlvbik7XG4gICAgICAgICAgICBfdGhpcy5fbmF0aXZlT3NjaWxsYXRvck5vZGUuc3RhcnQoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX3RoaXMuX25hdGl2ZUdhaW5Ob2RlID0gbnVsbDtcbiAgICAgICAgICAgIF90aGlzLl9uYXRpdmVPc2NpbGxhdG9yTm9kZSA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIF90aGlzLl9zdGF0ZSA9IG51bGw7XG4gICAgICAgICAgLypcbiAgICAgICAgICAgKiBCdWcgIzM0OiBDaHJvbWUgYW5kIEVkZ2UgcHJldGVuZCB0byBiZSBydW5uaW5nIHJpZ2h0IGF3YXksIGJ1dCBmaXJlIGFuIG9uc3RhdGVjaGFuZ2UgZXZlbnQgd2hlbiB0aGUgc3RhdGUgYWN0dWFsbHkgY2hhbmdlc1xuICAgICAgICAgICAqIHRvICdydW5uaW5nJy5cbiAgICAgICAgICAgKi9cbiAgICAgICAgICBpZiAobmF0aXZlQXVkaW9Db250ZXh0LnN0YXRlID09PSAncnVubmluZycpIHtcbiAgICAgICAgICAgIF90aGlzLl9zdGF0ZSA9ICdzdXNwZW5kZWQnO1xuICAgICAgICAgICAgdmFyIF9yZXZva2VTdGF0ZSA9IGZ1bmN0aW9uIHJldm9rZVN0YXRlKCkge1xuICAgICAgICAgICAgICBpZiAoX3RoaXMuX3N0YXRlID09PSAnc3VzcGVuZGVkJykge1xuICAgICAgICAgICAgICAgIF90aGlzLl9zdGF0ZSA9IG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbmF0aXZlQXVkaW9Db250ZXh0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3N0YXRlY2hhbmdlJywgX3Jldm9rZVN0YXRlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBuYXRpdmVBdWRpb0NvbnRleHQuYWRkRXZlbnRMaXN0ZW5lcignc3RhdGVjaGFuZ2UnLCBfcmV2b2tlU3RhdGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgIH1cbiAgICAgICAgX2luaGVyaXRzKE1pbmltYWxBdWRpb0NvbnRleHQsIF9taW5pbWFsQmFzZUF1ZGlvQ29udCk7XG4gICAgICAgIHJldHVybiBfY3JlYXRlQ2xhc3MoTWluaW1hbEF1ZGlvQ29udGV4dCwgW3tcbiAgICAgICAgICBrZXk6IFwiYmFzZUxhdGVuY3lcIixcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9iYXNlTGF0ZW5jeTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBrZXk6IFwic3RhdGVcIixcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdGF0ZSAhPT0gbnVsbCA/IHRoaXMuX3N0YXRlIDogdGhpcy5fbmF0aXZlQXVkaW9Db250ZXh0LnN0YXRlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIGtleTogXCJjbG9zZVwiLFxuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuICAgICAgICAgICAgLy8gQnVnICMzNTogRmlyZWZveCBkb2VzIG5vdCB0aHJvdyBhbiBlcnJvciBpZiB0aGUgQXVkaW9Db250ZXh0IHdhcyBjbG9zZWQgYmVmb3JlLlxuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09ICdjbG9zZWQnKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLl9uYXRpdmVBdWRpb0NvbnRleHQuY2xvc2UoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBjcmVhdGVJbnZhbGlkU3RhdGVFcnJvcigpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEJ1ZyAjMzQ6IElmIHRoZSBzdGF0ZSB3YXMgc2V0IHRvIHN1c3BlbmRlZCBiZWZvcmUgaXQgc2hvdWxkIGJlIHJldm9rZWQgbm93LlxuICAgICAgICAgICAgaWYgKHRoaXMuX3N0YXRlID09PSAnc3VzcGVuZGVkJykge1xuICAgICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbmF0aXZlQXVkaW9Db250ZXh0LmNsb3NlKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGlmIChfdGhpczIuX25hdGl2ZUdhaW5Ob2RlICE9PSBudWxsICYmIF90aGlzMi5fbmF0aXZlT3NjaWxsYXRvck5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBfdGhpczIuX25hdGl2ZU9zY2lsbGF0b3JOb2RlLnN0b3AoKTtcbiAgICAgICAgICAgICAgICBfdGhpczIuX25hdGl2ZUdhaW5Ob2RlLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICBfdGhpczIuX25hdGl2ZU9zY2lsbGF0b3JOb2RlLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBkZWFjdGl2YXRlQXVkaW9HcmFwaChfdGhpczIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcInJlc3VtZVwiLFxuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZXN1bWUoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMzID0gdGhpcztcbiAgICAgICAgICAgIGlmICh0aGlzLl9zdGF0ZSA9PT0gJ3N1c3BlbmRlZCcpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3Jlc29sdmVQcm9taXNlID0gZnVuY3Rpb24gcmVzb2x2ZVByb21pc2UoKSB7XG4gICAgICAgICAgICAgICAgICBfdGhpczMuX25hdGl2ZUF1ZGlvQ29udGV4dC5yZW1vdmVFdmVudExpc3RlbmVyKCdzdGF0ZWNoYW5nZScsIF9yZXNvbHZlUHJvbWlzZSk7XG4gICAgICAgICAgICAgICAgICBpZiAoX3RoaXMzLl9uYXRpdmVBdWRpb0NvbnRleHQuc3RhdGUgPT09ICdydW5uaW5nJykge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBfdGhpczMucmVzdW1lKCkudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgX3RoaXMzLl9uYXRpdmVBdWRpb0NvbnRleHQuYWRkRXZlbnRMaXN0ZW5lcignc3RhdGVjaGFuZ2UnLCBfcmVzb2x2ZVByb21pc2UpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9uYXRpdmVBdWRpb0NvbnRleHQucmVzdW1lKClbXCJjYXRjaFwiXShmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgIC8vIEJ1ZyAjNTU6IENocm9tZSBhbmQgRWRnZSBkbyB0aHJvdyBhbiBJbnZhbGlkQWNjZXNzRXJyb3IgaW5zdGVhZCBvZiBhbiBJbnZhbGlkU3RhdGVFcnJvci5cbiAgICAgICAgICAgICAgLy8gQnVnICM1NjogU2FmYXJpIGludm9rZXMgdGhlIGNhdGNoIGhhbmRsZXIgYnV0IHdpdGhvdXQgYW4gZXJyb3IuXG4gICAgICAgICAgICAgIGlmIChlcnIgPT09IHVuZGVmaW5lZCB8fCBlcnIuY29kZSA9PT0gMTUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBjcmVhdGVJbnZhbGlkU3RhdGVFcnJvcigpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIGtleTogXCJzdXNwZW5kXCIsXG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHN1c3BlbmQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbmF0aXZlQXVkaW9Db250ZXh0LnN1c3BlbmQoKVtcImNhdGNoXCJdKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgLy8gQnVnICM1NjogU2FmYXJpIGludm9rZXMgdGhlIGNhdGNoIGhhbmRsZXIgYnV0IHdpdGhvdXQgYW4gZXJyb3IuXG4gICAgICAgICAgICAgIGlmIChlcnIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IGNyZWF0ZUludmFsaWRTdGF0ZUVycm9yKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XSk7XG4gICAgICB9KG1pbmltYWxCYXNlQXVkaW9Db250ZXh0Q29uc3RydWN0b3IpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBfY2FsbFN1cGVyJDYodCwgbywgZSkgeyByZXR1cm4gbyA9IF9nZXRQcm90b3R5cGVPZihvKSwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odCwgX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCQ2KCkgPyBSZWZsZWN0LmNvbnN0cnVjdChvLCBlIHx8IFtdLCBfZ2V0UHJvdG90eXBlT2YodCkuY29uc3RydWN0b3IpIDogby5hcHBseSh0LCBlKSk7IH1cbiAgICBmdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JDYoKSB7IHRyeSB7IHZhciB0ID0gIUJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgfSBjYXRjaCAodCkge30gcmV0dXJuIChfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JDYgPSBmdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyByZXR1cm4gISF0OyB9KSgpOyB9XG4gICAgdmFyIGNyZWF0ZU1pbmltYWxCYXNlQXVkaW9Db250ZXh0Q29uc3RydWN0b3IgPSBmdW5jdGlvbiBjcmVhdGVNaW5pbWFsQmFzZUF1ZGlvQ29udGV4dENvbnN0cnVjdG9yKGF1ZGlvRGVzdGluYXRpb25Ob2RlQ29uc3RydWN0b3IsIGNyZWF0ZUF1ZGlvTGlzdGVuZXIsIGV2ZW50VGFyZ2V0Q29uc3RydWN0b3IsIGlzTmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCwgdW5yZW5kZXJlZEF1ZGlvV29ya2xldE5vZGVTdG9yZSwgd3JhcEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9ldmVudFRhcmdldENvbnN0cnVjdCkge1xuICAgICAgICBmdW5jdGlvbiBNaW5pbWFsQmFzZUF1ZGlvQ29udGV4dChfbmF0aXZlQ29udGV4dCwgbnVtYmVyT2ZDaGFubmVscykge1xuICAgICAgICAgIHZhciBfdGhpcztcbiAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTWluaW1hbEJhc2VBdWRpb0NvbnRleHQpO1xuICAgICAgICAgIF90aGlzID0gX2NhbGxTdXBlciQ2KHRoaXMsIE1pbmltYWxCYXNlQXVkaW9Db250ZXh0LCBbX25hdGl2ZUNvbnRleHRdKTtcbiAgICAgICAgICBfdGhpcy5fbmF0aXZlQ29udGV4dCA9IF9uYXRpdmVDb250ZXh0O1xuICAgICAgICAgIENPTlRFWFRfU1RPUkUuc2V0KF90aGlzLCBfbmF0aXZlQ29udGV4dCk7XG4gICAgICAgICAgaWYgKGlzTmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dChfbmF0aXZlQ29udGV4dCkpIHtcbiAgICAgICAgICAgIHVucmVuZGVyZWRBdWRpb1dvcmtsZXROb2RlU3RvcmUuc2V0KF9uYXRpdmVDb250ZXh0LCBuZXcgU2V0KCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBfdGhpcy5fZGVzdGluYXRpb24gPSBuZXcgYXVkaW9EZXN0aW5hdGlvbk5vZGVDb25zdHJ1Y3RvcihfdGhpcywgbnVtYmVyT2ZDaGFubmVscyk7XG4gICAgICAgICAgX3RoaXMuX2xpc3RlbmVyID0gY3JlYXRlQXVkaW9MaXN0ZW5lcihfdGhpcywgX25hdGl2ZUNvbnRleHQpO1xuICAgICAgICAgIF90aGlzLl9vbnN0YXRlY2hhbmdlID0gbnVsbDtcbiAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgIH1cbiAgICAgICAgX2luaGVyaXRzKE1pbmltYWxCYXNlQXVkaW9Db250ZXh0LCBfZXZlbnRUYXJnZXRDb25zdHJ1Y3QpO1xuICAgICAgICByZXR1cm4gX2NyZWF0ZUNsYXNzKE1pbmltYWxCYXNlQXVkaW9Db250ZXh0LCBbe1xuICAgICAgICAgIGtleTogXCJjdXJyZW50VGltZVwiLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25hdGl2ZUNvbnRleHQuY3VycmVudFRpbWU7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcImRlc3RpbmF0aW9uXCIsXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVzdGluYXRpb247XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcImxpc3RlbmVyXCIsXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbGlzdGVuZXI7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcIm9uc3RhdGVjaGFuZ2VcIixcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9vbnN0YXRlY2hhbmdlO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgICAgIHZhciB3cmFwcGVkTGlzdGVuZXIgPSB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgPyB3cmFwRXZlbnRMaXN0ZW5lcih0aGlzLCB2YWx1ZSkgOiBudWxsO1xuICAgICAgICAgICAgdGhpcy5fbmF0aXZlQ29udGV4dC5vbnN0YXRlY2hhbmdlID0gd3JhcHBlZExpc3RlbmVyO1xuICAgICAgICAgICAgdmFyIG5hdGl2ZU9uU3RhdGVDaGFuZ2UgPSB0aGlzLl9uYXRpdmVDb250ZXh0Lm9uc3RhdGVjaGFuZ2U7XG4gICAgICAgICAgICB0aGlzLl9vbnN0YXRlY2hhbmdlID0gbmF0aXZlT25TdGF0ZUNoYW5nZSAhPT0gbnVsbCAmJiBuYXRpdmVPblN0YXRlQ2hhbmdlID09PSB3cmFwcGVkTGlzdGVuZXIgPyB2YWx1ZSA6IG5hdGl2ZU9uU3RhdGVDaGFuZ2U7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcInNhbXBsZVJhdGVcIixcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9uYXRpdmVDb250ZXh0LnNhbXBsZVJhdGU7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcInN0YXRlXCIsXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbmF0aXZlQ29udGV4dC5zdGF0ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1dKTtcbiAgICAgIH0oZXZlbnRUYXJnZXRDb25zdHJ1Y3Rvcik7XG4gICAgfTtcblxuICAgIHZhciB0ZXN0UHJvbWlzZVN1cHBvcnQgPSBmdW5jdGlvbiB0ZXN0UHJvbWlzZVN1cHBvcnQobmF0aXZlQ29udGV4dCkge1xuICAgICAgLy8gVGhpcyAxMiBudW1iZXJzIHJlcHJlc2VudCB0aGUgNDggYnl0ZXMgb2YgYW4gZW1wdHkgV0FWRSBmaWxlIHdpdGggYSBzaW5nbGUgc2FtcGxlLlxuICAgICAgdmFyIHVpbnQzMkFycmF5ID0gbmV3IFVpbnQzMkFycmF5KFsxMTc5MDExNDEwLCA0MCwgMTE2MzI4MDcyNywgNTQ0NTAxMDk0LCAxNiwgMTMxMDczLCA0NDEwMCwgMTc2NDAwLCAxMDQ4NTgwLCAxNjM1MDE3MDYwLCA0LCAwXSk7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBCdWcgIzE6IFNhZmFyaSByZXF1aXJlcyBhIHN1Y2Nlc3NDYWxsYmFjay5cbiAgICAgICAgdmFyIHByb21pc2UgPSBuYXRpdmVDb250ZXh0LmRlY29kZUF1ZGlvRGF0YSh1aW50MzJBcnJheS5idWZmZXIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvLyBJZ25vcmUgdGhlIHN1Y2Nlc3MgY2FsbGJhY2suXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocHJvbWlzZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHByb21pc2VbXCJjYXRjaFwiXShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgLy8gSWdub3JlIHJlamVjdGVkIGVycm9ycy5cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBjYXRjaCAoX3VudXNlZCkge1xuICAgICAgICAvLyBJZ25vcmUgZXJyb3JzLlxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBvd25LZXlzJGcoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuICAgIGZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkZyhlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzJGcoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzJGcoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTsgfSk7IH0gcmV0dXJuIGU7IH1cbiAgICBmdW5jdGlvbiBfY2FsbFN1cGVyJDUodCwgbywgZSkgeyByZXR1cm4gbyA9IF9nZXRQcm90b3R5cGVPZihvKSwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odCwgX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCQ1KCkgPyBSZWZsZWN0LmNvbnN0cnVjdChvLCBlIHx8IFtdLCBfZ2V0UHJvdG90eXBlT2YodCkuY29uc3RydWN0b3IpIDogby5hcHBseSh0LCBlKSk7IH1cbiAgICBmdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JDUoKSB7IHRyeSB7IHZhciB0ID0gIUJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgfSBjYXRjaCAodCkge30gcmV0dXJuIChfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JDUgPSBmdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyByZXR1cm4gISF0OyB9KSgpOyB9XG4gICAgdmFyIERFRkFVTFRfT1BUSU9OUyQ2ID0ge1xuICAgICAgbnVtYmVyT2ZDaGFubmVsczogMVxuICAgIH07XG4gICAgdmFyIGNyZWF0ZU1pbmltYWxPZmZsaW5lQXVkaW9Db250ZXh0Q29uc3RydWN0b3IgPSBmdW5jdGlvbiBjcmVhdGVNaW5pbWFsT2ZmbGluZUF1ZGlvQ29udGV4dENvbnN0cnVjdG9yKGNhY2hlVGVzdFJlc3VsdCwgY3JlYXRlSW52YWxpZFN0YXRlRXJyb3IsIGNyZWF0ZU5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQsIG1pbmltYWxCYXNlQXVkaW9Db250ZXh0Q29uc3RydWN0b3IsIF9zdGFydFJlbmRlcmluZykge1xuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX21pbmltYWxCYXNlQXVkaW9Db250KSB7XG4gICAgICAgIGZ1bmN0aW9uIE1pbmltYWxPZmZsaW5lQXVkaW9Db250ZXh0KG9wdGlvbnMpIHtcbiAgICAgICAgICB2YXIgX3RoaXM7XG4gICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1pbmltYWxPZmZsaW5lQXVkaW9Db250ZXh0KTtcbiAgICAgICAgICB2YXIgX0RFRkFVTFRfT1BUSU9OUyRvcHRpID0gX29iamVjdFNwcmVhZCRnKF9vYmplY3RTcHJlYWQkZyh7fSwgREVGQVVMVF9PUFRJT05TJDYpLCBvcHRpb25zKSxcbiAgICAgICAgICAgIGxlbmd0aCA9IF9ERUZBVUxUX09QVElPTlMkb3B0aS5sZW5ndGgsXG4gICAgICAgICAgICBudW1iZXJPZkNoYW5uZWxzID0gX0RFRkFVTFRfT1BUSU9OUyRvcHRpLm51bWJlck9mQ2hhbm5lbHMsXG4gICAgICAgICAgICBzYW1wbGVSYXRlID0gX0RFRkFVTFRfT1BUSU9OUyRvcHRpLnNhbXBsZVJhdGU7XG4gICAgICAgICAgdmFyIG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQgPSBjcmVhdGVOYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KG51bWJlck9mQ2hhbm5lbHMsIGxlbmd0aCwgc2FtcGxlUmF0ZSk7XG4gICAgICAgICAgLy8gIzIxIFNhZmFyaSBkb2VzIG5vdCBzdXBwb3J0IHByb21pc2VzIGFuZCB0aGVyZWZvcmUgd291bGQgZmlyZSB0aGUgc3RhdGVjaGFuZ2UgZXZlbnQgYmVmb3JlIHRoZSBwcm9taXNlIGNhbiBiZSByZXNvbHZlZC5cbiAgICAgICAgICBpZiAoIWNhY2hlVGVzdFJlc3VsdCh0ZXN0UHJvbWlzZVN1cHBvcnQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0ZXN0UHJvbWlzZVN1cHBvcnQobmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCk7XG4gICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgIG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQuYWRkRXZlbnRMaXN0ZW5lcignc3RhdGVjaGFuZ2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgICAgICAgdmFyIF9kZWxheVN0YXRlQ2hhbmdlRXZlbnQgPSBmdW5jdGlvbiBkZWxheVN0YXRlQ2hhbmdlRXZlbnQoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuX3N0YXRlID09PSAncnVubmluZycpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3N0YXRlY2hhbmdlJywgX2RlbGF5U3RhdGVDaGFuZ2VFdmVudCk7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fd2FpdEZvclRoZVByb21pc2VUb1NldHRsZShldmVudCk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpICs9IDE7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICByZXR1cm4gX2RlbGF5U3RhdGVDaGFuZ2VFdmVudDtcbiAgICAgICAgICAgIH0oKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIF90aGlzID0gX2NhbGxTdXBlciQ1KHRoaXMsIE1pbmltYWxPZmZsaW5lQXVkaW9Db250ZXh0LCBbbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCwgbnVtYmVyT2ZDaGFubmVsc10pO1xuICAgICAgICAgIF90aGlzLl9sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgICAgX3RoaXMuX25hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQgPSBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0O1xuICAgICAgICAgIF90aGlzLl9zdGF0ZSA9IG51bGw7XG4gICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICB9XG4gICAgICAgIF9pbmhlcml0cyhNaW5pbWFsT2ZmbGluZUF1ZGlvQ29udGV4dCwgX21pbmltYWxCYXNlQXVkaW9Db250KTtcbiAgICAgICAgcmV0dXJuIF9jcmVhdGVDbGFzcyhNaW5pbWFsT2ZmbGluZUF1ZGlvQ29udGV4dCwgW3tcbiAgICAgICAgICBrZXk6IFwibGVuZ3RoXCIsXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAvLyBCdWcgIzE3OiBTYWZhcmkgZG9lcyBub3QgeWV0IGV4cG9zZSB0aGUgbGVuZ3RoLlxuICAgICAgICAgICAgaWYgKHRoaXMuX25hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQubGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9uYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0Lmxlbmd0aDtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBrZXk6IFwic3RhdGVcIixcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdGF0ZSA9PT0gbnVsbCA/IHRoaXMuX25hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQuc3RhdGUgOiB0aGlzLl9zdGF0ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBrZXk6IFwic3RhcnRSZW5kZXJpbmdcIixcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc3RhcnRSZW5kZXJpbmcoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBCdWcgIzkgJiAjNTk6IEl0IGlzIHRoZW9yZXRpY2FsbHkgcG9zc2libGUgdGhhdCBzdGFydFJlbmRlcmluZygpIHdpbGwgZmlyc3QgcmVuZGVyIGEgcGFydGlhbE9mZmxpbmVBdWRpb0NvbnRleHQuIFRoZXJlZm9yZVxuICAgICAgICAgICAgICogdGhlIHN0YXRlIG9mIHRoZSBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0IG1pZ2h0IG5vIHRyYW5zaXRpb24gdG8gcnVubmluZyBpbW1lZGlhdGVseS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKHRoaXMuX3N0YXRlID09PSAncnVubmluZycpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGNyZWF0ZUludmFsaWRTdGF0ZUVycm9yKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSAncnVubmluZyc7XG4gICAgICAgICAgICByZXR1cm4gX3N0YXJ0UmVuZGVyaW5nKHRoaXMuZGVzdGluYXRpb24sIHRoaXMuX25hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQpW1wiZmluYWxseVwiXShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIF90aGlzMi5fc3RhdGUgPSBudWxsO1xuICAgICAgICAgICAgICBkZWFjdGl2YXRlQXVkaW9HcmFwaChfdGhpczIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcIl93YWl0Rm9yVGhlUHJvbWlzZVRvU2V0dGxlXCIsXG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF93YWl0Rm9yVGhlUHJvbWlzZVRvU2V0dGxlKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMzID0gdGhpcztcbiAgICAgICAgICAgIGlmICh0aGlzLl9zdGF0ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICB0aGlzLl9uYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzMy5fd2FpdEZvclRoZVByb21pc2VUb1NldHRsZShldmVudCk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfV0pO1xuICAgICAgfShtaW5pbWFsQmFzZUF1ZGlvQ29udGV4dENvbnN0cnVjdG9yKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkMShyLCBlKSB7IHZhciB0ID0gXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgU3ltYm9sICYmIHJbU3ltYm9sLml0ZXJhdG9yXSB8fCByW1wiQEBpdGVyYXRvclwiXTsgaWYgKCF0KSB7IGlmIChBcnJheS5pc0FycmF5KHIpIHx8ICh0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5JDEocikpIHx8IGUpIHsgdCAmJiAociA9IHQpOyB2YXIgX24gPSAwLCBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyByZXR1cm4gX24gPj0gci5sZW5ndGggPyB7IGRvbmU6ICEwIH0gOiB7IGRvbmU6ICExLCB2YWx1ZTogcltfbisrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKHIpIHsgdGhyb3cgcjsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbywgYSA9ICEwLCB1ID0gITE7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IHQgPSB0LmNhbGwocik7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciByID0gdC5uZXh0KCk7IHJldHVybiBhID0gci5kb25lLCByOyB9LCBlOiBmdW5jdGlvbiBlKHIpIHsgdSA9ICEwLCBvID0gcjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgYSB8fCBudWxsID09IHRbXCJyZXR1cm5cIl0gfHwgdFtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAodSkgdGhyb3cgbzsgfSB9IH07IH1cbiAgICBmdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkMShyLCBhKSB7IGlmIChyKSB7IGlmIChcInN0cmluZ1wiID09IHR5cGVvZiByKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkkMShyLCBhKTsgdmFyIHQgPSB7fS50b1N0cmluZy5jYWxsKHIpLnNsaWNlKDgsIC0xKTsgcmV0dXJuIFwiT2JqZWN0XCIgPT09IHQgJiYgci5jb25zdHJ1Y3RvciAmJiAodCA9IHIuY29uc3RydWN0b3IubmFtZSksIFwiTWFwXCIgPT09IHQgfHwgXCJTZXRcIiA9PT0gdCA/IEFycmF5LmZyb20ocikgOiBcIkFyZ3VtZW50c1wiID09PSB0IHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KHQpID8gX2FycmF5TGlrZVRvQXJyYXkkMShyLCBhKSA6IHZvaWQgMDsgfSB9XG4gICAgZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkkMShyLCBhKSB7IChudWxsID09IGEgfHwgYSA+IHIubGVuZ3RoKSAmJiAoYSA9IHIubGVuZ3RoKTsgZm9yICh2YXIgZSA9IDAsIG4gPSBBcnJheShhKTsgZSA8IGE7IGUrKykgbltlXSA9IHJbZV07IHJldHVybiBuOyB9XG4gICAgdmFyIGNyZWF0ZU1vbml0b3JDb25uZWN0aW9ucyA9IGZ1bmN0aW9uIGNyZWF0ZU1vbml0b3JDb25uZWN0aW9ucyhpbnNlcnRFbGVtZW50SW5TZXQsIGlzTmF0aXZlQXVkaW9Ob2RlKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKG5hdGl2ZUF1ZGlvTm9kZSwgd2hlbkNvbm5lY3RlZCwgd2hlbkRpc2Nvbm5lY3RlZCkge1xuICAgICAgICB2YXIgY29ubmVjdGlvbnMgPSBuZXcgU2V0KCk7XG4gICAgICAgIG5hdGl2ZUF1ZGlvTm9kZS5jb25uZWN0ID0gZnVuY3Rpb24gKGNvbm5lY3QpIHtcbiAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6aW52YWxpZC12b2lkIG5vLWluZmVycmFibGUtdHlwZXNcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGRlc3RpbmF0aW9uKSB7XG4gICAgICAgICAgICB2YXIgb3V0cHV0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuICAgICAgICAgICAgdmFyIGlucHV0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAwO1xuICAgICAgICAgICAgdmFyIHdhc0Rpc2Nvbm5lY3RlZCA9IGNvbm5lY3Rpb25zLnNpemUgPT09IDA7XG4gICAgICAgICAgICBpZiAoaXNOYXRpdmVBdWRpb05vZGUoZGVzdGluYXRpb24pKSB7XG4gICAgICAgICAgICAgIC8vIEB0b2RvIFR5cGVTY3JpcHQgY2Fubm90IGluZmVyIHRoZSBvdmVybG9hZGVkIHNpZ25hdHVyZSB3aXRoIDMgYXJndW1lbnRzIHlldC5cbiAgICAgICAgICAgICAgY29ubmVjdC5jYWxsKG5hdGl2ZUF1ZGlvTm9kZSwgZGVzdGluYXRpb24sIG91dHB1dCwgaW5wdXQpO1xuICAgICAgICAgICAgICBpbnNlcnRFbGVtZW50SW5TZXQoY29ubmVjdGlvbnMsIFtkZXN0aW5hdGlvbiwgb3V0cHV0LCBpbnB1dF0sIGZ1bmN0aW9uIChjb25uZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb25bMF0gPT09IGRlc3RpbmF0aW9uICYmIGNvbm5lY3Rpb25bMV0gPT09IG91dHB1dCAmJiBjb25uZWN0aW9uWzJdID09PSBpbnB1dDtcbiAgICAgICAgICAgICAgfSwgdHJ1ZSk7XG4gICAgICAgICAgICAgIGlmICh3YXNEaXNjb25uZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICB3aGVuQ29ubmVjdGVkKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGRlc3RpbmF0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29ubmVjdC5jYWxsKG5hdGl2ZUF1ZGlvTm9kZSwgZGVzdGluYXRpb24sIG91dHB1dCk7XG4gICAgICAgICAgICBpbnNlcnRFbGVtZW50SW5TZXQoY29ubmVjdGlvbnMsIFtkZXN0aW5hdGlvbiwgb3V0cHV0XSwgZnVuY3Rpb24gKGNvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb25bMF0gPT09IGRlc3RpbmF0aW9uICYmIGNvbm5lY3Rpb25bMV0gPT09IG91dHB1dDtcbiAgICAgICAgICAgIH0sIHRydWUpO1xuICAgICAgICAgICAgaWYgKHdhc0Rpc2Nvbm5lY3RlZCkge1xuICAgICAgICAgICAgICB3aGVuQ29ubmVjdGVkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfTtcbiAgICAgICAgfShuYXRpdmVBdWRpb05vZGUuY29ubmVjdCk7XG4gICAgICAgIG5hdGl2ZUF1ZGlvTm9kZS5kaXNjb25uZWN0ID0gZnVuY3Rpb24gKGRpc2Nvbm5lY3QpIHtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGRlc3RpbmF0aW9uT3JPdXRwdXQsIG91dHB1dCwgaW5wdXQpIHtcbiAgICAgICAgICAgIHZhciB3YXNDb25uZWN0ZWQgPSBjb25uZWN0aW9ucy5zaXplID4gMDtcbiAgICAgICAgICAgIGlmIChkZXN0aW5hdGlvbk9yT3V0cHV0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgZGlzY29ubmVjdC5hcHBseShuYXRpdmVBdWRpb05vZGUpO1xuICAgICAgICAgICAgICBjb25uZWN0aW9ucy5jbGVhcigpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZGVzdGluYXRpb25Pck91dHB1dCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgLy8gQHRvZG8gVHlwZVNjcmlwdCBjYW5ub3QgaW5mZXIgdGhlIG92ZXJsb2FkZWQgc2lnbmF0dXJlIHdpdGggMSBhcmd1bWVudCB5ZXQuXG4gICAgICAgICAgICAgIGRpc2Nvbm5lY3QuY2FsbChuYXRpdmVBdWRpb05vZGUsIGRlc3RpbmF0aW9uT3JPdXRwdXQpO1xuICAgICAgICAgICAgICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkMShjb25uZWN0aW9ucyksXG4gICAgICAgICAgICAgICAgX3N0ZXA7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICAgICAgICAgIHZhciBjb25uZWN0aW9uID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgICAgICAgICBpZiAoY29ubmVjdGlvblsxXSA9PT0gZGVzdGluYXRpb25Pck91dHB1dCkge1xuICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uc1tcImRlbGV0ZVwiXShjb25uZWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKGlzTmF0aXZlQXVkaW9Ob2RlKGRlc3RpbmF0aW9uT3JPdXRwdXQpKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRvZG8gVHlwZVNjcmlwdCBjYW5ub3QgaW5mZXIgdGhlIG92ZXJsb2FkZWQgc2lnbmF0dXJlIHdpdGggMyBhcmd1bWVudHMgeWV0LlxuICAgICAgICAgICAgICAgIGRpc2Nvbm5lY3QuY2FsbChuYXRpdmVBdWRpb05vZGUsIGRlc3RpbmF0aW9uT3JPdXRwdXQsIG91dHB1dCwgaW5wdXQpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEB0b2RvIFR5cGVTY3JpcHQgY2Fubm90IGluZmVyIHRoZSBvdmVybG9hZGVkIHNpZ25hdHVyZSB3aXRoIDIgYXJndW1lbnRzIHlldC5cbiAgICAgICAgICAgICAgICBkaXNjb25uZWN0LmNhbGwobmF0aXZlQXVkaW9Ob2RlLCBkZXN0aW5hdGlvbk9yT3V0cHV0LCBvdXRwdXQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhciBfaXRlcmF0b3IyID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkMShjb25uZWN0aW9ucyksXG4gICAgICAgICAgICAgICAgX3N0ZXAyO1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZvciAoX2l0ZXJhdG9yMi5zKCk7ICEoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgICAgICAgICB2YXIgX2Nvbm5lY3Rpb24gPSBfc3RlcDIudmFsdWU7XG4gICAgICAgICAgICAgICAgICBpZiAoX2Nvbm5lY3Rpb25bMF0gPT09IGRlc3RpbmF0aW9uT3JPdXRwdXQgJiYgKG91dHB1dCA9PT0gdW5kZWZpbmVkIHx8IF9jb25uZWN0aW9uWzFdID09PSBvdXRwdXQpICYmIChpbnB1dCA9PT0gdW5kZWZpbmVkIHx8IF9jb25uZWN0aW9uWzJdID09PSBpbnB1dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvbnNbXCJkZWxldGVcIl0oX2Nvbm5lY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgX2l0ZXJhdG9yMi5lKGVycik7XG4gICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgX2l0ZXJhdG9yMi5mKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBpc0Rpc2Nvbm5lY3RlZCA9IGNvbm5lY3Rpb25zLnNpemUgPT09IDA7XG4gICAgICAgICAgICBpZiAod2FzQ29ubmVjdGVkICYmIGlzRGlzY29ubmVjdGVkKSB7XG4gICAgICAgICAgICAgIHdoZW5EaXNjb25uZWN0ZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9KG5hdGl2ZUF1ZGlvTm9kZS5kaXNjb25uZWN0KTtcbiAgICAgICAgcmV0dXJuIG5hdGl2ZUF1ZGlvTm9kZTtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBhc3NpZ25OYXRpdmVBdWRpb05vZGVPcHRpb24gPSBmdW5jdGlvbiBhc3NpZ25OYXRpdmVBdWRpb05vZGVPcHRpb24obmF0aXZlQXVkaW9Ob2RlLCBvcHRpb25zLCBvcHRpb24pIHtcbiAgICAgIHZhciB2YWx1ZSA9IG9wdGlvbnNbb3B0aW9uXTtcbiAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBuYXRpdmVBdWRpb05vZGVbb3B0aW9uXSkge1xuICAgICAgICBuYXRpdmVBdWRpb05vZGVbb3B0aW9uXSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgYXNzaWduTmF0aXZlQXVkaW9Ob2RlT3B0aW9ucyA9IGZ1bmN0aW9uIGFzc2lnbk5hdGl2ZUF1ZGlvTm9kZU9wdGlvbnMobmF0aXZlQXVkaW9Ob2RlLCBvcHRpb25zKSB7XG4gICAgICBhc3NpZ25OYXRpdmVBdWRpb05vZGVPcHRpb24obmF0aXZlQXVkaW9Ob2RlLCBvcHRpb25zLCAnY2hhbm5lbENvdW50Jyk7XG4gICAgICBhc3NpZ25OYXRpdmVBdWRpb05vZGVPcHRpb24obmF0aXZlQXVkaW9Ob2RlLCBvcHRpb25zLCAnY2hhbm5lbENvdW50TW9kZScpO1xuICAgICAgYXNzaWduTmF0aXZlQXVkaW9Ob2RlT3B0aW9uKG5hdGl2ZUF1ZGlvTm9kZSwgb3B0aW9ucywgJ2NoYW5uZWxJbnRlcnByZXRhdGlvbicpO1xuICAgIH07XG5cbiAgICB2YXIgdGVzdEFuYWx5c2VyTm9kZUdldEZsb2F0VGltZURvbWFpbkRhdGFNZXRob2RTdXBwb3J0ID0gZnVuY3Rpb24gdGVzdEFuYWx5c2VyTm9kZUdldEZsb2F0VGltZURvbWFpbkRhdGFNZXRob2RTdXBwb3J0KG5hdGl2ZUFuYWx5c2VyTm9kZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiBuYXRpdmVBbmFseXNlck5vZGUuZ2V0RmxvYXRUaW1lRG9tYWluRGF0YSA9PT0gJ2Z1bmN0aW9uJztcbiAgICB9O1xuXG4gICAgdmFyIHdyYXBBbmFseXNlck5vZGVHZXRGbG9hdFRpbWVEb21haW5EYXRhTWV0aG9kID0gZnVuY3Rpb24gd3JhcEFuYWx5c2VyTm9kZUdldEZsb2F0VGltZURvbWFpbkRhdGFNZXRob2QobmF0aXZlQW5hbHlzZXJOb2RlKSB7XG4gICAgICBuYXRpdmVBbmFseXNlck5vZGUuZ2V0RmxvYXRUaW1lRG9tYWluRGF0YSA9IGZ1bmN0aW9uIChhcnJheSkge1xuICAgICAgICB2YXIgYnl0ZVRpbWVEb21haW5EYXRhID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXkubGVuZ3RoKTtcbiAgICAgICAgbmF0aXZlQW5hbHlzZXJOb2RlLmdldEJ5dGVUaW1lRG9tYWluRGF0YShieXRlVGltZURvbWFpbkRhdGEpO1xuICAgICAgICB2YXIgbGVuZ3RoID0gTWF0aC5tYXgoYnl0ZVRpbWVEb21haW5EYXRhLmxlbmd0aCwgbmF0aXZlQW5hbHlzZXJOb2RlLmZmdFNpemUpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgYXJyYXlbaV0gPSAoYnl0ZVRpbWVEb21haW5EYXRhW2ldIC0gMTI4KSAqIDAuMDA3ODEyNTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyYXk7XG4gICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlTmF0aXZlQW5hbHlzZXJOb2RlRmFjdG9yeSA9IGZ1bmN0aW9uIGNyZWF0ZU5hdGl2ZUFuYWx5c2VyTm9kZUZhY3RvcnkoY2FjaGVUZXN0UmVzdWx0LCBjcmVhdGVJbmRleFNpemVFcnJvcikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChuYXRpdmVDb250ZXh0LCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBuYXRpdmVBbmFseXNlck5vZGUgPSBuYXRpdmVDb250ZXh0LmNyZWF0ZUFuYWx5c2VyKCk7XG4gICAgICAgIC8vIEJ1ZyAjMzc6IEZpcmVmb3ggZG9lcyBub3QgY3JlYXRlIGFuIEFuYWx5c2VyTm9kZSB3aXRoIHRoZSBkZWZhdWx0IHByb3BlcnRpZXMuXG4gICAgICAgIGFzc2lnbk5hdGl2ZUF1ZGlvTm9kZU9wdGlvbnMobmF0aXZlQW5hbHlzZXJOb2RlLCBvcHRpb25zKTtcbiAgICAgICAgLy8gQnVnICMxMTg6IFNhZmFyaSBkb2VzIG5vdCB0aHJvdyBhbiBlcnJvciBpZiBtYXhEZWNpYmVscyBpcyBub3QgbW9yZSB0aGFuIG1pbkRlY2liZWxzLlxuICAgICAgICBpZiAoIShvcHRpb25zLm1heERlY2liZWxzID4gb3B0aW9ucy5taW5EZWNpYmVscykpIHtcbiAgICAgICAgICB0aHJvdyBjcmVhdGVJbmRleFNpemVFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIGFzc2lnbk5hdGl2ZUF1ZGlvTm9kZU9wdGlvbihuYXRpdmVBbmFseXNlck5vZGUsIG9wdGlvbnMsICdmZnRTaXplJyk7XG4gICAgICAgIGFzc2lnbk5hdGl2ZUF1ZGlvTm9kZU9wdGlvbihuYXRpdmVBbmFseXNlck5vZGUsIG9wdGlvbnMsICdtYXhEZWNpYmVscycpO1xuICAgICAgICBhc3NpZ25OYXRpdmVBdWRpb05vZGVPcHRpb24obmF0aXZlQW5hbHlzZXJOb2RlLCBvcHRpb25zLCAnbWluRGVjaWJlbHMnKTtcbiAgICAgICAgYXNzaWduTmF0aXZlQXVkaW9Ob2RlT3B0aW9uKG5hdGl2ZUFuYWx5c2VyTm9kZSwgb3B0aW9ucywgJ3Ntb290aGluZ1RpbWVDb25zdGFudCcpO1xuICAgICAgICAvLyBCdWcgIzM2OiBTYWZhcmkgZG9lcyBub3Qgc3VwcG9ydCBnZXRGbG9hdFRpbWVEb21haW5EYXRhKCkgeWV0LlxuICAgICAgICBpZiAoIWNhY2hlVGVzdFJlc3VsdCh0ZXN0QW5hbHlzZXJOb2RlR2V0RmxvYXRUaW1lRG9tYWluRGF0YU1ldGhvZFN1cHBvcnQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gdGVzdEFuYWx5c2VyTm9kZUdldEZsb2F0VGltZURvbWFpbkRhdGFNZXRob2RTdXBwb3J0KG5hdGl2ZUFuYWx5c2VyTm9kZSk7XG4gICAgICAgIH0pKSB7XG4gICAgICAgICAgd3JhcEFuYWx5c2VyTm9kZUdldEZsb2F0VGltZURvbWFpbkRhdGFNZXRob2QobmF0aXZlQW5hbHlzZXJOb2RlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmF0aXZlQW5hbHlzZXJOb2RlO1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZU5hdGl2ZUF1ZGlvQnVmZmVyQ29uc3RydWN0b3IgPSBmdW5jdGlvbiBjcmVhdGVOYXRpdmVBdWRpb0J1ZmZlckNvbnN0cnVjdG9yKHdpbmRvdykge1xuICAgICAgaWYgKHdpbmRvdyA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmICh3aW5kb3cuaGFzT3duUHJvcGVydHkoJ0F1ZGlvQnVmZmVyJykpIHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5BdWRpb0J1ZmZlcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICB2YXIgYXNzaWduTmF0aXZlQXVkaW9Ob2RlQXVkaW9QYXJhbVZhbHVlID0gZnVuY3Rpb24gYXNzaWduTmF0aXZlQXVkaW9Ob2RlQXVkaW9QYXJhbVZhbHVlKG5hdGl2ZUF1ZGlvTm9kZSwgb3B0aW9ucywgYXVkaW9QYXJhbSkge1xuICAgICAgdmFyIHZhbHVlID0gb3B0aW9uc1thdWRpb1BhcmFtXTtcbiAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBuYXRpdmVBdWRpb05vZGVbYXVkaW9QYXJhbV0udmFsdWUpIHtcbiAgICAgICAgbmF0aXZlQXVkaW9Ob2RlW2F1ZGlvUGFyYW1dLnZhbHVlID0gdmFsdWU7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciB3cmFwQXVkaW9CdWZmZXJTb3VyY2VOb2RlU3RhcnRNZXRob2RDb25zZWN1dGl2ZUNhbGxzID0gZnVuY3Rpb24gd3JhcEF1ZGlvQnVmZmVyU291cmNlTm9kZVN0YXJ0TWV0aG9kQ29uc2VjdXRpdmVDYWxscyhuYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGUpIHtcbiAgICAgIG5hdGl2ZUF1ZGlvQnVmZmVyU291cmNlTm9kZS5zdGFydCA9IGZ1bmN0aW9uIChzdGFydCkge1xuICAgICAgICB2YXIgaXNTY2hlZHVsZWQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgd2hlbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogMDtcbiAgICAgICAgICB2YXIgb2Zmc2V0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuICAgICAgICAgIHZhciBkdXJhdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkO1xuICAgICAgICAgIGlmIChpc1NjaGVkdWxlZCkge1xuICAgICAgICAgICAgdGhyb3cgY3JlYXRlSW52YWxpZFN0YXRlRXJyb3IoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3RhcnQuY2FsbChuYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGUsIHdoZW4sIG9mZnNldCwgZHVyYXRpb24pO1xuICAgICAgICAgIGlzU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgIH0obmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2RlLnN0YXJ0KTtcbiAgICB9O1xuXG4gICAgdmFyIHdyYXBBdWRpb1NjaGVkdWxlZFNvdXJjZU5vZGVTdGFydE1ldGhvZE5lZ2F0aXZlUGFyYW1ldGVycyA9IGZ1bmN0aW9uIHdyYXBBdWRpb1NjaGVkdWxlZFNvdXJjZU5vZGVTdGFydE1ldGhvZE5lZ2F0aXZlUGFyYW1ldGVycyhuYXRpdmVBdWRpb1NjaGVkdWxlZFNvdXJjZU5vZGUpIHtcbiAgICAgIG5hdGl2ZUF1ZGlvU2NoZWR1bGVkU291cmNlTm9kZS5zdGFydCA9IGZ1bmN0aW9uIChzdGFydCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciB3aGVuID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAwO1xuICAgICAgICAgIHZhciBvZmZzZXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDA7XG4gICAgICAgICAgdmFyIGR1cmF0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgaWYgKHR5cGVvZiBkdXJhdGlvbiA9PT0gJ251bWJlcicgJiYgZHVyYXRpb24gPCAwIHx8IG9mZnNldCA8IDAgfHwgd2hlbiA8IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiVGhlIHBhcmFtZXRlcnMgY2FuJ3QgYmUgbmVnYXRpdmUuXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBAdG9kbyBUeXBlU2NyaXB0IGNhbm5vdCBpbmZlciB0aGUgb3ZlcmxvYWRlZCBzaWduYXR1cmUgd2l0aCAzIGFyZ3VtZW50cyB5ZXQuXG4gICAgICAgICAgc3RhcnQuY2FsbChuYXRpdmVBdWRpb1NjaGVkdWxlZFNvdXJjZU5vZGUsIHdoZW4sIG9mZnNldCwgZHVyYXRpb24pO1xuICAgICAgICB9O1xuICAgICAgfShuYXRpdmVBdWRpb1NjaGVkdWxlZFNvdXJjZU5vZGUuc3RhcnQpO1xuICAgIH07XG5cbiAgICB2YXIgd3JhcEF1ZGlvU2NoZWR1bGVkU291cmNlTm9kZVN0b3BNZXRob2ROZWdhdGl2ZVBhcmFtZXRlcnMgPSBmdW5jdGlvbiB3cmFwQXVkaW9TY2hlZHVsZWRTb3VyY2VOb2RlU3RvcE1ldGhvZE5lZ2F0aXZlUGFyYW1ldGVycyhuYXRpdmVBdWRpb1NjaGVkdWxlZFNvdXJjZU5vZGUpIHtcbiAgICAgIG5hdGl2ZUF1ZGlvU2NoZWR1bGVkU291cmNlTm9kZS5zdG9wID0gZnVuY3Rpb24gKHN0b3ApIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgd2hlbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogMDtcbiAgICAgICAgICBpZiAod2hlbiA8IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiVGhlIHBhcmFtZXRlciBjYW4ndCBiZSBuZWdhdGl2ZS5cIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0b3AuY2FsbChuYXRpdmVBdWRpb1NjaGVkdWxlZFNvdXJjZU5vZGUsIHdoZW4pO1xuICAgICAgICB9O1xuICAgICAgfShuYXRpdmVBdWRpb1NjaGVkdWxlZFNvdXJjZU5vZGUuc3RvcCk7XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVOYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGVGYWN0b3J5ID0gZnVuY3Rpb24gY3JlYXRlTmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2RlRmFjdG9yeShhZGRTaWxlbnRDb25uZWN0aW9uLCBjYWNoZVRlc3RSZXN1bHQsIHRlc3RBdWRpb0J1ZmZlclNvdXJjZU5vZGVTdGFydE1ldGhvZENvbnNlY3V0aXZlQ2FsbHNTdXBwb3J0LCB0ZXN0QXVkaW9CdWZmZXJTb3VyY2VOb2RlU3RhcnRNZXRob2RPZmZzZXRDbGFtcGluZ1N1cHBvcnQsIHRlc3RBdWRpb0J1ZmZlclNvdXJjZU5vZGVTdG9wTWV0aG9kTnVsbGlmaWVkQnVmZmVyU3VwcG9ydCwgdGVzdEF1ZGlvU2NoZWR1bGVkU291cmNlTm9kZVN0YXJ0TWV0aG9kTmVnYXRpdmVQYXJhbWV0ZXJzU3VwcG9ydCwgdGVzdEF1ZGlvU2NoZWR1bGVkU291cmNlTm9kZVN0b3BNZXRob2RDb25zZWN1dGl2ZUNhbGxzU3VwcG9ydCwgdGVzdEF1ZGlvU2NoZWR1bGVkU291cmNlTm9kZVN0b3BNZXRob2ROZWdhdGl2ZVBhcmFtZXRlcnNTdXBwb3J0LCB3cmFwQXVkaW9CdWZmZXJTb3VyY2VOb2RlU3RhcnRNZXRob2RPZmZzZXRDbGFtcGxpbmcsIHdyYXBBdWRpb0J1ZmZlclNvdXJjZU5vZGVTdG9wTWV0aG9kTnVsbGlmaWVkQnVmZmVyLCB3cmFwQXVkaW9TY2hlZHVsZWRTb3VyY2VOb2RlU3RvcE1ldGhvZENvbnNlY3V0aXZlQ2FsbHMpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAobmF0aXZlQ29udGV4dCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgbmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2RlID0gbmF0aXZlQ29udGV4dC5jcmVhdGVCdWZmZXJTb3VyY2UoKTtcbiAgICAgICAgYXNzaWduTmF0aXZlQXVkaW9Ob2RlT3B0aW9ucyhuYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGUsIG9wdGlvbnMpO1xuICAgICAgICBhc3NpZ25OYXRpdmVBdWRpb05vZGVBdWRpb1BhcmFtVmFsdWUobmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2RlLCBvcHRpb25zLCAncGxheWJhY2tSYXRlJyk7XG4gICAgICAgIGFzc2lnbk5hdGl2ZUF1ZGlvTm9kZU9wdGlvbihuYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGUsIG9wdGlvbnMsICdidWZmZXInKTtcbiAgICAgICAgLy8gQnVnICMxNDk6IFNhZmFyaSBkb2VzIG5vdCB5ZXQgc3VwcG9ydCB0aGUgZGV0dW5lIEF1ZGlvUGFyYW0uXG4gICAgICAgIGFzc2lnbk5hdGl2ZUF1ZGlvTm9kZU9wdGlvbihuYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGUsIG9wdGlvbnMsICdsb29wJyk7XG4gICAgICAgIGFzc2lnbk5hdGl2ZUF1ZGlvTm9kZU9wdGlvbihuYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGUsIG9wdGlvbnMsICdsb29wRW5kJyk7XG4gICAgICAgIGFzc2lnbk5hdGl2ZUF1ZGlvTm9kZU9wdGlvbihuYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGUsIG9wdGlvbnMsICdsb29wU3RhcnQnKTtcbiAgICAgICAgLy8gQnVnICM2OTogU2FmYXJpIGRvZXMgYWxsb3cgY2FsbHMgdG8gc3RhcnQoKSBvZiBhbiBhbHJlYWR5IHNjaGVkdWxlZCBBdWRpb0J1ZmZlclNvdXJjZU5vZGUuXG4gICAgICAgIGlmICghY2FjaGVUZXN0UmVzdWx0KHRlc3RBdWRpb0J1ZmZlclNvdXJjZU5vZGVTdGFydE1ldGhvZENvbnNlY3V0aXZlQ2FsbHNTdXBwb3J0LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHRlc3RBdWRpb0J1ZmZlclNvdXJjZU5vZGVTdGFydE1ldGhvZENvbnNlY3V0aXZlQ2FsbHNTdXBwb3J0KG5hdGl2ZUNvbnRleHQpO1xuICAgICAgICB9KSkge1xuICAgICAgICAgIHdyYXBBdWRpb0J1ZmZlclNvdXJjZU5vZGVTdGFydE1ldGhvZENvbnNlY3V0aXZlQ2FsbHMobmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2RlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBCdWcgIzE1NCAmICMxNTU6IFNhZmFyaSBkb2VzIG5vdCBoYW5kbGUgb2Zmc2V0cyB3aGljaCBhcmUgZXF1YWwgdG8gb3IgZ3JlYXRlciB0aGFuIHRoZSBkdXJhdGlvbiBvZiB0aGUgYnVmZmVyLlxuICAgICAgICBpZiAoIWNhY2hlVGVzdFJlc3VsdCh0ZXN0QXVkaW9CdWZmZXJTb3VyY2VOb2RlU3RhcnRNZXRob2RPZmZzZXRDbGFtcGluZ1N1cHBvcnQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gdGVzdEF1ZGlvQnVmZmVyU291cmNlTm9kZVN0YXJ0TWV0aG9kT2Zmc2V0Q2xhbXBpbmdTdXBwb3J0KG5hdGl2ZUNvbnRleHQpO1xuICAgICAgICB9KSkge1xuICAgICAgICAgIHdyYXBBdWRpb0J1ZmZlclNvdXJjZU5vZGVTdGFydE1ldGhvZE9mZnNldENsYW1wbGluZyhuYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEJ1ZyAjMTYyOiBTYWZhcmkgZG9lcyB0aHJvdyBhbiBlcnJvciB3aGVuIHN0b3AoKSBpcyBjYWxsZWQgb24gYW4gQXVkaW9CdWZmZXJTb3VyY2VOb2RlIHdoaWNoIGhhcyBubyBidWZmZXIgYXNzaWduZWQgdG8gaXQuXG4gICAgICAgIGlmICghY2FjaGVUZXN0UmVzdWx0KHRlc3RBdWRpb0J1ZmZlclNvdXJjZU5vZGVTdG9wTWV0aG9kTnVsbGlmaWVkQnVmZmVyU3VwcG9ydCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB0ZXN0QXVkaW9CdWZmZXJTb3VyY2VOb2RlU3RvcE1ldGhvZE51bGxpZmllZEJ1ZmZlclN1cHBvcnQobmF0aXZlQ29udGV4dCk7XG4gICAgICAgIH0pKSB7XG4gICAgICAgICAgd3JhcEF1ZGlvQnVmZmVyU291cmNlTm9kZVN0b3BNZXRob2ROdWxsaWZpZWRCdWZmZXIobmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2RlLCBuYXRpdmVDb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBCdWcgIzQ0OiBTYWZhcmkgZG9lcyBub3QgdGhyb3cgYSBSYW5nZUVycm9yIHlldC5cbiAgICAgICAgaWYgKCFjYWNoZVRlc3RSZXN1bHQodGVzdEF1ZGlvU2NoZWR1bGVkU291cmNlTm9kZVN0YXJ0TWV0aG9kTmVnYXRpdmVQYXJhbWV0ZXJzU3VwcG9ydCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB0ZXN0QXVkaW9TY2hlZHVsZWRTb3VyY2VOb2RlU3RhcnRNZXRob2ROZWdhdGl2ZVBhcmFtZXRlcnNTdXBwb3J0KG5hdGl2ZUNvbnRleHQpO1xuICAgICAgICB9KSkge1xuICAgICAgICAgIHdyYXBBdWRpb1NjaGVkdWxlZFNvdXJjZU5vZGVTdGFydE1ldGhvZE5lZ2F0aXZlUGFyYW1ldGVycyhuYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEJ1ZyAjMTk6IFNhZmFyaSBkb2VzIG5vdCBpZ25vcmUgY2FsbHMgdG8gc3RvcCgpIG9mIGFuIGFscmVhZHkgc3RvcHBlZCBBdWRpb0J1ZmZlclNvdXJjZU5vZGUuXG4gICAgICAgIGlmICghY2FjaGVUZXN0UmVzdWx0KHRlc3RBdWRpb1NjaGVkdWxlZFNvdXJjZU5vZGVTdG9wTWV0aG9kQ29uc2VjdXRpdmVDYWxsc1N1cHBvcnQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gdGVzdEF1ZGlvU2NoZWR1bGVkU291cmNlTm9kZVN0b3BNZXRob2RDb25zZWN1dGl2ZUNhbGxzU3VwcG9ydChuYXRpdmVDb250ZXh0KTtcbiAgICAgICAgfSkpIHtcbiAgICAgICAgICB3cmFwQXVkaW9TY2hlZHVsZWRTb3VyY2VOb2RlU3RvcE1ldGhvZENvbnNlY3V0aXZlQ2FsbHMobmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2RlLCBuYXRpdmVDb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBCdWcgIzQ0OiBPbmx5IEZpcmVmb3ggZG9lcyBub3QgdGhyb3cgYSBSYW5nZUVycm9yIHlldC5cbiAgICAgICAgaWYgKCFjYWNoZVRlc3RSZXN1bHQodGVzdEF1ZGlvU2NoZWR1bGVkU291cmNlTm9kZVN0b3BNZXRob2ROZWdhdGl2ZVBhcmFtZXRlcnNTdXBwb3J0LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHRlc3RBdWRpb1NjaGVkdWxlZFNvdXJjZU5vZGVTdG9wTWV0aG9kTmVnYXRpdmVQYXJhbWV0ZXJzU3VwcG9ydChuYXRpdmVDb250ZXh0KTtcbiAgICAgICAgfSkpIHtcbiAgICAgICAgICB3cmFwQXVkaW9TY2hlZHVsZWRTb3VyY2VOb2RlU3RvcE1ldGhvZE5lZ2F0aXZlUGFyYW1ldGVycyhuYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEJ1ZyAjMTc1OiBTYWZhcmkgd2lsbCBub3QgZmlyZSBhbiBlbmRlZCBldmVudCBpZiB0aGUgQXVkaW9CdWZmZXJTb3VyY2VOb2RlIGlzIHVuY29ubmVjdGVkLlxuICAgICAgICBhZGRTaWxlbnRDb25uZWN0aW9uKG5hdGl2ZUNvbnRleHQsIG5hdGl2ZUF1ZGlvQnVmZmVyU291cmNlTm9kZSk7XG4gICAgICAgIHJldHVybiBuYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGU7XG4gICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlTmF0aXZlQXVkaW9Db250ZXh0Q29uc3RydWN0b3IgPSBmdW5jdGlvbiBjcmVhdGVOYXRpdmVBdWRpb0NvbnRleHRDb25zdHJ1Y3Rvcih3aW5kb3cpIHtcbiAgICAgIGlmICh3aW5kb3cgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBpZiAod2luZG93Lmhhc093blByb3BlcnR5KCdBdWRpb0NvbnRleHQnKSkge1xuICAgICAgICByZXR1cm4gd2luZG93LkF1ZGlvQ29udGV4dDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3aW5kb3cuaGFzT3duUHJvcGVydHkoJ3dlYmtpdEF1ZGlvQ29udGV4dCcpID8gd2luZG93LndlYmtpdEF1ZGlvQ29udGV4dCA6IG51bGw7XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVOYXRpdmVBdWRpb0Rlc3RpbmF0aW9uTm9kZUZhY3RvcnkgPSBmdW5jdGlvbiBjcmVhdGVOYXRpdmVBdWRpb0Rlc3RpbmF0aW9uTm9kZUZhY3RvcnkoY3JlYXRlTmF0aXZlR2Fpbk5vZGUsIG92ZXJ3cml0ZUFjY2Vzc29ycykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChuYXRpdmVDb250ZXh0LCBjaGFubmVsQ291bnQsIGlzTm9kZU9mTmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCkge1xuICAgICAgICB2YXIgbmF0aXZlQXVkaW9EZXN0aW5hdGlvbk5vZGUgPSBuYXRpdmVDb250ZXh0LmRlc3RpbmF0aW9uO1xuICAgICAgICAvLyBCdWcgIzEzMjogU2FmYXJpIGRvZXMgbm90IGhhdmUgdGhlIGNvcnJlY3QgY2hhbm5lbENvdW50LlxuICAgICAgICBpZiAobmF0aXZlQXVkaW9EZXN0aW5hdGlvbk5vZGUuY2hhbm5lbENvdW50ICE9PSBjaGFubmVsQ291bnQpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgbmF0aXZlQXVkaW9EZXN0aW5hdGlvbk5vZGUuY2hhbm5lbENvdW50ID0gY2hhbm5lbENvdW50O1xuICAgICAgICAgIH0gY2F0Y2ggKF91bnVzZWQpIHtcbiAgICAgICAgICAgIC8vIEJ1ZyAjMTY5OiBTYWZhcmkgdGhyb3dzIGFuIGVycm9yIG9uIGVhY2ggYXR0ZW1wdCB0byBjaGFuZ2UgdGhlIGNoYW5uZWxDb3VudC5cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQnVnICM4MzogU2FmYXJpIGRvZXMgbm90IGhhdmUgdGhlIGNvcnJlY3QgY2hhbm5lbENvdW50TW9kZS5cbiAgICAgICAgaWYgKGlzTm9kZU9mTmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCAmJiBuYXRpdmVBdWRpb0Rlc3RpbmF0aW9uTm9kZS5jaGFubmVsQ291bnRNb2RlICE9PSAnZXhwbGljaXQnKSB7XG4gICAgICAgICAgbmF0aXZlQXVkaW9EZXN0aW5hdGlvbk5vZGUuY2hhbm5lbENvdW50TW9kZSA9ICdleHBsaWNpdCc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQnVnICM0NzogVGhlIEF1ZGlvRGVzdGluYXRpb25Ob2RlIGluIFNhZmFyaSBkb2VzIG5vdCBpbml0aWFsaXplIHRoZSBtYXhDaGFubmVsQ291bnQgcHJvcGVydHkgY29ycmVjdGx5LlxuICAgICAgICBpZiAobmF0aXZlQXVkaW9EZXN0aW5hdGlvbk5vZGUubWF4Q2hhbm5lbENvdW50ID09PSAwKSB7XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5hdGl2ZUF1ZGlvRGVzdGluYXRpb25Ob2RlLCAnbWF4Q2hhbm5lbENvdW50Jywge1xuICAgICAgICAgICAgdmFsdWU6IGNoYW5uZWxDb3VudFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIEJ1ZyAjMTY4OiBObyBicm93c2VyIGRvZXMgeWV0IGhhdmUgYW4gQXVkaW9EZXN0aW5hdGlvbk5vZGUgd2l0aCBhbiBvdXRwdXQuXG4gICAgICAgIHZhciBnYWluTm9kZSA9IGNyZWF0ZU5hdGl2ZUdhaW5Ob2RlKG5hdGl2ZUNvbnRleHQsIHtcbiAgICAgICAgICBjaGFubmVsQ291bnQ6IGNoYW5uZWxDb3VudCxcbiAgICAgICAgICBjaGFubmVsQ291bnRNb2RlOiBuYXRpdmVBdWRpb0Rlc3RpbmF0aW9uTm9kZS5jaGFubmVsQ291bnRNb2RlLFxuICAgICAgICAgIGNoYW5uZWxJbnRlcnByZXRhdGlvbjogbmF0aXZlQXVkaW9EZXN0aW5hdGlvbk5vZGUuY2hhbm5lbEludGVycHJldGF0aW9uLFxuICAgICAgICAgIGdhaW46IDFcbiAgICAgICAgfSk7XG4gICAgICAgIG92ZXJ3cml0ZUFjY2Vzc29ycyhnYWluTm9kZSwgJ2NoYW5uZWxDb3VudCcsIGZ1bmN0aW9uIChnZXQpIHtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGdldC5jYWxsKGdhaW5Ob2RlKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9LCBmdW5jdGlvbiAoc2V0KSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgc2V0LmNhbGwoZ2Fpbk5vZGUsIHZhbHVlKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIG5hdGl2ZUF1ZGlvRGVzdGluYXRpb25Ob2RlLmNoYW5uZWxDb3VudCA9IHZhbHVlO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgIC8vIEJ1ZyAjMTY5OiBTYWZhcmkgdGhyb3dzIGFuIGVycm9yIG9uIGVhY2ggYXR0ZW1wdCB0byBjaGFuZ2UgdGhlIGNoYW5uZWxDb3VudC5cbiAgICAgICAgICAgICAgaWYgKHZhbHVlID4gbmF0aXZlQXVkaW9EZXN0aW5hdGlvbk5vZGUubWF4Q2hhbm5lbENvdW50KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIG92ZXJ3cml0ZUFjY2Vzc29ycyhnYWluTm9kZSwgJ2NoYW5uZWxDb3VudE1vZGUnLCBmdW5jdGlvbiAoZ2V0KSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXQuY2FsbChnYWluTm9kZSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKHNldCkge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHNldC5jYWxsKGdhaW5Ob2RlLCB2YWx1ZSk7XG4gICAgICAgICAgICBuYXRpdmVBdWRpb0Rlc3RpbmF0aW9uTm9kZS5jaGFubmVsQ291bnRNb2RlID0gdmFsdWU7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIG92ZXJ3cml0ZUFjY2Vzc29ycyhnYWluTm9kZSwgJ2NoYW5uZWxJbnRlcnByZXRhdGlvbicsIGZ1bmN0aW9uIChnZXQpIHtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGdldC5jYWxsKGdhaW5Ob2RlKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9LCBmdW5jdGlvbiAoc2V0KSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgc2V0LmNhbGwoZ2Fpbk5vZGUsIHZhbHVlKTtcbiAgICAgICAgICAgIG5hdGl2ZUF1ZGlvRGVzdGluYXRpb25Ob2RlLmNoYW5uZWxJbnRlcnByZXRhdGlvbiA9IHZhbHVlO1xuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZ2Fpbk5vZGUsICdtYXhDaGFubmVsQ291bnQnLCB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmF0aXZlQXVkaW9EZXN0aW5hdGlvbk5vZGUubWF4Q2hhbm5lbENvdW50O1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEB0b2RvIFRoaXMgc2hvdWxkIGJlIGRpc2Nvbm5lY3RlZCB3aGVuIHRoZSBjb250ZXh0IGlzIGNsb3NlZC5cbiAgICAgICAgZ2Fpbk5vZGUuY29ubmVjdChuYXRpdmVBdWRpb0Rlc3RpbmF0aW9uTm9kZSk7XG4gICAgICAgIHJldHVybiBnYWluTm9kZTtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVOYXRpdmVBdWRpb1dvcmtsZXROb2RlQ29uc3RydWN0b3IgPSBmdW5jdGlvbiBjcmVhdGVOYXRpdmVBdWRpb1dvcmtsZXROb2RlQ29uc3RydWN0b3Iod2luZG93KSB7XG4gICAgICBpZiAod2luZG93ID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdpbmRvdy5oYXNPd25Qcm9wZXJ0eSgnQXVkaW9Xb3JrbGV0Tm9kZScpID8gd2luZG93LkF1ZGlvV29ya2xldE5vZGUgOiBudWxsO1xuICAgIH07XG5cbiAgICB2YXIgdGVzdENsb25hYmlsaXR5T2ZBdWRpb1dvcmtsZXROb2RlT3B0aW9ucyA9IGZ1bmN0aW9uIHRlc3RDbG9uYWJpbGl0eU9mQXVkaW9Xb3JrbGV0Tm9kZU9wdGlvbnMoYXVkaW9Xb3JrbGV0Tm9kZU9wdGlvbnMpIHtcbiAgICAgIHZhciBfTWVzc2FnZUNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKSxcbiAgICAgICAgcG9ydDEgPSBfTWVzc2FnZUNoYW5uZWwucG9ydDE7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBUaGlzIHdpbGwgdGhyb3cgYW4gZXJyb3IgaWYgdGhlIGF1ZGlvV29ya2xldE5vZGVPcHRpb25zIGFyZSBub3QgY2xvbmFibGUuXG4gICAgICAgIHBvcnQxLnBvc3RNZXNzYWdlKGF1ZGlvV29ya2xldE5vZGVPcHRpb25zKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHBvcnQxLmNsb3NlKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIG93bktleXMkZihlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XG4gICAgZnVuY3Rpb24gX29iamVjdFNwcmVhZCRmKGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMkZihPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMkZihPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxuICAgIHZhciBjcmVhdGVOYXRpdmVBdWRpb1dvcmtsZXROb2RlRmFjdG9yeSA9IGZ1bmN0aW9uIGNyZWF0ZU5hdGl2ZUF1ZGlvV29ya2xldE5vZGVGYWN0b3J5KGNyZWF0ZUludmFsaWRTdGF0ZUVycm9yLCBjcmVhdGVOYXRpdmVBdWRpb1dvcmtsZXROb2RlRmFrZXIsIGNyZWF0ZU5hdGl2ZUdhaW5Ob2RlLCBjcmVhdGVOb3RTdXBwb3J0ZWRFcnJvciwgbW9uaXRvckNvbm5lY3Rpb25zKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKG5hdGl2ZUNvbnRleHQsIGJhc2VMYXRlbmN5LCBuYXRpdmVBdWRpb1dvcmtsZXROb2RlQ29uc3RydWN0b3IsIG5hbWUsIHByb2Nlc3NvckNvbnN0cnVjdG9yLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChuYXRpdmVBdWRpb1dvcmtsZXROb2RlQ29uc3RydWN0b3IgIT09IG51bGwpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIG5hdGl2ZUF1ZGlvV29ya2xldE5vZGUgPSBuZXcgbmF0aXZlQXVkaW9Xb3JrbGV0Tm9kZUNvbnN0cnVjdG9yKG5hdGl2ZUNvbnRleHQsIG5hbWUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgdmFyIHBhdGNoZWRFdmVudExpc3RlbmVycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIHZhciBvbnByb2Nlc3NvcmVycm9yID0gbnVsbDtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKG5hdGl2ZUF1ZGlvV29ya2xldE5vZGUsIHtcbiAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICogQnVnICM2MTogT3ZlcndyaXRpbmcgdGhlIHByb3BlcnR5IGFjY2Vzc29ycyBmb3IgY2hhbm5lbENvdW50IGFuZCBjaGFubmVsQ291bnRNb2RlIGlzIG5lY2Vzc2FyeSBhcyBsb25nIGFzIHNvbWVcbiAgICAgICAgICAgICAgICogYnJvd3NlcnMgaGF2ZSBubyBuYXRpdmUgaW1wbGVtZW50YXRpb24gdG8gYWNoaWV2ZSBhIGNvbnNpc3RlbnQgYmVoYXZpb3IuXG4gICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICBjaGFubmVsQ291bnQ6IHtcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zLmNoYW5uZWxDb3VudDtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KCkge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgY3JlYXRlSW52YWxpZFN0YXRlRXJyb3IoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGNoYW5uZWxDb3VudE1vZGU6IHtcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiAnZXhwbGljaXQnO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoKSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBjcmVhdGVJbnZhbGlkU3RhdGVFcnJvcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgLy8gQnVnICMxNTY6IENocm9tZSBhbmQgRWRnZSBkbyBub3QgeWV0IGZpcmUgYW4gRXJyb3JFdmVudC5cbiAgICAgICAgICAgICAgb25wcm9jZXNzb3JlcnJvcjoge1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG9ucHJvY2Vzc29yZXJyb3I7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvbnByb2Nlc3NvcmVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIG5hdGl2ZUF1ZGlvV29ya2xldE5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcigncHJvY2Vzc29yZXJyb3InLCBvbnByb2Nlc3NvcmVycm9yKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIG9ucHJvY2Vzc29yZXJyb3IgPSB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgPyB2YWx1ZSA6IG51bGw7XG4gICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9ucHJvY2Vzc29yZXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgbmF0aXZlQXVkaW9Xb3JrbGV0Tm9kZS5hZGRFdmVudExpc3RlbmVyKCdwcm9jZXNzb3JlcnJvcicsIG9ucHJvY2Vzc29yZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBuYXRpdmVBdWRpb1dvcmtsZXROb2RlLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAoYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICAgICAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGFyZ3NbMF0gPT09ICdwcm9jZXNzb3JlcnJvcicpIHtcbiAgICAgICAgICAgICAgICAgIHZhciB1bnBhdGNoZWRFdmVudExpc3RlbmVyID0gdHlwZW9mIGFyZ3NbMV0gPT09ICdmdW5jdGlvbicgPyBhcmdzWzFdIDogX3R5cGVvZihhcmdzWzFdKSA9PT0gJ29iamVjdCcgJiYgYXJnc1sxXSAhPT0gbnVsbCAmJiB0eXBlb2YgYXJnc1sxXS5oYW5kbGVFdmVudCA9PT0gJ2Z1bmN0aW9uJyA/IGFyZ3NbMV0uaGFuZGxlRXZlbnQgOiBudWxsO1xuICAgICAgICAgICAgICAgICAgaWYgKHVucGF0Y2hlZEV2ZW50TGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhdGNoZWRFdmVudExpc3RlbmVyID0gcGF0Y2hlZEV2ZW50TGlzdGVuZXJzLmdldChhcmdzWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhdGNoZWRFdmVudExpc3RlbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICBhcmdzWzFdID0gcGF0Y2hlZEV2ZW50TGlzdGVuZXI7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgYXJnc1sxXSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQnVnICMxNzg6IENocm9tZSBhbmQgRWRnZSBkbyBmaXJlIGFuIGV2ZW50IG9mIHR5cGUgZXJyb3IuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ2Vycm9yJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhldmVudCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiAncHJvY2Vzc29yZXJyb3InXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdW5wYXRjaGVkRXZlbnRMaXN0ZW5lcihldmVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICB1bnBhdGNoZWRFdmVudExpc3RlbmVyKG5ldyBFcnJvckV2ZW50KGFyZ3NbMF0sIF9vYmplY3RTcHJlYWQkZih7fSwgZXZlbnQpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICBwYXRjaGVkRXZlbnRMaXN0ZW5lcnMuc2V0KHVucGF0Y2hlZEV2ZW50TGlzdGVuZXIsIGFyZ3NbMV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEJ1ZyAjMTc4OiBDaHJvbWUgYW5kIEVkZ2UgZG8gZmlyZSBhbiBldmVudCBvZiB0eXBlIGVycm9yLlxuICAgICAgICAgICAgICAgIGFkZEV2ZW50TGlzdGVuZXIuY2FsbChuYXRpdmVBdWRpb1dvcmtsZXROb2RlLCAnZXJyb3InLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWRkRXZlbnRMaXN0ZW5lci5jYWxsLmFwcGx5KGFkZEV2ZW50TGlzdGVuZXIsIFtuYXRpdmVBdWRpb1dvcmtsZXROb2RlXS5jb25jYXQoYXJncykpO1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfShuYXRpdmVBdWRpb1dvcmtsZXROb2RlLmFkZEV2ZW50TGlzdGVuZXIpO1xuICAgICAgICAgICAgbmF0aXZlQXVkaW9Xb3JrbGV0Tm9kZS5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKHJlbW92ZUV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgICAgICAgICAgIGFyZ3NbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGFyZ3NbMF0gPT09ICdwcm9jZXNzb3JlcnJvcicpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBwYXRjaGVkRXZlbnRMaXN0ZW5lciA9IHBhdGNoZWRFdmVudExpc3RlbmVycy5nZXQoYXJnc1sxXSk7XG4gICAgICAgICAgICAgICAgICBpZiAocGF0Y2hlZEV2ZW50TGlzdGVuZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBwYXRjaGVkRXZlbnRMaXN0ZW5lcnNbXCJkZWxldGVcIl0oYXJnc1sxXSk7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3NbMV0gPSBwYXRjaGVkRXZlbnRMaXN0ZW5lcjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQnVnICMxNzg6IENocm9tZSBhbmQgRWRnZSBkbyBmaXJlIGFuIGV2ZW50IG9mIHR5cGUgZXJyb3IuXG4gICAgICAgICAgICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lci5jYWxsKG5hdGl2ZUF1ZGlvV29ya2xldE5vZGUsICdlcnJvcicsIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgICAgICAgICAgICAgIHJldHVybiByZW1vdmVFdmVudExpc3RlbmVyLmNhbGwobmF0aXZlQXVkaW9Xb3JrbGV0Tm9kZSwgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KG5hdGl2ZUF1ZGlvV29ya2xldE5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcik7XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogQnVnICM4NjogQ2hyb21lIGFuZCBFZGdlIGRvIG5vdCBpbnZva2UgdGhlIHByb2Nlc3MoKSBmdW5jdGlvbiBpZiB0aGUgY29ycmVzcG9uZGluZyBBdWRpb1dvcmtsZXROb2RlIGlzIHVuY29ubmVjdGVkIGJ1dFxuICAgICAgICAgICAgICogaGFzIGFuIG91dHB1dC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMubnVtYmVyT2ZPdXRwdXRzICE9PSAwKSB7XG4gICAgICAgICAgICAgIHZhciBuYXRpdmVHYWluTm9kZSA9IGNyZWF0ZU5hdGl2ZUdhaW5Ob2RlKG5hdGl2ZUNvbnRleHQsIHtcbiAgICAgICAgICAgICAgICBjaGFubmVsQ291bnQ6IDEsXG4gICAgICAgICAgICAgICAgY2hhbm5lbENvdW50TW9kZTogJ2V4cGxpY2l0JyxcbiAgICAgICAgICAgICAgICBjaGFubmVsSW50ZXJwcmV0YXRpb246ICdkaXNjcmV0ZScsXG4gICAgICAgICAgICAgICAgZ2FpbjogMFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgbmF0aXZlQXVkaW9Xb3JrbGV0Tm9kZS5jb25uZWN0KG5hdGl2ZUdhaW5Ob2RlKS5jb25uZWN0KG5hdGl2ZUNvbnRleHQuZGVzdGluYXRpb24pO1xuICAgICAgICAgICAgICB2YXIgd2hlbkNvbm5lY3RlZCA9IGZ1bmN0aW9uIHdoZW5Db25uZWN0ZWQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5hdGl2ZUdhaW5Ob2RlLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgdmFyIHdoZW5EaXNjb25uZWN0ZWQgPSBmdW5jdGlvbiB3aGVuRGlzY29ubmVjdGVkKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuYXRpdmVHYWluTm9kZS5jb25uZWN0KG5hdGl2ZUNvbnRleHQuZGVzdGluYXRpb24pO1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAvLyBAdG9kbyBEaXNjb25uZWN0IHRoZSBjb25uZWN0aW9uIHdoZW4gdGhlIHByb2Nlc3MoKSBmdW5jdGlvbiBvZiB0aGUgQXVkaW9Xb3JrbGV0Tm9kZSByZXR1cm5zIGZhbHNlLlxuICAgICAgICAgICAgICByZXR1cm4gbW9uaXRvckNvbm5lY3Rpb25zKG5hdGl2ZUF1ZGlvV29ya2xldE5vZGUsIHdoZW5Db25uZWN0ZWQsIHdoZW5EaXNjb25uZWN0ZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5hdGl2ZUF1ZGlvV29ya2xldE5vZGU7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAvLyBCdWcgIzYwOiBDaHJvbWUgJiBFZGdlIHRocm93IGFuIEludmFsaWRTdGF0ZUVycm9yIGluc3RlYWQgb2YgYSBOb3RTdXBwb3J0ZWRFcnJvci5cbiAgICAgICAgICAgIGlmIChlcnIuY29kZSA9PT0gMTEpIHtcbiAgICAgICAgICAgICAgdGhyb3cgY3JlYXRlTm90U3VwcG9ydGVkRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQnVnICM2MTogT25seSBDaHJvbWUgJiBFZGdlIGhhdmUgYW4gaW1wbGVtZW50YXRpb24gb2YgdGhlIEF1ZGlvV29ya2xldE5vZGUgeWV0LlxuICAgICAgICBpZiAocHJvY2Vzc29yQ29uc3RydWN0b3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRocm93IGNyZWF0ZU5vdFN1cHBvcnRlZEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGVzdENsb25hYmlsaXR5T2ZBdWRpb1dvcmtsZXROb2RlT3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZU5hdGl2ZUF1ZGlvV29ya2xldE5vZGVGYWtlcihuYXRpdmVDb250ZXh0LCBiYXNlTGF0ZW5jeSwgcHJvY2Vzc29yQ29uc3RydWN0b3IsIG9wdGlvbnMpO1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIGNvbXB1dGVCdWZmZXJTaXplID0gZnVuY3Rpb24gY29tcHV0ZUJ1ZmZlclNpemUoYmFzZUxhdGVuY3ksIHNhbXBsZVJhdGUpIHtcbiAgICAgIGlmIChiYXNlTGF0ZW5jeSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gNTEyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIE1hdGgubWF4KDUxMiwgTWF0aC5taW4oMTYzODQsIE1hdGgucG93KDIsIE1hdGgucm91bmQoTWF0aC5sb2cyKGJhc2VMYXRlbmN5ICogc2FtcGxlUmF0ZSkpKSkpO1xuICAgIH07XG5cbiAgICB2YXIgY2xvbmVBdWRpb1dvcmtsZXROb2RlT3B0aW9ucyA9IGZ1bmN0aW9uIGNsb25lQXVkaW9Xb3JrbGV0Tm9kZU9wdGlvbnMoYXVkaW9Xb3JrbGV0Tm9kZU9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHZhciBfTWVzc2FnZUNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKSxcbiAgICAgICAgICBwb3J0MSA9IF9NZXNzYWdlQ2hhbm5lbC5wb3J0MSxcbiAgICAgICAgICBwb3J0MiA9IF9NZXNzYWdlQ2hhbm5lbC5wb3J0MjtcbiAgICAgICAgcG9ydDEub25tZXNzYWdlID0gZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgICAgICB2YXIgZGF0YSA9IF9yZWYuZGF0YTtcbiAgICAgICAgICBwb3J0MS5jbG9zZSgpO1xuICAgICAgICAgIHBvcnQyLmNsb3NlKCk7XG4gICAgICAgICAgcmVzb2x2ZShkYXRhKTtcbiAgICAgICAgfTtcbiAgICAgICAgcG9ydDEub25tZXNzYWdlZXJyb3IgPSBmdW5jdGlvbiAoX3JlZjIpIHtcbiAgICAgICAgICB2YXIgZGF0YSA9IF9yZWYyLmRhdGE7XG4gICAgICAgICAgcG9ydDEuY2xvc2UoKTtcbiAgICAgICAgICBwb3J0Mi5jbG9zZSgpO1xuICAgICAgICAgIHJlamVjdChkYXRhKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gVGhpcyB3aWxsIHRocm93IGFuIGVycm9yIGlmIHRoZSBhdWRpb1dvcmtsZXROb2RlT3B0aW9ucyBhcmUgbm90IGNsb25hYmxlLlxuICAgICAgICBwb3J0Mi5wb3N0TWVzc2FnZShhdWRpb1dvcmtsZXROb2RlT3B0aW9ucyk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZUF1ZGlvV29ya2xldFByb2Nlc3NvclByb21pc2UgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9yZWYgPSBfYXN5bmNUb0dlbmVyYXRvcigvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUocHJvY2Vzc29yQ29uc3RydWN0b3IsIGF1ZGlvV29ya2xldE5vZGVPcHRpb25zKSB7XG4gICAgICAgIHZhciBjbG9uZWRBdWRpb1dvcmtsZXROb2RlT3B0aW9ucztcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgICAgIHdoaWxlICgxKSBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAyO1xuICAgICAgICAgICAgICByZXR1cm4gY2xvbmVBdWRpb1dvcmtsZXROb2RlT3B0aW9ucyhhdWRpb1dvcmtsZXROb2RlT3B0aW9ucyk7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgIGNsb25lZEF1ZGlvV29ya2xldE5vZGVPcHRpb25zID0gX2NvbnRleHQuc2VudDtcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCBuZXcgcHJvY2Vzc29yQ29uc3RydWN0b3IoY2xvbmVkQXVkaW9Xb3JrbGV0Tm9kZU9wdGlvbnMpKTtcbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUpO1xuICAgICAgfSkpO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZUF1ZGlvV29ya2xldFByb2Nlc3NvclByb21pc2UoX3gsIF94Mikge1xuICAgICAgICByZXR1cm4gX3JlZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICB9KCk7XG5cbiAgICB2YXIgY3JlYXRlQXVkaW9Xb3JrbGV0UHJvY2Vzc29yID0gZnVuY3Rpb24gY3JlYXRlQXVkaW9Xb3JrbGV0UHJvY2Vzc29yKG5hdGl2ZUNvbnRleHQsIG5hdGl2ZUF1ZGlvV29ya2xldE5vZGUsIHByb2Nlc3NvckNvbnN0cnVjdG9yLCBhdWRpb1dvcmtsZXROb2RlT3B0aW9ucykge1xuICAgICAgdmFyIG5vZGVUb1Byb2Nlc3Nvck1hcCA9IE5PREVfVE9fUFJPQ0VTU09SX01BUFMuZ2V0KG5hdGl2ZUNvbnRleHQpO1xuICAgICAgaWYgKG5vZGVUb1Byb2Nlc3Nvck1hcCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG5vZGVUb1Byb2Nlc3Nvck1hcCA9IG5ldyBXZWFrTWFwKCk7XG4gICAgICAgIE5PREVfVE9fUFJPQ0VTU09SX01BUFMuc2V0KG5hdGl2ZUNvbnRleHQsIG5vZGVUb1Byb2Nlc3Nvck1hcCk7XG4gICAgICB9XG4gICAgICB2YXIgYXVkaW9Xb3JrbGV0UHJvY2Vzc29yUHJvbWlzZSA9IGNyZWF0ZUF1ZGlvV29ya2xldFByb2Nlc3NvclByb21pc2UocHJvY2Vzc29yQ29uc3RydWN0b3IsIGF1ZGlvV29ya2xldE5vZGVPcHRpb25zKTtcbiAgICAgIG5vZGVUb1Byb2Nlc3Nvck1hcC5zZXQobmF0aXZlQXVkaW9Xb3JrbGV0Tm9kZSwgYXVkaW9Xb3JrbGV0UHJvY2Vzc29yUHJvbWlzZSk7XG4gICAgICByZXR1cm4gYXVkaW9Xb3JrbGV0UHJvY2Vzc29yUHJvbWlzZTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gb3duS2V5cyRlKGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cbiAgICBmdW5jdGlvbiBfb2JqZWN0U3ByZWFkJGUoZSkgeyBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykgeyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gb3duS2V5cyRlKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyRlKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XG4gICAgZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIociwgZSkgeyB2YXIgdCA9IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIFN5bWJvbCAmJiByW1N5bWJvbC5pdGVyYXRvcl0gfHwgcltcIkBAaXRlcmF0b3JcIl07IGlmICghdCkgeyBpZiAoQXJyYXkuaXNBcnJheShyKSB8fCAodCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShyKSkgfHwgZSkgeyB0ICYmIChyID0gdCk7IHZhciBfbiA9IDAsIEYgPSBmdW5jdGlvbiBGKCkge307IHJldHVybiB7IHM6IEYsIG46IGZ1bmN0aW9uIG4oKSB7IHJldHVybiBfbiA+PSByLmxlbmd0aCA/IHsgZG9uZTogITAgfSA6IHsgZG9uZTogITEsIHZhbHVlOiByW19uKytdIH07IH0sIGU6IGZ1bmN0aW9uIGUocikgeyB0aHJvdyByOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBvLCBhID0gITAsIHUgPSAhMTsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgdCA9IHQuY2FsbChyKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHIgPSB0Lm5leHQoKTsgcmV0dXJuIGEgPSByLmRvbmUsIHI7IH0sIGU6IGZ1bmN0aW9uIGUocikgeyB1ID0gITAsIG8gPSByOyB9LCBmOiBmdW5jdGlvbiBmKCkgeyB0cnkgeyBhIHx8IG51bGwgPT0gdFtcInJldHVyblwiXSB8fCB0W1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmICh1KSB0aHJvdyBvOyB9IH0gfTsgfVxuICAgIGZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShyLCBhKSB7IGlmIChyKSB7IGlmIChcInN0cmluZ1wiID09IHR5cGVvZiByKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkociwgYSk7IHZhciB0ID0ge30udG9TdHJpbmcuY2FsbChyKS5zbGljZSg4LCAtMSk7IHJldHVybiBcIk9iamVjdFwiID09PSB0ICYmIHIuY29uc3RydWN0b3IgJiYgKHQgPSByLmNvbnN0cnVjdG9yLm5hbWUpLCBcIk1hcFwiID09PSB0IHx8IFwiU2V0XCIgPT09IHQgPyBBcnJheS5mcm9tKHIpIDogXCJBcmd1bWVudHNcIiA9PT0gdCB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdCh0KSA/IF9hcnJheUxpa2VUb0FycmF5KHIsIGEpIDogdm9pZCAwOyB9IH1cbiAgICBmdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShyLCBhKSB7IChudWxsID09IGEgfHwgYSA+IHIubGVuZ3RoKSAmJiAoYSA9IHIubGVuZ3RoKTsgZm9yICh2YXIgZSA9IDAsIG4gPSBBcnJheShhKTsgZSA8IGE7IGUrKykgbltlXSA9IHJbZV07IHJldHVybiBuOyB9XG4gICAgdmFyIGNyZWF0ZU5hdGl2ZUF1ZGlvV29ya2xldE5vZGVGYWtlckZhY3RvcnkgPSBmdW5jdGlvbiBjcmVhdGVOYXRpdmVBdWRpb1dvcmtsZXROb2RlRmFrZXJGYWN0b3J5KGNvbm5lY3RNdWx0aXBsZU91dHB1dHMsIGNyZWF0ZUluZGV4U2l6ZUVycm9yLCBjcmVhdGVJbnZhbGlkU3RhdGVFcnJvciwgY3JlYXRlTmF0aXZlQ2hhbm5lbE1lcmdlck5vZGUsIGNyZWF0ZU5hdGl2ZUNoYW5uZWxTcGxpdHRlck5vZGUsIGNyZWF0ZU5hdGl2ZUNvbnN0YW50U291cmNlTm9kZSwgY3JlYXRlTmF0aXZlR2Fpbk5vZGUsIGNyZWF0ZU5hdGl2ZVNjcmlwdFByb2Nlc3Nvck5vZGUsIGNyZWF0ZU5vdFN1cHBvcnRlZEVycm9yLCBkaXNjb25uZWN0TXVsdGlwbGVPdXRwdXRzLCBleHBvc2VDdXJyZW50RnJhbWVBbmRDdXJyZW50VGltZSwgZ2V0QWN0aXZlQXVkaW9Xb3JrbGV0Tm9kZUlucHV0cywgbW9uaXRvckNvbm5lY3Rpb25zKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKG5hdGl2ZUNvbnRleHQsIGJhc2VMYXRlbmN5LCBwcm9jZXNzb3JDb25zdHJ1Y3Rvciwgb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucy5udW1iZXJPZklucHV0cyA9PT0gMCAmJiBvcHRpb25zLm51bWJlck9mT3V0cHV0cyA9PT0gMCkge1xuICAgICAgICAgIHRocm93IGNyZWF0ZU5vdFN1cHBvcnRlZEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG91dHB1dENoYW5uZWxDb3VudCA9IEFycmF5LmlzQXJyYXkob3B0aW9ucy5vdXRwdXRDaGFubmVsQ291bnQpID8gb3B0aW9ucy5vdXRwdXRDaGFubmVsQ291bnQgOiBBcnJheS5mcm9tKG9wdGlvbnMub3V0cHV0Q2hhbm5lbENvdW50KTtcbiAgICAgICAgLy8gQHRvZG8gQ2hlY2sgaWYgYW55IG9mIHRoZSBjaGFubmVsQ291bnQgdmFsdWVzIGlzIGdyZWF0ZXIgdGhhbiB0aGUgaW1wbGVtZW50YXRpb24ncyBtYXhpbXVtIG51bWJlciBvZiBjaGFubmVscy5cbiAgICAgICAgaWYgKG91dHB1dENoYW5uZWxDb3VudC5zb21lKGZ1bmN0aW9uIChjaGFubmVsQ291bnQpIHtcbiAgICAgICAgICByZXR1cm4gY2hhbm5lbENvdW50IDwgMTtcbiAgICAgICAgfSkpIHtcbiAgICAgICAgICB0aHJvdyBjcmVhdGVOb3RTdXBwb3J0ZWRFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvdXRwdXRDaGFubmVsQ291bnQubGVuZ3RoICE9PSBvcHRpb25zLm51bWJlck9mT3V0cHV0cykge1xuICAgICAgICAgIHRocm93IGNyZWF0ZUluZGV4U2l6ZUVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQnVnICM2MTogVGhpcyBpcyBub3QgcGFydCBvZiB0aGUgc3RhbmRhcmQgYnV0IHJlcXVpcmVkIGZvciB0aGUgZmFrZXIgdG8gd29yay5cbiAgICAgICAgaWYgKG9wdGlvbnMuY2hhbm5lbENvdW50TW9kZSAhPT0gJ2V4cGxpY2l0Jykge1xuICAgICAgICAgIHRocm93IGNyZWF0ZU5vdFN1cHBvcnRlZEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG51bWJlck9mSW5wdXRDaGFubmVscyA9IG9wdGlvbnMuY2hhbm5lbENvdW50ICogb3B0aW9ucy5udW1iZXJPZklucHV0cztcbiAgICAgICAgdmFyIG51bWJlck9mT3V0cHV0Q2hhbm5lbHMgPSBvdXRwdXRDaGFubmVsQ291bnQucmVkdWNlKGZ1bmN0aW9uIChzdW0sIHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIHN1bSArIHZhbHVlO1xuICAgICAgICB9LCAwKTtcbiAgICAgICAgdmFyIG51bWJlck9mUGFyYW1ldGVycyA9IHByb2Nlc3NvckNvbnN0cnVjdG9yLnBhcmFtZXRlckRlc2NyaXB0b3JzID09PSB1bmRlZmluZWQgPyAwIDogcHJvY2Vzc29yQ29uc3RydWN0b3IucGFyYW1ldGVyRGVzY3JpcHRvcnMubGVuZ3RoO1xuICAgICAgICAvLyBCdWcgIzYxOiBUaGlzIGlzIG5vdCBwYXJ0IG9mIHRoZSBzdGFuZGFyZCBidXQgcmVxdWlyZWQgZm9yIHRoZSBmYWtlciB0byB3b3JrLlxuICAgICAgICBpZiAobnVtYmVyT2ZJbnB1dENoYW5uZWxzICsgbnVtYmVyT2ZQYXJhbWV0ZXJzID4gNiB8fCBudW1iZXJPZk91dHB1dENoYW5uZWxzID4gNikge1xuICAgICAgICAgIHRocm93IGNyZWF0ZU5vdFN1cHBvcnRlZEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1lc3NhZ2VDaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgICAgIHZhciBnYWluTm9kZXMgPSBbXTtcbiAgICAgICAgdmFyIGlucHV0Q2hhbm5lbFNwbGl0dGVyTm9kZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcHRpb25zLm51bWJlck9mSW5wdXRzOyBpICs9IDEpIHtcbiAgICAgICAgICBnYWluTm9kZXMucHVzaChjcmVhdGVOYXRpdmVHYWluTm9kZShuYXRpdmVDb250ZXh0LCB7XG4gICAgICAgICAgICBjaGFubmVsQ291bnQ6IG9wdGlvbnMuY2hhbm5lbENvdW50LFxuICAgICAgICAgICAgY2hhbm5lbENvdW50TW9kZTogb3B0aW9ucy5jaGFubmVsQ291bnRNb2RlLFxuICAgICAgICAgICAgY2hhbm5lbEludGVycHJldGF0aW9uOiBvcHRpb25zLmNoYW5uZWxJbnRlcnByZXRhdGlvbixcbiAgICAgICAgICAgIGdhaW46IDFcbiAgICAgICAgICB9KSk7XG4gICAgICAgICAgaW5wdXRDaGFubmVsU3BsaXR0ZXJOb2Rlcy5wdXNoKGNyZWF0ZU5hdGl2ZUNoYW5uZWxTcGxpdHRlck5vZGUobmF0aXZlQ29udGV4dCwge1xuICAgICAgICAgICAgY2hhbm5lbENvdW50OiBvcHRpb25zLmNoYW5uZWxDb3VudCxcbiAgICAgICAgICAgIGNoYW5uZWxDb3VudE1vZGU6ICdleHBsaWNpdCcsXG4gICAgICAgICAgICBjaGFubmVsSW50ZXJwcmV0YXRpb246ICdkaXNjcmV0ZScsXG4gICAgICAgICAgICBudW1iZXJPZk91dHB1dHM6IG9wdGlvbnMuY2hhbm5lbENvdW50XG4gICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb25zdGFudFNvdXJjZU5vZGVzID0gW107XG4gICAgICAgIGlmIChwcm9jZXNzb3JDb25zdHJ1Y3Rvci5wYXJhbWV0ZXJEZXNjcmlwdG9ycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHByb2Nlc3NvckNvbnN0cnVjdG9yLnBhcmFtZXRlckRlc2NyaXB0b3JzKSxcbiAgICAgICAgICAgIF9zdGVwO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcCgpIHtcbiAgICAgICAgICAgICAgdmFyIF9zdGVwJHZhbHVlID0gX3N0ZXAudmFsdWUsXG4gICAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlID0gX3N0ZXAkdmFsdWUuZGVmYXVsdFZhbHVlLFxuICAgICAgICAgICAgICAgIG1heFZhbHVlID0gX3N0ZXAkdmFsdWUubWF4VmFsdWUsXG4gICAgICAgICAgICAgICAgbWluVmFsdWUgPSBfc3RlcCR2YWx1ZS5taW5WYWx1ZSxcbiAgICAgICAgICAgICAgICBuYW1lID0gX3N0ZXAkdmFsdWUubmFtZTtcbiAgICAgICAgICAgICAgdmFyIGNvbnN0YW50U291cmNlTm9kZSA9IGNyZWF0ZU5hdGl2ZUNvbnN0YW50U291cmNlTm9kZShuYXRpdmVDb250ZXh0LCB7XG4gICAgICAgICAgICAgICAgY2hhbm5lbENvdW50OiAxLFxuICAgICAgICAgICAgICAgIGNoYW5uZWxDb3VudE1vZGU6ICdleHBsaWNpdCcsXG4gICAgICAgICAgICAgICAgY2hhbm5lbEludGVycHJldGF0aW9uOiAnZGlzY3JldGUnLFxuICAgICAgICAgICAgICAgIG9mZnNldDogb3B0aW9ucy5wYXJhbWV0ZXJEYXRhW25hbWVdICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnBhcmFtZXRlckRhdGFbbmFtZV0gOiBkZWZhdWx0VmFsdWUgPT09IHVuZGVmaW5lZCA/IDAgOiBkZWZhdWx0VmFsdWVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnN0YW50U291cmNlTm9kZS5vZmZzZXQsIHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0VmFsdWU6IHtcbiAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVmYXVsdFZhbHVlID09PSB1bmRlZmluZWQgPyAwIDogZGVmYXVsdFZhbHVlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbWF4VmFsdWU6IHtcbiAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWF4VmFsdWUgPT09IHVuZGVmaW5lZCA/IE1PU1RfUE9TSVRJVkVfU0lOR0xFX0ZMT0FUIDogbWF4VmFsdWU7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBtaW5WYWx1ZToge1xuICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtaW5WYWx1ZSA9PT0gdW5kZWZpbmVkID8gTU9TVF9ORUdBVElWRV9TSU5HTEVfRkxPQVQgOiBtaW5WYWx1ZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBjb25zdGFudFNvdXJjZU5vZGVzLnB1c2goY29uc3RhbnRTb3VyY2VOb2RlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgICAgICAgICBfbG9vcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGlucHV0Q2hhbm5lbE1lcmdlck5vZGUgPSBjcmVhdGVOYXRpdmVDaGFubmVsTWVyZ2VyTm9kZShuYXRpdmVDb250ZXh0LCB7XG4gICAgICAgICAgY2hhbm5lbENvdW50OiAxLFxuICAgICAgICAgIGNoYW5uZWxDb3VudE1vZGU6ICdleHBsaWNpdCcsXG4gICAgICAgICAgY2hhbm5lbEludGVycHJldGF0aW9uOiAnc3BlYWtlcnMnLFxuICAgICAgICAgIG51bWJlck9mSW5wdXRzOiBNYXRoLm1heCgxLCBudW1iZXJPZklucHV0Q2hhbm5lbHMgKyBudW1iZXJPZlBhcmFtZXRlcnMpXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgYnVmZmVyU2l6ZSA9IGNvbXB1dGVCdWZmZXJTaXplKGJhc2VMYXRlbmN5LCBuYXRpdmVDb250ZXh0LnNhbXBsZVJhdGUpO1xuICAgICAgICB2YXIgc2NyaXB0UHJvY2Vzc29yTm9kZSA9IGNyZWF0ZU5hdGl2ZVNjcmlwdFByb2Nlc3Nvck5vZGUobmF0aXZlQ29udGV4dCwgYnVmZmVyU2l6ZSwgbnVtYmVyT2ZJbnB1dENoYW5uZWxzICsgbnVtYmVyT2ZQYXJhbWV0ZXJzLFxuICAgICAgICAvLyBCdWcgIzg3OiBPbmx5IEZpcmVmb3ggd2lsbCBmaXJlIGFuIEF1ZGlvUHJvY2Vzc2luZ0V2ZW50IGlmIHRoZXJlIGlzIG5vIGNvbm5lY3RlZCBvdXRwdXQuXG4gICAgICAgIE1hdGgubWF4KDEsIG51bWJlck9mT3V0cHV0Q2hhbm5lbHMpKTtcbiAgICAgICAgdmFyIG91dHB1dENoYW5uZWxTcGxpdHRlck5vZGUgPSBjcmVhdGVOYXRpdmVDaGFubmVsU3BsaXR0ZXJOb2RlKG5hdGl2ZUNvbnRleHQsIHtcbiAgICAgICAgICBjaGFubmVsQ291bnQ6IE1hdGgubWF4KDEsIG51bWJlck9mT3V0cHV0Q2hhbm5lbHMpLFxuICAgICAgICAgIGNoYW5uZWxDb3VudE1vZGU6ICdleHBsaWNpdCcsXG4gICAgICAgICAgY2hhbm5lbEludGVycHJldGF0aW9uOiAnZGlzY3JldGUnLFxuICAgICAgICAgIG51bWJlck9mT3V0cHV0czogTWF0aC5tYXgoMSwgbnVtYmVyT2ZPdXRwdXRDaGFubmVscylcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBvdXRwdXRDaGFubmVsTWVyZ2VyTm9kZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IG9wdGlvbnMubnVtYmVyT2ZPdXRwdXRzOyBfaSArPSAxKSB7XG4gICAgICAgICAgb3V0cHV0Q2hhbm5lbE1lcmdlck5vZGVzLnB1c2goY3JlYXRlTmF0aXZlQ2hhbm5lbE1lcmdlck5vZGUobmF0aXZlQ29udGV4dCwge1xuICAgICAgICAgICAgY2hhbm5lbENvdW50OiAxLFxuICAgICAgICAgICAgY2hhbm5lbENvdW50TW9kZTogJ2V4cGxpY2l0JyxcbiAgICAgICAgICAgIGNoYW5uZWxJbnRlcnByZXRhdGlvbjogJ3NwZWFrZXJzJyxcbiAgICAgICAgICAgIG51bWJlck9mSW5wdXRzOiBvdXRwdXRDaGFubmVsQ291bnRbX2ldXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IG9wdGlvbnMubnVtYmVyT2ZJbnB1dHM7IF9pMiArPSAxKSB7XG4gICAgICAgICAgZ2Fpbk5vZGVzW19pMl0uY29ubmVjdChpbnB1dENoYW5uZWxTcGxpdHRlck5vZGVzW19pMl0pO1xuICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgb3B0aW9ucy5jaGFubmVsQ291bnQ7IGogKz0gMSkge1xuICAgICAgICAgICAgaW5wdXRDaGFubmVsU3BsaXR0ZXJOb2Rlc1tfaTJdLmNvbm5lY3QoaW5wdXRDaGFubmVsTWVyZ2VyTm9kZSwgaiwgX2kyICogb3B0aW9ucy5jaGFubmVsQ291bnQgKyBqKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBhcmFtZXRlck1hcCA9IG5ldyBSZWFkT25seU1hcChwcm9jZXNzb3JDb25zdHJ1Y3Rvci5wYXJhbWV0ZXJEZXNjcmlwdG9ycyA9PT0gdW5kZWZpbmVkID8gW10gOiBwcm9jZXNzb3JDb25zdHJ1Y3Rvci5wYXJhbWV0ZXJEZXNjcmlwdG9ycy5tYXAoZnVuY3Rpb24gKF9yZWYsIGluZGV4KSB7XG4gICAgICAgICAgdmFyIG5hbWUgPSBfcmVmLm5hbWU7XG4gICAgICAgICAgdmFyIGNvbnN0YW50U291cmNlTm9kZSA9IGNvbnN0YW50U291cmNlTm9kZXNbaW5kZXhdO1xuICAgICAgICAgIGNvbnN0YW50U291cmNlTm9kZS5jb25uZWN0KGlucHV0Q2hhbm5lbE1lcmdlck5vZGUsIDAsIG51bWJlck9mSW5wdXRDaGFubmVscyArIGluZGV4KTtcbiAgICAgICAgICBjb25zdGFudFNvdXJjZU5vZGUuc3RhcnQoMCk7XG4gICAgICAgICAgcmV0dXJuIFtuYW1lLCBjb25zdGFudFNvdXJjZU5vZGUub2Zmc2V0XTtcbiAgICAgICAgfSkpO1xuICAgICAgICBpbnB1dENoYW5uZWxNZXJnZXJOb2RlLmNvbm5lY3Qoc2NyaXB0UHJvY2Vzc29yTm9kZSk7XG4gICAgICAgIHZhciBjaGFubmVsSW50ZXJwcmV0YXRpb24gPSBvcHRpb25zLmNoYW5uZWxJbnRlcnByZXRhdGlvbjtcbiAgICAgICAgdmFyIG9ucHJvY2Vzc29yZXJyb3IgPSBudWxsO1xuICAgICAgICAvLyBCdWcgIzg3OiBFeHBvc2UgYXQgbGVhc3Qgb25lIG91dHB1dCB0byBtYWtlIHRoaXMgbm9kZSBjb25uZWN0YWJsZS5cbiAgICAgICAgdmFyIG91dHB1dEF1ZGlvTm9kZXMgPSBvcHRpb25zLm51bWJlck9mT3V0cHV0cyA9PT0gMCA/IFtzY3JpcHRQcm9jZXNzb3JOb2RlXSA6IG91dHB1dENoYW5uZWxNZXJnZXJOb2RlcztcbiAgICAgICAgdmFyIG5hdGl2ZUF1ZGlvV29ya2xldE5vZGVGYWtlciA9IHtcbiAgICAgICAgICBnZXQgYnVmZmVyU2l6ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBidWZmZXJTaXplO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZ2V0IGNoYW5uZWxDb3VudCgpIHtcbiAgICAgICAgICAgIHJldHVybiBvcHRpb25zLmNoYW5uZWxDb3VudDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNldCBjaGFubmVsQ291bnQoXykge1xuICAgICAgICAgICAgLy8gQnVnICM2MTogVGhpcyBpcyBub3QgcGFydCBvZiB0aGUgc3RhbmRhcmQgYnV0IHJlcXVpcmVkIGZvciB0aGUgZmFrZXIgdG8gd29yay5cbiAgICAgICAgICAgIHRocm93IGNyZWF0ZUludmFsaWRTdGF0ZUVycm9yKCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBnZXQgY2hhbm5lbENvdW50TW9kZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBvcHRpb25zLmNoYW5uZWxDb3VudE1vZGU7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzZXQgY2hhbm5lbENvdW50TW9kZShfKSB7XG4gICAgICAgICAgICAvLyBCdWcgIzYxOiBUaGlzIGlzIG5vdCBwYXJ0IG9mIHRoZSBzdGFuZGFyZCBidXQgcmVxdWlyZWQgZm9yIHRoZSBmYWtlciB0byB3b3JrLlxuICAgICAgICAgICAgdGhyb3cgY3JlYXRlSW52YWxpZFN0YXRlRXJyb3IoKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGdldCBjaGFubmVsSW50ZXJwcmV0YXRpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gY2hhbm5lbEludGVycHJldGF0aW9uO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc2V0IGNoYW5uZWxJbnRlcnByZXRhdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2kzID0gMCwgX2dhaW5Ob2RlcyA9IGdhaW5Ob2RlczsgX2kzIDwgX2dhaW5Ob2Rlcy5sZW5ndGg7IF9pMysrKSB7XG4gICAgICAgICAgICAgIHZhciBnYWluTm9kZSA9IF9nYWluTm9kZXNbX2kzXTtcbiAgICAgICAgICAgICAgZ2Fpbk5vZGUuY2hhbm5lbEludGVycHJldGF0aW9uID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGFubmVsSW50ZXJwcmV0YXRpb24gPSB2YWx1ZTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGdldCBjb250ZXh0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHNjcmlwdFByb2Nlc3Nvck5vZGUuY29udGV4dDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGdldCBpbnB1dHMoKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2Fpbk5vZGVzO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZ2V0IG51bWJlck9mSW5wdXRzKCkge1xuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMubnVtYmVyT2ZJbnB1dHM7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBnZXQgbnVtYmVyT2ZPdXRwdXRzKCkge1xuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMubnVtYmVyT2ZPdXRwdXRzO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZ2V0IG9ucHJvY2Vzc29yZXJyb3IoKSB7XG4gICAgICAgICAgICByZXR1cm4gb25wcm9jZXNzb3JlcnJvcjtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNldCBvbnByb2Nlc3NvcmVycm9yKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9ucHJvY2Vzc29yZXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgbmF0aXZlQXVkaW9Xb3JrbGV0Tm9kZUZha2VyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Byb2Nlc3NvcmVycm9yJywgb25wcm9jZXNzb3JlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvbnByb2Nlc3NvcmVycm9yID0gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nID8gdmFsdWUgOiBudWxsO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvbnByb2Nlc3NvcmVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIG5hdGl2ZUF1ZGlvV29ya2xldE5vZGVGYWtlci5hZGRFdmVudExpc3RlbmVyKCdwcm9jZXNzb3JlcnJvcicsIG9ucHJvY2Vzc29yZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZ2V0IHBhcmFtZXRlcnMoKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyYW1ldGVyTWFwO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZ2V0IHBvcnQoKSB7XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZUNoYW5uZWwucG9ydDI7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBhZGRFdmVudExpc3RlbmVyOiBmdW5jdGlvbiBhZGRFdmVudExpc3RlbmVyKCkge1xuICAgICAgICAgICAgcmV0dXJuIHNjcmlwdFByb2Nlc3Nvck5vZGUuYWRkRXZlbnRMaXN0ZW5lcihhcmd1bWVudHMubGVuZ3RoIDw9IDAgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMF0sIGFyZ3VtZW50cy5sZW5ndGggPD0gMSA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzLmxlbmd0aCA8PSAyID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzJdKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNvbm5lY3Q6IGNvbm5lY3RNdWx0aXBsZU91dHB1dHMuYmluZChudWxsLCBvdXRwdXRBdWRpb05vZGVzKSxcbiAgICAgICAgICBkaXNjb25uZWN0OiBkaXNjb25uZWN0TXVsdGlwbGVPdXRwdXRzLmJpbmQobnVsbCwgb3V0cHV0QXVkaW9Ob2RlcyksXG4gICAgICAgICAgZGlzcGF0Y2hFdmVudDogZnVuY3Rpb24gZGlzcGF0Y2hFdmVudCgpIHtcbiAgICAgICAgICAgIHJldHVybiBzY3JpcHRQcm9jZXNzb3JOb2RlLmRpc3BhdGNoRXZlbnQoYXJndW1lbnRzLmxlbmd0aCA8PSAwID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzBdKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXIoKSB7XG4gICAgICAgICAgICByZXR1cm4gc2NyaXB0UHJvY2Vzc29yTm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKGFyZ3VtZW50cy5sZW5ndGggPD0gMCA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1swXSwgYXJndW1lbnRzLmxlbmd0aCA8PSAxID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzFdLCBhcmd1bWVudHMubGVuZ3RoIDw9IDIgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMl0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHBhdGNoZWRFdmVudExpc3RlbmVycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgbWVzc2FnZUNoYW5uZWwucG9ydDEuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIChhZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFyZ3NbMF0gPT09ICdtZXNzYWdlJykge1xuICAgICAgICAgICAgICB2YXIgdW5wYXRjaGVkRXZlbnRMaXN0ZW5lciA9IHR5cGVvZiBhcmdzWzFdID09PSAnZnVuY3Rpb24nID8gYXJnc1sxXSA6IF90eXBlb2YoYXJnc1sxXSkgPT09ICdvYmplY3QnICYmIGFyZ3NbMV0gIT09IG51bGwgJiYgdHlwZW9mIGFyZ3NbMV0uaGFuZGxlRXZlbnQgPT09ICdmdW5jdGlvbicgPyBhcmdzWzFdLmhhbmRsZUV2ZW50IDogbnVsbDtcbiAgICAgICAgICAgICAgaWYgKHVucGF0Y2hlZEV2ZW50TGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGF0Y2hlZEV2ZW50TGlzdGVuZXIgPSBwYXRjaGVkRXZlbnRMaXN0ZW5lcnMuZ2V0KGFyZ3NbMV0pO1xuICAgICAgICAgICAgICAgIGlmIChwYXRjaGVkRXZlbnRMaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICBhcmdzWzFdID0gcGF0Y2hlZEV2ZW50TGlzdGVuZXI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGFyZ3NbMV0gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgZXhwb3NlQ3VycmVudEZyYW1lQW5kQ3VycmVudFRpbWUobmF0aXZlQ29udGV4dC5jdXJyZW50VGltZSwgbmF0aXZlQ29udGV4dC5zYW1wbGVSYXRlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVucGF0Y2hlZEV2ZW50TGlzdGVuZXIoZXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICBwYXRjaGVkRXZlbnRMaXN0ZW5lcnMuc2V0KHVucGF0Y2hlZEV2ZW50TGlzdGVuZXIsIGFyZ3NbMV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFkZEV2ZW50TGlzdGVuZXIuY2FsbChtZXNzYWdlQ2hhbm5lbC5wb3J0MSwgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfShtZXNzYWdlQ2hhbm5lbC5wb3J0MS5hZGRFdmVudExpc3RlbmVyKTtcbiAgICAgICAgbWVzc2FnZUNoYW5uZWwucG9ydDEucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIChyZW1vdmVFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICAgICAgICBhcmdzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYXJnc1swXSA9PT0gJ21lc3NhZ2UnKSB7XG4gICAgICAgICAgICAgIHZhciBwYXRjaGVkRXZlbnRMaXN0ZW5lciA9IHBhdGNoZWRFdmVudExpc3RlbmVycy5nZXQoYXJnc1sxXSk7XG4gICAgICAgICAgICAgIGlmIChwYXRjaGVkRXZlbnRMaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcGF0Y2hlZEV2ZW50TGlzdGVuZXJzW1wiZGVsZXRlXCJdKGFyZ3NbMV0pO1xuICAgICAgICAgICAgICAgIGFyZ3NbMV0gPSBwYXRjaGVkRXZlbnRMaXN0ZW5lcjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlbW92ZUV2ZW50TGlzdGVuZXIuY2FsbChtZXNzYWdlQ2hhbm5lbC5wb3J0MSwgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfShtZXNzYWdlQ2hhbm5lbC5wb3J0MS5yZW1vdmVFdmVudExpc3RlbmVyKTtcbiAgICAgICAgdmFyIG9ubWVzc2FnZSA9IG51bGw7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtZXNzYWdlQ2hhbm5lbC5wb3J0MSwgJ29ubWVzc2FnZScsIHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiBvbm1lc3NhZ2U7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvbm1lc3NhZ2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgbWVzc2FnZUNoYW5uZWwucG9ydDEucmVtb3ZlRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIG9ubWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvbm1lc3NhZ2UgPSB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgPyB2YWx1ZSA6IG51bGw7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9ubWVzc2FnZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICBtZXNzYWdlQ2hhbm5lbC5wb3J0MS5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgb25tZXNzYWdlKTtcbiAgICAgICAgICAgICAgbWVzc2FnZUNoYW5uZWwucG9ydDEuc3RhcnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBwcm9jZXNzb3JDb25zdHJ1Y3Rvci5wcm90b3R5cGUucG9ydCA9IG1lc3NhZ2VDaGFubmVsLnBvcnQxO1xuICAgICAgICB2YXIgYXVkaW9Xb3JrbGV0UHJvY2Vzc29yID0gbnVsbDtcbiAgICAgICAgdmFyIGF1ZGlvV29ya2xldFByb2Nlc3NvclByb21pc2UgPSBjcmVhdGVBdWRpb1dvcmtsZXRQcm9jZXNzb3IobmF0aXZlQ29udGV4dCwgbmF0aXZlQXVkaW9Xb3JrbGV0Tm9kZUZha2VyLCBwcm9jZXNzb3JDb25zdHJ1Y3Rvciwgb3B0aW9ucyk7XG4gICAgICAgIGF1ZGlvV29ya2xldFByb2Nlc3NvclByb21pc2UudGhlbihmdW5jdGlvbiAoZFdya2x0UHJjc3NyKSB7XG4gICAgICAgICAgcmV0dXJuIGF1ZGlvV29ya2xldFByb2Nlc3NvciA9IGRXcmtsdFByY3NzcjtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBpbnB1dHMgPSBjcmVhdGVOZXN0ZWRBcnJheXMob3B0aW9ucy5udW1iZXJPZklucHV0cywgb3B0aW9ucy5jaGFubmVsQ291bnQpO1xuICAgICAgICB2YXIgb3V0cHV0cyA9IGNyZWF0ZU5lc3RlZEFycmF5cyhvcHRpb25zLm51bWJlck9mT3V0cHV0cywgb3V0cHV0Q2hhbm5lbENvdW50KTtcbiAgICAgICAgdmFyIHBhcmFtZXRlcnMgPSBwcm9jZXNzb3JDb25zdHJ1Y3Rvci5wYXJhbWV0ZXJEZXNjcmlwdG9ycyA9PT0gdW5kZWZpbmVkID8gW10gOiBwcm9jZXNzb3JDb25zdHJ1Y3Rvci5wYXJhbWV0ZXJEZXNjcmlwdG9ycy5yZWR1Y2UoZnVuY3Rpb24gKHBybXRycywgX3JlZjIpIHtcbiAgICAgICAgICB2YXIgbmFtZSA9IF9yZWYyLm5hbWU7XG4gICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQkZShfb2JqZWN0U3ByZWFkJGUoe30sIHBybXRycyksIHt9LCBfZGVmaW5lUHJvcGVydHkoe30sIG5hbWUsIG5ldyBGbG9hdDMyQXJyYXkoMTI4KSkpO1xuICAgICAgICB9LCB7fSk7XG4gICAgICAgIHZhciBpc0FjdGl2ZSA9IHRydWU7XG4gICAgICAgIHZhciBkaXNjb25uZWN0T3V0cHV0c0dyYXBoID0gZnVuY3Rpb24gZGlzY29ubmVjdE91dHB1dHNHcmFwaCgpIHtcbiAgICAgICAgICBpZiAob3B0aW9ucy5udW1iZXJPZk91dHB1dHMgPiAwKSB7XG4gICAgICAgICAgICBzY3JpcHRQcm9jZXNzb3JOb2RlLmRpc2Nvbm5lY3Qob3V0cHV0Q2hhbm5lbFNwbGl0dGVyTm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAodmFyIF9pNCA9IDAsIG91dHB1dENoYW5uZWxTcGxpdHRlck5vZGVPdXRwdXQgPSAwOyBfaTQgPCBvcHRpb25zLm51bWJlck9mT3V0cHV0czsgX2k0ICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBvdXRwdXRDaGFubmVsTWVyZ2VyTm9kZSA9IG91dHB1dENoYW5uZWxNZXJnZXJOb2Rlc1tfaTRdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2ogPSAwOyBfaiA8IG91dHB1dENoYW5uZWxDb3VudFtfaTRdOyBfaiArPSAxKSB7XG4gICAgICAgICAgICAgIG91dHB1dENoYW5uZWxTcGxpdHRlck5vZGUuZGlzY29ubmVjdChvdXRwdXRDaGFubmVsTWVyZ2VyTm9kZSwgb3V0cHV0Q2hhbm5lbFNwbGl0dGVyTm9kZU91dHB1dCArIF9qLCBfaik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdXRwdXRDaGFubmVsU3BsaXR0ZXJOb2RlT3V0cHV0ICs9IG91dHB1dENoYW5uZWxDb3VudFtfaTRdO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGFjdGl2ZUlucHV0SW5kZXhlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOmRlcHJlY2F0aW9uXG4gICAgICAgIHNjcmlwdFByb2Nlc3Nvck5vZGUub25hdWRpb3Byb2Nlc3MgPSBmdW5jdGlvbiAoX3JlZjMpIHtcbiAgICAgICAgICB2YXIgaW5wdXRCdWZmZXIgPSBfcmVmMy5pbnB1dEJ1ZmZlcixcbiAgICAgICAgICAgIG91dHB1dEJ1ZmZlciA9IF9yZWYzLm91dHB1dEJ1ZmZlcjtcbiAgICAgICAgICBpZiAoYXVkaW9Xb3JrbGV0UHJvY2Vzc29yICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgYWN0aXZlSW5wdXRzID0gZ2V0QWN0aXZlQXVkaW9Xb3JrbGV0Tm9kZUlucHV0cyhuYXRpdmVBdWRpb1dvcmtsZXROb2RlRmFrZXIpO1xuICAgICAgICAgICAgdmFyIF9sb29wMiA9IGZ1bmN0aW9uIF9sb29wMihfaTUpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgX2oyID0gMDsgX2oyIDwgb3B0aW9ucy5udW1iZXJPZklucHV0czsgX2oyICs9IDEpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IG9wdGlvbnMuY2hhbm5lbENvdW50OyBrICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgIGNvcHlGcm9tQ2hhbm5lbChpbnB1dEJ1ZmZlciwgaW5wdXRzW19qMl0sIGssIGssIF9pNSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChwcm9jZXNzb3JDb25zdHJ1Y3Rvci5wYXJhbWV0ZXJEZXNjcmlwdG9ycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcHJvY2Vzc29yQ29uc3RydWN0b3IucGFyYW1ldGVyRGVzY3JpcHRvcnMuZm9yRWFjaChmdW5jdGlvbiAoX3JlZjQsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IF9yZWY0Lm5hbWU7XG4gICAgICAgICAgICAgICAgICBjb3B5RnJvbUNoYW5uZWwoaW5wdXRCdWZmZXIsIHBhcmFtZXRlcnMsIG5hbWUsIG51bWJlck9mSW5wdXRDaGFubmVscyArIGluZGV4LCBfaTUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGZvciAodmFyIF9qMyA9IDA7IF9qMyA8IG9wdGlvbnMubnVtYmVyT2ZJbnB1dHM7IF9qMyArPSAxKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2sgPSAwOyBfayA8IG91dHB1dENoYW5uZWxDb3VudFtfajNdOyBfayArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAvLyBUaGUgYnl0ZUxlbmd0aCB3aWxsIGJlIDAgd2hlbiB0aGUgQXJyYXlCdWZmZXIgd2FzIHRyYW5zZmVycmVkLlxuICAgICAgICAgICAgICAgICAgaWYgKG91dHB1dHNbX2ozXVtfa10uYnl0ZUxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXRzW19qM11bX2tdID0gbmV3IEZsb2F0MzJBcnJheSgxMjgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhciBwb3RlbnRpYWxseUVtcHR5SW5wdXRzID0gaW5wdXRzLm1hcChmdW5jdGlvbiAoaW5wdXQsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICB2YXIgYWN0aXZlSW5wdXQgPSBhY3RpdmVJbnB1dHNbaW5kZXhdO1xuICAgICAgICAgICAgICAgICAgaWYgKGFjdGl2ZUlucHV0LnNpemUgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZUlucHV0SW5kZXhlcy5zZXQoaW5kZXgsIGJ1ZmZlclNpemUgLyAxMjgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB2YXIgY291bnQgPSBhY3RpdmVJbnB1dEluZGV4ZXMuZ2V0KGluZGV4KTtcbiAgICAgICAgICAgICAgICAgIGlmIChjb3VudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC5ldmVyeShmdW5jdGlvbiAoY2hhbm5lbERhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoYW5uZWxEYXRhLmV2ZXJ5KGZ1bmN0aW9uIChzYW1wbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2FtcGxlID09PSAwO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb3VudCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZUlucHV0SW5kZXhlc1tcImRlbGV0ZVwiXShpbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgYWN0aXZlSW5wdXRJbmRleGVzLnNldChpbmRleCwgY291bnQgLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHZhciBhY3RpdmVTb3VyY2VGbGFnID0gZXhwb3NlQ3VycmVudEZyYW1lQW5kQ3VycmVudFRpbWUobmF0aXZlQ29udGV4dC5jdXJyZW50VGltZSArIF9pNSAvIG5hdGl2ZUNvbnRleHQuc2FtcGxlUmF0ZSwgbmF0aXZlQ29udGV4dC5zYW1wbGVSYXRlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gYXVkaW9Xb3JrbGV0UHJvY2Vzc29yLnByb2Nlc3MocG90ZW50aWFsbHlFbXB0eUlucHV0cywgb3V0cHV0cywgcGFyYW1ldGVycyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaXNBY3RpdmUgPSBhY3RpdmVTb3VyY2VGbGFnO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9qNCA9IDAsIG91dHB1dENoYW5uZWxTcGxpdHRlck5vZGVPdXRwdXQgPSAwOyBfajQgPCBvcHRpb25zLm51bWJlck9mT3V0cHV0czsgX2o0ICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9rMiA9IDA7IF9rMiA8IG91dHB1dENoYW5uZWxDb3VudFtfajRdOyBfazIgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICBjb3B5VG9DaGFubmVsKG91dHB1dEJ1ZmZlciwgb3V0cHV0c1tfajRdLCBfazIsIG91dHB1dENoYW5uZWxTcGxpdHRlck5vZGVPdXRwdXQgKyBfazIsIF9pNSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBvdXRwdXRDaGFubmVsU3BsaXR0ZXJOb2RlT3V0cHV0ICs9IG91dHB1dENoYW5uZWxDb3VudFtfajRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpc0FjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIG5hdGl2ZUF1ZGlvV29ya2xldE5vZGVGYWtlci5kaXNwYXRjaEV2ZW50KG5ldyBFcnJvckV2ZW50KCdwcm9jZXNzb3JlcnJvcicsIHtcbiAgICAgICAgICAgICAgICAgIGNvbG5vOiBlcnJvci5jb2xubyxcbiAgICAgICAgICAgICAgICAgIGZpbGVuYW1lOiBlcnJvci5maWxlbmFtZSxcbiAgICAgICAgICAgICAgICAgIGxpbmVubzogZXJyb3IubGluZW5vLFxuICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZXJyb3IubWVzc2FnZVxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoIWlzQWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2o1ID0gMDsgX2o1IDwgb3B0aW9ucy5udW1iZXJPZklucHV0czsgX2o1ICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgIGdhaW5Ob2Rlc1tfajVdLmRpc2Nvbm5lY3QoaW5wdXRDaGFubmVsU3BsaXR0ZXJOb2Rlc1tfajVdKTtcbiAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9rMyA9IDA7IF9rMyA8IG9wdGlvbnMuY2hhbm5lbENvdW50OyBfazMgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICBpbnB1dENoYW5uZWxTcGxpdHRlck5vZGVzW19pNV0uZGlzY29ubmVjdChpbnB1dENoYW5uZWxNZXJnZXJOb2RlLCBfazMsIF9qNSAqIG9wdGlvbnMuY2hhbm5lbENvdW50ICsgX2szKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHByb2Nlc3NvckNvbnN0cnVjdG9yLnBhcmFtZXRlckRlc2NyaXB0b3JzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBsZW5ndGggPSBwcm9jZXNzb3JDb25zdHJ1Y3Rvci5wYXJhbWV0ZXJEZXNjcmlwdG9ycy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICBmb3IgKHZhciBfajYgPSAwOyBfajYgPCBsZW5ndGg7IF9qNiArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb25zdGFudFNvdXJjZU5vZGUgPSBjb25zdGFudFNvdXJjZU5vZGVzW19qNl07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0YW50U291cmNlTm9kZS5kaXNjb25uZWN0KGlucHV0Q2hhbm5lbE1lcmdlck5vZGUsIDAsIG51bWJlck9mSW5wdXRDaGFubmVscyArIF9qNik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0YW50U291cmNlTm9kZS5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlucHV0Q2hhbm5lbE1lcmdlck5vZGUuZGlzY29ubmVjdChzY3JpcHRQcm9jZXNzb3JOb2RlKTtcbiAgICAgICAgICAgICAgICBzY3JpcHRQcm9jZXNzb3JOb2RlLm9uYXVkaW9wcm9jZXNzID0gbnVsbDsgLy8gdHNsaW50OmRpc2FibGUtbGluZTpkZXByZWNhdGlvblxuICAgICAgICAgICAgICAgIGlmIChpc0Nvbm5lY3RlZCkge1xuICAgICAgICAgICAgICAgICAgZGlzY29ubmVjdE91dHB1dHNHcmFwaCgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBkaXNjb25uZWN0RmFrZUdyYXBoKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAxOyAvLyBicmVha1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZm9yICh2YXIgX2k1ID0gMDsgX2k1IDwgYnVmZmVyU2l6ZTsgX2k1ICs9IDEyOCkge1xuICAgICAgICAgICAgICBpZiAoX2xvb3AyKF9pNSkpIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGlzQ29ubmVjdGVkID0gZmFsc2U7XG4gICAgICAgIC8vIEJ1ZyAjODc6IE9ubHkgRmlyZWZveCB3aWxsIGZpcmUgYW4gQXVkaW9Qcm9jZXNzaW5nRXZlbnQgaWYgdGhlcmUgaXMgbm8gY29ubmVjdGVkIG91dHB1dC5cbiAgICAgICAgdmFyIG5hdGl2ZUdhaW5Ob2RlID0gY3JlYXRlTmF0aXZlR2Fpbk5vZGUobmF0aXZlQ29udGV4dCwge1xuICAgICAgICAgIGNoYW5uZWxDb3VudDogMSxcbiAgICAgICAgICBjaGFubmVsQ291bnRNb2RlOiAnZXhwbGljaXQnLFxuICAgICAgICAgIGNoYW5uZWxJbnRlcnByZXRhdGlvbjogJ2Rpc2NyZXRlJyxcbiAgICAgICAgICBnYWluOiAwXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgY29ubmVjdEZha2VHcmFwaCA9IGZ1bmN0aW9uIGNvbm5lY3RGYWtlR3JhcGgoKSB7XG4gICAgICAgICAgcmV0dXJuIHNjcmlwdFByb2Nlc3Nvck5vZGUuY29ubmVjdChuYXRpdmVHYWluTm9kZSkuY29ubmVjdChuYXRpdmVDb250ZXh0LmRlc3RpbmF0aW9uKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGRpc2Nvbm5lY3RGYWtlR3JhcGggPSBmdW5jdGlvbiBkaXNjb25uZWN0RmFrZUdyYXBoKCkge1xuICAgICAgICAgIHNjcmlwdFByb2Nlc3Nvck5vZGUuZGlzY29ubmVjdChuYXRpdmVHYWluTm9kZSk7XG4gICAgICAgICAgbmF0aXZlR2Fpbk5vZGUuZGlzY29ubmVjdCgpO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgd2hlbkNvbm5lY3RlZCA9IGZ1bmN0aW9uIHdoZW5Db25uZWN0ZWQoKSB7XG4gICAgICAgICAgaWYgKGlzQWN0aXZlKSB7XG4gICAgICAgICAgICBkaXNjb25uZWN0RmFrZUdyYXBoKCk7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5udW1iZXJPZk91dHB1dHMgPiAwKSB7XG4gICAgICAgICAgICAgIHNjcmlwdFByb2Nlc3Nvck5vZGUuY29ubmVjdChvdXRwdXRDaGFubmVsU3BsaXR0ZXJOb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIF9pNiA9IDAsIG91dHB1dENoYW5uZWxTcGxpdHRlck5vZGVPdXRwdXQgPSAwOyBfaTYgPCBvcHRpb25zLm51bWJlck9mT3V0cHV0czsgX2k2ICs9IDEpIHtcbiAgICAgICAgICAgICAgdmFyIG91dHB1dENoYW5uZWxNZXJnZXJOb2RlID0gb3V0cHV0Q2hhbm5lbE1lcmdlck5vZGVzW19pNl07XG4gICAgICAgICAgICAgIGZvciAodmFyIF9qNyA9IDA7IF9qNyA8IG91dHB1dENoYW5uZWxDb3VudFtfaTZdOyBfajcgKz0gMSkge1xuICAgICAgICAgICAgICAgIG91dHB1dENoYW5uZWxTcGxpdHRlck5vZGUuY29ubmVjdChvdXRwdXRDaGFubmVsTWVyZ2VyTm9kZSwgb3V0cHV0Q2hhbm5lbFNwbGl0dGVyTm9kZU91dHB1dCArIF9qNywgX2o3KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBvdXRwdXRDaGFubmVsU3BsaXR0ZXJOb2RlT3V0cHV0ICs9IG91dHB1dENoYW5uZWxDb3VudFtfaTZdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpc0Nvbm5lY3RlZCA9IHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIHZhciB3aGVuRGlzY29ubmVjdGVkID0gZnVuY3Rpb24gd2hlbkRpc2Nvbm5lY3RlZCgpIHtcbiAgICAgICAgICBpZiAoaXNBY3RpdmUpIHtcbiAgICAgICAgICAgIGNvbm5lY3RGYWtlR3JhcGgoKTtcbiAgICAgICAgICAgIGRpc2Nvbm5lY3RPdXRwdXRzR3JhcGgoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaXNDb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgICAgY29ubmVjdEZha2VHcmFwaCgpO1xuICAgICAgICByZXR1cm4gbW9uaXRvckNvbm5lY3Rpb25zKG5hdGl2ZUF1ZGlvV29ya2xldE5vZGVGYWtlciwgd2hlbkNvbm5lY3RlZCwgd2hlbkRpc2Nvbm5lY3RlZCk7XG4gICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlTmF0aXZlQmlxdWFkRmlsdGVyTm9kZSA9IGZ1bmN0aW9uIGNyZWF0ZU5hdGl2ZUJpcXVhZEZpbHRlck5vZGUobmF0aXZlQ29udGV4dCwgb3B0aW9ucykge1xuICAgICAgdmFyIG5hdGl2ZUJpcXVhZEZpbHRlck5vZGUgPSBuYXRpdmVDb250ZXh0LmNyZWF0ZUJpcXVhZEZpbHRlcigpO1xuICAgICAgYXNzaWduTmF0aXZlQXVkaW9Ob2RlT3B0aW9ucyhuYXRpdmVCaXF1YWRGaWx0ZXJOb2RlLCBvcHRpb25zKTtcbiAgICAgIGFzc2lnbk5hdGl2ZUF1ZGlvTm9kZUF1ZGlvUGFyYW1WYWx1ZShuYXRpdmVCaXF1YWRGaWx0ZXJOb2RlLCBvcHRpb25zLCAnUScpO1xuICAgICAgYXNzaWduTmF0aXZlQXVkaW9Ob2RlQXVkaW9QYXJhbVZhbHVlKG5hdGl2ZUJpcXVhZEZpbHRlck5vZGUsIG9wdGlvbnMsICdkZXR1bmUnKTtcbiAgICAgIGFzc2lnbk5hdGl2ZUF1ZGlvTm9kZUF1ZGlvUGFyYW1WYWx1ZShuYXRpdmVCaXF1YWRGaWx0ZXJOb2RlLCBvcHRpb25zLCAnZnJlcXVlbmN5Jyk7XG4gICAgICBhc3NpZ25OYXRpdmVBdWRpb05vZGVBdWRpb1BhcmFtVmFsdWUobmF0aXZlQmlxdWFkRmlsdGVyTm9kZSwgb3B0aW9ucywgJ2dhaW4nKTtcbiAgICAgIGFzc2lnbk5hdGl2ZUF1ZGlvTm9kZU9wdGlvbihuYXRpdmVCaXF1YWRGaWx0ZXJOb2RlLCBvcHRpb25zLCAndHlwZScpO1xuICAgICAgcmV0dXJuIG5hdGl2ZUJpcXVhZEZpbHRlck5vZGU7XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVOYXRpdmVDaGFubmVsTWVyZ2VyTm9kZUZhY3RvcnkgPSBmdW5jdGlvbiBjcmVhdGVOYXRpdmVDaGFubmVsTWVyZ2VyTm9kZUZhY3RvcnkobmF0aXZlQXVkaW9Db250ZXh0Q29uc3RydWN0b3IsIHdyYXBDaGFubmVsTWVyZ2VyTm9kZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChuYXRpdmVDb250ZXh0LCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBuYXRpdmVDaGFubmVsTWVyZ2VyTm9kZSA9IG5hdGl2ZUNvbnRleHQuY3JlYXRlQ2hhbm5lbE1lcmdlcihvcHRpb25zLm51bWJlck9mSW5wdXRzKTtcbiAgICAgICAgLypcbiAgICAgICAgICogQnVnICMyMDogU2FmYXJpIHJlcXVpcmVzIGEgY29ubmVjdGlvbiBvZiBhbnkga2luZCB0byB0cmVhdCB0aGUgaW5wdXQgc2lnbmFsIGNvcnJlY3RseS5cbiAgICAgICAgICogQHRvZG8gVW5mb3J0dW5hdGVseSB0aGVyZSBpcyBubyB3YXkgdG8gdGVzdCBmb3IgdGhpcyBiZWhhdmlvciBpbiBhIHN5bmNocm9ub3VzIGZhc2hpb24gd2hpY2ggaXMgd2h5IHRlc3RpbmcgZm9yIHRoZSBleGlzdGVuY2Ugb2ZcbiAgICAgICAgICogdGhlIHdlYmtpdEF1ZGlvQ29udGV4dCBpcyB1c2VkIGFzIGEgd29ya2Fyb3VuZCBoZXJlLlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKG5hdGl2ZUF1ZGlvQ29udGV4dENvbnN0cnVjdG9yICE9PSBudWxsICYmIG5hdGl2ZUF1ZGlvQ29udGV4dENvbnN0cnVjdG9yLm5hbWUgPT09ICd3ZWJraXRBdWRpb0NvbnRleHQnKSB7XG4gICAgICAgICAgd3JhcENoYW5uZWxNZXJnZXJOb2RlKG5hdGl2ZUNvbnRleHQsIG5hdGl2ZUNoYW5uZWxNZXJnZXJOb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBhc3NpZ25OYXRpdmVBdWRpb05vZGVPcHRpb25zKG5hdGl2ZUNoYW5uZWxNZXJnZXJOb2RlLCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIG5hdGl2ZUNoYW5uZWxNZXJnZXJOb2RlO1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIHdyYXBDaGFubmVsU3BsaXR0ZXJOb2RlID0gZnVuY3Rpb24gd3JhcENoYW5uZWxTcGxpdHRlck5vZGUoY2hhbm5lbFNwbGl0dGVyTm9kZSkge1xuICAgICAgdmFyIGNoYW5uZWxDb3VudCA9IGNoYW5uZWxTcGxpdHRlck5vZGUubnVtYmVyT2ZPdXRwdXRzO1xuICAgICAgLy8gQnVnICM5NzogU2FmYXJpIGRvZXMgbm90IHRocm93IGFuIGVycm9yIHdoZW4gYXR0ZW1wdGluZyB0byBjaGFuZ2UgdGhlIGNoYW5uZWxDb3VudCB0byBzb21ldGhpbmcgb3RoZXIgdGhhbiBpdHMgaW5pdGlhbCB2YWx1ZS5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjaGFubmVsU3BsaXR0ZXJOb2RlLCAnY2hhbm5lbENvdW50Jywge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gY2hhbm5lbENvdW50O1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICAgIGlmICh2YWx1ZSAhPT0gY2hhbm5lbENvdW50KSB7XG4gICAgICAgICAgICB0aHJvdyBjcmVhdGVJbnZhbGlkU3RhdGVFcnJvcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICAvLyBCdWcgIzMwOiBTYWZhcmkgZG9lcyBub3QgdGhyb3cgYW4gZXJyb3Igd2hlbiBhdHRlbXB0aW5nIHRvIGNoYW5nZSB0aGUgY2hhbm5lbENvdW50TW9kZSB0byBzb21ldGhpbmcgb3RoZXIgdGhhbiBleHBsaWNpdC5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjaGFubmVsU3BsaXR0ZXJOb2RlLCAnY2hhbm5lbENvdW50TW9kZScsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuICdleHBsaWNpdCc7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgICAgaWYgKHZhbHVlICE9PSAnZXhwbGljaXQnKSB7XG4gICAgICAgICAgICB0aHJvdyBjcmVhdGVJbnZhbGlkU3RhdGVFcnJvcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICAvLyBCdWcgIzMyOiBTYWZhcmkgZG9lcyBub3QgdGhyb3cgYW4gZXJyb3Igd2hlbiBhdHRlbXB0aW5nIHRvIGNoYW5nZSB0aGUgY2hhbm5lbEludGVycHJldGF0aW9uIHRvIHNvbWV0aGluZyBvdGhlciB0aGFuIGRpc2NyZXRlLlxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNoYW5uZWxTcGxpdHRlck5vZGUsICdjaGFubmVsSW50ZXJwcmV0YXRpb24nLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgIHJldHVybiAnZGlzY3JldGUnO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJ2Rpc2NyZXRlJykge1xuICAgICAgICAgICAgdGhyb3cgY3JlYXRlSW52YWxpZFN0YXRlRXJyb3IoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlTmF0aXZlQ2hhbm5lbFNwbGl0dGVyTm9kZSA9IGZ1bmN0aW9uIGNyZWF0ZU5hdGl2ZUNoYW5uZWxTcGxpdHRlck5vZGUobmF0aXZlQ29udGV4dCwgb3B0aW9ucykge1xuICAgICAgdmFyIG5hdGl2ZUNoYW5uZWxTcGxpdHRlck5vZGUgPSBuYXRpdmVDb250ZXh0LmNyZWF0ZUNoYW5uZWxTcGxpdHRlcihvcHRpb25zLm51bWJlck9mT3V0cHV0cyk7XG4gICAgICAvLyBCdWcgIzk2OiBTYWZhcmkgZG9lcyBub3QgaGF2ZSB0aGUgY29ycmVjdCBjaGFubmVsQ291bnQuXG4gICAgICAvLyBCdWcgIzI5OiBTYWZhcmkgZG9lcyBub3QgaGF2ZSB0aGUgY29ycmVjdCBjaGFubmVsQ291bnRNb2RlLlxuICAgICAgLy8gQnVnICMzMTogU2FmYXJpIGRvZXMgbm90IGhhdmUgdGhlIGNvcnJlY3QgY2hhbm5lbEludGVycHJldGF0aW9uLlxuICAgICAgYXNzaWduTmF0aXZlQXVkaW9Ob2RlT3B0aW9ucyhuYXRpdmVDaGFubmVsU3BsaXR0ZXJOb2RlLCBvcHRpb25zKTtcbiAgICAgIC8vIEJ1ZyAjMjksICMzMCwgIzMxLCAjMzIsICM5NiAmICM5NzogT25seSBDaHJvbWUsIEVkZ2UgJiBGaXJlZm94IHBhcnRpYWxseSBzdXBwb3J0IHRoZSBzcGVjIHlldC5cbiAgICAgIHdyYXBDaGFubmVsU3BsaXR0ZXJOb2RlKG5hdGl2ZUNoYW5uZWxTcGxpdHRlck5vZGUpO1xuICAgICAgcmV0dXJuIG5hdGl2ZUNoYW5uZWxTcGxpdHRlck5vZGU7XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVOYXRpdmVDb25zdGFudFNvdXJjZU5vZGVGYWN0b3J5ID0gZnVuY3Rpb24gY3JlYXRlTmF0aXZlQ29uc3RhbnRTb3VyY2VOb2RlRmFjdG9yeShhZGRTaWxlbnRDb25uZWN0aW9uLCBjYWNoZVRlc3RSZXN1bHQsIGNyZWF0ZU5hdGl2ZUNvbnN0YW50U291cmNlTm9kZUZha2VyLCB0ZXN0QXVkaW9TY2hlZHVsZWRTb3VyY2VOb2RlU3RhcnRNZXRob2ROZWdhdGl2ZVBhcmFtZXRlcnNTdXBwb3J0LCB0ZXN0QXVkaW9TY2hlZHVsZWRTb3VyY2VOb2RlU3RvcE1ldGhvZE5lZ2F0aXZlUGFyYW1ldGVyc1N1cHBvcnQpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAobmF0aXZlQ29udGV4dCwgb3B0aW9ucykge1xuICAgICAgICAvLyBCdWcgIzYyOiBTYWZhcmkgZG9lcyBub3Qgc3VwcG9ydCBDb25zdGFudFNvdXJjZU5vZGVzLlxuICAgICAgICBpZiAobmF0aXZlQ29udGV4dC5jcmVhdGVDb25zdGFudFNvdXJjZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZU5hdGl2ZUNvbnN0YW50U291cmNlTm9kZUZha2VyKG5hdGl2ZUNvbnRleHQsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuYXRpdmVDb25zdGFudFNvdXJjZU5vZGUgPSBuYXRpdmVDb250ZXh0LmNyZWF0ZUNvbnN0YW50U291cmNlKCk7XG4gICAgICAgIGFzc2lnbk5hdGl2ZUF1ZGlvTm9kZU9wdGlvbnMobmF0aXZlQ29uc3RhbnRTb3VyY2VOb2RlLCBvcHRpb25zKTtcbiAgICAgICAgYXNzaWduTmF0aXZlQXVkaW9Ob2RlQXVkaW9QYXJhbVZhbHVlKG5hdGl2ZUNvbnN0YW50U291cmNlTm9kZSwgb3B0aW9ucywgJ29mZnNldCcpO1xuICAgICAgICAvLyBCdWcgIzQ0OiBTYWZhcmkgZG9lcyBub3QgdGhyb3cgYSBSYW5nZUVycm9yIHlldC5cbiAgICAgICAgaWYgKCFjYWNoZVRlc3RSZXN1bHQodGVzdEF1ZGlvU2NoZWR1bGVkU291cmNlTm9kZVN0YXJ0TWV0aG9kTmVnYXRpdmVQYXJhbWV0ZXJzU3VwcG9ydCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB0ZXN0QXVkaW9TY2hlZHVsZWRTb3VyY2VOb2RlU3RhcnRNZXRob2ROZWdhdGl2ZVBhcmFtZXRlcnNTdXBwb3J0KG5hdGl2ZUNvbnRleHQpO1xuICAgICAgICB9KSkge1xuICAgICAgICAgIHdyYXBBdWRpb1NjaGVkdWxlZFNvdXJjZU5vZGVTdGFydE1ldGhvZE5lZ2F0aXZlUGFyYW1ldGVycyhuYXRpdmVDb25zdGFudFNvdXJjZU5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEJ1ZyAjNDQ6IE9ubHkgRmlyZWZveCBkb2VzIG5vdCB0aHJvdyBhIFJhbmdlRXJyb3IgeWV0LlxuICAgICAgICBpZiAoIWNhY2hlVGVzdFJlc3VsdCh0ZXN0QXVkaW9TY2hlZHVsZWRTb3VyY2VOb2RlU3RvcE1ldGhvZE5lZ2F0aXZlUGFyYW1ldGVyc1N1cHBvcnQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gdGVzdEF1ZGlvU2NoZWR1bGVkU291cmNlTm9kZVN0b3BNZXRob2ROZWdhdGl2ZVBhcmFtZXRlcnNTdXBwb3J0KG5hdGl2ZUNvbnRleHQpO1xuICAgICAgICB9KSkge1xuICAgICAgICAgIHdyYXBBdWRpb1NjaGVkdWxlZFNvdXJjZU5vZGVTdG9wTWV0aG9kTmVnYXRpdmVQYXJhbWV0ZXJzKG5hdGl2ZUNvbnN0YW50U291cmNlTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQnVnICMxNzU6IFNhZmFyaSB3aWxsIG5vdCBmaXJlIGFuIGVuZGVkIGV2ZW50IGlmIHRoZSBDb25zdGFudFNvdXJjZU5vZGUgaXMgdW5jb25uZWN0ZWQuXG4gICAgICAgIGFkZFNpbGVudENvbm5lY3Rpb24obmF0aXZlQ29udGV4dCwgbmF0aXZlQ29uc3RhbnRTb3VyY2VOb2RlKTtcbiAgICAgICAgcmV0dXJuIG5hdGl2ZUNvbnN0YW50U291cmNlTm9kZTtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBpbnRlcmNlcHRDb25uZWN0aW9ucyA9IGZ1bmN0aW9uIGludGVyY2VwdENvbm5lY3Rpb25zKG9yaWdpbmFsLCBpbnRlcmNlcHRvcikge1xuICAgICAgb3JpZ2luYWwuY29ubmVjdCA9IGludGVyY2VwdG9yLmNvbm5lY3QuYmluZChpbnRlcmNlcHRvcik7XG4gICAgICBvcmlnaW5hbC5kaXNjb25uZWN0ID0gaW50ZXJjZXB0b3IuZGlzY29ubmVjdC5iaW5kKGludGVyY2VwdG9yKTtcbiAgICAgIHJldHVybiBvcmlnaW5hbDtcbiAgICB9O1xuXG4gICAgdmFyIF9leGNsdWRlZCQzID0gW1wib2Zmc2V0XCJdO1xuICAgIGZ1bmN0aW9uIG93bktleXMkZChlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XG4gICAgZnVuY3Rpb24gX29iamVjdFNwcmVhZCRkKGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMkZChPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMkZChPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxuICAgIHZhciBjcmVhdGVOYXRpdmVDb25zdGFudFNvdXJjZU5vZGVGYWtlckZhY3RvcnkgPSBmdW5jdGlvbiBjcmVhdGVOYXRpdmVDb25zdGFudFNvdXJjZU5vZGVGYWtlckZhY3RvcnkoYWRkU2lsZW50Q29ubmVjdGlvbiwgY3JlYXRlTmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2RlLCBjcmVhdGVOYXRpdmVHYWluTm9kZSwgbW9uaXRvckNvbm5lY3Rpb25zKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKG5hdGl2ZUNvbnRleHQsIF9yZWYpIHtcbiAgICAgICAgdmFyIG9mZnNldCA9IF9yZWYub2Zmc2V0LFxuICAgICAgICAgIGF1ZGlvTm9kZU9wdGlvbnMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgX2V4Y2x1ZGVkJDMpO1xuICAgICAgICB2YXIgYXVkaW9CdWZmZXIgPSBuYXRpdmVDb250ZXh0LmNyZWF0ZUJ1ZmZlcigxLCAyLCA0NDEwMCk7XG4gICAgICAgIHZhciBhdWRpb0J1ZmZlclNvdXJjZU5vZGUgPSBjcmVhdGVOYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGUobmF0aXZlQ29udGV4dCwge1xuICAgICAgICAgIGJ1ZmZlcjogbnVsbCxcbiAgICAgICAgICBjaGFubmVsQ291bnQ6IDIsXG4gICAgICAgICAgY2hhbm5lbENvdW50TW9kZTogJ21heCcsXG4gICAgICAgICAgY2hhbm5lbEludGVycHJldGF0aW9uOiAnc3BlYWtlcnMnLFxuICAgICAgICAgIGxvb3A6IGZhbHNlLFxuICAgICAgICAgIGxvb3BFbmQ6IDAsXG4gICAgICAgICAgbG9vcFN0YXJ0OiAwLFxuICAgICAgICAgIHBsYXliYWNrUmF0ZTogMVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGdhaW5Ob2RlID0gY3JlYXRlTmF0aXZlR2Fpbk5vZGUobmF0aXZlQ29udGV4dCwgX29iamVjdFNwcmVhZCRkKF9vYmplY3RTcHJlYWQkZCh7fSwgYXVkaW9Ob2RlT3B0aW9ucyksIHt9LCB7XG4gICAgICAgICAgZ2Fpbjogb2Zmc2V0XG4gICAgICAgIH0pKTtcbiAgICAgICAgLy8gQnVnICM1OiBTYWZhcmkgZG9lcyBub3Qgc3VwcG9ydCBjb3B5RnJvbUNoYW5uZWwoKSBhbmQgY29weVRvQ2hhbm5lbCgpLlxuICAgICAgICB2YXIgY2hhbm5lbERhdGEgPSBhdWRpb0J1ZmZlci5nZXRDaGFubmVsRGF0YSgwKTtcbiAgICAgICAgLy8gQnVnICM5NTogU2FmYXJpIGRvZXMgbm90IHBsYXkgb3IgbG9vcCBvbmUgc2FtcGxlIGJ1ZmZlcnMuXG4gICAgICAgIGNoYW5uZWxEYXRhWzBdID0gMTtcbiAgICAgICAgY2hhbm5lbERhdGFbMV0gPSAxO1xuICAgICAgICBhdWRpb0J1ZmZlclNvdXJjZU5vZGUuYnVmZmVyID0gYXVkaW9CdWZmZXI7XG4gICAgICAgIGF1ZGlvQnVmZmVyU291cmNlTm9kZS5sb29wID0gdHJ1ZTtcbiAgICAgICAgdmFyIG5hdGl2ZUNvbnN0YW50U291cmNlTm9kZUZha2VyID0ge1xuICAgICAgICAgIGdldCBidWZmZXJTaXplKCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGdldCBjaGFubmVsQ291bnQoKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2Fpbk5vZGUuY2hhbm5lbENvdW50O1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc2V0IGNoYW5uZWxDb3VudCh2YWx1ZSkge1xuICAgICAgICAgICAgZ2Fpbk5vZGUuY2hhbm5lbENvdW50ID0gdmFsdWU7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBnZXQgY2hhbm5lbENvdW50TW9kZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBnYWluTm9kZS5jaGFubmVsQ291bnRNb2RlO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc2V0IGNoYW5uZWxDb3VudE1vZGUodmFsdWUpIHtcbiAgICAgICAgICAgIGdhaW5Ob2RlLmNoYW5uZWxDb3VudE1vZGUgPSB2YWx1ZTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGdldCBjaGFubmVsSW50ZXJwcmV0YXRpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2Fpbk5vZGUuY2hhbm5lbEludGVycHJldGF0aW9uO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc2V0IGNoYW5uZWxJbnRlcnByZXRhdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgZ2Fpbk5vZGUuY2hhbm5lbEludGVycHJldGF0aW9uID0gdmFsdWU7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBnZXQgY29udGV4dCgpIHtcbiAgICAgICAgICAgIHJldHVybiBnYWluTm9kZS5jb250ZXh0O1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZ2V0IGlucHV0cygpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGdldCBudW1iZXJPZklucHV0cygpIHtcbiAgICAgICAgICAgIHJldHVybiBhdWRpb0J1ZmZlclNvdXJjZU5vZGUubnVtYmVyT2ZJbnB1dHM7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBnZXQgbnVtYmVyT2ZPdXRwdXRzKCkge1xuICAgICAgICAgICAgcmV0dXJuIGdhaW5Ob2RlLm51bWJlck9mT3V0cHV0cztcbiAgICAgICAgICB9LFxuICAgICAgICAgIGdldCBvZmZzZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2Fpbk5vZGUuZ2FpbjtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGdldCBvbmVuZGVkKCkge1xuICAgICAgICAgICAgcmV0dXJuIGF1ZGlvQnVmZmVyU291cmNlTm9kZS5vbmVuZGVkO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc2V0IG9uZW5kZWQodmFsdWUpIHtcbiAgICAgICAgICAgIGF1ZGlvQnVmZmVyU291cmNlTm9kZS5vbmVuZGVkID0gdmFsdWU7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBhZGRFdmVudExpc3RlbmVyOiBmdW5jdGlvbiBhZGRFdmVudExpc3RlbmVyKCkge1xuICAgICAgICAgICAgcmV0dXJuIGF1ZGlvQnVmZmVyU291cmNlTm9kZS5hZGRFdmVudExpc3RlbmVyKGFyZ3VtZW50cy5sZW5ndGggPD0gMCA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1swXSwgYXJndW1lbnRzLmxlbmd0aCA8PSAxID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzFdLCBhcmd1bWVudHMubGVuZ3RoIDw9IDIgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMl0pO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZGlzcGF0Y2hFdmVudDogZnVuY3Rpb24gZGlzcGF0Y2hFdmVudCgpIHtcbiAgICAgICAgICAgIHJldHVybiBhdWRpb0J1ZmZlclNvdXJjZU5vZGUuZGlzcGF0Y2hFdmVudChhcmd1bWVudHMubGVuZ3RoIDw9IDAgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMF0pO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcigpIHtcbiAgICAgICAgICAgIHJldHVybiBhdWRpb0J1ZmZlclNvdXJjZU5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihhcmd1bWVudHMubGVuZ3RoIDw9IDAgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMF0sIGFyZ3VtZW50cy5sZW5ndGggPD0gMSA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzLmxlbmd0aCA8PSAyID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzJdKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHN0YXJ0OiBmdW5jdGlvbiBzdGFydCgpIHtcbiAgICAgICAgICAgIHZhciB3aGVuID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAwO1xuICAgICAgICAgICAgYXVkaW9CdWZmZXJTb3VyY2VOb2RlLnN0YXJ0LmNhbGwoYXVkaW9CdWZmZXJTb3VyY2VOb2RlLCB3aGVuKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHN0b3A6IGZ1bmN0aW9uIHN0b3AoKSB7XG4gICAgICAgICAgICB2YXIgd2hlbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogMDtcbiAgICAgICAgICAgIGF1ZGlvQnVmZmVyU291cmNlTm9kZS5zdG9wLmNhbGwoYXVkaW9CdWZmZXJTb3VyY2VOb2RlLCB3aGVuKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHZhciB3aGVuQ29ubmVjdGVkID0gZnVuY3Rpb24gd2hlbkNvbm5lY3RlZCgpIHtcbiAgICAgICAgICByZXR1cm4gYXVkaW9CdWZmZXJTb3VyY2VOb2RlLmNvbm5lY3QoZ2Fpbk5vZGUpO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgd2hlbkRpc2Nvbm5lY3RlZCA9IGZ1bmN0aW9uIHdoZW5EaXNjb25uZWN0ZWQoKSB7XG4gICAgICAgICAgcmV0dXJuIGF1ZGlvQnVmZmVyU291cmNlTm9kZS5kaXNjb25uZWN0KGdhaW5Ob2RlKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gQnVnICMxNzU6IFNhZmFyaSB3aWxsIG5vdCBmaXJlIGFuIGVuZGVkIGV2ZW50IGlmIHRoZSBBdWRpb0J1ZmZlclNvdXJjZU5vZGUgaXMgdW5jb25uZWN0ZWQuXG4gICAgICAgIGFkZFNpbGVudENvbm5lY3Rpb24obmF0aXZlQ29udGV4dCwgYXVkaW9CdWZmZXJTb3VyY2VOb2RlKTtcbiAgICAgICAgcmV0dXJuIG1vbml0b3JDb25uZWN0aW9ucyhpbnRlcmNlcHRDb25uZWN0aW9ucyhuYXRpdmVDb25zdGFudFNvdXJjZU5vZGVGYWtlciwgZ2Fpbk5vZGUpLCB3aGVuQ29ubmVjdGVkLCB3aGVuRGlzY29ubmVjdGVkKTtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVOYXRpdmVDb252b2x2ZXJOb2RlRmFjdG9yeSA9IGZ1bmN0aW9uIGNyZWF0ZU5hdGl2ZUNvbnZvbHZlck5vZGVGYWN0b3J5KGNyZWF0ZU5vdFN1cHBvcnRlZEVycm9yLCBvdmVyd3JpdGVBY2Nlc3NvcnMpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAobmF0aXZlQ29udGV4dCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgbmF0aXZlQ29udm9sdmVyTm9kZSA9IG5hdGl2ZUNvbnRleHQuY3JlYXRlQ29udm9sdmVyKCk7XG4gICAgICAgIGFzc2lnbk5hdGl2ZUF1ZGlvTm9kZU9wdGlvbnMobmF0aXZlQ29udm9sdmVyTm9kZSwgb3B0aW9ucyk7XG4gICAgICAgIC8vIFRoZSBub3JtYWxpemUgcHJvcGVydHkgbmVlZHMgdG8gYmUgc2V0IGJlZm9yZSBzZXR0aW5nIHRoZSBidWZmZXIuXG4gICAgICAgIGlmIChvcHRpb25zLmRpc2FibGVOb3JtYWxpemF0aW9uID09PSBuYXRpdmVDb252b2x2ZXJOb2RlLm5vcm1hbGl6ZSkge1xuICAgICAgICAgIG5hdGl2ZUNvbnZvbHZlck5vZGUubm9ybWFsaXplID0gIW9wdGlvbnMuZGlzYWJsZU5vcm1hbGl6YXRpb247XG4gICAgICAgIH1cbiAgICAgICAgYXNzaWduTmF0aXZlQXVkaW9Ob2RlT3B0aW9uKG5hdGl2ZUNvbnZvbHZlck5vZGUsIG9wdGlvbnMsICdidWZmZXInKTtcbiAgICAgICAgLy8gQnVnICMxMTM6IFNhZmFyaSBkb2VzIGFsbG93IHRvIHNldCB0aGUgY2hhbm5lbENvdW50IHRvIGEgdmFsdWUgbGFyZ2VyIHRoYW4gMi5cbiAgICAgICAgaWYgKG9wdGlvbnMuY2hhbm5lbENvdW50ID4gMikge1xuICAgICAgICAgIHRocm93IGNyZWF0ZU5vdFN1cHBvcnRlZEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgb3ZlcndyaXRlQWNjZXNzb3JzKG5hdGl2ZUNvbnZvbHZlck5vZGUsICdjaGFubmVsQ291bnQnLCBmdW5jdGlvbiAoZ2V0KSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXQuY2FsbChuYXRpdmVDb252b2x2ZXJOb2RlKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9LCBmdW5jdGlvbiAoc2V0KSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlID4gMikge1xuICAgICAgICAgICAgICB0aHJvdyBjcmVhdGVOb3RTdXBwb3J0ZWRFcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNldC5jYWxsKG5hdGl2ZUNvbnZvbHZlck5vZGUsIHZhbHVlKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gQnVnICMxMTQ6IFNhZmFyaSBhbGxvd3MgdG8gc2V0IHRoZSBjaGFubmVsQ291bnRNb2RlIHRvICdtYXgnLlxuICAgICAgICBpZiAob3B0aW9ucy5jaGFubmVsQ291bnRNb2RlID09PSAnbWF4Jykge1xuICAgICAgICAgIHRocm93IGNyZWF0ZU5vdFN1cHBvcnRlZEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgb3ZlcndyaXRlQWNjZXNzb3JzKG5hdGl2ZUNvbnZvbHZlck5vZGUsICdjaGFubmVsQ291bnRNb2RlJywgZnVuY3Rpb24gKGdldCkge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0LmNhbGwobmF0aXZlQ29udm9sdmVyTm9kZSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKHNldCkge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gJ21heCcpIHtcbiAgICAgICAgICAgICAgdGhyb3cgY3JlYXRlTm90U3VwcG9ydGVkRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzZXQuY2FsbChuYXRpdmVDb252b2x2ZXJOb2RlLCB2YWx1ZSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuYXRpdmVDb252b2x2ZXJOb2RlO1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZU5hdGl2ZURlbGF5Tm9kZSA9IGZ1bmN0aW9uIGNyZWF0ZU5hdGl2ZURlbGF5Tm9kZShuYXRpdmVDb250ZXh0LCBvcHRpb25zKSB7XG4gICAgICB2YXIgbmF0aXZlRGVsYXlOb2RlID0gbmF0aXZlQ29udGV4dC5jcmVhdGVEZWxheShvcHRpb25zLm1heERlbGF5VGltZSk7XG4gICAgICBhc3NpZ25OYXRpdmVBdWRpb05vZGVPcHRpb25zKG5hdGl2ZURlbGF5Tm9kZSwgb3B0aW9ucyk7XG4gICAgICBhc3NpZ25OYXRpdmVBdWRpb05vZGVBdWRpb1BhcmFtVmFsdWUobmF0aXZlRGVsYXlOb2RlLCBvcHRpb25zLCAnZGVsYXlUaW1lJyk7XG4gICAgICByZXR1cm4gbmF0aXZlRGVsYXlOb2RlO1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlTmF0aXZlRHluYW1pY3NDb21wcmVzc29yTm9kZUZhY3RvcnkgPSBmdW5jdGlvbiBjcmVhdGVOYXRpdmVEeW5hbWljc0NvbXByZXNzb3JOb2RlRmFjdG9yeShjcmVhdGVOb3RTdXBwb3J0ZWRFcnJvcikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChuYXRpdmVDb250ZXh0LCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBuYXRpdmVEeW5hbWljc0NvbXByZXNzb3JOb2RlID0gbmF0aXZlQ29udGV4dC5jcmVhdGVEeW5hbWljc0NvbXByZXNzb3IoKTtcbiAgICAgICAgYXNzaWduTmF0aXZlQXVkaW9Ob2RlT3B0aW9ucyhuYXRpdmVEeW5hbWljc0NvbXByZXNzb3JOb2RlLCBvcHRpb25zKTtcbiAgICAgICAgLy8gQnVnICMxMDg6IFNhZmFyaSBhbGxvd3MgYSBjaGFubmVsQ291bnQgb2YgdGhyZWUgYW5kIGFib3ZlLlxuICAgICAgICBpZiAob3B0aW9ucy5jaGFubmVsQ291bnQgPiAyKSB7XG4gICAgICAgICAgdGhyb3cgY3JlYXRlTm90U3VwcG9ydGVkRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBCdWcgIzEwOTogT25seSBDaHJvbWUgYW5kIEZpcmVmb3ggZGlzYWxsb3cgYSBjaGFubmVsQ291bnRNb2RlIG9mICdtYXgnLlxuICAgICAgICBpZiAob3B0aW9ucy5jaGFubmVsQ291bnRNb2RlID09PSAnbWF4Jykge1xuICAgICAgICAgIHRocm93IGNyZWF0ZU5vdFN1cHBvcnRlZEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgYXNzaWduTmF0aXZlQXVkaW9Ob2RlQXVkaW9QYXJhbVZhbHVlKG5hdGl2ZUR5bmFtaWNzQ29tcHJlc3Nvck5vZGUsIG9wdGlvbnMsICdhdHRhY2snKTtcbiAgICAgICAgYXNzaWduTmF0aXZlQXVkaW9Ob2RlQXVkaW9QYXJhbVZhbHVlKG5hdGl2ZUR5bmFtaWNzQ29tcHJlc3Nvck5vZGUsIG9wdGlvbnMsICdrbmVlJyk7XG4gICAgICAgIGFzc2lnbk5hdGl2ZUF1ZGlvTm9kZUF1ZGlvUGFyYW1WYWx1ZShuYXRpdmVEeW5hbWljc0NvbXByZXNzb3JOb2RlLCBvcHRpb25zLCAncmF0aW8nKTtcbiAgICAgICAgYXNzaWduTmF0aXZlQXVkaW9Ob2RlQXVkaW9QYXJhbVZhbHVlKG5hdGl2ZUR5bmFtaWNzQ29tcHJlc3Nvck5vZGUsIG9wdGlvbnMsICdyZWxlYXNlJyk7XG4gICAgICAgIGFzc2lnbk5hdGl2ZUF1ZGlvTm9kZUF1ZGlvUGFyYW1WYWx1ZShuYXRpdmVEeW5hbWljc0NvbXByZXNzb3JOb2RlLCBvcHRpb25zLCAndGhyZXNob2xkJyk7XG4gICAgICAgIHJldHVybiBuYXRpdmVEeW5hbWljc0NvbXByZXNzb3JOb2RlO1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZU5hdGl2ZUdhaW5Ob2RlID0gZnVuY3Rpb24gY3JlYXRlTmF0aXZlR2Fpbk5vZGUobmF0aXZlQ29udGV4dCwgb3B0aW9ucykge1xuICAgICAgdmFyIG5hdGl2ZUdhaW5Ob2RlID0gbmF0aXZlQ29udGV4dC5jcmVhdGVHYWluKCk7XG4gICAgICBhc3NpZ25OYXRpdmVBdWRpb05vZGVPcHRpb25zKG5hdGl2ZUdhaW5Ob2RlLCBvcHRpb25zKTtcbiAgICAgIGFzc2lnbk5hdGl2ZUF1ZGlvTm9kZUF1ZGlvUGFyYW1WYWx1ZShuYXRpdmVHYWluTm9kZSwgb3B0aW9ucywgJ2dhaW4nKTtcbiAgICAgIHJldHVybiBuYXRpdmVHYWluTm9kZTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZU5hdGl2ZUlJUkZpbHRlck5vZGVGYWN0b3J5ID0gZnVuY3Rpb24gY3JlYXRlTmF0aXZlSUlSRmlsdGVyTm9kZUZhY3RvcnkoY3JlYXRlTmF0aXZlSUlSRmlsdGVyTm9kZUZha2VyKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKG5hdGl2ZUNvbnRleHQsIGJhc2VMYXRlbmN5LCBvcHRpb25zKSB7XG4gICAgICAgIC8vIEJ1ZyAjOTogU2FmYXJpIGRvZXMgbm90IHN1cHBvcnQgSUlSRmlsdGVyTm9kZXMuXG4gICAgICAgIGlmIChuYXRpdmVDb250ZXh0LmNyZWF0ZUlJUkZpbHRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZU5hdGl2ZUlJUkZpbHRlck5vZGVGYWtlcihuYXRpdmVDb250ZXh0LCBiYXNlTGF0ZW5jeSwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQHRvZG8gVHlwZVNjcmlwdCBkZWZpbmVzIHRoZSBwYXJhbWV0ZXJzIG9mIGNyZWF0ZUlJUkZpbHRlcigpIGFzIGFycmF5cyBvZiBudW1iZXJzLlxuICAgICAgICB2YXIgbmF0aXZlSUlSRmlsdGVyTm9kZSA9IG5hdGl2ZUNvbnRleHQuY3JlYXRlSUlSRmlsdGVyKG9wdGlvbnMuZmVlZGZvcndhcmQsIG9wdGlvbnMuZmVlZGJhY2spO1xuICAgICAgICBhc3NpZ25OYXRpdmVBdWRpb05vZGVPcHRpb25zKG5hdGl2ZUlJUkZpbHRlck5vZGUsIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gbmF0aXZlSUlSRmlsdGVyTm9kZTtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGRpdmlkZShhLCBiKSB7XG4gICAgICB2YXIgZGVub21pbmF0b3IgPSBiWzBdICogYlswXSArIGJbMV0gKiBiWzFdO1xuICAgICAgcmV0dXJuIFsoYVswXSAqIGJbMF0gKyBhWzFdICogYlsxXSkgLyBkZW5vbWluYXRvciwgKGFbMV0gKiBiWzBdIC0gYVswXSAqIGJbMV0pIC8gZGVub21pbmF0b3JdO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtdWx0aXBseShhLCBiKSB7XG4gICAgICByZXR1cm4gW2FbMF0gKiBiWzBdIC0gYVsxXSAqIGJbMV0sIGFbMF0gKiBiWzFdICsgYVsxXSAqIGJbMF1dO1xuICAgIH1cbiAgICBmdW5jdGlvbiBldmFsdWF0ZVBvbHlub21pYWwoY29lZmZpY2llbnQsIHopIHtcbiAgICAgIHZhciByZXN1bHQgPSBbMCwgMF07XG4gICAgICBmb3IgKHZhciBpID0gY29lZmZpY2llbnQubGVuZ3RoIC0gMTsgaSA+PSAwOyBpIC09IDEpIHtcbiAgICAgICAgcmVzdWx0ID0gbXVsdGlwbHkocmVzdWx0LCB6KTtcbiAgICAgICAgcmVzdWx0WzBdICs9IGNvZWZmaWNpZW50W2ldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgdmFyIGNyZWF0ZU5hdGl2ZUlJUkZpbHRlck5vZGVGYWtlckZhY3RvcnkgPSBmdW5jdGlvbiBjcmVhdGVOYXRpdmVJSVJGaWx0ZXJOb2RlRmFrZXJGYWN0b3J5KGNyZWF0ZUludmFsaWRBY2Nlc3NFcnJvciwgY3JlYXRlSW52YWxpZFN0YXRlRXJyb3IsIGNyZWF0ZU5hdGl2ZVNjcmlwdFByb2Nlc3Nvck5vZGUsIGNyZWF0ZU5vdFN1cHBvcnRlZEVycm9yKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKG5hdGl2ZUNvbnRleHQsIGJhc2VMYXRlbmN5LCBfcmVmKSB7XG4gICAgICAgIHZhciBjaGFubmVsQ291bnQgPSBfcmVmLmNoYW5uZWxDb3VudCxcbiAgICAgICAgICBjaGFubmVsQ291bnRNb2RlID0gX3JlZi5jaGFubmVsQ291bnRNb2RlLFxuICAgICAgICAgIGNoYW5uZWxJbnRlcnByZXRhdGlvbiA9IF9yZWYuY2hhbm5lbEludGVycHJldGF0aW9uLFxuICAgICAgICAgIGZlZWRiYWNrID0gX3JlZi5mZWVkYmFjayxcbiAgICAgICAgICBmZWVkZm9yd2FyZCA9IF9yZWYuZmVlZGZvcndhcmQ7XG4gICAgICAgIHZhciBidWZmZXJTaXplID0gY29tcHV0ZUJ1ZmZlclNpemUoYmFzZUxhdGVuY3ksIG5hdGl2ZUNvbnRleHQuc2FtcGxlUmF0ZSk7XG4gICAgICAgIHZhciBjb252ZXJ0ZWRGZWVkYmFjayA9IGZlZWRiYWNrIGluc3RhbmNlb2YgRmxvYXQ2NEFycmF5ID8gZmVlZGJhY2sgOiBuZXcgRmxvYXQ2NEFycmF5KGZlZWRiYWNrKTtcbiAgICAgICAgdmFyIGNvbnZlcnRlZEZlZWRmb3J3YXJkID0gZmVlZGZvcndhcmQgaW5zdGFuY2VvZiBGbG9hdDY0QXJyYXkgPyBmZWVkZm9yd2FyZCA6IG5ldyBGbG9hdDY0QXJyYXkoZmVlZGZvcndhcmQpO1xuICAgICAgICB2YXIgZmVlZGJhY2tMZW5ndGggPSBjb252ZXJ0ZWRGZWVkYmFjay5sZW5ndGg7XG4gICAgICAgIHZhciBmZWVkZm9yd2FyZExlbmd0aCA9IGNvbnZlcnRlZEZlZWRmb3J3YXJkLmxlbmd0aDtcbiAgICAgICAgdmFyIG1pbkxlbmd0aCA9IE1hdGgubWluKGZlZWRiYWNrTGVuZ3RoLCBmZWVkZm9yd2FyZExlbmd0aCk7XG4gICAgICAgIGlmIChmZWVkYmFja0xlbmd0aCA9PT0gMCB8fCBmZWVkYmFja0xlbmd0aCA+IDIwKSB7XG4gICAgICAgICAgdGhyb3cgY3JlYXRlTm90U3VwcG9ydGVkRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29udmVydGVkRmVlZGJhY2tbMF0gPT09IDApIHtcbiAgICAgICAgICB0aHJvdyBjcmVhdGVJbnZhbGlkU3RhdGVFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmZWVkZm9yd2FyZExlbmd0aCA9PT0gMCB8fCBmZWVkZm9yd2FyZExlbmd0aCA+IDIwKSB7XG4gICAgICAgICAgdGhyb3cgY3JlYXRlTm90U3VwcG9ydGVkRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29udmVydGVkRmVlZGZvcndhcmRbMF0gPT09IDApIHtcbiAgICAgICAgICB0aHJvdyBjcmVhdGVJbnZhbGlkU3RhdGVFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb252ZXJ0ZWRGZWVkYmFja1swXSAhPT0gMSkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmVlZGZvcndhcmRMZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgY29udmVydGVkRmVlZGZvcndhcmRbaV0gLz0gY29udmVydGVkRmVlZGJhY2tbMF07XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBmZWVkYmFja0xlbmd0aDsgX2kgKz0gMSkge1xuICAgICAgICAgICAgY29udmVydGVkRmVlZGJhY2tbX2ldIC89IGNvbnZlcnRlZEZlZWRiYWNrWzBdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgc2NyaXB0UHJvY2Vzc29yTm9kZSA9IGNyZWF0ZU5hdGl2ZVNjcmlwdFByb2Nlc3Nvck5vZGUobmF0aXZlQ29udGV4dCwgYnVmZmVyU2l6ZSwgY2hhbm5lbENvdW50LCBjaGFubmVsQ291bnQpO1xuICAgICAgICBzY3JpcHRQcm9jZXNzb3JOb2RlLmNoYW5uZWxDb3VudCA9IGNoYW5uZWxDb3VudDtcbiAgICAgICAgc2NyaXB0UHJvY2Vzc29yTm9kZS5jaGFubmVsQ291bnRNb2RlID0gY2hhbm5lbENvdW50TW9kZTtcbiAgICAgICAgc2NyaXB0UHJvY2Vzc29yTm9kZS5jaGFubmVsSW50ZXJwcmV0YXRpb24gPSBjaGFubmVsSW50ZXJwcmV0YXRpb247XG4gICAgICAgIHZhciBidWZmZXJMZW5ndGggPSAzMjtcbiAgICAgICAgdmFyIGJ1ZmZlckluZGV4ZXMgPSBbXTtcbiAgICAgICAgdmFyIHhCdWZmZXJzID0gW107XG4gICAgICAgIHZhciB5QnVmZmVycyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBjaGFubmVsQ291bnQ7IF9pMiArPSAxKSB7XG4gICAgICAgICAgYnVmZmVySW5kZXhlcy5wdXNoKDApO1xuICAgICAgICAgIHZhciB4QnVmZmVyID0gbmV3IEZsb2F0MzJBcnJheShidWZmZXJMZW5ndGgpO1xuICAgICAgICAgIHZhciB5QnVmZmVyID0gbmV3IEZsb2F0MzJBcnJheShidWZmZXJMZW5ndGgpO1xuICAgICAgICAgIHhCdWZmZXIuZmlsbCgwKTtcbiAgICAgICAgICB5QnVmZmVyLmZpbGwoMCk7XG4gICAgICAgICAgeEJ1ZmZlcnMucHVzaCh4QnVmZmVyKTtcbiAgICAgICAgICB5QnVmZmVycy5wdXNoKHlCdWZmZXIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpkZXByZWNhdGlvblxuICAgICAgICBzY3JpcHRQcm9jZXNzb3JOb2RlLm9uYXVkaW9wcm9jZXNzID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgdmFyIGlucHV0QnVmZmVyID0gZXZlbnQuaW5wdXRCdWZmZXI7XG4gICAgICAgICAgdmFyIG91dHB1dEJ1ZmZlciA9IGV2ZW50Lm91dHB1dEJ1ZmZlcjtcbiAgICAgICAgICB2YXIgbnVtYmVyT2ZDaGFubmVscyA9IGlucHV0QnVmZmVyLm51bWJlck9mQ2hhbm5lbHM7XG4gICAgICAgICAgZm9yICh2YXIgX2kzID0gMDsgX2kzIDwgbnVtYmVyT2ZDaGFubmVsczsgX2kzICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBpbnB1dCA9IGlucHV0QnVmZmVyLmdldENoYW5uZWxEYXRhKF9pMyk7XG4gICAgICAgICAgICB2YXIgb3V0cHV0ID0gb3V0cHV0QnVmZmVyLmdldENoYW5uZWxEYXRhKF9pMyk7XG4gICAgICAgICAgICBidWZmZXJJbmRleGVzW19pM10gPSBmaWx0ZXJCdWZmZXIoY29udmVydGVkRmVlZGJhY2ssIGZlZWRiYWNrTGVuZ3RoLCBjb252ZXJ0ZWRGZWVkZm9yd2FyZCwgZmVlZGZvcndhcmRMZW5ndGgsIG1pbkxlbmd0aCwgeEJ1ZmZlcnNbX2kzXSwgeUJ1ZmZlcnNbX2kzXSwgYnVmZmVySW5kZXhlc1tfaTNdLCBidWZmZXJMZW5ndGgsIGlucHV0LCBvdXRwdXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdmFyIG55cXVpc3QgPSBuYXRpdmVDb250ZXh0LnNhbXBsZVJhdGUgLyAyO1xuICAgICAgICB2YXIgbmF0aXZlSUlSRmlsdGVyTm9kZUZha2VyID0ge1xuICAgICAgICAgIGdldCBidWZmZXJTaXplKCkge1xuICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlclNpemU7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBnZXQgY2hhbm5lbENvdW50KCkge1xuICAgICAgICAgICAgcmV0dXJuIHNjcmlwdFByb2Nlc3Nvck5vZGUuY2hhbm5lbENvdW50O1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc2V0IGNoYW5uZWxDb3VudCh2YWx1ZSkge1xuICAgICAgICAgICAgc2NyaXB0UHJvY2Vzc29yTm9kZS5jaGFubmVsQ291bnQgPSB2YWx1ZTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGdldCBjaGFubmVsQ291bnRNb2RlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHNjcmlwdFByb2Nlc3Nvck5vZGUuY2hhbm5lbENvdW50TW9kZTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNldCBjaGFubmVsQ291bnRNb2RlKHZhbHVlKSB7XG4gICAgICAgICAgICBzY3JpcHRQcm9jZXNzb3JOb2RlLmNoYW5uZWxDb3VudE1vZGUgPSB2YWx1ZTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGdldCBjaGFubmVsSW50ZXJwcmV0YXRpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gc2NyaXB0UHJvY2Vzc29yTm9kZS5jaGFubmVsSW50ZXJwcmV0YXRpb247XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzZXQgY2hhbm5lbEludGVycHJldGF0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICBzY3JpcHRQcm9jZXNzb3JOb2RlLmNoYW5uZWxJbnRlcnByZXRhdGlvbiA9IHZhbHVlO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZ2V0IGNvbnRleHQoKSB7XG4gICAgICAgICAgICByZXR1cm4gc2NyaXB0UHJvY2Vzc29yTm9kZS5jb250ZXh0O1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZ2V0IGlucHV0cygpIHtcbiAgICAgICAgICAgIHJldHVybiBbc2NyaXB0UHJvY2Vzc29yTm9kZV07XG4gICAgICAgICAgfSxcbiAgICAgICAgICBnZXQgbnVtYmVyT2ZJbnB1dHMoKSB7XG4gICAgICAgICAgICByZXR1cm4gc2NyaXB0UHJvY2Vzc29yTm9kZS5udW1iZXJPZklucHV0cztcbiAgICAgICAgICB9LFxuICAgICAgICAgIGdldCBudW1iZXJPZk91dHB1dHMoKSB7XG4gICAgICAgICAgICByZXR1cm4gc2NyaXB0UHJvY2Vzc29yTm9kZS5udW1iZXJPZk91dHB1dHM7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBhZGRFdmVudExpc3RlbmVyOiBmdW5jdGlvbiBhZGRFdmVudExpc3RlbmVyKCkge1xuICAgICAgICAgICAgLy8gQHRvZG8gRGlzc2FsbG93IGFkZGluZyBhbiBhdWRpb3Byb2Nlc3MgbGlzdGVuZXIuXG4gICAgICAgICAgICByZXR1cm4gc2NyaXB0UHJvY2Vzc29yTm9kZS5hZGRFdmVudExpc3RlbmVyKGFyZ3VtZW50cy5sZW5ndGggPD0gMCA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1swXSwgYXJndW1lbnRzLmxlbmd0aCA8PSAxID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzFdLCBhcmd1bWVudHMubGVuZ3RoIDw9IDIgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMl0pO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZGlzcGF0Y2hFdmVudDogZnVuY3Rpb24gZGlzcGF0Y2hFdmVudCgpIHtcbiAgICAgICAgICAgIHJldHVybiBzY3JpcHRQcm9jZXNzb3JOb2RlLmRpc3BhdGNoRXZlbnQoYXJndW1lbnRzLmxlbmd0aCA8PSAwID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzBdKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGdldEZyZXF1ZW5jeVJlc3BvbnNlOiBmdW5jdGlvbiBnZXRGcmVxdWVuY3lSZXNwb25zZShmcmVxdWVuY3lIeiwgbWFnUmVzcG9uc2UsIHBoYXNlUmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGlmIChmcmVxdWVuY3lIei5sZW5ndGggIT09IG1hZ1Jlc3BvbnNlLmxlbmd0aCB8fCBtYWdSZXNwb25zZS5sZW5ndGggIT09IHBoYXNlUmVzcG9uc2UubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHRocm93IGNyZWF0ZUludmFsaWRBY2Nlc3NFcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGxlbmd0aCA9IGZyZXF1ZW5jeUh6Lmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAodmFyIF9pNCA9IDA7IF9pNCA8IGxlbmd0aDsgX2k0ICs9IDEpIHtcbiAgICAgICAgICAgICAgdmFyIG9tZWdhID0gLU1hdGguUEkgKiAoZnJlcXVlbmN5SHpbX2k0XSAvIG55cXVpc3QpO1xuICAgICAgICAgICAgICB2YXIgeiA9IFtNYXRoLmNvcyhvbWVnYSksIE1hdGguc2luKG9tZWdhKV07XG4gICAgICAgICAgICAgIHZhciBudW1lcmF0b3IgPSBldmFsdWF0ZVBvbHlub21pYWwoY29udmVydGVkRmVlZGZvcndhcmQsIHopO1xuICAgICAgICAgICAgICB2YXIgZGVub21pbmF0b3IgPSBldmFsdWF0ZVBvbHlub21pYWwoY29udmVydGVkRmVlZGJhY2ssIHopO1xuICAgICAgICAgICAgICB2YXIgcmVzcG9uc2UgPSBkaXZpZGUobnVtZXJhdG9yLCBkZW5vbWluYXRvcik7XG4gICAgICAgICAgICAgIG1hZ1Jlc3BvbnNlW19pNF0gPSBNYXRoLnNxcnQocmVzcG9uc2VbMF0gKiByZXNwb25zZVswXSArIHJlc3BvbnNlWzFdICogcmVzcG9uc2VbMV0pO1xuICAgICAgICAgICAgICBwaGFzZVJlc3BvbnNlW19pNF0gPSBNYXRoLmF0YW4yKHJlc3BvbnNlWzFdLCByZXNwb25zZVswXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICByZW1vdmVFdmVudExpc3RlbmVyOiBmdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVyKCkge1xuICAgICAgICAgICAgcmV0dXJuIHNjcmlwdFByb2Nlc3Nvck5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihhcmd1bWVudHMubGVuZ3RoIDw9IDAgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMF0sIGFyZ3VtZW50cy5sZW5ndGggPD0gMSA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzLmxlbmd0aCA8PSAyID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzJdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBpbnRlcmNlcHRDb25uZWN0aW9ucyhuYXRpdmVJSVJGaWx0ZXJOb2RlRmFrZXIsIHNjcmlwdFByb2Nlc3Nvck5vZGUpO1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZU5hdGl2ZU1lZGlhRWxlbWVudEF1ZGlvU291cmNlTm9kZSA9IGZ1bmN0aW9uIGNyZWF0ZU5hdGl2ZU1lZGlhRWxlbWVudEF1ZGlvU291cmNlTm9kZShuYXRpdmVBdWRpb0NvbnRleHQsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBuYXRpdmVBdWRpb0NvbnRleHQuY3JlYXRlTWVkaWFFbGVtZW50U291cmNlKG9wdGlvbnMubWVkaWFFbGVtZW50KTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZU5hdGl2ZU1lZGlhU3RyZWFtQXVkaW9EZXN0aW5hdGlvbk5vZGUgPSBmdW5jdGlvbiBjcmVhdGVOYXRpdmVNZWRpYVN0cmVhbUF1ZGlvRGVzdGluYXRpb25Ob2RlKG5hdGl2ZUF1ZGlvQ29udGV4dCwgb3B0aW9ucykge1xuICAgICAgdmFyIG5hdGl2ZU1lZGlhU3RyZWFtQXVkaW9EZXN0aW5hdGlvbk5vZGUgPSBuYXRpdmVBdWRpb0NvbnRleHQuY3JlYXRlTWVkaWFTdHJlYW1EZXN0aW5hdGlvbigpO1xuICAgICAgYXNzaWduTmF0aXZlQXVkaW9Ob2RlT3B0aW9ucyhuYXRpdmVNZWRpYVN0cmVhbUF1ZGlvRGVzdGluYXRpb25Ob2RlLCBvcHRpb25zKTtcbiAgICAgIC8vIEJ1ZyAjMTc0OiBTYWZhcmkgZG9lcyBleHBvc2UgYSB3cm9uZyBudW1iZXJPZk91dHB1dHMuXG4gICAgICBpZiAobmF0aXZlTWVkaWFTdHJlYW1BdWRpb0Rlc3RpbmF0aW9uTm9kZS5udW1iZXJPZk91dHB1dHMgPT09IDEpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5hdGl2ZU1lZGlhU3RyZWFtQXVkaW9EZXN0aW5hdGlvbk5vZGUsICdudW1iZXJPZk91dHB1dHMnLCB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5hdGl2ZU1lZGlhU3RyZWFtQXVkaW9EZXN0aW5hdGlvbk5vZGU7XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVOYXRpdmVNZWRpYVN0cmVhbUF1ZGlvU291cmNlTm9kZSA9IGZ1bmN0aW9uIGNyZWF0ZU5hdGl2ZU1lZGlhU3RyZWFtQXVkaW9Tb3VyY2VOb2RlKG5hdGl2ZUF1ZGlvQ29udGV4dCwgX3JlZikge1xuICAgICAgdmFyIG1lZGlhU3RyZWFtID0gX3JlZi5tZWRpYVN0cmVhbTtcbiAgICAgIHZhciBhdWRpb1N0cmVhbVRyYWNrcyA9IG1lZGlhU3RyZWFtLmdldEF1ZGlvVHJhY2tzKCk7XG4gICAgICAvKlxuICAgICAgICogQnVnICMxNTE6IFNhZmFyaSBkb2VzIG5vdCB1c2UgdGhlIGF1ZGlvIHRyYWNrIGFzIGlucHV0IGFueW1vcmUgaWYgaXQgZ2V0cyByZW1vdmVkIGZyb20gdGhlIG1lZGlhU3RyZWFtIGFmdGVyIGNvbnN0cnVjdGlvbi5cbiAgICAgICAqIEJ1ZyAjMTU5OiBTYWZhcmkgcGlja3MgdGhlIGZpcnN0IGF1ZGlvIHRyYWNrIGlmIHRoZSBNZWRpYVN0cmVhbSBoYXMgbW9yZSB0aGFuIG9uZSBhdWRpbyB0cmFjay5cbiAgICAgICAqL1xuICAgICAgYXVkaW9TdHJlYW1UcmFja3Muc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gYS5pZCA8IGIuaWQgPyAtMSA6IGEuaWQgPiBiLmlkID8gMSA6IDA7XG4gICAgICB9KTtcbiAgICAgIHZhciBmaWx0ZXJlZEF1ZGlvU3RyZWFtVHJhY2tzID0gYXVkaW9TdHJlYW1UcmFja3Muc2xpY2UoMCwgMSk7XG4gICAgICB2YXIgbmF0aXZlTWVkaWFTdHJlYW1BdWRpb1NvdXJjZU5vZGUgPSBuYXRpdmVBdWRpb0NvbnRleHQuY3JlYXRlTWVkaWFTdHJlYW1Tb3VyY2UobmV3IE1lZGlhU3RyZWFtKGZpbHRlcmVkQXVkaW9TdHJlYW1UcmFja3MpKTtcbiAgICAgIC8qXG4gICAgICAgKiBCdWcgIzE1MSAmICMxNTk6IFRoZSBnaXZlbiBtZWRpYVN0cmVhbSBnZXRzIHJlY29uc3RydWN0ZWQgYmVmb3JlIGl0IGdldHMgcGFzc2VkIHRvIHRoZSBuYXRpdmUgbm9kZSB3aGljaCBpcyB3aHkgdGhlIGFjY2Vzc29yIG5lZWRzXG4gICAgICAgKiB0byBiZSBvdmVyd3JpdHRlbiBhcyBpdCB3b3VsZCBvdGhlcndpc2UgZXhwb3NlIHRoZSByZWNvbnN0cnVjdGVkIHZlcnNpb24uXG4gICAgICAgKi9cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuYXRpdmVNZWRpYVN0cmVhbUF1ZGlvU291cmNlTm9kZSwgJ21lZGlhU3RyZWFtJywge1xuICAgICAgICB2YWx1ZTogbWVkaWFTdHJlYW1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG5hdGl2ZU1lZGlhU3RyZWFtQXVkaW9Tb3VyY2VOb2RlO1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlTmF0aXZlTWVkaWFTdHJlYW1UcmFja0F1ZGlvU291cmNlTm9kZUZhY3RvcnkgPSBmdW5jdGlvbiBjcmVhdGVOYXRpdmVNZWRpYVN0cmVhbVRyYWNrQXVkaW9Tb3VyY2VOb2RlRmFjdG9yeShjcmVhdGVJbnZhbGlkU3RhdGVFcnJvciwgaXNOYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKG5hdGl2ZUF1ZGlvQ29udGV4dCwgX3JlZikge1xuICAgICAgICB2YXIgbWVkaWFTdHJlYW1UcmFjayA9IF9yZWYubWVkaWFTdHJlYW1UcmFjaztcbiAgICAgICAgLy8gQnVnICMxMjE6IE9ubHkgRmlyZWZveCBkb2VzIHlldCBzdXBwb3J0IHRoZSBNZWRpYVN0cmVhbVRyYWNrQXVkaW9Tb3VyY2VOb2RlLlxuICAgICAgICBpZiAodHlwZW9mIG5hdGl2ZUF1ZGlvQ29udGV4dC5jcmVhdGVNZWRpYVN0cmVhbVRyYWNrU291cmNlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgcmV0dXJuIG5hdGl2ZUF1ZGlvQ29udGV4dC5jcmVhdGVNZWRpYVN0cmVhbVRyYWNrU291cmNlKG1lZGlhU3RyZWFtVHJhY2spO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtZWRpYVN0cmVhbSA9IG5ldyBNZWRpYVN0cmVhbShbbWVkaWFTdHJlYW1UcmFja10pO1xuICAgICAgICB2YXIgbmF0aXZlTWVkaWFTdHJlYW1BdWRpb1NvdXJjZU5vZGUgPSBuYXRpdmVBdWRpb0NvbnRleHQuY3JlYXRlTWVkaWFTdHJlYW1Tb3VyY2UobWVkaWFTdHJlYW0pO1xuICAgICAgICAvLyBCdWcgIzEyMDogRmlyZWZveCBkb2VzIG5vdCB0aHJvdyBhbiBlcnJvciBpZiB0aGUgbWVkaWFTdHJlYW0gaGFzIG5vIGF1ZGlvIHRyYWNrLlxuICAgICAgICBpZiAobWVkaWFTdHJlYW1UcmFjay5raW5kICE9PSAnYXVkaW8nKSB7XG4gICAgICAgICAgdGhyb3cgY3JlYXRlSW52YWxpZFN0YXRlRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBCdWcgIzE3MjogU2FmYXJpIGFsbG93cyB0byBjcmVhdGUgYSBNZWRpYVN0cmVhbUF1ZGlvU291cmNlTm9kZSB3aXRoIGFuIE9mZmxpbmVBdWRpb0NvbnRleHQuXG4gICAgICAgIGlmIChpc05hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQobmF0aXZlQXVkaW9Db250ZXh0KSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmF0aXZlTWVkaWFTdHJlYW1BdWRpb1NvdXJjZU5vZGU7XG4gICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlTmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dENvbnN0cnVjdG9yID0gZnVuY3Rpb24gY3JlYXRlTmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dENvbnN0cnVjdG9yKHdpbmRvdykge1xuICAgICAgaWYgKHdpbmRvdyA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmICh3aW5kb3cuaGFzT3duUHJvcGVydHkoJ09mZmxpbmVBdWRpb0NvbnRleHQnKSkge1xuICAgICAgICByZXR1cm4gd2luZG93Lk9mZmxpbmVBdWRpb0NvbnRleHQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gd2luZG93Lmhhc093blByb3BlcnR5KCd3ZWJraXRPZmZsaW5lQXVkaW9Db250ZXh0JykgPyB3aW5kb3cud2Via2l0T2ZmbGluZUF1ZGlvQ29udGV4dCA6IG51bGw7XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVOYXRpdmVPc2NpbGxhdG9yTm9kZUZhY3RvcnkgPSBmdW5jdGlvbiBjcmVhdGVOYXRpdmVPc2NpbGxhdG9yTm9kZUZhY3RvcnkoYWRkU2lsZW50Q29ubmVjdGlvbiwgY2FjaGVUZXN0UmVzdWx0LCB0ZXN0QXVkaW9TY2hlZHVsZWRTb3VyY2VOb2RlU3RhcnRNZXRob2ROZWdhdGl2ZVBhcmFtZXRlcnNTdXBwb3J0LCB0ZXN0QXVkaW9TY2hlZHVsZWRTb3VyY2VOb2RlU3RvcE1ldGhvZENvbnNlY3V0aXZlQ2FsbHNTdXBwb3J0LCB0ZXN0QXVkaW9TY2hlZHVsZWRTb3VyY2VOb2RlU3RvcE1ldGhvZE5lZ2F0aXZlUGFyYW1ldGVyc1N1cHBvcnQsIHdyYXBBdWRpb1NjaGVkdWxlZFNvdXJjZU5vZGVTdG9wTWV0aG9kQ29uc2VjdXRpdmVDYWxscykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChuYXRpdmVDb250ZXh0LCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBuYXRpdmVPc2NpbGxhdG9yTm9kZSA9IG5hdGl2ZUNvbnRleHQuY3JlYXRlT3NjaWxsYXRvcigpO1xuICAgICAgICBhc3NpZ25OYXRpdmVBdWRpb05vZGVPcHRpb25zKG5hdGl2ZU9zY2lsbGF0b3JOb2RlLCBvcHRpb25zKTtcbiAgICAgICAgYXNzaWduTmF0aXZlQXVkaW9Ob2RlQXVkaW9QYXJhbVZhbHVlKG5hdGl2ZU9zY2lsbGF0b3JOb2RlLCBvcHRpb25zLCAnZGV0dW5lJyk7XG4gICAgICAgIGFzc2lnbk5hdGl2ZUF1ZGlvTm9kZUF1ZGlvUGFyYW1WYWx1ZShuYXRpdmVPc2NpbGxhdG9yTm9kZSwgb3B0aW9ucywgJ2ZyZXF1ZW5jeScpO1xuICAgICAgICBpZiAob3B0aW9ucy5wZXJpb2RpY1dhdmUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIG5hdGl2ZU9zY2lsbGF0b3JOb2RlLnNldFBlcmlvZGljV2F2ZShvcHRpb25zLnBlcmlvZGljV2F2ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXNzaWduTmF0aXZlQXVkaW9Ob2RlT3B0aW9uKG5hdGl2ZU9zY2lsbGF0b3JOb2RlLCBvcHRpb25zLCAndHlwZScpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEJ1ZyAjNDQ6IE9ubHkgQ2hyb21lICYgRWRnZSB0aHJvdyBhIFJhbmdlRXJyb3IgeWV0LlxuICAgICAgICBpZiAoIWNhY2hlVGVzdFJlc3VsdCh0ZXN0QXVkaW9TY2hlZHVsZWRTb3VyY2VOb2RlU3RhcnRNZXRob2ROZWdhdGl2ZVBhcmFtZXRlcnNTdXBwb3J0LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHRlc3RBdWRpb1NjaGVkdWxlZFNvdXJjZU5vZGVTdGFydE1ldGhvZE5lZ2F0aXZlUGFyYW1ldGVyc1N1cHBvcnQobmF0aXZlQ29udGV4dCk7XG4gICAgICAgIH0pKSB7XG4gICAgICAgICAgd3JhcEF1ZGlvU2NoZWR1bGVkU291cmNlTm9kZVN0YXJ0TWV0aG9kTmVnYXRpdmVQYXJhbWV0ZXJzKG5hdGl2ZU9zY2lsbGF0b3JOb2RlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBCdWcgIzE5OiBTYWZhcmkgZG9lcyBub3QgaWdub3JlIGNhbGxzIHRvIHN0b3AoKSBvZiBhbiBhbHJlYWR5IHN0b3BwZWQgQXVkaW9CdWZmZXJTb3VyY2VOb2RlLlxuICAgICAgICBpZiAoIWNhY2hlVGVzdFJlc3VsdCh0ZXN0QXVkaW9TY2hlZHVsZWRTb3VyY2VOb2RlU3RvcE1ldGhvZENvbnNlY3V0aXZlQ2FsbHNTdXBwb3J0LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHRlc3RBdWRpb1NjaGVkdWxlZFNvdXJjZU5vZGVTdG9wTWV0aG9kQ29uc2VjdXRpdmVDYWxsc1N1cHBvcnQobmF0aXZlQ29udGV4dCk7XG4gICAgICAgIH0pKSB7XG4gICAgICAgICAgd3JhcEF1ZGlvU2NoZWR1bGVkU291cmNlTm9kZVN0b3BNZXRob2RDb25zZWN1dGl2ZUNhbGxzKG5hdGl2ZU9zY2lsbGF0b3JOb2RlLCBuYXRpdmVDb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBCdWcgIzQ0OiBPbmx5IEZpcmVmb3ggZG9lcyBub3QgdGhyb3cgYSBSYW5nZUVycm9yIHlldC5cbiAgICAgICAgaWYgKCFjYWNoZVRlc3RSZXN1bHQodGVzdEF1ZGlvU2NoZWR1bGVkU291cmNlTm9kZVN0b3BNZXRob2ROZWdhdGl2ZVBhcmFtZXRlcnNTdXBwb3J0LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHRlc3RBdWRpb1NjaGVkdWxlZFNvdXJjZU5vZGVTdG9wTWV0aG9kTmVnYXRpdmVQYXJhbWV0ZXJzU3VwcG9ydChuYXRpdmVDb250ZXh0KTtcbiAgICAgICAgfSkpIHtcbiAgICAgICAgICB3cmFwQXVkaW9TY2hlZHVsZWRTb3VyY2VOb2RlU3RvcE1ldGhvZE5lZ2F0aXZlUGFyYW1ldGVycyhuYXRpdmVPc2NpbGxhdG9yTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQnVnICMxNzU6IFNhZmFyaSB3aWxsIG5vdCBmaXJlIGFuIGVuZGVkIGV2ZW50IGlmIHRoZSBPc2NpbGxhdG9yTm9kZSBpcyB1bmNvbm5lY3RlZC5cbiAgICAgICAgYWRkU2lsZW50Q29ubmVjdGlvbihuYXRpdmVDb250ZXh0LCBuYXRpdmVPc2NpbGxhdG9yTm9kZSk7XG4gICAgICAgIHJldHVybiBuYXRpdmVPc2NpbGxhdG9yTm9kZTtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVOYXRpdmVQYW5uZXJOb2RlRmFjdG9yeSA9IGZ1bmN0aW9uIGNyZWF0ZU5hdGl2ZVBhbm5lck5vZGVGYWN0b3J5KGNyZWF0ZU5hdGl2ZVBhbm5lck5vZGVGYWtlcikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChuYXRpdmVDb250ZXh0LCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBuYXRpdmVQYW5uZXJOb2RlID0gbmF0aXZlQ29udGV4dC5jcmVhdGVQYW5uZXIoKTtcbiAgICAgICAgLy8gQnVnICMxMjQ6IFNhZmFyaSBkb2VzIG5vdCBzdXBwb3J0IG1vZGlmeWluZyB0aGUgb3JpZW50YXRpb24gYW5kIHRoZSBwb3NpdGlvbiB3aXRoIEF1ZGlvUGFyYW1zLlxuICAgICAgICBpZiAobmF0aXZlUGFubmVyTm9kZS5vcmllbnRhdGlvblggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiBjcmVhdGVOYXRpdmVQYW5uZXJOb2RlRmFrZXIobmF0aXZlQ29udGV4dCwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgYXNzaWduTmF0aXZlQXVkaW9Ob2RlT3B0aW9ucyhuYXRpdmVQYW5uZXJOb2RlLCBvcHRpb25zKTtcbiAgICAgICAgYXNzaWduTmF0aXZlQXVkaW9Ob2RlQXVkaW9QYXJhbVZhbHVlKG5hdGl2ZVBhbm5lck5vZGUsIG9wdGlvbnMsICdvcmllbnRhdGlvblgnKTtcbiAgICAgICAgYXNzaWduTmF0aXZlQXVkaW9Ob2RlQXVkaW9QYXJhbVZhbHVlKG5hdGl2ZVBhbm5lck5vZGUsIG9wdGlvbnMsICdvcmllbnRhdGlvblknKTtcbiAgICAgICAgYXNzaWduTmF0aXZlQXVkaW9Ob2RlQXVkaW9QYXJhbVZhbHVlKG5hdGl2ZVBhbm5lck5vZGUsIG9wdGlvbnMsICdvcmllbnRhdGlvblonKTtcbiAgICAgICAgYXNzaWduTmF0aXZlQXVkaW9Ob2RlQXVkaW9QYXJhbVZhbHVlKG5hdGl2ZVBhbm5lck5vZGUsIG9wdGlvbnMsICdwb3NpdGlvblgnKTtcbiAgICAgICAgYXNzaWduTmF0aXZlQXVkaW9Ob2RlQXVkaW9QYXJhbVZhbHVlKG5hdGl2ZVBhbm5lck5vZGUsIG9wdGlvbnMsICdwb3NpdGlvblknKTtcbiAgICAgICAgYXNzaWduTmF0aXZlQXVkaW9Ob2RlQXVkaW9QYXJhbVZhbHVlKG5hdGl2ZVBhbm5lck5vZGUsIG9wdGlvbnMsICdwb3NpdGlvblonKTtcbiAgICAgICAgYXNzaWduTmF0aXZlQXVkaW9Ob2RlT3B0aW9uKG5hdGl2ZVBhbm5lck5vZGUsIG9wdGlvbnMsICdjb25lSW5uZXJBbmdsZScpO1xuICAgICAgICBhc3NpZ25OYXRpdmVBdWRpb05vZGVPcHRpb24obmF0aXZlUGFubmVyTm9kZSwgb3B0aW9ucywgJ2NvbmVPdXRlckFuZ2xlJyk7XG4gICAgICAgIGFzc2lnbk5hdGl2ZUF1ZGlvTm9kZU9wdGlvbihuYXRpdmVQYW5uZXJOb2RlLCBvcHRpb25zLCAnY29uZU91dGVyR2FpbicpO1xuICAgICAgICBhc3NpZ25OYXRpdmVBdWRpb05vZGVPcHRpb24obmF0aXZlUGFubmVyTm9kZSwgb3B0aW9ucywgJ2Rpc3RhbmNlTW9kZWwnKTtcbiAgICAgICAgYXNzaWduTmF0aXZlQXVkaW9Ob2RlT3B0aW9uKG5hdGl2ZVBhbm5lck5vZGUsIG9wdGlvbnMsICdtYXhEaXN0YW5jZScpO1xuICAgICAgICBhc3NpZ25OYXRpdmVBdWRpb05vZGVPcHRpb24obmF0aXZlUGFubmVyTm9kZSwgb3B0aW9ucywgJ3Bhbm5pbmdNb2RlbCcpO1xuICAgICAgICBhc3NpZ25OYXRpdmVBdWRpb05vZGVPcHRpb24obmF0aXZlUGFubmVyTm9kZSwgb3B0aW9ucywgJ3JlZkRpc3RhbmNlJyk7XG4gICAgICAgIGFzc2lnbk5hdGl2ZUF1ZGlvTm9kZU9wdGlvbihuYXRpdmVQYW5uZXJOb2RlLCBvcHRpb25zLCAncm9sbG9mZkZhY3RvcicpO1xuICAgICAgICByZXR1cm4gbmF0aXZlUGFubmVyTm9kZTtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBfZXhjbHVkZWQkMiA9IFtcImNvbmVJbm5lckFuZ2xlXCIsIFwiY29uZU91dGVyQW5nbGVcIiwgXCJjb25lT3V0ZXJHYWluXCIsIFwiZGlzdGFuY2VNb2RlbFwiLCBcIm1heERpc3RhbmNlXCIsIFwib3JpZW50YXRpb25YXCIsIFwib3JpZW50YXRpb25ZXCIsIFwib3JpZW50YXRpb25aXCIsIFwicGFubmluZ01vZGVsXCIsIFwicG9zaXRpb25YXCIsIFwicG9zaXRpb25ZXCIsIFwicG9zaXRpb25aXCIsIFwicmVmRGlzdGFuY2VcIiwgXCJyb2xsb2ZmRmFjdG9yXCJdO1xuICAgIGZ1bmN0aW9uIG93bktleXMkYyhlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XG4gICAgZnVuY3Rpb24gX29iamVjdFNwcmVhZCRjKGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMkYyhPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMkYyhPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxuICAgIHZhciBjcmVhdGVOYXRpdmVQYW5uZXJOb2RlRmFrZXJGYWN0b3J5ID0gZnVuY3Rpb24gY3JlYXRlTmF0aXZlUGFubmVyTm9kZUZha2VyRmFjdG9yeShjb25uZWN0TmF0aXZlQXVkaW9Ob2RlVG9OYXRpdmVBdWRpb05vZGUsIGNyZWF0ZUludmFsaWRTdGF0ZUVycm9yLCBjcmVhdGVOYXRpdmVDaGFubmVsTWVyZ2VyTm9kZSwgY3JlYXRlTmF0aXZlR2Fpbk5vZGUsIGNyZWF0ZU5hdGl2ZVNjcmlwdFByb2Nlc3Nvck5vZGUsIGNyZWF0ZU5hdGl2ZVdhdmVTaGFwZXJOb2RlLCBjcmVhdGVOb3RTdXBwb3J0ZWRFcnJvciwgZGlzY29ubmVjdE5hdGl2ZUF1ZGlvTm9kZUZyb21OYXRpdmVBdWRpb05vZGUsIGdldEZpcnN0U2FtcGxlLCBtb25pdG9yQ29ubmVjdGlvbnMpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAobmF0aXZlQ29udGV4dCwgX3JlZikge1xuICAgICAgICB2YXIgY29uZUlubmVyQW5nbGUgPSBfcmVmLmNvbmVJbm5lckFuZ2xlLFxuICAgICAgICAgIGNvbmVPdXRlckFuZ2xlID0gX3JlZi5jb25lT3V0ZXJBbmdsZSxcbiAgICAgICAgICBjb25lT3V0ZXJHYWluID0gX3JlZi5jb25lT3V0ZXJHYWluLFxuICAgICAgICAgIGRpc3RhbmNlTW9kZWwgPSBfcmVmLmRpc3RhbmNlTW9kZWwsXG4gICAgICAgICAgbWF4RGlzdGFuY2UgPSBfcmVmLm1heERpc3RhbmNlLFxuICAgICAgICAgIG9yaWVudGF0aW9uWCA9IF9yZWYub3JpZW50YXRpb25YLFxuICAgICAgICAgIG9yaWVudGF0aW9uWSA9IF9yZWYub3JpZW50YXRpb25ZLFxuICAgICAgICAgIG9yaWVudGF0aW9uWiA9IF9yZWYub3JpZW50YXRpb25aLFxuICAgICAgICAgIHBhbm5pbmdNb2RlbCA9IF9yZWYucGFubmluZ01vZGVsLFxuICAgICAgICAgIHBvc2l0aW9uWCA9IF9yZWYucG9zaXRpb25YLFxuICAgICAgICAgIHBvc2l0aW9uWSA9IF9yZWYucG9zaXRpb25ZLFxuICAgICAgICAgIHBvc2l0aW9uWiA9IF9yZWYucG9zaXRpb25aLFxuICAgICAgICAgIHJlZkRpc3RhbmNlID0gX3JlZi5yZWZEaXN0YW5jZSxcbiAgICAgICAgICByb2xsb2ZmRmFjdG9yID0gX3JlZi5yb2xsb2ZmRmFjdG9yLFxuICAgICAgICAgIGF1ZGlvTm9kZU9wdGlvbnMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgX2V4Y2x1ZGVkJDIpO1xuICAgICAgICB2YXIgcGFubmVyTm9kZSA9IG5hdGl2ZUNvbnRleHQuY3JlYXRlUGFubmVyKCk7XG4gICAgICAgIC8vIEJ1ZyAjMTI1OiBTYWZhcmkgZG9lcyBub3QgdGhyb3cgYW4gZXJyb3IgeWV0LlxuICAgICAgICBpZiAoYXVkaW9Ob2RlT3B0aW9ucy5jaGFubmVsQ291bnQgPiAyKSB7XG4gICAgICAgICAgdGhyb3cgY3JlYXRlTm90U3VwcG9ydGVkRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBCdWcgIzEyNjogU2FmYXJpIGRvZXMgbm90IHRocm93IGFuIGVycm9yIHlldC5cbiAgICAgICAgaWYgKGF1ZGlvTm9kZU9wdGlvbnMuY2hhbm5lbENvdW50TW9kZSA9PT0gJ21heCcpIHtcbiAgICAgICAgICB0aHJvdyBjcmVhdGVOb3RTdXBwb3J0ZWRFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIGFzc2lnbk5hdGl2ZUF1ZGlvTm9kZU9wdGlvbnMocGFubmVyTm9kZSwgYXVkaW9Ob2RlT3B0aW9ucyk7XG4gICAgICAgIHZhciBTSU5HTEVfQ0hBTk5FTF9PUFRJT05TID0ge1xuICAgICAgICAgIGNoYW5uZWxDb3VudDogMSxcbiAgICAgICAgICBjaGFubmVsQ291bnRNb2RlOiAnZXhwbGljaXQnLFxuICAgICAgICAgIGNoYW5uZWxJbnRlcnByZXRhdGlvbjogJ2Rpc2NyZXRlJ1xuICAgICAgICB9O1xuICAgICAgICB2YXIgY2hhbm5lbE1lcmdlck5vZGUgPSBjcmVhdGVOYXRpdmVDaGFubmVsTWVyZ2VyTm9kZShuYXRpdmVDb250ZXh0LCBfb2JqZWN0U3ByZWFkJGMoX29iamVjdFNwcmVhZCRjKHt9LCBTSU5HTEVfQ0hBTk5FTF9PUFRJT05TKSwge30sIHtcbiAgICAgICAgICBjaGFubmVsSW50ZXJwcmV0YXRpb246ICdzcGVha2VycycsXG4gICAgICAgICAgbnVtYmVyT2ZJbnB1dHM6IDZcbiAgICAgICAgfSkpO1xuICAgICAgICB2YXIgaW5wdXRHYWluTm9kZSA9IGNyZWF0ZU5hdGl2ZUdhaW5Ob2RlKG5hdGl2ZUNvbnRleHQsIF9vYmplY3RTcHJlYWQkYyhfb2JqZWN0U3ByZWFkJGMoe30sIGF1ZGlvTm9kZU9wdGlvbnMpLCB7fSwge1xuICAgICAgICAgIGdhaW46IDFcbiAgICAgICAgfSkpO1xuICAgICAgICB2YXIgb3JpZW50YXRpb25YR2Fpbk5vZGUgPSBjcmVhdGVOYXRpdmVHYWluTm9kZShuYXRpdmVDb250ZXh0LCBfb2JqZWN0U3ByZWFkJGMoX29iamVjdFNwcmVhZCRjKHt9LCBTSU5HTEVfQ0hBTk5FTF9PUFRJT05TKSwge30sIHtcbiAgICAgICAgICBnYWluOiAxXG4gICAgICAgIH0pKTtcbiAgICAgICAgdmFyIG9yaWVudGF0aW9uWUdhaW5Ob2RlID0gY3JlYXRlTmF0aXZlR2Fpbk5vZGUobmF0aXZlQ29udGV4dCwgX29iamVjdFNwcmVhZCRjKF9vYmplY3RTcHJlYWQkYyh7fSwgU0lOR0xFX0NIQU5ORUxfT1BUSU9OUyksIHt9LCB7XG4gICAgICAgICAgZ2FpbjogMFxuICAgICAgICB9KSk7XG4gICAgICAgIHZhciBvcmllbnRhdGlvblpHYWluTm9kZSA9IGNyZWF0ZU5hdGl2ZUdhaW5Ob2RlKG5hdGl2ZUNvbnRleHQsIF9vYmplY3RTcHJlYWQkYyhfb2JqZWN0U3ByZWFkJGMoe30sIFNJTkdMRV9DSEFOTkVMX09QVElPTlMpLCB7fSwge1xuICAgICAgICAgIGdhaW46IDBcbiAgICAgICAgfSkpO1xuICAgICAgICB2YXIgcG9zaXRpb25YR2Fpbk5vZGUgPSBjcmVhdGVOYXRpdmVHYWluTm9kZShuYXRpdmVDb250ZXh0LCBfb2JqZWN0U3ByZWFkJGMoX29iamVjdFNwcmVhZCRjKHt9LCBTSU5HTEVfQ0hBTk5FTF9PUFRJT05TKSwge30sIHtcbiAgICAgICAgICBnYWluOiAwXG4gICAgICAgIH0pKTtcbiAgICAgICAgdmFyIHBvc2l0aW9uWUdhaW5Ob2RlID0gY3JlYXRlTmF0aXZlR2Fpbk5vZGUobmF0aXZlQ29udGV4dCwgX29iamVjdFNwcmVhZCRjKF9vYmplY3RTcHJlYWQkYyh7fSwgU0lOR0xFX0NIQU5ORUxfT1BUSU9OUyksIHt9LCB7XG4gICAgICAgICAgZ2FpbjogMFxuICAgICAgICB9KSk7XG4gICAgICAgIHZhciBwb3NpdGlvblpHYWluTm9kZSA9IGNyZWF0ZU5hdGl2ZUdhaW5Ob2RlKG5hdGl2ZUNvbnRleHQsIF9vYmplY3RTcHJlYWQkYyhfb2JqZWN0U3ByZWFkJGMoe30sIFNJTkdMRV9DSEFOTkVMX09QVElPTlMpLCB7fSwge1xuICAgICAgICAgIGdhaW46IDBcbiAgICAgICAgfSkpO1xuICAgICAgICB2YXIgc2NyaXB0UHJvY2Vzc29yTm9kZSA9IGNyZWF0ZU5hdGl2ZVNjcmlwdFByb2Nlc3Nvck5vZGUobmF0aXZlQ29udGV4dCwgMjU2LCA2LCAxKTtcbiAgICAgICAgdmFyIHdhdmVTaGFwZXJOb2RlID0gY3JlYXRlTmF0aXZlV2F2ZVNoYXBlck5vZGUobmF0aXZlQ29udGV4dCwgX29iamVjdFNwcmVhZCRjKF9vYmplY3RTcHJlYWQkYyh7fSwgU0lOR0xFX0NIQU5ORUxfT1BUSU9OUyksIHt9LCB7XG4gICAgICAgICAgY3VydmU6IG5ldyBGbG9hdDMyQXJyYXkoWzEsIDFdKSxcbiAgICAgICAgICBvdmVyc2FtcGxlOiAnbm9uZSdcbiAgICAgICAgfSkpO1xuICAgICAgICB2YXIgbGFzdE9yaWVudGF0aW9uID0gW29yaWVudGF0aW9uWCwgb3JpZW50YXRpb25ZLCBvcmllbnRhdGlvblpdO1xuICAgICAgICB2YXIgbGFzdFBvc2l0aW9uID0gW3Bvc2l0aW9uWCwgcG9zaXRpb25ZLCBwb3NpdGlvblpdO1xuICAgICAgICB2YXIgYnVmZmVyID0gbmV3IEZsb2F0MzJBcnJheSgxKTtcbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOmRlcHJlY2F0aW9uXG4gICAgICAgIHNjcmlwdFByb2Nlc3Nvck5vZGUub25hdWRpb3Byb2Nlc3MgPSBmdW5jdGlvbiAoX3JlZjIpIHtcbiAgICAgICAgICB2YXIgaW5wdXRCdWZmZXIgPSBfcmVmMi5pbnB1dEJ1ZmZlcjtcbiAgICAgICAgICB2YXIgb3JpZW50YXRpb24gPSBbZ2V0Rmlyc3RTYW1wbGUoaW5wdXRCdWZmZXIsIGJ1ZmZlciwgMCksIGdldEZpcnN0U2FtcGxlKGlucHV0QnVmZmVyLCBidWZmZXIsIDEpLCBnZXRGaXJzdFNhbXBsZShpbnB1dEJ1ZmZlciwgYnVmZmVyLCAyKV07XG4gICAgICAgICAgaWYgKG9yaWVudGF0aW9uLnNvbWUoZnVuY3Rpb24gKHZhbHVlLCBpbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlICE9PSBsYXN0T3JpZW50YXRpb25baW5kZXhdO1xuICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICBwYW5uZXJOb2RlLnNldE9yaWVudGF0aW9uLmFwcGx5KHBhbm5lck5vZGUsIG9yaWVudGF0aW9uKTsgLy8gdHNsaW50OmRpc2FibGUtbGluZTpkZXByZWNhdGlvblxuICAgICAgICAgICAgbGFzdE9yaWVudGF0aW9uID0gb3JpZW50YXRpb247XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBwb3NpdG9uID0gW2dldEZpcnN0U2FtcGxlKGlucHV0QnVmZmVyLCBidWZmZXIsIDMpLCBnZXRGaXJzdFNhbXBsZShpbnB1dEJ1ZmZlciwgYnVmZmVyLCA0KSwgZ2V0Rmlyc3RTYW1wbGUoaW5wdXRCdWZmZXIsIGJ1ZmZlciwgNSldO1xuICAgICAgICAgIGlmIChwb3NpdG9uLnNvbWUoZnVuY3Rpb24gKHZhbHVlLCBpbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlICE9PSBsYXN0UG9zaXRpb25baW5kZXhdO1xuICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICBwYW5uZXJOb2RlLnNldFBvc2l0aW9uLmFwcGx5KHBhbm5lck5vZGUsIHBvc2l0b24pOyAvLyB0c2xpbnQ6ZGlzYWJsZS1saW5lOmRlcHJlY2F0aW9uXG4gICAgICAgICAgICBsYXN0UG9zaXRpb24gPSBwb3NpdG9uO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9yaWVudGF0aW9uWUdhaW5Ob2RlLmdhaW4sICdkZWZhdWx0VmFsdWUnLCB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob3JpZW50YXRpb25aR2Fpbk5vZGUuZ2FpbiwgJ2RlZmF1bHRWYWx1ZScsIHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwb3NpdGlvblhHYWluTm9kZS5nYWluLCAnZGVmYXVsdFZhbHVlJywge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHBvc2l0aW9uWUdhaW5Ob2RlLmdhaW4sICdkZWZhdWx0VmFsdWUnLCB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocG9zaXRpb25aR2Fpbk5vZGUuZ2FpbiwgJ2RlZmF1bHRWYWx1ZScsIHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBuYXRpdmVQYW5uZXJOb2RlRmFrZXIgPSB7XG4gICAgICAgICAgZ2V0IGJ1ZmZlclNpemUoKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZ2V0IGNoYW5uZWxDb3VudCgpIHtcbiAgICAgICAgICAgIHJldHVybiBwYW5uZXJOb2RlLmNoYW5uZWxDb3VudDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNldCBjaGFubmVsQ291bnQodmFsdWUpIHtcbiAgICAgICAgICAgIC8vIEJ1ZyAjMTI1OiBTYWZhcmkgZG9lcyBub3QgdGhyb3cgYW4gZXJyb3IgeWV0LlxuICAgICAgICAgICAgaWYgKHZhbHVlID4gMikge1xuICAgICAgICAgICAgICB0aHJvdyBjcmVhdGVOb3RTdXBwb3J0ZWRFcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5wdXRHYWluTm9kZS5jaGFubmVsQ291bnQgPSB2YWx1ZTtcbiAgICAgICAgICAgIHBhbm5lck5vZGUuY2hhbm5lbENvdW50ID0gdmFsdWU7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBnZXQgY2hhbm5lbENvdW50TW9kZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBwYW5uZXJOb2RlLmNoYW5uZWxDb3VudE1vZGU7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzZXQgY2hhbm5lbENvdW50TW9kZSh2YWx1ZSkge1xuICAgICAgICAgICAgLy8gQnVnICMxMjY6IFNhZmFyaSBkb2VzIG5vdCB0aHJvdyBhbiBlcnJvciB5ZXQuXG4gICAgICAgICAgICBpZiAodmFsdWUgPT09ICdtYXgnKSB7XG4gICAgICAgICAgICAgIHRocm93IGNyZWF0ZU5vdFN1cHBvcnRlZEVycm9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbnB1dEdhaW5Ob2RlLmNoYW5uZWxDb3VudE1vZGUgPSB2YWx1ZTtcbiAgICAgICAgICAgIHBhbm5lck5vZGUuY2hhbm5lbENvdW50TW9kZSA9IHZhbHVlO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZ2V0IGNoYW5uZWxJbnRlcnByZXRhdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBwYW5uZXJOb2RlLmNoYW5uZWxJbnRlcnByZXRhdGlvbjtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNldCBjaGFubmVsSW50ZXJwcmV0YXRpb24odmFsdWUpIHtcbiAgICAgICAgICAgIGlucHV0R2Fpbk5vZGUuY2hhbm5lbEludGVycHJldGF0aW9uID0gdmFsdWU7XG4gICAgICAgICAgICBwYW5uZXJOb2RlLmNoYW5uZWxJbnRlcnByZXRhdGlvbiA9IHZhbHVlO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZ2V0IGNvbmVJbm5lckFuZ2xlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHBhbm5lck5vZGUuY29uZUlubmVyQW5nbGU7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzZXQgY29uZUlubmVyQW5nbGUodmFsdWUpIHtcbiAgICAgICAgICAgIHBhbm5lck5vZGUuY29uZUlubmVyQW5nbGUgPSB2YWx1ZTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGdldCBjb25lT3V0ZXJBbmdsZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBwYW5uZXJOb2RlLmNvbmVPdXRlckFuZ2xlO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc2V0IGNvbmVPdXRlckFuZ2xlKHZhbHVlKSB7XG4gICAgICAgICAgICBwYW5uZXJOb2RlLmNvbmVPdXRlckFuZ2xlID0gdmFsdWU7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBnZXQgY29uZU91dGVyR2FpbigpIHtcbiAgICAgICAgICAgIHJldHVybiBwYW5uZXJOb2RlLmNvbmVPdXRlckdhaW47XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzZXQgY29uZU91dGVyR2Fpbih2YWx1ZSkge1xuICAgICAgICAgICAgLy8gQnVnICMxMjc6IFNhZmFyaSBkb2VzIG5vdCB0aHJvdyBhbiBJbnZhbGlkU3RhdGVFcnJvciB5ZXQuXG4gICAgICAgICAgICBpZiAodmFsdWUgPCAwIHx8IHZhbHVlID4gMSkge1xuICAgICAgICAgICAgICB0aHJvdyBjcmVhdGVJbnZhbGlkU3RhdGVFcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFubmVyTm9kZS5jb25lT3V0ZXJHYWluID0gdmFsdWU7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBnZXQgY29udGV4dCgpIHtcbiAgICAgICAgICAgIHJldHVybiBwYW5uZXJOb2RlLmNvbnRleHQ7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBnZXQgZGlzdGFuY2VNb2RlbCgpIHtcbiAgICAgICAgICAgIHJldHVybiBwYW5uZXJOb2RlLmRpc3RhbmNlTW9kZWw7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzZXQgZGlzdGFuY2VNb2RlbCh2YWx1ZSkge1xuICAgICAgICAgICAgcGFubmVyTm9kZS5kaXN0YW5jZU1vZGVsID0gdmFsdWU7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBnZXQgaW5wdXRzKCkge1xuICAgICAgICAgICAgcmV0dXJuIFtpbnB1dEdhaW5Ob2RlXTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGdldCBtYXhEaXN0YW5jZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBwYW5uZXJOb2RlLm1heERpc3RhbmNlO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc2V0IG1heERpc3RhbmNlKHZhbHVlKSB7XG4gICAgICAgICAgICAvLyBCdWcgIzEyODogU2FmYXJpIGRvZXMgbm90IHRocm93IGFuIGVycm9yIHlldC5cbiAgICAgICAgICAgIGlmICh2YWx1ZSA8IDApIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhbm5lck5vZGUubWF4RGlzdGFuY2UgPSB2YWx1ZTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGdldCBudW1iZXJPZklucHV0cygpIHtcbiAgICAgICAgICAgIHJldHVybiBwYW5uZXJOb2RlLm51bWJlck9mSW5wdXRzO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZ2V0IG51bWJlck9mT3V0cHV0cygpIHtcbiAgICAgICAgICAgIHJldHVybiBwYW5uZXJOb2RlLm51bWJlck9mT3V0cHV0cztcbiAgICAgICAgICB9LFxuICAgICAgICAgIGdldCBvcmllbnRhdGlvblgoKSB7XG4gICAgICAgICAgICByZXR1cm4gb3JpZW50YXRpb25YR2Fpbk5vZGUuZ2FpbjtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGdldCBvcmllbnRhdGlvblkoKSB7XG4gICAgICAgICAgICByZXR1cm4gb3JpZW50YXRpb25ZR2Fpbk5vZGUuZ2FpbjtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGdldCBvcmllbnRhdGlvblooKSB7XG4gICAgICAgICAgICByZXR1cm4gb3JpZW50YXRpb25aR2Fpbk5vZGUuZ2FpbjtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGdldCBwYW5uaW5nTW9kZWwoKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFubmVyTm9kZS5wYW5uaW5nTW9kZWw7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzZXQgcGFubmluZ01vZGVsKHZhbHVlKSB7XG4gICAgICAgICAgICBwYW5uZXJOb2RlLnBhbm5pbmdNb2RlbCA9IHZhbHVlO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZ2V0IHBvc2l0aW9uWCgpIHtcbiAgICAgICAgICAgIHJldHVybiBwb3NpdGlvblhHYWluTm9kZS5nYWluO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZ2V0IHBvc2l0aW9uWSgpIHtcbiAgICAgICAgICAgIHJldHVybiBwb3NpdGlvbllHYWluTm9kZS5nYWluO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZ2V0IHBvc2l0aW9uWigpIHtcbiAgICAgICAgICAgIHJldHVybiBwb3NpdGlvblpHYWluTm9kZS5nYWluO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZ2V0IHJlZkRpc3RhbmNlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHBhbm5lck5vZGUucmVmRGlzdGFuY2U7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzZXQgcmVmRGlzdGFuY2UodmFsdWUpIHtcbiAgICAgICAgICAgIC8vIEJ1ZyAjMTI5OiBTYWZhcmkgZG9lcyBub3QgdGhyb3cgYW4gZXJyb3IgeWV0LlxuICAgICAgICAgICAgaWYgKHZhbHVlIDwgMCkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFubmVyTm9kZS5yZWZEaXN0YW5jZSA9IHZhbHVlO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZ2V0IHJvbGxvZmZGYWN0b3IoKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFubmVyTm9kZS5yb2xsb2ZmRmFjdG9yO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc2V0IHJvbGxvZmZGYWN0b3IodmFsdWUpIHtcbiAgICAgICAgICAgIC8vIEJ1ZyAjMTMwOiBTYWZhcmkgZG9lcyBub3QgdGhyb3cgYW4gZXJyb3IgeWV0LlxuICAgICAgICAgICAgaWYgKHZhbHVlIDwgMCkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFubmVyTm9kZS5yb2xsb2ZmRmFjdG9yID0gdmFsdWU7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBhZGRFdmVudExpc3RlbmVyOiBmdW5jdGlvbiBhZGRFdmVudExpc3RlbmVyKCkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0R2Fpbk5vZGUuYWRkRXZlbnRMaXN0ZW5lcihhcmd1bWVudHMubGVuZ3RoIDw9IDAgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMF0sIGFyZ3VtZW50cy5sZW5ndGggPD0gMSA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzLmxlbmd0aCA8PSAyID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzJdKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGRpc3BhdGNoRXZlbnQ6IGZ1bmN0aW9uIGRpc3BhdGNoRXZlbnQoKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXRHYWluTm9kZS5kaXNwYXRjaEV2ZW50KGFyZ3VtZW50cy5sZW5ndGggPD0gMCA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1swXSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICByZW1vdmVFdmVudExpc3RlbmVyOiBmdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVyKCkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0R2Fpbk5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihhcmd1bWVudHMubGVuZ3RoIDw9IDAgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMF0sIGFyZ3VtZW50cy5sZW5ndGggPD0gMSA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzLmxlbmd0aCA8PSAyID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzJdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGlmIChjb25lSW5uZXJBbmdsZSAhPT0gbmF0aXZlUGFubmVyTm9kZUZha2VyLmNvbmVJbm5lckFuZ2xlKSB7XG4gICAgICAgICAgbmF0aXZlUGFubmVyTm9kZUZha2VyLmNvbmVJbm5lckFuZ2xlID0gY29uZUlubmVyQW5nbGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbmVPdXRlckFuZ2xlICE9PSBuYXRpdmVQYW5uZXJOb2RlRmFrZXIuY29uZU91dGVyQW5nbGUpIHtcbiAgICAgICAgICBuYXRpdmVQYW5uZXJOb2RlRmFrZXIuY29uZU91dGVyQW5nbGUgPSBjb25lT3V0ZXJBbmdsZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uZU91dGVyR2FpbiAhPT0gbmF0aXZlUGFubmVyTm9kZUZha2VyLmNvbmVPdXRlckdhaW4pIHtcbiAgICAgICAgICBuYXRpdmVQYW5uZXJOb2RlRmFrZXIuY29uZU91dGVyR2FpbiA9IGNvbmVPdXRlckdhaW47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRpc3RhbmNlTW9kZWwgIT09IG5hdGl2ZVBhbm5lck5vZGVGYWtlci5kaXN0YW5jZU1vZGVsKSB7XG4gICAgICAgICAgbmF0aXZlUGFubmVyTm9kZUZha2VyLmRpc3RhbmNlTW9kZWwgPSBkaXN0YW5jZU1vZGVsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXhEaXN0YW5jZSAhPT0gbmF0aXZlUGFubmVyTm9kZUZha2VyLm1heERpc3RhbmNlKSB7XG4gICAgICAgICAgbmF0aXZlUGFubmVyTm9kZUZha2VyLm1heERpc3RhbmNlID0gbWF4RGlzdGFuY2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9yaWVudGF0aW9uWCAhPT0gbmF0aXZlUGFubmVyTm9kZUZha2VyLm9yaWVudGF0aW9uWC52YWx1ZSkge1xuICAgICAgICAgIG5hdGl2ZVBhbm5lck5vZGVGYWtlci5vcmllbnRhdGlvblgudmFsdWUgPSBvcmllbnRhdGlvblg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9yaWVudGF0aW9uWSAhPT0gbmF0aXZlUGFubmVyTm9kZUZha2VyLm9yaWVudGF0aW9uWS52YWx1ZSkge1xuICAgICAgICAgIG5hdGl2ZVBhbm5lck5vZGVGYWtlci5vcmllbnRhdGlvblkudmFsdWUgPSBvcmllbnRhdGlvblk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9yaWVudGF0aW9uWiAhPT0gbmF0aXZlUGFubmVyTm9kZUZha2VyLm9yaWVudGF0aW9uWi52YWx1ZSkge1xuICAgICAgICAgIG5hdGl2ZVBhbm5lck5vZGVGYWtlci5vcmllbnRhdGlvbloudmFsdWUgPSBvcmllbnRhdGlvblo7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhbm5pbmdNb2RlbCAhPT0gbmF0aXZlUGFubmVyTm9kZUZha2VyLnBhbm5pbmdNb2RlbCkge1xuICAgICAgICAgIG5hdGl2ZVBhbm5lck5vZGVGYWtlci5wYW5uaW5nTW9kZWwgPSBwYW5uaW5nTW9kZWw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvc2l0aW9uWCAhPT0gbmF0aXZlUGFubmVyTm9kZUZha2VyLnBvc2l0aW9uWC52YWx1ZSkge1xuICAgICAgICAgIG5hdGl2ZVBhbm5lck5vZGVGYWtlci5wb3NpdGlvblgudmFsdWUgPSBwb3NpdGlvblg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvc2l0aW9uWSAhPT0gbmF0aXZlUGFubmVyTm9kZUZha2VyLnBvc2l0aW9uWS52YWx1ZSkge1xuICAgICAgICAgIG5hdGl2ZVBhbm5lck5vZGVGYWtlci5wb3NpdGlvblkudmFsdWUgPSBwb3NpdGlvblk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvc2l0aW9uWiAhPT0gbmF0aXZlUGFubmVyTm9kZUZha2VyLnBvc2l0aW9uWi52YWx1ZSkge1xuICAgICAgICAgIG5hdGl2ZVBhbm5lck5vZGVGYWtlci5wb3NpdGlvbloudmFsdWUgPSBwb3NpdGlvblo7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlZkRpc3RhbmNlICE9PSBuYXRpdmVQYW5uZXJOb2RlRmFrZXIucmVmRGlzdGFuY2UpIHtcbiAgICAgICAgICBuYXRpdmVQYW5uZXJOb2RlRmFrZXIucmVmRGlzdGFuY2UgPSByZWZEaXN0YW5jZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocm9sbG9mZkZhY3RvciAhPT0gbmF0aXZlUGFubmVyTm9kZUZha2VyLnJvbGxvZmZGYWN0b3IpIHtcbiAgICAgICAgICBuYXRpdmVQYW5uZXJOb2RlRmFrZXIucm9sbG9mZkZhY3RvciA9IHJvbGxvZmZGYWN0b3I7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhc3RPcmllbnRhdGlvblswXSAhPT0gMSB8fCBsYXN0T3JpZW50YXRpb25bMV0gIT09IDAgfHwgbGFzdE9yaWVudGF0aW9uWzJdICE9PSAwKSB7XG4gICAgICAgICAgcGFubmVyTm9kZS5zZXRPcmllbnRhdGlvbi5hcHBseShwYW5uZXJOb2RlLCBfdG9Db25zdW1hYmxlQXJyYXkobGFzdE9yaWVudGF0aW9uKSk7IC8vIHRzbGludDpkaXNhYmxlLWxpbmU6ZGVwcmVjYXRpb25cbiAgICAgICAgfVxuICAgICAgICBpZiAobGFzdFBvc2l0aW9uWzBdICE9PSAwIHx8IGxhc3RQb3NpdGlvblsxXSAhPT0gMCB8fCBsYXN0UG9zaXRpb25bMl0gIT09IDApIHtcbiAgICAgICAgICBwYW5uZXJOb2RlLnNldFBvc2l0aW9uLmFwcGx5KHBhbm5lck5vZGUsIF90b0NvbnN1bWFibGVBcnJheShsYXN0UG9zaXRpb24pKTsgLy8gdHNsaW50OmRpc2FibGUtbGluZTpkZXByZWNhdGlvblxuICAgICAgICB9XG4gICAgICAgIHZhciB3aGVuQ29ubmVjdGVkID0gZnVuY3Rpb24gd2hlbkNvbm5lY3RlZCgpIHtcbiAgICAgICAgICBpbnB1dEdhaW5Ob2RlLmNvbm5lY3QocGFubmVyTm9kZSk7XG4gICAgICAgICAgLy8gQnVnICMxMTk6IFNhZmFyaSBkb2VzIG5vdCBmdWxseSBzdXBwb3J0IHRoZSBXYXZlU2hhcGVyTm9kZS5cbiAgICAgICAgICBjb25uZWN0TmF0aXZlQXVkaW9Ob2RlVG9OYXRpdmVBdWRpb05vZGUoaW5wdXRHYWluTm9kZSwgd2F2ZVNoYXBlck5vZGUsIDAsIDApO1xuICAgICAgICAgIHdhdmVTaGFwZXJOb2RlLmNvbm5lY3Qob3JpZW50YXRpb25YR2Fpbk5vZGUpLmNvbm5lY3QoY2hhbm5lbE1lcmdlck5vZGUsIDAsIDApO1xuICAgICAgICAgIHdhdmVTaGFwZXJOb2RlLmNvbm5lY3Qob3JpZW50YXRpb25ZR2Fpbk5vZGUpLmNvbm5lY3QoY2hhbm5lbE1lcmdlck5vZGUsIDAsIDEpO1xuICAgICAgICAgIHdhdmVTaGFwZXJOb2RlLmNvbm5lY3Qob3JpZW50YXRpb25aR2Fpbk5vZGUpLmNvbm5lY3QoY2hhbm5lbE1lcmdlck5vZGUsIDAsIDIpO1xuICAgICAgICAgIHdhdmVTaGFwZXJOb2RlLmNvbm5lY3QocG9zaXRpb25YR2Fpbk5vZGUpLmNvbm5lY3QoY2hhbm5lbE1lcmdlck5vZGUsIDAsIDMpO1xuICAgICAgICAgIHdhdmVTaGFwZXJOb2RlLmNvbm5lY3QocG9zaXRpb25ZR2Fpbk5vZGUpLmNvbm5lY3QoY2hhbm5lbE1lcmdlck5vZGUsIDAsIDQpO1xuICAgICAgICAgIHdhdmVTaGFwZXJOb2RlLmNvbm5lY3QocG9zaXRpb25aR2Fpbk5vZGUpLmNvbm5lY3QoY2hhbm5lbE1lcmdlck5vZGUsIDAsIDUpO1xuICAgICAgICAgIGNoYW5uZWxNZXJnZXJOb2RlLmNvbm5lY3Qoc2NyaXB0UHJvY2Vzc29yTm9kZSkuY29ubmVjdChuYXRpdmVDb250ZXh0LmRlc3RpbmF0aW9uKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHdoZW5EaXNjb25uZWN0ZWQgPSBmdW5jdGlvbiB3aGVuRGlzY29ubmVjdGVkKCkge1xuICAgICAgICAgIGlucHV0R2Fpbk5vZGUuZGlzY29ubmVjdChwYW5uZXJOb2RlKTtcbiAgICAgICAgICAvLyBCdWcgIzExOTogU2FmYXJpIGRvZXMgbm90IGZ1bGx5IHN1cHBvcnQgdGhlIFdhdmVTaGFwZXJOb2RlLlxuICAgICAgICAgIGRpc2Nvbm5lY3ROYXRpdmVBdWRpb05vZGVGcm9tTmF0aXZlQXVkaW9Ob2RlKGlucHV0R2Fpbk5vZGUsIHdhdmVTaGFwZXJOb2RlLCAwLCAwKTtcbiAgICAgICAgICB3YXZlU2hhcGVyTm9kZS5kaXNjb25uZWN0KG9yaWVudGF0aW9uWEdhaW5Ob2RlKTtcbiAgICAgICAgICBvcmllbnRhdGlvblhHYWluTm9kZS5kaXNjb25uZWN0KGNoYW5uZWxNZXJnZXJOb2RlKTtcbiAgICAgICAgICB3YXZlU2hhcGVyTm9kZS5kaXNjb25uZWN0KG9yaWVudGF0aW9uWUdhaW5Ob2RlKTtcbiAgICAgICAgICBvcmllbnRhdGlvbllHYWluTm9kZS5kaXNjb25uZWN0KGNoYW5uZWxNZXJnZXJOb2RlKTtcbiAgICAgICAgICB3YXZlU2hhcGVyTm9kZS5kaXNjb25uZWN0KG9yaWVudGF0aW9uWkdhaW5Ob2RlKTtcbiAgICAgICAgICBvcmllbnRhdGlvblpHYWluTm9kZS5kaXNjb25uZWN0KGNoYW5uZWxNZXJnZXJOb2RlKTtcbiAgICAgICAgICB3YXZlU2hhcGVyTm9kZS5kaXNjb25uZWN0KHBvc2l0aW9uWEdhaW5Ob2RlKTtcbiAgICAgICAgICBwb3NpdGlvblhHYWluTm9kZS5kaXNjb25uZWN0KGNoYW5uZWxNZXJnZXJOb2RlKTtcbiAgICAgICAgICB3YXZlU2hhcGVyTm9kZS5kaXNjb25uZWN0KHBvc2l0aW9uWUdhaW5Ob2RlKTtcbiAgICAgICAgICBwb3NpdGlvbllHYWluTm9kZS5kaXNjb25uZWN0KGNoYW5uZWxNZXJnZXJOb2RlKTtcbiAgICAgICAgICB3YXZlU2hhcGVyTm9kZS5kaXNjb25uZWN0KHBvc2l0aW9uWkdhaW5Ob2RlKTtcbiAgICAgICAgICBwb3NpdGlvblpHYWluTm9kZS5kaXNjb25uZWN0KGNoYW5uZWxNZXJnZXJOb2RlKTtcbiAgICAgICAgICBjaGFubmVsTWVyZ2VyTm9kZS5kaXNjb25uZWN0KHNjcmlwdFByb2Nlc3Nvck5vZGUpO1xuICAgICAgICAgIHNjcmlwdFByb2Nlc3Nvck5vZGUuZGlzY29ubmVjdChuYXRpdmVDb250ZXh0LmRlc3RpbmF0aW9uKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG1vbml0b3JDb25uZWN0aW9ucyhpbnRlcmNlcHRDb25uZWN0aW9ucyhuYXRpdmVQYW5uZXJOb2RlRmFrZXIsIHBhbm5lck5vZGUpLCB3aGVuQ29ubmVjdGVkLCB3aGVuRGlzY29ubmVjdGVkKTtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVOYXRpdmVQZXJpb2RpY1dhdmVGYWN0b3J5ID0gZnVuY3Rpb24gY3JlYXRlTmF0aXZlUGVyaW9kaWNXYXZlRmFjdG9yeShjcmVhdGVJbmRleFNpemVFcnJvcikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChuYXRpdmVDb250ZXh0LCBfcmVmKSB7XG4gICAgICAgIHZhciBkaXNhYmxlTm9ybWFsaXphdGlvbiA9IF9yZWYuZGlzYWJsZU5vcm1hbGl6YXRpb24sXG4gICAgICAgICAgaW1hZyA9IF9yZWYuaW1hZyxcbiAgICAgICAgICByZWFsID0gX3JlZi5yZWFsO1xuICAgICAgICAvLyBCdWcgIzE4MDogU2FmYXJpIGRvZXMgbm90IGFsbG93IHRvIHVzZSBvcmRpbmFyeSBhcnJheXMuXG4gICAgICAgIHZhciBjb252ZXJ0ZWRJbWFnID0gaW1hZyBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSA/IGltYWcgOiBuZXcgRmxvYXQzMkFycmF5KGltYWcpO1xuICAgICAgICB2YXIgY29udmVydGVkUmVhbCA9IHJlYWwgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkgPyByZWFsIDogbmV3IEZsb2F0MzJBcnJheShyZWFsKTtcbiAgICAgICAgdmFyIG5hdGl2ZVBlcmlvZGljV2F2ZSA9IG5hdGl2ZUNvbnRleHQuY3JlYXRlUGVyaW9kaWNXYXZlKGNvbnZlcnRlZFJlYWwsIGNvbnZlcnRlZEltYWcsIHtcbiAgICAgICAgICBkaXNhYmxlTm9ybWFsaXphdGlvbjogZGlzYWJsZU5vcm1hbGl6YXRpb25cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEJ1ZyAjMTgxOiBTYWZhcmkgZG9lcyBub3QgdGhyb3cgYW4gSW5kZXhTaXplRXJyb3Igc28gZmFyIGlmIHRoZSBnaXZlbiBhcnJheXMgaGF2ZSBsZXNzIHRoYW4gdHdvIHZhbHVlcy5cbiAgICAgICAgaWYgKEFycmF5LmZyb20oaW1hZykubGVuZ3RoIDwgMikge1xuICAgICAgICAgIHRocm93IGNyZWF0ZUluZGV4U2l6ZUVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5hdGl2ZVBlcmlvZGljV2F2ZTtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVOYXRpdmVTY3JpcHRQcm9jZXNzb3JOb2RlID0gZnVuY3Rpb24gY3JlYXRlTmF0aXZlU2NyaXB0UHJvY2Vzc29yTm9kZShuYXRpdmVDb250ZXh0LCBidWZmZXJTaXplLCBudW1iZXJPZklucHV0Q2hhbm5lbHMsIG51bWJlck9mT3V0cHV0Q2hhbm5lbHMpIHtcbiAgICAgIHJldHVybiBuYXRpdmVDb250ZXh0LmNyZWF0ZVNjcmlwdFByb2Nlc3NvcihidWZmZXJTaXplLCBudW1iZXJPZklucHV0Q2hhbm5lbHMsIG51bWJlck9mT3V0cHV0Q2hhbm5lbHMpOyAvLyB0c2xpbnQ6ZGlzYWJsZS1saW5lIGRlcHJlY2F0aW9uXG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVOYXRpdmVTdGVyZW9QYW5uZXJOb2RlRmFjdG9yeSA9IGZ1bmN0aW9uIGNyZWF0ZU5hdGl2ZVN0ZXJlb1Bhbm5lck5vZGVGYWN0b3J5KGNyZWF0ZU5hdGl2ZVN0ZXJlb1Bhbm5lck5vZGVGYWtlciwgY3JlYXRlTm90U3VwcG9ydGVkRXJyb3IpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAobmF0aXZlQ29udGV4dCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgY2hhbm5lbENvdW50TW9kZSA9IG9wdGlvbnMuY2hhbm5lbENvdW50TW9kZTtcbiAgICAgICAgLypcbiAgICAgICAgICogQnVnICMxMDU6IFRoZSBjaGFubmVsQ291bnRNb2RlIG9mICdjbGFtcGVkLW1heCcgc2hvdWxkIGJlIHN1cHBvcnRlZC4gSG93ZXZlciBpdCBpcyBub3QgcG9zc2libGUgdG8gd3JpdGUgYSBwb2x5ZmlsbCBmb3IgU2FmYXJpXG4gICAgICAgICAqIHdoaWNoIHN1cHBvcnRzIGl0IGFuZCB0aGVyZWZvcmUgaXQgY2FuJ3QgYmUgc3VwcG9ydGVkIGF0IGFsbC5cbiAgICAgICAgICovXG4gICAgICAgIGlmIChjaGFubmVsQ291bnRNb2RlID09PSAnY2xhbXBlZC1tYXgnKSB7XG4gICAgICAgICAgdGhyb3cgY3JlYXRlTm90U3VwcG9ydGVkRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBCdWcgIzEwNTogU2FmYXJpIGRvZXMgbm90IHN1cHBvcnQgdGhlIFN0ZXJlb1Bhbm5lck5vZGUuXG4gICAgICAgIGlmIChuYXRpdmVDb250ZXh0LmNyZWF0ZVN0ZXJlb1Bhbm5lciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZU5hdGl2ZVN0ZXJlb1Bhbm5lck5vZGVGYWtlcihuYXRpdmVDb250ZXh0LCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmF0aXZlU3RlcmVvUGFubmVyTm9kZSA9IG5hdGl2ZUNvbnRleHQuY3JlYXRlU3RlcmVvUGFubmVyKCk7XG4gICAgICAgIGFzc2lnbk5hdGl2ZUF1ZGlvTm9kZU9wdGlvbnMobmF0aXZlU3RlcmVvUGFubmVyTm9kZSwgb3B0aW9ucyk7XG4gICAgICAgIGFzc2lnbk5hdGl2ZUF1ZGlvTm9kZUF1ZGlvUGFyYW1WYWx1ZShuYXRpdmVTdGVyZW9QYW5uZXJOb2RlLCBvcHRpb25zLCAncGFuJyk7XG4gICAgICAgIC8qXG4gICAgICAgICAqIEJ1ZyAjMTA1OiBUaGUgY2hhbm5lbENvdW50TW9kZSBvZiAnY2xhbXBlZC1tYXgnIHNob3VsZCBiZSBzdXBwb3J0ZWQuIEhvd2V2ZXIgaXQgaXMgbm90IHBvc3NpYmxlIHRvIHdyaXRlIGEgcG9seWZpbGwgZm9yIFNhZmFyaVxuICAgICAgICAgKiB3aGljaCBzdXBwb3J0cyBpdCBhbmQgdGhlcmVmb3JlIGl0IGNhbid0IGJlIHN1cHBvcnRlZCBhdCBhbGwuXG4gICAgICAgICAqL1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobmF0aXZlU3RlcmVvUGFubmVyTm9kZSwgJ2NoYW5uZWxDb3VudE1vZGUnLCB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gY2hhbm5lbENvdW50TW9kZTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IGNoYW5uZWxDb3VudE1vZGUpIHtcbiAgICAgICAgICAgICAgdGhyb3cgY3JlYXRlTm90U3VwcG9ydGVkRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmF0aXZlU3RlcmVvUGFubmVyTm9kZTtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBfZXhjbHVkZWQkMSA9IFtcImNoYW5uZWxDb3VudFwiLCBcImNoYW5uZWxDb3VudE1vZGVcIiwgXCJwYW5cIl07XG4gICAgZnVuY3Rpb24gb3duS2V5cyRiKGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cbiAgICBmdW5jdGlvbiBfb2JqZWN0U3ByZWFkJGIoZSkgeyBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykgeyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gb3duS2V5cyRiKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyRiKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XG4gICAgdmFyIGNyZWF0ZU5hdGl2ZVN0ZXJlb1Bhbm5lck5vZGVGYWtlckZhY3RvcnkgPSBmdW5jdGlvbiBjcmVhdGVOYXRpdmVTdGVyZW9QYW5uZXJOb2RlRmFrZXJGYWN0b3J5KGNyZWF0ZU5hdGl2ZUNoYW5uZWxNZXJnZXJOb2RlLCBjcmVhdGVOYXRpdmVDaGFubmVsU3BsaXR0ZXJOb2RlLCBjcmVhdGVOYXRpdmVHYWluTm9kZSwgY3JlYXRlTmF0aXZlV2F2ZVNoYXBlck5vZGUsIGNyZWF0ZU5vdFN1cHBvcnRlZEVycm9yLCBtb25pdG9yQ29ubmVjdGlvbnMpIHtcbiAgICAgIC8vIFRoZSBjdXJ2ZSBoYXMgYSBzaXplIG9mIDE0Yml0IHBsdXMgMSB2YWx1ZSB0byBoYXZlIGFuIGV4YWN0IHJlcHJlc2VudGF0aW9uIGZvciB6ZXJvLiBUaGlzIHZhbHVlIGhhcyBiZWVuIGRldGVybWluZWQgZXhwZXJpbWVudGFsbHkuXG4gICAgICB2YXIgQ1VSVkVfU0laRSA9IDE2Mzg1O1xuICAgICAgdmFyIERDX0NVUlZFID0gbmV3IEZsb2F0MzJBcnJheShbMSwgMV0pO1xuICAgICAgdmFyIEhBTEZfUEkgPSBNYXRoLlBJIC8gMjtcbiAgICAgIHZhciBTSU5HTEVfQ0hBTk5FTF9PUFRJT05TID0ge1xuICAgICAgICBjaGFubmVsQ291bnQ6IDEsXG4gICAgICAgIGNoYW5uZWxDb3VudE1vZGU6ICdleHBsaWNpdCcsXG4gICAgICAgIGNoYW5uZWxJbnRlcnByZXRhdGlvbjogJ2Rpc2NyZXRlJ1xuICAgICAgfTtcbiAgICAgIHZhciBTSU5HTEVfQ0hBTk5FTF9XQVZFX1NIQVBFUl9PUFRJT05TID0gX29iamVjdFNwcmVhZCRiKF9vYmplY3RTcHJlYWQkYih7fSwgU0lOR0xFX0NIQU5ORUxfT1BUSU9OUyksIHt9LCB7XG4gICAgICAgIG92ZXJzYW1wbGU6ICdub25lJ1xuICAgICAgfSk7XG4gICAgICB2YXIgYnVpbGRJbnRlcm5hbEdyYXBoRm9yTW9ubyA9IGZ1bmN0aW9uIGJ1aWxkSW50ZXJuYWxHcmFwaEZvck1vbm8obmF0aXZlQ29udGV4dCwgaW5wdXRHYWluTm9kZSwgcGFuR2Fpbk5vZGUsIGNoYW5uZWxNZXJnZXJOb2RlKSB7XG4gICAgICAgIHZhciBsZWZ0V2F2ZVNoYXBlckN1cnZlID0gbmV3IEZsb2F0MzJBcnJheShDVVJWRV9TSVpFKTtcbiAgICAgICAgdmFyIHJpZ2h0V2F2ZVNoYXBlckN1cnZlID0gbmV3IEZsb2F0MzJBcnJheShDVVJWRV9TSVpFKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBDVVJWRV9TSVpFOyBpICs9IDEpIHtcbiAgICAgICAgICB2YXIgeCA9IGkgLyAoQ1VSVkVfU0laRSAtIDEpICogSEFMRl9QSTtcbiAgICAgICAgICBsZWZ0V2F2ZVNoYXBlckN1cnZlW2ldID0gTWF0aC5jb3MoeCk7XG4gICAgICAgICAgcmlnaHRXYXZlU2hhcGVyQ3VydmVbaV0gPSBNYXRoLnNpbih4KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGVmdEdhaW5Ob2RlID0gY3JlYXRlTmF0aXZlR2Fpbk5vZGUobmF0aXZlQ29udGV4dCwgX29iamVjdFNwcmVhZCRiKF9vYmplY3RTcHJlYWQkYih7fSwgU0lOR0xFX0NIQU5ORUxfT1BUSU9OUyksIHt9LCB7XG4gICAgICAgICAgZ2FpbjogMFxuICAgICAgICB9KSk7XG4gICAgICAgIC8vIEJ1ZyAjMTE5OiBTYWZhcmkgZG9lcyBub3QgZnVsbHkgc3VwcG9ydCB0aGUgV2F2ZVNoYXBlck5vZGUuXG4gICAgICAgIHZhciBsZWZ0V2F2ZVNoYXBlck5vZGUgPSBjcmVhdGVOYXRpdmVXYXZlU2hhcGVyTm9kZShuYXRpdmVDb250ZXh0LCBfb2JqZWN0U3ByZWFkJGIoX29iamVjdFNwcmVhZCRiKHt9LCBTSU5HTEVfQ0hBTk5FTF9XQVZFX1NIQVBFUl9PUFRJT05TKSwge30sIHtcbiAgICAgICAgICBjdXJ2ZTogbGVmdFdhdmVTaGFwZXJDdXJ2ZVxuICAgICAgICB9KSk7XG4gICAgICAgIC8vIEJ1ZyAjMTE5OiBTYWZhcmkgZG9lcyBub3QgZnVsbHkgc3VwcG9ydCB0aGUgV2F2ZVNoYXBlck5vZGUuXG4gICAgICAgIHZhciBwYW5XYXZlU2hhcGVyTm9kZSA9IGNyZWF0ZU5hdGl2ZVdhdmVTaGFwZXJOb2RlKG5hdGl2ZUNvbnRleHQsIF9vYmplY3RTcHJlYWQkYihfb2JqZWN0U3ByZWFkJGIoe30sIFNJTkdMRV9DSEFOTkVMX1dBVkVfU0hBUEVSX09QVElPTlMpLCB7fSwge1xuICAgICAgICAgIGN1cnZlOiBEQ19DVVJWRVxuICAgICAgICB9KSk7XG4gICAgICAgIHZhciByaWdodEdhaW5Ob2RlID0gY3JlYXRlTmF0aXZlR2Fpbk5vZGUobmF0aXZlQ29udGV4dCwgX29iamVjdFNwcmVhZCRiKF9vYmplY3RTcHJlYWQkYih7fSwgU0lOR0xFX0NIQU5ORUxfT1BUSU9OUyksIHt9LCB7XG4gICAgICAgICAgZ2FpbjogMFxuICAgICAgICB9KSk7XG4gICAgICAgIC8vIEJ1ZyAjMTE5OiBTYWZhcmkgZG9lcyBub3QgZnVsbHkgc3VwcG9ydCB0aGUgV2F2ZVNoYXBlck5vZGUuXG4gICAgICAgIHZhciByaWdodFdhdmVTaGFwZXJOb2RlID0gY3JlYXRlTmF0aXZlV2F2ZVNoYXBlck5vZGUobmF0aXZlQ29udGV4dCwgX29iamVjdFNwcmVhZCRiKF9vYmplY3RTcHJlYWQkYih7fSwgU0lOR0xFX0NIQU5ORUxfV0FWRV9TSEFQRVJfT1BUSU9OUyksIHt9LCB7XG4gICAgICAgICAgY3VydmU6IHJpZ2h0V2F2ZVNoYXBlckN1cnZlXG4gICAgICAgIH0pKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBjb25uZWN0R3JhcGg6IGZ1bmN0aW9uIGNvbm5lY3RHcmFwaCgpIHtcbiAgICAgICAgICAgIGlucHV0R2Fpbk5vZGUuY29ubmVjdChsZWZ0R2Fpbk5vZGUpO1xuICAgICAgICAgICAgaW5wdXRHYWluTm9kZS5jb25uZWN0KHBhbldhdmVTaGFwZXJOb2RlLmlucHV0cyA9PT0gdW5kZWZpbmVkID8gcGFuV2F2ZVNoYXBlck5vZGUgOiBwYW5XYXZlU2hhcGVyTm9kZS5pbnB1dHNbMF0pO1xuICAgICAgICAgICAgaW5wdXRHYWluTm9kZS5jb25uZWN0KHJpZ2h0R2Fpbk5vZGUpO1xuICAgICAgICAgICAgcGFuV2F2ZVNoYXBlck5vZGUuY29ubmVjdChwYW5HYWluTm9kZSk7XG4gICAgICAgICAgICBwYW5HYWluTm9kZS5jb25uZWN0KGxlZnRXYXZlU2hhcGVyTm9kZS5pbnB1dHMgPT09IHVuZGVmaW5lZCA/IGxlZnRXYXZlU2hhcGVyTm9kZSA6IGxlZnRXYXZlU2hhcGVyTm9kZS5pbnB1dHNbMF0pO1xuICAgICAgICAgICAgcGFuR2Fpbk5vZGUuY29ubmVjdChyaWdodFdhdmVTaGFwZXJOb2RlLmlucHV0cyA9PT0gdW5kZWZpbmVkID8gcmlnaHRXYXZlU2hhcGVyTm9kZSA6IHJpZ2h0V2F2ZVNoYXBlck5vZGUuaW5wdXRzWzBdKTtcbiAgICAgICAgICAgIGxlZnRXYXZlU2hhcGVyTm9kZS5jb25uZWN0KGxlZnRHYWluTm9kZS5nYWluKTtcbiAgICAgICAgICAgIHJpZ2h0V2F2ZVNoYXBlck5vZGUuY29ubmVjdChyaWdodEdhaW5Ob2RlLmdhaW4pO1xuICAgICAgICAgICAgbGVmdEdhaW5Ob2RlLmNvbm5lY3QoY2hhbm5lbE1lcmdlck5vZGUsIDAsIDApO1xuICAgICAgICAgICAgcmlnaHRHYWluTm9kZS5jb25uZWN0KGNoYW5uZWxNZXJnZXJOb2RlLCAwLCAxKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGRpc2Nvbm5lY3RHcmFwaDogZnVuY3Rpb24gZGlzY29ubmVjdEdyYXBoKCkge1xuICAgICAgICAgICAgaW5wdXRHYWluTm9kZS5kaXNjb25uZWN0KGxlZnRHYWluTm9kZSk7XG4gICAgICAgICAgICBpbnB1dEdhaW5Ob2RlLmRpc2Nvbm5lY3QocGFuV2F2ZVNoYXBlck5vZGUuaW5wdXRzID09PSB1bmRlZmluZWQgPyBwYW5XYXZlU2hhcGVyTm9kZSA6IHBhbldhdmVTaGFwZXJOb2RlLmlucHV0c1swXSk7XG4gICAgICAgICAgICBpbnB1dEdhaW5Ob2RlLmRpc2Nvbm5lY3QocmlnaHRHYWluTm9kZSk7XG4gICAgICAgICAgICBwYW5XYXZlU2hhcGVyTm9kZS5kaXNjb25uZWN0KHBhbkdhaW5Ob2RlKTtcbiAgICAgICAgICAgIHBhbkdhaW5Ob2RlLmRpc2Nvbm5lY3QobGVmdFdhdmVTaGFwZXJOb2RlLmlucHV0cyA9PT0gdW5kZWZpbmVkID8gbGVmdFdhdmVTaGFwZXJOb2RlIDogbGVmdFdhdmVTaGFwZXJOb2RlLmlucHV0c1swXSk7XG4gICAgICAgICAgICBwYW5HYWluTm9kZS5kaXNjb25uZWN0KHJpZ2h0V2F2ZVNoYXBlck5vZGUuaW5wdXRzID09PSB1bmRlZmluZWQgPyByaWdodFdhdmVTaGFwZXJOb2RlIDogcmlnaHRXYXZlU2hhcGVyTm9kZS5pbnB1dHNbMF0pO1xuICAgICAgICAgICAgbGVmdFdhdmVTaGFwZXJOb2RlLmRpc2Nvbm5lY3QobGVmdEdhaW5Ob2RlLmdhaW4pO1xuICAgICAgICAgICAgcmlnaHRXYXZlU2hhcGVyTm9kZS5kaXNjb25uZWN0KHJpZ2h0R2Fpbk5vZGUuZ2Fpbik7XG4gICAgICAgICAgICBsZWZ0R2Fpbk5vZGUuZGlzY29ubmVjdChjaGFubmVsTWVyZ2VyTm9kZSwgMCwgMCk7XG4gICAgICAgICAgICByaWdodEdhaW5Ob2RlLmRpc2Nvbm5lY3QoY2hhbm5lbE1lcmdlck5vZGUsIDAsIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgICB2YXIgYnVpbGRJbnRlcm5hbEdyYXBoRm9yU3RlcmVvID0gZnVuY3Rpb24gYnVpbGRJbnRlcm5hbEdyYXBoRm9yU3RlcmVvKG5hdGl2ZUNvbnRleHQsIGlucHV0R2Fpbk5vZGUsIHBhbkdhaW5Ob2RlLCBjaGFubmVsTWVyZ2VyTm9kZSkge1xuICAgICAgICB2YXIgbGVmdElucHV0Rm9yTGVmdE91dHB1dFdhdmVTaGFwZXJDdXJ2ZSA9IG5ldyBGbG9hdDMyQXJyYXkoQ1VSVkVfU0laRSk7XG4gICAgICAgIHZhciBsZWZ0SW5wdXRGb3JSaWdodE91dHB1dFdhdmVTaGFwZXJDdXJ2ZSA9IG5ldyBGbG9hdDMyQXJyYXkoQ1VSVkVfU0laRSk7XG4gICAgICAgIHZhciByaWdodElucHV0Rm9yTGVmdE91dHB1dFdhdmVTaGFwZXJDdXJ2ZSA9IG5ldyBGbG9hdDMyQXJyYXkoQ1VSVkVfU0laRSk7XG4gICAgICAgIHZhciByaWdodElucHV0Rm9yUmlnaHRPdXRwdXRXYXZlU2hhcGVyQ3VydmUgPSBuZXcgRmxvYXQzMkFycmF5KENVUlZFX1NJWkUpO1xuICAgICAgICB2YXIgY2VudGVySW5kZXggPSBNYXRoLmZsb29yKENVUlZFX1NJWkUgLyAyKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBDVVJWRV9TSVpFOyBpICs9IDEpIHtcbiAgICAgICAgICBpZiAoaSA+IGNlbnRlckluZGV4KSB7XG4gICAgICAgICAgICB2YXIgeCA9IChpIC0gY2VudGVySW5kZXgpIC8gKENVUlZFX1NJWkUgLSAxIC0gY2VudGVySW5kZXgpICogSEFMRl9QSTtcbiAgICAgICAgICAgIGxlZnRJbnB1dEZvckxlZnRPdXRwdXRXYXZlU2hhcGVyQ3VydmVbaV0gPSBNYXRoLmNvcyh4KTtcbiAgICAgICAgICAgIGxlZnRJbnB1dEZvclJpZ2h0T3V0cHV0V2F2ZVNoYXBlckN1cnZlW2ldID0gTWF0aC5zaW4oeCk7XG4gICAgICAgICAgICByaWdodElucHV0Rm9yTGVmdE91dHB1dFdhdmVTaGFwZXJDdXJ2ZVtpXSA9IDA7XG4gICAgICAgICAgICByaWdodElucHV0Rm9yUmlnaHRPdXRwdXRXYXZlU2hhcGVyQ3VydmVbaV0gPSAxO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgX3ggPSBpIC8gKENVUlZFX1NJWkUgLSAxIC0gY2VudGVySW5kZXgpICogSEFMRl9QSTtcbiAgICAgICAgICAgIGxlZnRJbnB1dEZvckxlZnRPdXRwdXRXYXZlU2hhcGVyQ3VydmVbaV0gPSAxO1xuICAgICAgICAgICAgbGVmdElucHV0Rm9yUmlnaHRPdXRwdXRXYXZlU2hhcGVyQ3VydmVbaV0gPSAwO1xuICAgICAgICAgICAgcmlnaHRJbnB1dEZvckxlZnRPdXRwdXRXYXZlU2hhcGVyQ3VydmVbaV0gPSBNYXRoLmNvcyhfeCk7XG4gICAgICAgICAgICByaWdodElucHV0Rm9yUmlnaHRPdXRwdXRXYXZlU2hhcGVyQ3VydmVbaV0gPSBNYXRoLnNpbihfeCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBjaGFubmVsU3BsaXR0ZXJOb2RlID0gY3JlYXRlTmF0aXZlQ2hhbm5lbFNwbGl0dGVyTm9kZShuYXRpdmVDb250ZXh0LCB7XG4gICAgICAgICAgY2hhbm5lbENvdW50OiAyLFxuICAgICAgICAgIGNoYW5uZWxDb3VudE1vZGU6ICdleHBsaWNpdCcsXG4gICAgICAgICAgY2hhbm5lbEludGVycHJldGF0aW9uOiAnZGlzY3JldGUnLFxuICAgICAgICAgIG51bWJlck9mT3V0cHV0czogMlxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGxlZnRJbnB1dEZvckxlZnRPdXRwdXRHYWluTm9kZSA9IGNyZWF0ZU5hdGl2ZUdhaW5Ob2RlKG5hdGl2ZUNvbnRleHQsIF9vYmplY3RTcHJlYWQkYihfb2JqZWN0U3ByZWFkJGIoe30sIFNJTkdMRV9DSEFOTkVMX09QVElPTlMpLCB7fSwge1xuICAgICAgICAgIGdhaW46IDBcbiAgICAgICAgfSkpO1xuICAgICAgICAvLyBCdWcgIzExOTogU2FmYXJpIGRvZXMgbm90IGZ1bGx5IHN1cHBvcnQgdGhlIFdhdmVTaGFwZXJOb2RlLlxuICAgICAgICB2YXIgbGVmdElucHV0Rm9yTGVmdE91dHB1dFdhdmVTaGFwZXJOb2RlID0gY3JlYXRlTmF0aXZlV2F2ZVNoYXBlck5vZGUobmF0aXZlQ29udGV4dCwgX29iamVjdFNwcmVhZCRiKF9vYmplY3RTcHJlYWQkYih7fSwgU0lOR0xFX0NIQU5ORUxfV0FWRV9TSEFQRVJfT1BUSU9OUyksIHt9LCB7XG4gICAgICAgICAgY3VydmU6IGxlZnRJbnB1dEZvckxlZnRPdXRwdXRXYXZlU2hhcGVyQ3VydmVcbiAgICAgICAgfSkpO1xuICAgICAgICB2YXIgbGVmdElucHV0Rm9yUmlnaHRPdXRwdXRHYWluTm9kZSA9IGNyZWF0ZU5hdGl2ZUdhaW5Ob2RlKG5hdGl2ZUNvbnRleHQsIF9vYmplY3RTcHJlYWQkYihfb2JqZWN0U3ByZWFkJGIoe30sIFNJTkdMRV9DSEFOTkVMX09QVElPTlMpLCB7fSwge1xuICAgICAgICAgIGdhaW46IDBcbiAgICAgICAgfSkpO1xuICAgICAgICAvLyBCdWcgIzExOTogU2FmYXJpIGRvZXMgbm90IGZ1bGx5IHN1cHBvcnQgdGhlIFdhdmVTaGFwZXJOb2RlLlxuICAgICAgICB2YXIgbGVmdElucHV0Rm9yUmlnaHRPdXRwdXRXYXZlU2hhcGVyTm9kZSA9IGNyZWF0ZU5hdGl2ZVdhdmVTaGFwZXJOb2RlKG5hdGl2ZUNvbnRleHQsIF9vYmplY3RTcHJlYWQkYihfb2JqZWN0U3ByZWFkJGIoe30sIFNJTkdMRV9DSEFOTkVMX1dBVkVfU0hBUEVSX09QVElPTlMpLCB7fSwge1xuICAgICAgICAgIGN1cnZlOiBsZWZ0SW5wdXRGb3JSaWdodE91dHB1dFdhdmVTaGFwZXJDdXJ2ZVxuICAgICAgICB9KSk7XG4gICAgICAgIC8vIEJ1ZyAjMTE5OiBTYWZhcmkgZG9lcyBub3QgZnVsbHkgc3VwcG9ydCB0aGUgV2F2ZVNoYXBlck5vZGUuXG4gICAgICAgIHZhciBwYW5XYXZlU2hhcGVyTm9kZSA9IGNyZWF0ZU5hdGl2ZVdhdmVTaGFwZXJOb2RlKG5hdGl2ZUNvbnRleHQsIF9vYmplY3RTcHJlYWQkYihfb2JqZWN0U3ByZWFkJGIoe30sIFNJTkdMRV9DSEFOTkVMX1dBVkVfU0hBUEVSX09QVElPTlMpLCB7fSwge1xuICAgICAgICAgIGN1cnZlOiBEQ19DVVJWRVxuICAgICAgICB9KSk7XG4gICAgICAgIHZhciByaWdodElucHV0Rm9yTGVmdE91dHB1dEdhaW5Ob2RlID0gY3JlYXRlTmF0aXZlR2Fpbk5vZGUobmF0aXZlQ29udGV4dCwgX29iamVjdFNwcmVhZCRiKF9vYmplY3RTcHJlYWQkYih7fSwgU0lOR0xFX0NIQU5ORUxfT1BUSU9OUyksIHt9LCB7XG4gICAgICAgICAgZ2FpbjogMFxuICAgICAgICB9KSk7XG4gICAgICAgIC8vIEJ1ZyAjMTE5OiBTYWZhcmkgZG9lcyBub3QgZnVsbHkgc3VwcG9ydCB0aGUgV2F2ZVNoYXBlck5vZGUuXG4gICAgICAgIHZhciByaWdodElucHV0Rm9yTGVmdE91dHB1dFdhdmVTaGFwZXJOb2RlID0gY3JlYXRlTmF0aXZlV2F2ZVNoYXBlck5vZGUobmF0aXZlQ29udGV4dCwgX29iamVjdFNwcmVhZCRiKF9vYmplY3RTcHJlYWQkYih7fSwgU0lOR0xFX0NIQU5ORUxfV0FWRV9TSEFQRVJfT1BUSU9OUyksIHt9LCB7XG4gICAgICAgICAgY3VydmU6IHJpZ2h0SW5wdXRGb3JMZWZ0T3V0cHV0V2F2ZVNoYXBlckN1cnZlXG4gICAgICAgIH0pKTtcbiAgICAgICAgdmFyIHJpZ2h0SW5wdXRGb3JSaWdodE91dHB1dEdhaW5Ob2RlID0gY3JlYXRlTmF0aXZlR2Fpbk5vZGUobmF0aXZlQ29udGV4dCwgX29iamVjdFNwcmVhZCRiKF9vYmplY3RTcHJlYWQkYih7fSwgU0lOR0xFX0NIQU5ORUxfT1BUSU9OUyksIHt9LCB7XG4gICAgICAgICAgZ2FpbjogMFxuICAgICAgICB9KSk7XG4gICAgICAgIC8vIEJ1ZyAjMTE5OiBTYWZhcmkgZG9lcyBub3QgZnVsbHkgc3VwcG9ydCB0aGUgV2F2ZVNoYXBlck5vZGUuXG4gICAgICAgIHZhciByaWdodElucHV0Rm9yUmlnaHRPdXRwdXRXYXZlU2hhcGVyTm9kZSA9IGNyZWF0ZU5hdGl2ZVdhdmVTaGFwZXJOb2RlKG5hdGl2ZUNvbnRleHQsIF9vYmplY3RTcHJlYWQkYihfb2JqZWN0U3ByZWFkJGIoe30sIFNJTkdMRV9DSEFOTkVMX1dBVkVfU0hBUEVSX09QVElPTlMpLCB7fSwge1xuICAgICAgICAgIGN1cnZlOiByaWdodElucHV0Rm9yUmlnaHRPdXRwdXRXYXZlU2hhcGVyQ3VydmVcbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGNvbm5lY3RHcmFwaDogZnVuY3Rpb24gY29ubmVjdEdyYXBoKCkge1xuICAgICAgICAgICAgaW5wdXRHYWluTm9kZS5jb25uZWN0KGNoYW5uZWxTcGxpdHRlck5vZGUpO1xuICAgICAgICAgICAgaW5wdXRHYWluTm9kZS5jb25uZWN0KHBhbldhdmVTaGFwZXJOb2RlLmlucHV0cyA9PT0gdW5kZWZpbmVkID8gcGFuV2F2ZVNoYXBlck5vZGUgOiBwYW5XYXZlU2hhcGVyTm9kZS5pbnB1dHNbMF0pO1xuICAgICAgICAgICAgY2hhbm5lbFNwbGl0dGVyTm9kZS5jb25uZWN0KGxlZnRJbnB1dEZvckxlZnRPdXRwdXRHYWluTm9kZSwgMCk7XG4gICAgICAgICAgICBjaGFubmVsU3BsaXR0ZXJOb2RlLmNvbm5lY3QobGVmdElucHV0Rm9yUmlnaHRPdXRwdXRHYWluTm9kZSwgMCk7XG4gICAgICAgICAgICBjaGFubmVsU3BsaXR0ZXJOb2RlLmNvbm5lY3QocmlnaHRJbnB1dEZvckxlZnRPdXRwdXRHYWluTm9kZSwgMSk7XG4gICAgICAgICAgICBjaGFubmVsU3BsaXR0ZXJOb2RlLmNvbm5lY3QocmlnaHRJbnB1dEZvclJpZ2h0T3V0cHV0R2Fpbk5vZGUsIDEpO1xuICAgICAgICAgICAgcGFuV2F2ZVNoYXBlck5vZGUuY29ubmVjdChwYW5HYWluTm9kZSk7XG4gICAgICAgICAgICBwYW5HYWluTm9kZS5jb25uZWN0KGxlZnRJbnB1dEZvckxlZnRPdXRwdXRXYXZlU2hhcGVyTm9kZS5pbnB1dHMgPT09IHVuZGVmaW5lZCA/IGxlZnRJbnB1dEZvckxlZnRPdXRwdXRXYXZlU2hhcGVyTm9kZSA6IGxlZnRJbnB1dEZvckxlZnRPdXRwdXRXYXZlU2hhcGVyTm9kZS5pbnB1dHNbMF0pO1xuICAgICAgICAgICAgcGFuR2Fpbk5vZGUuY29ubmVjdChsZWZ0SW5wdXRGb3JSaWdodE91dHB1dFdhdmVTaGFwZXJOb2RlLmlucHV0cyA9PT0gdW5kZWZpbmVkID8gbGVmdElucHV0Rm9yUmlnaHRPdXRwdXRXYXZlU2hhcGVyTm9kZSA6IGxlZnRJbnB1dEZvclJpZ2h0T3V0cHV0V2F2ZVNoYXBlck5vZGUuaW5wdXRzWzBdKTtcbiAgICAgICAgICAgIHBhbkdhaW5Ob2RlLmNvbm5lY3QocmlnaHRJbnB1dEZvckxlZnRPdXRwdXRXYXZlU2hhcGVyTm9kZS5pbnB1dHMgPT09IHVuZGVmaW5lZCA/IHJpZ2h0SW5wdXRGb3JMZWZ0T3V0cHV0V2F2ZVNoYXBlck5vZGUgOiByaWdodElucHV0Rm9yTGVmdE91dHB1dFdhdmVTaGFwZXJOb2RlLmlucHV0c1swXSk7XG4gICAgICAgICAgICBwYW5HYWluTm9kZS5jb25uZWN0KHJpZ2h0SW5wdXRGb3JSaWdodE91dHB1dFdhdmVTaGFwZXJOb2RlLmlucHV0cyA9PT0gdW5kZWZpbmVkID8gcmlnaHRJbnB1dEZvclJpZ2h0T3V0cHV0V2F2ZVNoYXBlck5vZGUgOiByaWdodElucHV0Rm9yUmlnaHRPdXRwdXRXYXZlU2hhcGVyTm9kZS5pbnB1dHNbMF0pO1xuICAgICAgICAgICAgbGVmdElucHV0Rm9yTGVmdE91dHB1dFdhdmVTaGFwZXJOb2RlLmNvbm5lY3QobGVmdElucHV0Rm9yTGVmdE91dHB1dEdhaW5Ob2RlLmdhaW4pO1xuICAgICAgICAgICAgbGVmdElucHV0Rm9yUmlnaHRPdXRwdXRXYXZlU2hhcGVyTm9kZS5jb25uZWN0KGxlZnRJbnB1dEZvclJpZ2h0T3V0cHV0R2Fpbk5vZGUuZ2Fpbik7XG4gICAgICAgICAgICByaWdodElucHV0Rm9yTGVmdE91dHB1dFdhdmVTaGFwZXJOb2RlLmNvbm5lY3QocmlnaHRJbnB1dEZvckxlZnRPdXRwdXRHYWluTm9kZS5nYWluKTtcbiAgICAgICAgICAgIHJpZ2h0SW5wdXRGb3JSaWdodE91dHB1dFdhdmVTaGFwZXJOb2RlLmNvbm5lY3QocmlnaHRJbnB1dEZvclJpZ2h0T3V0cHV0R2Fpbk5vZGUuZ2Fpbik7XG4gICAgICAgICAgICBsZWZ0SW5wdXRGb3JMZWZ0T3V0cHV0R2Fpbk5vZGUuY29ubmVjdChjaGFubmVsTWVyZ2VyTm9kZSwgMCwgMCk7XG4gICAgICAgICAgICByaWdodElucHV0Rm9yTGVmdE91dHB1dEdhaW5Ob2RlLmNvbm5lY3QoY2hhbm5lbE1lcmdlck5vZGUsIDAsIDApO1xuICAgICAgICAgICAgbGVmdElucHV0Rm9yUmlnaHRPdXRwdXRHYWluTm9kZS5jb25uZWN0KGNoYW5uZWxNZXJnZXJOb2RlLCAwLCAxKTtcbiAgICAgICAgICAgIHJpZ2h0SW5wdXRGb3JSaWdodE91dHB1dEdhaW5Ob2RlLmNvbm5lY3QoY2hhbm5lbE1lcmdlck5vZGUsIDAsIDEpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZGlzY29ubmVjdEdyYXBoOiBmdW5jdGlvbiBkaXNjb25uZWN0R3JhcGgoKSB7XG4gICAgICAgICAgICBpbnB1dEdhaW5Ob2RlLmRpc2Nvbm5lY3QoY2hhbm5lbFNwbGl0dGVyTm9kZSk7XG4gICAgICAgICAgICBpbnB1dEdhaW5Ob2RlLmRpc2Nvbm5lY3QocGFuV2F2ZVNoYXBlck5vZGUuaW5wdXRzID09PSB1bmRlZmluZWQgPyBwYW5XYXZlU2hhcGVyTm9kZSA6IHBhbldhdmVTaGFwZXJOb2RlLmlucHV0c1swXSk7XG4gICAgICAgICAgICBjaGFubmVsU3BsaXR0ZXJOb2RlLmRpc2Nvbm5lY3QobGVmdElucHV0Rm9yTGVmdE91dHB1dEdhaW5Ob2RlLCAwKTtcbiAgICAgICAgICAgIGNoYW5uZWxTcGxpdHRlck5vZGUuZGlzY29ubmVjdChsZWZ0SW5wdXRGb3JSaWdodE91dHB1dEdhaW5Ob2RlLCAwKTtcbiAgICAgICAgICAgIGNoYW5uZWxTcGxpdHRlck5vZGUuZGlzY29ubmVjdChyaWdodElucHV0Rm9yTGVmdE91dHB1dEdhaW5Ob2RlLCAxKTtcbiAgICAgICAgICAgIGNoYW5uZWxTcGxpdHRlck5vZGUuZGlzY29ubmVjdChyaWdodElucHV0Rm9yUmlnaHRPdXRwdXRHYWluTm9kZSwgMSk7XG4gICAgICAgICAgICBwYW5XYXZlU2hhcGVyTm9kZS5kaXNjb25uZWN0KHBhbkdhaW5Ob2RlKTtcbiAgICAgICAgICAgIHBhbkdhaW5Ob2RlLmRpc2Nvbm5lY3QobGVmdElucHV0Rm9yTGVmdE91dHB1dFdhdmVTaGFwZXJOb2RlLmlucHV0cyA9PT0gdW5kZWZpbmVkID8gbGVmdElucHV0Rm9yTGVmdE91dHB1dFdhdmVTaGFwZXJOb2RlIDogbGVmdElucHV0Rm9yTGVmdE91dHB1dFdhdmVTaGFwZXJOb2RlLmlucHV0c1swXSk7XG4gICAgICAgICAgICBwYW5HYWluTm9kZS5kaXNjb25uZWN0KGxlZnRJbnB1dEZvclJpZ2h0T3V0cHV0V2F2ZVNoYXBlck5vZGUuaW5wdXRzID09PSB1bmRlZmluZWQgPyBsZWZ0SW5wdXRGb3JSaWdodE91dHB1dFdhdmVTaGFwZXJOb2RlIDogbGVmdElucHV0Rm9yUmlnaHRPdXRwdXRXYXZlU2hhcGVyTm9kZS5pbnB1dHNbMF0pO1xuICAgICAgICAgICAgcGFuR2Fpbk5vZGUuZGlzY29ubmVjdChyaWdodElucHV0Rm9yTGVmdE91dHB1dFdhdmVTaGFwZXJOb2RlLmlucHV0cyA9PT0gdW5kZWZpbmVkID8gcmlnaHRJbnB1dEZvckxlZnRPdXRwdXRXYXZlU2hhcGVyTm9kZSA6IHJpZ2h0SW5wdXRGb3JMZWZ0T3V0cHV0V2F2ZVNoYXBlck5vZGUuaW5wdXRzWzBdKTtcbiAgICAgICAgICAgIHBhbkdhaW5Ob2RlLmRpc2Nvbm5lY3QocmlnaHRJbnB1dEZvclJpZ2h0T3V0cHV0V2F2ZVNoYXBlck5vZGUuaW5wdXRzID09PSB1bmRlZmluZWQgPyByaWdodElucHV0Rm9yUmlnaHRPdXRwdXRXYXZlU2hhcGVyTm9kZSA6IHJpZ2h0SW5wdXRGb3JSaWdodE91dHB1dFdhdmVTaGFwZXJOb2RlLmlucHV0c1swXSk7XG4gICAgICAgICAgICBsZWZ0SW5wdXRGb3JMZWZ0T3V0cHV0V2F2ZVNoYXBlck5vZGUuZGlzY29ubmVjdChsZWZ0SW5wdXRGb3JMZWZ0T3V0cHV0R2Fpbk5vZGUuZ2Fpbik7XG4gICAgICAgICAgICBsZWZ0SW5wdXRGb3JSaWdodE91dHB1dFdhdmVTaGFwZXJOb2RlLmRpc2Nvbm5lY3QobGVmdElucHV0Rm9yUmlnaHRPdXRwdXRHYWluTm9kZS5nYWluKTtcbiAgICAgICAgICAgIHJpZ2h0SW5wdXRGb3JMZWZ0T3V0cHV0V2F2ZVNoYXBlck5vZGUuZGlzY29ubmVjdChyaWdodElucHV0Rm9yTGVmdE91dHB1dEdhaW5Ob2RlLmdhaW4pO1xuICAgICAgICAgICAgcmlnaHRJbnB1dEZvclJpZ2h0T3V0cHV0V2F2ZVNoYXBlck5vZGUuZGlzY29ubmVjdChyaWdodElucHV0Rm9yUmlnaHRPdXRwdXRHYWluTm9kZS5nYWluKTtcbiAgICAgICAgICAgIGxlZnRJbnB1dEZvckxlZnRPdXRwdXRHYWluTm9kZS5kaXNjb25uZWN0KGNoYW5uZWxNZXJnZXJOb2RlLCAwLCAwKTtcbiAgICAgICAgICAgIHJpZ2h0SW5wdXRGb3JMZWZ0T3V0cHV0R2Fpbk5vZGUuZGlzY29ubmVjdChjaGFubmVsTWVyZ2VyTm9kZSwgMCwgMCk7XG4gICAgICAgICAgICBsZWZ0SW5wdXRGb3JSaWdodE91dHB1dEdhaW5Ob2RlLmRpc2Nvbm5lY3QoY2hhbm5lbE1lcmdlck5vZGUsIDAsIDEpO1xuICAgICAgICAgICAgcmlnaHRJbnB1dEZvclJpZ2h0T3V0cHV0R2Fpbk5vZGUuZGlzY29ubmVjdChjaGFubmVsTWVyZ2VyTm9kZSwgMCwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfTtcbiAgICAgIHZhciBidWlsZEludGVybmFsR3JhcGggPSBmdW5jdGlvbiBidWlsZEludGVybmFsR3JhcGgobmF0aXZlQ29udGV4dCwgY2hhbm5lbENvdW50LCBpbnB1dEdhaW5Ob2RlLCBwYW5HYWluTm9kZSwgY2hhbm5lbE1lcmdlck5vZGUpIHtcbiAgICAgICAgaWYgKGNoYW5uZWxDb3VudCA9PT0gMSkge1xuICAgICAgICAgIHJldHVybiBidWlsZEludGVybmFsR3JhcGhGb3JNb25vKG5hdGl2ZUNvbnRleHQsIGlucHV0R2Fpbk5vZGUsIHBhbkdhaW5Ob2RlLCBjaGFubmVsTWVyZ2VyTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYW5uZWxDb3VudCA9PT0gMikge1xuICAgICAgICAgIHJldHVybiBidWlsZEludGVybmFsR3JhcGhGb3JTdGVyZW8obmF0aXZlQ29udGV4dCwgaW5wdXRHYWluTm9kZSwgcGFuR2Fpbk5vZGUsIGNoYW5uZWxNZXJnZXJOb2RlKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBjcmVhdGVOb3RTdXBwb3J0ZWRFcnJvcigpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAobmF0aXZlQ29udGV4dCwgX3JlZikge1xuICAgICAgICB2YXIgY2hhbm5lbENvdW50ID0gX3JlZi5jaGFubmVsQ291bnQsXG4gICAgICAgICAgY2hhbm5lbENvdW50TW9kZSA9IF9yZWYuY2hhbm5lbENvdW50TW9kZSxcbiAgICAgICAgICBwYW4gPSBfcmVmLnBhbixcbiAgICAgICAgICBhdWRpb05vZGVPcHRpb25zID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIF9leGNsdWRlZCQxKTtcbiAgICAgICAgaWYgKGNoYW5uZWxDb3VudE1vZGUgPT09ICdtYXgnKSB7XG4gICAgICAgICAgdGhyb3cgY3JlYXRlTm90U3VwcG9ydGVkRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2hhbm5lbE1lcmdlck5vZGUgPSBjcmVhdGVOYXRpdmVDaGFubmVsTWVyZ2VyTm9kZShuYXRpdmVDb250ZXh0LCBfb2JqZWN0U3ByZWFkJGIoX29iamVjdFNwcmVhZCRiKHt9LCBhdWRpb05vZGVPcHRpb25zKSwge30sIHtcbiAgICAgICAgICBjaGFubmVsQ291bnQ6IDEsXG4gICAgICAgICAgY2hhbm5lbENvdW50TW9kZTogY2hhbm5lbENvdW50TW9kZSxcbiAgICAgICAgICBudW1iZXJPZklucHV0czogMlxuICAgICAgICB9KSk7XG4gICAgICAgIHZhciBpbnB1dEdhaW5Ob2RlID0gY3JlYXRlTmF0aXZlR2Fpbk5vZGUobmF0aXZlQ29udGV4dCwgX29iamVjdFNwcmVhZCRiKF9vYmplY3RTcHJlYWQkYih7fSwgYXVkaW9Ob2RlT3B0aW9ucyksIHt9LCB7XG4gICAgICAgICAgY2hhbm5lbENvdW50OiBjaGFubmVsQ291bnQsXG4gICAgICAgICAgY2hhbm5lbENvdW50TW9kZTogY2hhbm5lbENvdW50TW9kZSxcbiAgICAgICAgICBnYWluOiAxXG4gICAgICAgIH0pKTtcbiAgICAgICAgdmFyIHBhbkdhaW5Ob2RlID0gY3JlYXRlTmF0aXZlR2Fpbk5vZGUobmF0aXZlQ29udGV4dCwge1xuICAgICAgICAgIGNoYW5uZWxDb3VudDogMSxcbiAgICAgICAgICBjaGFubmVsQ291bnRNb2RlOiAnZXhwbGljaXQnLFxuICAgICAgICAgIGNoYW5uZWxJbnRlcnByZXRhdGlvbjogJ2Rpc2NyZXRlJyxcbiAgICAgICAgICBnYWluOiBwYW5cbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBfYnVpbGRJbnRlcm5hbEdyYXBoID0gYnVpbGRJbnRlcm5hbEdyYXBoKG5hdGl2ZUNvbnRleHQsIGNoYW5uZWxDb3VudCwgaW5wdXRHYWluTm9kZSwgcGFuR2Fpbk5vZGUsIGNoYW5uZWxNZXJnZXJOb2RlKSxcbiAgICAgICAgICBjb25uZWN0R3JhcGggPSBfYnVpbGRJbnRlcm5hbEdyYXBoLmNvbm5lY3RHcmFwaCxcbiAgICAgICAgICBkaXNjb25uZWN0R3JhcGggPSBfYnVpbGRJbnRlcm5hbEdyYXBoLmRpc2Nvbm5lY3RHcmFwaDtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHBhbkdhaW5Ob2RlLmdhaW4sICdkZWZhdWx0VmFsdWUnLCB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocGFuR2Fpbk5vZGUuZ2FpbiwgJ21heFZhbHVlJywge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHBhbkdhaW5Ob2RlLmdhaW4sICdtaW5WYWx1ZScsIHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgbmF0aXZlU3RlcmVvUGFubmVyTm9kZUZha2VyRmFjdG9yeSA9IHtcbiAgICAgICAgICBnZXQgYnVmZmVyU2l6ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBnZXQgY2hhbm5lbENvdW50KCkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0R2Fpbk5vZGUuY2hhbm5lbENvdW50O1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc2V0IGNoYW5uZWxDb3VudCh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKGlucHV0R2Fpbk5vZGUuY2hhbm5lbENvdW50ICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgICBpZiAoaXNDb25uZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICBkaXNjb25uZWN0R3JhcGgoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2YXIgX2J1aWxkSW50ZXJuYWxHcmFwaDIgPSBidWlsZEludGVybmFsR3JhcGgobmF0aXZlQ29udGV4dCwgdmFsdWUsIGlucHV0R2Fpbk5vZGUsIHBhbkdhaW5Ob2RlLCBjaGFubmVsTWVyZ2VyTm9kZSk7XG4gICAgICAgICAgICAgIGNvbm5lY3RHcmFwaCA9IF9idWlsZEludGVybmFsR3JhcGgyLmNvbm5lY3RHcmFwaDtcbiAgICAgICAgICAgICAgZGlzY29ubmVjdEdyYXBoID0gX2J1aWxkSW50ZXJuYWxHcmFwaDIuZGlzY29ubmVjdEdyYXBoO1xuICAgICAgICAgICAgICBpZiAoaXNDb25uZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICBjb25uZWN0R3JhcGgoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5wdXRHYWluTm9kZS5jaGFubmVsQ291bnQgPSB2YWx1ZTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGdldCBjaGFubmVsQ291bnRNb2RlKCkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0R2Fpbk5vZGUuY2hhbm5lbENvdW50TW9kZTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNldCBjaGFubmVsQ291bnRNb2RlKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09ICdjbGFtcGVkLW1heCcgfHwgdmFsdWUgPT09ICdtYXgnKSB7XG4gICAgICAgICAgICAgIHRocm93IGNyZWF0ZU5vdFN1cHBvcnRlZEVycm9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbnB1dEdhaW5Ob2RlLmNoYW5uZWxDb3VudE1vZGUgPSB2YWx1ZTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGdldCBjaGFubmVsSW50ZXJwcmV0YXRpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXRHYWluTm9kZS5jaGFubmVsSW50ZXJwcmV0YXRpb247XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzZXQgY2hhbm5lbEludGVycHJldGF0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICBpbnB1dEdhaW5Ob2RlLmNoYW5uZWxJbnRlcnByZXRhdGlvbiA9IHZhbHVlO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZ2V0IGNvbnRleHQoKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXRHYWluTm9kZS5jb250ZXh0O1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZ2V0IGlucHV0cygpIHtcbiAgICAgICAgICAgIHJldHVybiBbaW5wdXRHYWluTm9kZV07XG4gICAgICAgICAgfSxcbiAgICAgICAgICBnZXQgbnVtYmVyT2ZJbnB1dHMoKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXRHYWluTm9kZS5udW1iZXJPZklucHV0cztcbiAgICAgICAgICB9LFxuICAgICAgICAgIGdldCBudW1iZXJPZk91dHB1dHMoKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXRHYWluTm9kZS5udW1iZXJPZk91dHB1dHM7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBnZXQgcGFuKCkge1xuICAgICAgICAgICAgcmV0dXJuIHBhbkdhaW5Ob2RlLmdhaW47XG4gICAgICAgICAgfSxcbiAgICAgICAgICBhZGRFdmVudExpc3RlbmVyOiBmdW5jdGlvbiBhZGRFdmVudExpc3RlbmVyKCkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0R2Fpbk5vZGUuYWRkRXZlbnRMaXN0ZW5lcihhcmd1bWVudHMubGVuZ3RoIDw9IDAgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMF0sIGFyZ3VtZW50cy5sZW5ndGggPD0gMSA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzLmxlbmd0aCA8PSAyID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzJdKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGRpc3BhdGNoRXZlbnQ6IGZ1bmN0aW9uIGRpc3BhdGNoRXZlbnQoKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXRHYWluTm9kZS5kaXNwYXRjaEV2ZW50KGFyZ3VtZW50cy5sZW5ndGggPD0gMCA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1swXSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICByZW1vdmVFdmVudExpc3RlbmVyOiBmdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVyKCkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0R2Fpbk5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihhcmd1bWVudHMubGVuZ3RoIDw9IDAgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMF0sIGFyZ3VtZW50cy5sZW5ndGggPD0gMSA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzLmxlbmd0aCA8PSAyID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzJdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHZhciBpc0Nvbm5lY3RlZCA9IGZhbHNlO1xuICAgICAgICB2YXIgd2hlbkNvbm5lY3RlZCA9IGZ1bmN0aW9uIHdoZW5Db25uZWN0ZWQoKSB7XG4gICAgICAgICAgY29ubmVjdEdyYXBoKCk7XG4gICAgICAgICAgaXNDb25uZWN0ZWQgPSB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgd2hlbkRpc2Nvbm5lY3RlZCA9IGZ1bmN0aW9uIHdoZW5EaXNjb25uZWN0ZWQoKSB7XG4gICAgICAgICAgZGlzY29ubmVjdEdyYXBoKCk7XG4gICAgICAgICAgaXNDb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG1vbml0b3JDb25uZWN0aW9ucyhpbnRlcmNlcHRDb25uZWN0aW9ucyhuYXRpdmVTdGVyZW9QYW5uZXJOb2RlRmFrZXJGYWN0b3J5LCBjaGFubmVsTWVyZ2VyTm9kZSksIHdoZW5Db25uZWN0ZWQsIHdoZW5EaXNjb25uZWN0ZWQpO1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZU5hdGl2ZVdhdmVTaGFwZXJOb2RlRmFjdG9yeSA9IGZ1bmN0aW9uIGNyZWF0ZU5hdGl2ZVdhdmVTaGFwZXJOb2RlRmFjdG9yeShjcmVhdGVDb25uZWN0ZWROYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGUsIGNyZWF0ZUludmFsaWRTdGF0ZUVycm9yLCBjcmVhdGVOYXRpdmVXYXZlU2hhcGVyTm9kZUZha2VyLCBpc0RDQ3VydmUsIG1vbml0b3JDb25uZWN0aW9ucywgbmF0aXZlQXVkaW9Db250ZXh0Q29uc3RydWN0b3IsIG92ZXJ3cml0ZUFjY2Vzc29ycykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChuYXRpdmVDb250ZXh0LCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBuYXRpdmVXYXZlU2hhcGVyTm9kZSA9IG5hdGl2ZUNvbnRleHQuY3JlYXRlV2F2ZVNoYXBlcigpO1xuICAgICAgICAvKlxuICAgICAgICAgKiBCdWcgIzExOTogU2FmYXJpIGRvZXMgbm90IGNvcnJlY3RseSBtYXAgdGhlIHZhbHVlcy5cbiAgICAgICAgICogQHRvZG8gVW5mb3J0dW5hdGVseSB0aGVyZSBpcyBubyB3YXkgdG8gdGVzdCBmb3IgdGhpcyBiZWhhdmlvciBpbiBhIHN5bmNocm9ub3VzIGZhc2hpb24gd2hpY2ggaXMgd2h5IHRlc3RpbmcgZm9yIHRoZSBleGlzdGVuY2Ugb2ZcbiAgICAgICAgICogdGhlIHdlYmtpdEF1ZGlvQ29udGV4dCBpcyB1c2VkIGFzIGEgd29ya2Fyb3VuZCBoZXJlLiBUZXN0aW5nIGZvciB0aGUgYXV0b21hdGlvblJhdGUgcHJvcGVydHkgaXMgbmVjZXNzYXJ5IGJlY2F1c2UgdGhpcyB3b3JrYXJvdW5kXG4gICAgICAgICAqIGlzbid0IG5lY2Vzc2FyeSBhbnltb3JlIHNpbmNlIHYxNC4wLjIgb2YgU2FmYXJpLlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKG5hdGl2ZUF1ZGlvQ29udGV4dENvbnN0cnVjdG9yICE9PSBudWxsICYmIG5hdGl2ZUF1ZGlvQ29udGV4dENvbnN0cnVjdG9yLm5hbWUgPT09ICd3ZWJraXRBdWRpb0NvbnRleHQnICYmIG5hdGl2ZUNvbnRleHQuY3JlYXRlR2FpbigpLmdhaW4uYXV0b21hdGlvblJhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiBjcmVhdGVOYXRpdmVXYXZlU2hhcGVyTm9kZUZha2VyKG5hdGl2ZUNvbnRleHQsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGFzc2lnbk5hdGl2ZUF1ZGlvTm9kZU9wdGlvbnMobmF0aXZlV2F2ZVNoYXBlck5vZGUsIG9wdGlvbnMpO1xuICAgICAgICB2YXIgY3VydmUgPSBvcHRpb25zLmN1cnZlID09PSBudWxsIHx8IG9wdGlvbnMuY3VydmUgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkgPyBvcHRpb25zLmN1cnZlIDogbmV3IEZsb2F0MzJBcnJheShvcHRpb25zLmN1cnZlKTtcbiAgICAgICAgLy8gQnVnICMxMDQ6IENocm9tZSBhbmQgRWRnZSB3aWxsIHRocm93IGFuIEludmFsaWRBY2Nlc3NFcnJvciB3aGVuIHRoZSBjdXJ2ZSBoYXMgbGVzcyB0aGFuIHR3byBzYW1wbGVzLlxuICAgICAgICBpZiAoY3VydmUgIT09IG51bGwgJiYgY3VydmUubGVuZ3RoIDwgMikge1xuICAgICAgICAgIHRocm93IGNyZWF0ZUludmFsaWRTdGF0ZUVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gT25seSB2YWx1ZXMgb2YgdHlwZSBGbG9hdDMyQXJyYXkgY2FuIGJlIGFzc2lnbmVkIHRvIHRoZSBjdXJ2ZSBwcm9wZXJ0eS5cbiAgICAgICAgYXNzaWduTmF0aXZlQXVkaW9Ob2RlT3B0aW9uKG5hdGl2ZVdhdmVTaGFwZXJOb2RlLCB7XG4gICAgICAgICAgY3VydmU6IGN1cnZlXG4gICAgICAgIH0sICdjdXJ2ZScpO1xuICAgICAgICBhc3NpZ25OYXRpdmVBdWRpb05vZGVPcHRpb24obmF0aXZlV2F2ZVNoYXBlck5vZGUsIG9wdGlvbnMsICdvdmVyc2FtcGxlJyk7XG4gICAgICAgIHZhciBkaXNjb25uZWN0TmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2RlID0gbnVsbDtcbiAgICAgICAgdmFyIGlzQ29ubmVjdGVkID0gZmFsc2U7XG4gICAgICAgIG92ZXJ3cml0ZUFjY2Vzc29ycyhuYXRpdmVXYXZlU2hhcGVyTm9kZSwgJ2N1cnZlJywgZnVuY3Rpb24gKGdldCkge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0LmNhbGwobmF0aXZlV2F2ZVNoYXBlck5vZGUpO1xuICAgICAgICAgIH07XG4gICAgICAgIH0sIGZ1bmN0aW9uIChzZXQpIHtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBzZXQuY2FsbChuYXRpdmVXYXZlU2hhcGVyTm9kZSwgdmFsdWUpO1xuICAgICAgICAgICAgaWYgKGlzQ29ubmVjdGVkKSB7XG4gICAgICAgICAgICAgIGlmIChpc0RDQ3VydmUodmFsdWUpICYmIGRpc2Nvbm5lY3ROYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBkaXNjb25uZWN0TmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2RlID0gY3JlYXRlQ29ubmVjdGVkTmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2RlKG5hdGl2ZUNvbnRleHQsIG5hdGl2ZVdhdmVTaGFwZXJOb2RlKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICghaXNEQ0N1cnZlKHZhbHVlKSAmJiBkaXNjb25uZWN0TmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2RlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZGlzY29ubmVjdE5hdGl2ZUF1ZGlvQnVmZmVyU291cmNlTm9kZSgpO1xuICAgICAgICAgICAgICAgIGRpc2Nvbm5lY3ROYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGUgPSBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciB3aGVuQ29ubmVjdGVkID0gZnVuY3Rpb24gd2hlbkNvbm5lY3RlZCgpIHtcbiAgICAgICAgICBpc0Nvbm5lY3RlZCA9IHRydWU7XG4gICAgICAgICAgaWYgKGlzRENDdXJ2ZShuYXRpdmVXYXZlU2hhcGVyTm9kZS5jdXJ2ZSkpIHtcbiAgICAgICAgICAgIGRpc2Nvbm5lY3ROYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGUgPSBjcmVhdGVDb25uZWN0ZWROYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGUobmF0aXZlQ29udGV4dCwgbmF0aXZlV2F2ZVNoYXBlck5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHdoZW5EaXNjb25uZWN0ZWQgPSBmdW5jdGlvbiB3aGVuRGlzY29ubmVjdGVkKCkge1xuICAgICAgICAgIGlzQ29ubmVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgaWYgKGRpc2Nvbm5lY3ROYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGRpc2Nvbm5lY3ROYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGUoKTtcbiAgICAgICAgICAgIGRpc2Nvbm5lY3ROYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGUgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG1vbml0b3JDb25uZWN0aW9ucyhuYXRpdmVXYXZlU2hhcGVyTm9kZSwgd2hlbkNvbm5lY3RlZCwgd2hlbkRpc2Nvbm5lY3RlZCk7XG4gICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgX2V4Y2x1ZGVkID0gW1wiY3VydmVcIiwgXCJvdmVyc2FtcGxlXCJdO1xuICAgIGZ1bmN0aW9uIG93bktleXMkYShlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XG4gICAgZnVuY3Rpb24gX29iamVjdFNwcmVhZCRhKGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMkYShPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMkYShPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxuICAgIHZhciBjcmVhdGVOYXRpdmVXYXZlU2hhcGVyTm9kZUZha2VyRmFjdG9yeSA9IGZ1bmN0aW9uIGNyZWF0ZU5hdGl2ZVdhdmVTaGFwZXJOb2RlRmFrZXJGYWN0b3J5KGNyZWF0ZUNvbm5lY3RlZE5hdGl2ZUF1ZGlvQnVmZmVyU291cmNlTm9kZSwgY3JlYXRlSW52YWxpZFN0YXRlRXJyb3IsIGNyZWF0ZU5hdGl2ZUdhaW5Ob2RlLCBpc0RDQ3VydmUsIG1vbml0b3JDb25uZWN0aW9ucykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChuYXRpdmVDb250ZXh0LCBfcmVmKSB7XG4gICAgICAgIHZhciBjdXJ2ZSA9IF9yZWYuY3VydmUsXG4gICAgICAgICAgb3ZlcnNhbXBsZSA9IF9yZWYub3ZlcnNhbXBsZSxcbiAgICAgICAgICBhdWRpb05vZGVPcHRpb25zID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIF9leGNsdWRlZCk7XG4gICAgICAgIHZhciBuZWdhdGl2ZVdhdmVTaGFwZXJOb2RlID0gbmF0aXZlQ29udGV4dC5jcmVhdGVXYXZlU2hhcGVyKCk7XG4gICAgICAgIHZhciBwb3NpdGl2ZVdhdmVTaGFwZXJOb2RlID0gbmF0aXZlQ29udGV4dC5jcmVhdGVXYXZlU2hhcGVyKCk7XG4gICAgICAgIGFzc2lnbk5hdGl2ZUF1ZGlvTm9kZU9wdGlvbnMobmVnYXRpdmVXYXZlU2hhcGVyTm9kZSwgYXVkaW9Ob2RlT3B0aW9ucyk7XG4gICAgICAgIGFzc2lnbk5hdGl2ZUF1ZGlvTm9kZU9wdGlvbnMocG9zaXRpdmVXYXZlU2hhcGVyTm9kZSwgYXVkaW9Ob2RlT3B0aW9ucyk7XG4gICAgICAgIHZhciBpbnB1dEdhaW5Ob2RlID0gY3JlYXRlTmF0aXZlR2Fpbk5vZGUobmF0aXZlQ29udGV4dCwgX29iamVjdFNwcmVhZCRhKF9vYmplY3RTcHJlYWQkYSh7fSwgYXVkaW9Ob2RlT3B0aW9ucyksIHt9LCB7XG4gICAgICAgICAgZ2FpbjogMVxuICAgICAgICB9KSk7XG4gICAgICAgIHZhciBpbnZlcnRHYWluTm9kZSA9IGNyZWF0ZU5hdGl2ZUdhaW5Ob2RlKG5hdGl2ZUNvbnRleHQsIF9vYmplY3RTcHJlYWQkYShfb2JqZWN0U3ByZWFkJGEoe30sIGF1ZGlvTm9kZU9wdGlvbnMpLCB7fSwge1xuICAgICAgICAgIGdhaW46IC0xXG4gICAgICAgIH0pKTtcbiAgICAgICAgdmFyIG91dHB1dEdhaW5Ob2RlID0gY3JlYXRlTmF0aXZlR2Fpbk5vZGUobmF0aXZlQ29udGV4dCwgX29iamVjdFNwcmVhZCRhKF9vYmplY3RTcHJlYWQkYSh7fSwgYXVkaW9Ob2RlT3B0aW9ucyksIHt9LCB7XG4gICAgICAgICAgZ2FpbjogMVxuICAgICAgICB9KSk7XG4gICAgICAgIHZhciByZXZlcnRHYWluTm9kZSA9IGNyZWF0ZU5hdGl2ZUdhaW5Ob2RlKG5hdGl2ZUNvbnRleHQsIF9vYmplY3RTcHJlYWQkYShfb2JqZWN0U3ByZWFkJGEoe30sIGF1ZGlvTm9kZU9wdGlvbnMpLCB7fSwge1xuICAgICAgICAgIGdhaW46IC0xXG4gICAgICAgIH0pKTtcbiAgICAgICAgdmFyIGRpc2Nvbm5lY3ROYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGUgPSBudWxsO1xuICAgICAgICB2YXIgaXNDb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgdmFyIHVubW9kaWZpZWRDdXJ2ZSA9IG51bGw7XG4gICAgICAgIHZhciBuYXRpdmVXYXZlU2hhcGVyTm9kZUZha2VyID0ge1xuICAgICAgICAgIGdldCBidWZmZXJTaXplKCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGdldCBjaGFubmVsQ291bnQoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmVnYXRpdmVXYXZlU2hhcGVyTm9kZS5jaGFubmVsQ291bnQ7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzZXQgY2hhbm5lbENvdW50KHZhbHVlKSB7XG4gICAgICAgICAgICBpbnB1dEdhaW5Ob2RlLmNoYW5uZWxDb3VudCA9IHZhbHVlO1xuICAgICAgICAgICAgaW52ZXJ0R2Fpbk5vZGUuY2hhbm5lbENvdW50ID0gdmFsdWU7XG4gICAgICAgICAgICBuZWdhdGl2ZVdhdmVTaGFwZXJOb2RlLmNoYW5uZWxDb3VudCA9IHZhbHVlO1xuICAgICAgICAgICAgb3V0cHV0R2Fpbk5vZGUuY2hhbm5lbENvdW50ID0gdmFsdWU7XG4gICAgICAgICAgICBwb3NpdGl2ZVdhdmVTaGFwZXJOb2RlLmNoYW5uZWxDb3VudCA9IHZhbHVlO1xuICAgICAgICAgICAgcmV2ZXJ0R2Fpbk5vZGUuY2hhbm5lbENvdW50ID0gdmFsdWU7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBnZXQgY2hhbm5lbENvdW50TW9kZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZWdhdGl2ZVdhdmVTaGFwZXJOb2RlLmNoYW5uZWxDb3VudE1vZGU7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzZXQgY2hhbm5lbENvdW50TW9kZSh2YWx1ZSkge1xuICAgICAgICAgICAgaW5wdXRHYWluTm9kZS5jaGFubmVsQ291bnRNb2RlID0gdmFsdWU7XG4gICAgICAgICAgICBpbnZlcnRHYWluTm9kZS5jaGFubmVsQ291bnRNb2RlID0gdmFsdWU7XG4gICAgICAgICAgICBuZWdhdGl2ZVdhdmVTaGFwZXJOb2RlLmNoYW5uZWxDb3VudE1vZGUgPSB2YWx1ZTtcbiAgICAgICAgICAgIG91dHB1dEdhaW5Ob2RlLmNoYW5uZWxDb3VudE1vZGUgPSB2YWx1ZTtcbiAgICAgICAgICAgIHBvc2l0aXZlV2F2ZVNoYXBlck5vZGUuY2hhbm5lbENvdW50TW9kZSA9IHZhbHVlO1xuICAgICAgICAgICAgcmV2ZXJ0R2Fpbk5vZGUuY2hhbm5lbENvdW50TW9kZSA9IHZhbHVlO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZ2V0IGNoYW5uZWxJbnRlcnByZXRhdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBuZWdhdGl2ZVdhdmVTaGFwZXJOb2RlLmNoYW5uZWxJbnRlcnByZXRhdGlvbjtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNldCBjaGFubmVsSW50ZXJwcmV0YXRpb24odmFsdWUpIHtcbiAgICAgICAgICAgIGlucHV0R2Fpbk5vZGUuY2hhbm5lbEludGVycHJldGF0aW9uID0gdmFsdWU7XG4gICAgICAgICAgICBpbnZlcnRHYWluTm9kZS5jaGFubmVsSW50ZXJwcmV0YXRpb24gPSB2YWx1ZTtcbiAgICAgICAgICAgIG5lZ2F0aXZlV2F2ZVNoYXBlck5vZGUuY2hhbm5lbEludGVycHJldGF0aW9uID0gdmFsdWU7XG4gICAgICAgICAgICBvdXRwdXRHYWluTm9kZS5jaGFubmVsSW50ZXJwcmV0YXRpb24gPSB2YWx1ZTtcbiAgICAgICAgICAgIHBvc2l0aXZlV2F2ZVNoYXBlck5vZGUuY2hhbm5lbEludGVycHJldGF0aW9uID0gdmFsdWU7XG4gICAgICAgICAgICByZXZlcnRHYWluTm9kZS5jaGFubmVsSW50ZXJwcmV0YXRpb24gPSB2YWx1ZTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGdldCBjb250ZXh0KCkge1xuICAgICAgICAgICAgcmV0dXJuIG5lZ2F0aXZlV2F2ZVNoYXBlck5vZGUuY29udGV4dDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGdldCBjdXJ2ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB1bm1vZGlmaWVkQ3VydmU7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzZXQgY3VydmUodmFsdWUpIHtcbiAgICAgICAgICAgIC8vIEJ1ZyAjMTAyOiBTYWZhcmkgZG9lcyBub3QgdGhyb3cgYW4gSW52YWxpZFN0YXRlRXJyb3Igd2hlbiB0aGUgY3VydmUgaGFzIGxlc3MgdGhhbiB0d28gc2FtcGxlcy5cbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZS5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICAgIHRocm93IGNyZWF0ZUludmFsaWRTdGF0ZUVycm9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgbmVnYXRpdmVXYXZlU2hhcGVyTm9kZS5jdXJ2ZSA9IHZhbHVlO1xuICAgICAgICAgICAgICBwb3NpdGl2ZVdhdmVTaGFwZXJOb2RlLmN1cnZlID0gdmFsdWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgY3VydmVMZW5ndGggPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICAgIHZhciBuZWdhdGl2ZUN1cnZlID0gbmV3IEZsb2F0MzJBcnJheShjdXJ2ZUxlbmd0aCArIDIgLSBjdXJ2ZUxlbmd0aCAlIDIpO1xuICAgICAgICAgICAgICB2YXIgcG9zaXRpdmVDdXJ2ZSA9IG5ldyBGbG9hdDMyQXJyYXkoY3VydmVMZW5ndGggKyAyIC0gY3VydmVMZW5ndGggJSAyKTtcbiAgICAgICAgICAgICAgbmVnYXRpdmVDdXJ2ZVswXSA9IHZhbHVlWzBdO1xuICAgICAgICAgICAgICBwb3NpdGl2ZUN1cnZlWzBdID0gLXZhbHVlW2N1cnZlTGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgIHZhciBsZW5ndGggPSBNYXRoLmNlaWwoKGN1cnZlTGVuZ3RoICsgMSkgLyAyKTtcbiAgICAgICAgICAgICAgdmFyIGNlbnRlckluZGV4ID0gKGN1cnZlTGVuZ3RoICsgMSkgLyAyIC0gMTtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgIHZhciB0aGVvcmV0aWNJbmRleCA9IGkgLyBsZW5ndGggKiBjZW50ZXJJbmRleDtcbiAgICAgICAgICAgICAgICB2YXIgbG93ZXJJbmRleCA9IE1hdGguZmxvb3IodGhlb3JldGljSW5kZXgpO1xuICAgICAgICAgICAgICAgIHZhciB1cHBlckluZGV4ID0gTWF0aC5jZWlsKHRoZW9yZXRpY0luZGV4KTtcbiAgICAgICAgICAgICAgICBuZWdhdGl2ZUN1cnZlW2ldID0gbG93ZXJJbmRleCA9PT0gdXBwZXJJbmRleCA/IHZhbHVlW2xvd2VySW5kZXhdIDogKDEgLSAodGhlb3JldGljSW5kZXggLSBsb3dlckluZGV4KSkgKiB2YWx1ZVtsb3dlckluZGV4XSArICgxIC0gKHVwcGVySW5kZXggLSB0aGVvcmV0aWNJbmRleCkpICogdmFsdWVbdXBwZXJJbmRleF07XG4gICAgICAgICAgICAgICAgcG9zaXRpdmVDdXJ2ZVtpXSA9IGxvd2VySW5kZXggPT09IHVwcGVySW5kZXggPyAtdmFsdWVbY3VydmVMZW5ndGggLSAxIC0gbG93ZXJJbmRleF0gOiAtKCgxIC0gKHRoZW9yZXRpY0luZGV4IC0gbG93ZXJJbmRleCkpICogdmFsdWVbY3VydmVMZW5ndGggLSAxIC0gbG93ZXJJbmRleF0pIC0gKDEgLSAodXBwZXJJbmRleCAtIHRoZW9yZXRpY0luZGV4KSkgKiB2YWx1ZVtjdXJ2ZUxlbmd0aCAtIDEgLSB1cHBlckluZGV4XTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBuZWdhdGl2ZUN1cnZlW2xlbmd0aF0gPSBjdXJ2ZUxlbmd0aCAlIDIgPT09IDEgPyB2YWx1ZVtsZW5ndGggLSAxXSA6ICh2YWx1ZVtsZW5ndGggLSAyXSArIHZhbHVlW2xlbmd0aCAtIDFdKSAvIDI7XG4gICAgICAgICAgICAgIG5lZ2F0aXZlV2F2ZVNoYXBlck5vZGUuY3VydmUgPSBuZWdhdGl2ZUN1cnZlO1xuICAgICAgICAgICAgICBwb3NpdGl2ZVdhdmVTaGFwZXJOb2RlLmN1cnZlID0gcG9zaXRpdmVDdXJ2ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVubW9kaWZpZWRDdXJ2ZSA9IHZhbHVlO1xuICAgICAgICAgICAgaWYgKGlzQ29ubmVjdGVkKSB7XG4gICAgICAgICAgICAgIGlmIChpc0RDQ3VydmUodW5tb2RpZmllZEN1cnZlKSAmJiBkaXNjb25uZWN0TmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2RlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZGlzY29ubmVjdE5hdGl2ZUF1ZGlvQnVmZmVyU291cmNlTm9kZSA9IGNyZWF0ZUNvbm5lY3RlZE5hdGl2ZUF1ZGlvQnVmZmVyU291cmNlTm9kZShuYXRpdmVDb250ZXh0LCBpbnB1dEdhaW5Ob2RlKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChkaXNjb25uZWN0TmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2RlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZGlzY29ubmVjdE5hdGl2ZUF1ZGlvQnVmZmVyU291cmNlTm9kZSgpO1xuICAgICAgICAgICAgICAgIGRpc2Nvbm5lY3ROYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGUgPSBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBnZXQgaW5wdXRzKCkge1xuICAgICAgICAgICAgcmV0dXJuIFtpbnB1dEdhaW5Ob2RlXTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGdldCBudW1iZXJPZklucHV0cygpIHtcbiAgICAgICAgICAgIHJldHVybiBuZWdhdGl2ZVdhdmVTaGFwZXJOb2RlLm51bWJlck9mSW5wdXRzO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZ2V0IG51bWJlck9mT3V0cHV0cygpIHtcbiAgICAgICAgICAgIHJldHVybiBuZWdhdGl2ZVdhdmVTaGFwZXJOb2RlLm51bWJlck9mT3V0cHV0cztcbiAgICAgICAgICB9LFxuICAgICAgICAgIGdldCBvdmVyc2FtcGxlKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5lZ2F0aXZlV2F2ZVNoYXBlck5vZGUub3ZlcnNhbXBsZTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNldCBvdmVyc2FtcGxlKHZhbHVlKSB7XG4gICAgICAgICAgICBuZWdhdGl2ZVdhdmVTaGFwZXJOb2RlLm92ZXJzYW1wbGUgPSB2YWx1ZTtcbiAgICAgICAgICAgIHBvc2l0aXZlV2F2ZVNoYXBlck5vZGUub3ZlcnNhbXBsZSA9IHZhbHVlO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcigpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dEdhaW5Ob2RlLmFkZEV2ZW50TGlzdGVuZXIoYXJndW1lbnRzLmxlbmd0aCA8PSAwID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzBdLCBhcmd1bWVudHMubGVuZ3RoIDw9IDEgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMV0sIGFyZ3VtZW50cy5sZW5ndGggPD0gMiA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1syXSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBkaXNwYXRjaEV2ZW50OiBmdW5jdGlvbiBkaXNwYXRjaEV2ZW50KCkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0R2Fpbk5vZGUuZGlzcGF0Y2hFdmVudChhcmd1bWVudHMubGVuZ3RoIDw9IDAgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMF0pO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcigpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dEdhaW5Ob2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoYXJndW1lbnRzLmxlbmd0aCA8PSAwID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzBdLCBhcmd1bWVudHMubGVuZ3RoIDw9IDEgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMV0sIGFyZ3VtZW50cy5sZW5ndGggPD0gMiA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1syXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBpZiAoY3VydmUgIT09IG51bGwpIHtcbiAgICAgICAgICAvLyBPbmx5IHZhbHVlcyBvZiB0eXBlIEZsb2F0MzJBcnJheSBjYW4gYmUgYXNzaWduZWQgdG8gdGhlIGN1cnZlIHByb3BlcnR5LlxuICAgICAgICAgIG5hdGl2ZVdhdmVTaGFwZXJOb2RlRmFrZXIuY3VydmUgPSBjdXJ2ZSBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSA/IGN1cnZlIDogbmV3IEZsb2F0MzJBcnJheShjdXJ2ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG92ZXJzYW1wbGUgIT09IG5hdGl2ZVdhdmVTaGFwZXJOb2RlRmFrZXIub3ZlcnNhbXBsZSkge1xuICAgICAgICAgIG5hdGl2ZVdhdmVTaGFwZXJOb2RlRmFrZXIub3ZlcnNhbXBsZSA9IG92ZXJzYW1wbGU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHdoZW5Db25uZWN0ZWQgPSBmdW5jdGlvbiB3aGVuQ29ubmVjdGVkKCkge1xuICAgICAgICAgIGlucHV0R2Fpbk5vZGUuY29ubmVjdChuZWdhdGl2ZVdhdmVTaGFwZXJOb2RlKS5jb25uZWN0KG91dHB1dEdhaW5Ob2RlKTtcbiAgICAgICAgICBpbnB1dEdhaW5Ob2RlLmNvbm5lY3QoaW52ZXJ0R2Fpbk5vZGUpLmNvbm5lY3QocG9zaXRpdmVXYXZlU2hhcGVyTm9kZSkuY29ubmVjdChyZXZlcnRHYWluTm9kZSkuY29ubmVjdChvdXRwdXRHYWluTm9kZSk7XG4gICAgICAgICAgaXNDb25uZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgIGlmIChpc0RDQ3VydmUodW5tb2RpZmllZEN1cnZlKSkge1xuICAgICAgICAgICAgZGlzY29ubmVjdE5hdGl2ZUF1ZGlvQnVmZmVyU291cmNlTm9kZSA9IGNyZWF0ZUNvbm5lY3RlZE5hdGl2ZUF1ZGlvQnVmZmVyU291cmNlTm9kZShuYXRpdmVDb250ZXh0LCBpbnB1dEdhaW5Ob2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHZhciB3aGVuRGlzY29ubmVjdGVkID0gZnVuY3Rpb24gd2hlbkRpc2Nvbm5lY3RlZCgpIHtcbiAgICAgICAgICBpbnB1dEdhaW5Ob2RlLmRpc2Nvbm5lY3QobmVnYXRpdmVXYXZlU2hhcGVyTm9kZSk7XG4gICAgICAgICAgbmVnYXRpdmVXYXZlU2hhcGVyTm9kZS5kaXNjb25uZWN0KG91dHB1dEdhaW5Ob2RlKTtcbiAgICAgICAgICBpbnB1dEdhaW5Ob2RlLmRpc2Nvbm5lY3QoaW52ZXJ0R2Fpbk5vZGUpO1xuICAgICAgICAgIGludmVydEdhaW5Ob2RlLmRpc2Nvbm5lY3QocG9zaXRpdmVXYXZlU2hhcGVyTm9kZSk7XG4gICAgICAgICAgcG9zaXRpdmVXYXZlU2hhcGVyTm9kZS5kaXNjb25uZWN0KHJldmVydEdhaW5Ob2RlKTtcbiAgICAgICAgICByZXZlcnRHYWluTm9kZS5kaXNjb25uZWN0KG91dHB1dEdhaW5Ob2RlKTtcbiAgICAgICAgICBpc0Nvbm5lY3RlZCA9IGZhbHNlO1xuICAgICAgICAgIGlmIChkaXNjb25uZWN0TmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2RlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBkaXNjb25uZWN0TmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2RlKCk7XG4gICAgICAgICAgICBkaXNjb25uZWN0TmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2RlID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBtb25pdG9yQ29ubmVjdGlvbnMoaW50ZXJjZXB0Q29ubmVjdGlvbnMobmF0aXZlV2F2ZVNoYXBlck5vZGVGYWtlciwgb3V0cHV0R2Fpbk5vZGUpLCB3aGVuQ29ubmVjdGVkLCB3aGVuRGlzY29ubmVjdGVkKTtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVOb3RTdXBwb3J0ZWRFcnJvciA9IGZ1bmN0aW9uIGNyZWF0ZU5vdFN1cHBvcnRlZEVycm9yKCkge1xuICAgICAgcmV0dXJuIG5ldyBET01FeGNlcHRpb24oJycsICdOb3RTdXBwb3J0ZWRFcnJvcicpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBvd25LZXlzJDkoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuICAgIGZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkOShlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzJDkoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzJDkoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTsgfSk7IH0gcmV0dXJuIGU7IH1cbiAgICBmdW5jdGlvbiBfY2FsbFN1cGVyJDQodCwgbywgZSkgeyByZXR1cm4gbyA9IF9nZXRQcm90b3R5cGVPZihvKSwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odCwgX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCQ0KCkgPyBSZWZsZWN0LmNvbnN0cnVjdChvLCBlIHx8IFtdLCBfZ2V0UHJvdG90eXBlT2YodCkuY29uc3RydWN0b3IpIDogby5hcHBseSh0LCBlKSk7IH1cbiAgICBmdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JDQoKSB7IHRyeSB7IHZhciB0ID0gIUJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgfSBjYXRjaCAodCkge30gcmV0dXJuIChfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JDQgPSBmdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyByZXR1cm4gISF0OyB9KSgpOyB9XG4gICAgdmFyIERFRkFVTFRfT1BUSU9OUyQ1ID0ge1xuICAgICAgbnVtYmVyT2ZDaGFubmVsczogMVxuICAgIH07XG4gICAgdmFyIGNyZWF0ZU9mZmxpbmVBdWRpb0NvbnRleHRDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uIGNyZWF0ZU9mZmxpbmVBdWRpb0NvbnRleHRDb25zdHJ1Y3RvcihiYXNlQXVkaW9Db250ZXh0Q29uc3RydWN0b3IsIGNhY2hlVGVzdFJlc3VsdCwgY3JlYXRlSW52YWxpZFN0YXRlRXJyb3IsIGNyZWF0ZU5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQsIF9zdGFydFJlbmRlcmluZykge1xuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX2Jhc2VBdWRpb0NvbnRleHRDb25zKSB7XG4gICAgICAgIGZ1bmN0aW9uIE9mZmxpbmVBdWRpb0NvbnRleHQoYSwgYiwgYykge1xuICAgICAgICAgIHZhciBfdGhpcztcbiAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgT2ZmbGluZUF1ZGlvQ29udGV4dCk7XG4gICAgICAgICAgdmFyIG9wdGlvbnM7XG4gICAgICAgICAgaWYgKHR5cGVvZiBhID09PSAnbnVtYmVyJyAmJiBiICE9PSB1bmRlZmluZWQgJiYgYyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvcHRpb25zID0ge1xuICAgICAgICAgICAgICBsZW5ndGg6IGIsXG4gICAgICAgICAgICAgIG51bWJlck9mQ2hhbm5lbHM6IGEsXG4gICAgICAgICAgICAgIHNhbXBsZVJhdGU6IGNcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSBlbHNlIGlmIChfdHlwZW9mKGEpID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgb3B0aW9ucyA9IGE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGdpdmVuIHBhcmFtZXRlcnMgYXJlIG5vdCB2YWxpZC4nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIF9ERUZBVUxUX09QVElPTlMkb3B0aSA9IF9vYmplY3RTcHJlYWQkOShfb2JqZWN0U3ByZWFkJDkoe30sIERFRkFVTFRfT1BUSU9OUyQ1KSwgb3B0aW9ucyksXG4gICAgICAgICAgICBsZW5ndGggPSBfREVGQVVMVF9PUFRJT05TJG9wdGkubGVuZ3RoLFxuICAgICAgICAgICAgbnVtYmVyT2ZDaGFubmVscyA9IF9ERUZBVUxUX09QVElPTlMkb3B0aS5udW1iZXJPZkNoYW5uZWxzLFxuICAgICAgICAgICAgc2FtcGxlUmF0ZSA9IF9ERUZBVUxUX09QVElPTlMkb3B0aS5zYW1wbGVSYXRlO1xuICAgICAgICAgIHZhciBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0ID0gY3JlYXRlTmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dChudW1iZXJPZkNoYW5uZWxzLCBsZW5ndGgsIHNhbXBsZVJhdGUpO1xuICAgICAgICAgIC8vICMyMSBTYWZhcmkgZG9lcyBub3Qgc3VwcG9ydCBwcm9taXNlcyBhbmQgdGhlcmVmb3JlIHdvdWxkIGZpcmUgdGhlIHN0YXRlY2hhbmdlIGV2ZW50IGJlZm9yZSB0aGUgcHJvbWlzZSBjYW4gYmUgcmVzb2x2ZWQuXG4gICAgICAgICAgaWYgKCFjYWNoZVRlc3RSZXN1bHQodGVzdFByb21pc2VTdXBwb3J0LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGVzdFByb21pc2VTdXBwb3J0KG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQpO1xuICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LmFkZEV2ZW50TGlzdGVuZXIoJ3N0YXRlY2hhbmdlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgICAgICAgIHZhciBfZGVsYXlTdGF0ZUNoYW5nZUV2ZW50ID0gZnVuY3Rpb24gZGVsYXlTdGF0ZUNoYW5nZUV2ZW50KGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLl9zdGF0ZSA9PT0gJ3J1bm5pbmcnKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dC5yZW1vdmVFdmVudExpc3RlbmVyKCdzdGF0ZWNoYW5nZScsIF9kZWxheVN0YXRlQ2hhbmdlRXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3dhaXRGb3JUaGVQcm9taXNlVG9TZXR0bGUoZXZlbnQpO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgcmV0dXJuIF9kZWxheVN0YXRlQ2hhbmdlRXZlbnQ7XG4gICAgICAgICAgICB9KCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBfdGhpcyA9IF9jYWxsU3VwZXIkNCh0aGlzLCBPZmZsaW5lQXVkaW9Db250ZXh0LCBbbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCwgbnVtYmVyT2ZDaGFubmVsc10pO1xuICAgICAgICAgIF90aGlzLl9sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgICAgX3RoaXMuX25hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQgPSBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0O1xuICAgICAgICAgIF90aGlzLl9zdGF0ZSA9IG51bGw7XG4gICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICB9XG4gICAgICAgIF9pbmhlcml0cyhPZmZsaW5lQXVkaW9Db250ZXh0LCBfYmFzZUF1ZGlvQ29udGV4dENvbnMpO1xuICAgICAgICByZXR1cm4gX2NyZWF0ZUNsYXNzKE9mZmxpbmVBdWRpb0NvbnRleHQsIFt7XG4gICAgICAgICAga2V5OiBcImxlbmd0aFwiLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgLy8gQnVnICMxNzogU2FmYXJpIGRvZXMgbm90IHlldCBleHBvc2UgdGhlIGxlbmd0aC5cbiAgICAgICAgICAgIGlmICh0aGlzLl9uYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0Lmxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLl9sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dC5sZW5ndGg7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcInN0YXRlXCIsXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RhdGUgPT09IG51bGwgPyB0aGlzLl9uYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LnN0YXRlIDogdGhpcy5fc3RhdGU7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcInN0YXJ0UmVuZGVyaW5nXCIsXG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHN0YXJ0UmVuZGVyaW5nKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogQnVnICM5ICYgIzU5OiBJdCBpcyB0aGVvcmV0aWNhbGx5IHBvc3NpYmxlIHRoYXQgc3RhcnRSZW5kZXJpbmcoKSB3aWxsIGZpcnN0IHJlbmRlciBhIHBhcnRpYWxPZmZsaW5lQXVkaW9Db250ZXh0LiBUaGVyZWZvcmVcbiAgICAgICAgICAgICAqIHRoZSBzdGF0ZSBvZiB0aGUgbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCBtaWdodCBubyB0cmFuc2l0aW9uIHRvIHJ1bm5pbmcgaW1tZWRpYXRlbHkuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmICh0aGlzLl9zdGF0ZSA9PT0gJ3J1bm5pbmcnKSB7XG4gICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChjcmVhdGVJbnZhbGlkU3RhdGVFcnJvcigpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gJ3J1bm5pbmcnO1xuICAgICAgICAgICAgcmV0dXJuIF9zdGFydFJlbmRlcmluZyh0aGlzLmRlc3RpbmF0aW9uLCB0aGlzLl9uYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KVtcImZpbmFsbHlcIl0oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBfdGhpczIuX3N0YXRlID0gbnVsbDtcbiAgICAgICAgICAgICAgZGVhY3RpdmF0ZUF1ZGlvR3JhcGgoX3RoaXMyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIGtleTogXCJfd2FpdEZvclRoZVByb21pc2VUb1NldHRsZVwiLFxuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfd2FpdEZvclRoZVByb21pc2VUb1NldHRsZShldmVudCkge1xuICAgICAgICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG4gICAgICAgICAgICBpZiAodGhpcy5fc3RhdGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgdGhpcy5fbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpczMuX3dhaXRGb3JUaGVQcm9taXNlVG9TZXR0bGUoZXZlbnQpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1dKTtcbiAgICAgIH0oYmFzZUF1ZGlvQ29udGV4dENvbnN0cnVjdG9yKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gb3duS2V5cyQ4KGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cbiAgICBmdW5jdGlvbiBfb2JqZWN0U3ByZWFkJDgoZSkgeyBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykgeyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gb3duS2V5cyQ4KE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyQ4KE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XG4gICAgZnVuY3Rpb24gX2NhbGxTdXBlciQzKHQsIG8sIGUpIHsgcmV0dXJuIG8gPSBfZ2V0UHJvdG90eXBlT2YobyksIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHQsIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkMygpID8gUmVmbGVjdC5jb25zdHJ1Y3QobywgZSB8fCBbXSwgX2dldFByb3RvdHlwZU9mKHQpLmNvbnN0cnVjdG9yKSA6IG8uYXBwbHkodCwgZSkpOyB9XG4gICAgZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCQzKCkgeyB0cnkgeyB2YXIgdCA9ICFCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IH0gY2F0Y2ggKHQpIHt9IHJldHVybiAoX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCQzID0gZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgcmV0dXJuICEhdDsgfSkoKTsgfVxuICAgIHZhciBERUZBVUxUX09QVElPTlMkNCA9IHtcbiAgICAgIGNoYW5uZWxDb3VudDogMixcbiAgICAgIGNoYW5uZWxDb3VudE1vZGU6ICdtYXgnLFxuICAgICAgLy8gVGhpcyBhdHRyaWJ1dGUgaGFzIG5vIGVmZmVjdCBmb3Igbm9kZXMgd2l0aCBubyBpbnB1dHMuXG4gICAgICBjaGFubmVsSW50ZXJwcmV0YXRpb246ICdzcGVha2VycycsXG4gICAgICAvLyBUaGlzIGF0dHJpYnV0ZSBoYXMgbm8gZWZmZWN0IGZvciBub2RlcyB3aXRoIG5vIGlucHV0cy5cbiAgICAgIGRldHVuZTogMCxcbiAgICAgIGZyZXF1ZW5jeTogNDQwLFxuICAgICAgcGVyaW9kaWNXYXZlOiB1bmRlZmluZWQsXG4gICAgICB0eXBlOiAnc2luZSdcbiAgICB9O1xuICAgIHZhciBjcmVhdGVPc2NpbGxhdG9yTm9kZUNvbnN0cnVjdG9yID0gZnVuY3Rpb24gY3JlYXRlT3NjaWxsYXRvck5vZGVDb25zdHJ1Y3RvcihhdWRpb05vZGVDb25zdHJ1Y3RvciwgY3JlYXRlQXVkaW9QYXJhbSwgY3JlYXRlTmF0aXZlT3NjaWxsYXRvck5vZGUsIGNyZWF0ZU9zY2lsbGF0b3JOb2RlUmVuZGVyZXIsIGdldE5hdGl2ZUNvbnRleHQsIGlzTmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCwgd3JhcEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9hdWRpb05vZGVDb25zdHJ1Y3Rvcikge1xuICAgICAgICBmdW5jdGlvbiBPc2NpbGxhdG9yTm9kZShjb250ZXh0LCBvcHRpb25zKSB7XG4gICAgICAgICAgdmFyIF90aGlzO1xuICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBPc2NpbGxhdG9yTm9kZSk7XG4gICAgICAgICAgdmFyIG5hdGl2ZUNvbnRleHQgPSBnZXROYXRpdmVDb250ZXh0KGNvbnRleHQpO1xuICAgICAgICAgIHZhciBtZXJnZWRPcHRpb25zID0gX29iamVjdFNwcmVhZCQ4KF9vYmplY3RTcHJlYWQkOCh7fSwgREVGQVVMVF9PUFRJT05TJDQpLCBvcHRpb25zKTtcbiAgICAgICAgICB2YXIgbmF0aXZlT3NjaWxsYXRvck5vZGUgPSBjcmVhdGVOYXRpdmVPc2NpbGxhdG9yTm9kZShuYXRpdmVDb250ZXh0LCBtZXJnZWRPcHRpb25zKTtcbiAgICAgICAgICB2YXIgaXNPZmZsaW5lID0gaXNOYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KG5hdGl2ZUNvbnRleHQpO1xuICAgICAgICAgIHZhciBvc2NpbGxhdG9yTm9kZVJlbmRlcmVyID0gaXNPZmZsaW5lID8gY3JlYXRlT3NjaWxsYXRvck5vZGVSZW5kZXJlcigpIDogbnVsbDtcbiAgICAgICAgICB2YXIgbnlxdWlzdCA9IGNvbnRleHQuc2FtcGxlUmF0ZSAvIDI7XG4gICAgICAgICAgX3RoaXMgPSBfY2FsbFN1cGVyJDModGhpcywgT3NjaWxsYXRvck5vZGUsIFtjb250ZXh0LCBmYWxzZSwgbmF0aXZlT3NjaWxsYXRvck5vZGUsIG9zY2lsbGF0b3JOb2RlUmVuZGVyZXJdKTtcbiAgICAgICAgICAvLyBCdWcgIzgxOiBGaXJlZm94ICYgU2FmYXJpIGRvIG5vdCBleHBvcnQgdGhlIGNvcnJlY3QgdmFsdWVzIGZvciBtYXhWYWx1ZSBhbmQgbWluVmFsdWUuXG4gICAgICAgICAgX3RoaXMuX2RldHVuZSA9IGNyZWF0ZUF1ZGlvUGFyYW0oX3RoaXMsIGlzT2ZmbGluZSwgbmF0aXZlT3NjaWxsYXRvck5vZGUuZGV0dW5lLCAxNTM2MDAsIC0xNTM2MDApO1xuICAgICAgICAgIC8vIEJ1ZyAjNzY6IFNhZmFyaSBkb2VzIG5vdCBleHBvcnQgdGhlIGNvcnJlY3QgdmFsdWVzIGZvciBtYXhWYWx1ZSBhbmQgbWluVmFsdWUuXG4gICAgICAgICAgX3RoaXMuX2ZyZXF1ZW5jeSA9IGNyZWF0ZUF1ZGlvUGFyYW0oX3RoaXMsIGlzT2ZmbGluZSwgbmF0aXZlT3NjaWxsYXRvck5vZGUuZnJlcXVlbmN5LCBueXF1aXN0LCAtbnlxdWlzdCk7XG4gICAgICAgICAgX3RoaXMuX25hdGl2ZU9zY2lsbGF0b3JOb2RlID0gbmF0aXZlT3NjaWxsYXRvck5vZGU7XG4gICAgICAgICAgX3RoaXMuX29uZW5kZWQgPSBudWxsO1xuICAgICAgICAgIF90aGlzLl9vc2NpbGxhdG9yTm9kZVJlbmRlcmVyID0gb3NjaWxsYXRvck5vZGVSZW5kZXJlcjtcbiAgICAgICAgICBpZiAoX3RoaXMuX29zY2lsbGF0b3JOb2RlUmVuZGVyZXIgIT09IG51bGwgJiYgbWVyZ2VkT3B0aW9ucy5wZXJpb2RpY1dhdmUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgX3RoaXMuX29zY2lsbGF0b3JOb2RlUmVuZGVyZXIucGVyaW9kaWNXYXZlID0gbWVyZ2VkT3B0aW9ucy5wZXJpb2RpY1dhdmU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgICAgfVxuICAgICAgICBfaW5oZXJpdHMoT3NjaWxsYXRvck5vZGUsIF9hdWRpb05vZGVDb25zdHJ1Y3Rvcik7XG4gICAgICAgIHJldHVybiBfY3JlYXRlQ2xhc3MoT3NjaWxsYXRvck5vZGUsIFt7XG4gICAgICAgICAga2V5OiBcImRldHVuZVwiLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RldHVuZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBrZXk6IFwiZnJlcXVlbmN5XCIsXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZnJlcXVlbmN5O1xuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIGtleTogXCJvbmVuZGVkXCIsXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fb25lbmRlZDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgd3JhcHBlZExpc3RlbmVyID0gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nID8gd3JhcEV2ZW50TGlzdGVuZXIodGhpcywgdmFsdWUpIDogbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX25hdGl2ZU9zY2lsbGF0b3JOb2RlLm9uZW5kZWQgPSB3cmFwcGVkTGlzdGVuZXI7XG4gICAgICAgICAgICB2YXIgbmF0aXZlT25FbmRlZCA9IHRoaXMuX25hdGl2ZU9zY2lsbGF0b3JOb2RlLm9uZW5kZWQ7XG4gICAgICAgICAgICB0aGlzLl9vbmVuZGVkID0gbmF0aXZlT25FbmRlZCAhPT0gbnVsbCAmJiBuYXRpdmVPbkVuZGVkID09PSB3cmFwcGVkTGlzdGVuZXIgPyB2YWx1ZSA6IG5hdGl2ZU9uRW5kZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcInR5cGVcIixcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9uYXRpdmVPc2NpbGxhdG9yTm9kZS50eXBlO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX25hdGl2ZU9zY2lsbGF0b3JOb2RlLnR5cGUgPSB2YWx1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9vc2NpbGxhdG9yTm9kZVJlbmRlcmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHRoaXMuX29zY2lsbGF0b3JOb2RlUmVuZGVyZXIucGVyaW9kaWNXYXZlID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBrZXk6IFwic2V0UGVyaW9kaWNXYXZlXCIsXG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldFBlcmlvZGljV2F2ZShwZXJpb2RpY1dhdmUpIHtcbiAgICAgICAgICAgIHRoaXMuX25hdGl2ZU9zY2lsbGF0b3JOb2RlLnNldFBlcmlvZGljV2F2ZShwZXJpb2RpY1dhdmUpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX29zY2lsbGF0b3JOb2RlUmVuZGVyZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgdGhpcy5fb3NjaWxsYXRvck5vZGVSZW5kZXJlci5wZXJpb2RpY1dhdmUgPSBwZXJpb2RpY1dhdmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcInN0YXJ0XCIsXG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHN0YXJ0KCkge1xuICAgICAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgd2hlbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogMDtcbiAgICAgICAgICAgIHRoaXMuX25hdGl2ZU9zY2lsbGF0b3JOb2RlLnN0YXJ0KHdoZW4pO1xuICAgICAgICAgICAgaWYgKHRoaXMuX29zY2lsbGF0b3JOb2RlUmVuZGVyZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgdGhpcy5fb3NjaWxsYXRvck5vZGVSZW5kZXJlci5zdGFydCA9IHdoZW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb250ZXh0LnN0YXRlICE9PSAnY2xvc2VkJykge1xuICAgICAgICAgICAgICBzZXRJbnRlcm5hbFN0YXRlVG9BY3RpdmUodGhpcyk7XG4gICAgICAgICAgICAgIHZhciBfcmVzZXRJbnRlcm5hbFN0YXRlVG9QYXNzaXZlID0gZnVuY3Rpb24gcmVzZXRJbnRlcm5hbFN0YXRlVG9QYXNzaXZlKCkge1xuICAgICAgICAgICAgICAgIF90aGlzMi5fbmF0aXZlT3NjaWxsYXRvck5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcignZW5kZWQnLCBfcmVzZXRJbnRlcm5hbFN0YXRlVG9QYXNzaXZlKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNBY3RpdmVBdWRpb05vZGUoX3RoaXMyKSkge1xuICAgICAgICAgICAgICAgICAgc2V0SW50ZXJuYWxTdGF0ZVRvUGFzc2l2ZShfdGhpczIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgdGhpcy5fbmF0aXZlT3NjaWxsYXRvck5vZGUuYWRkRXZlbnRMaXN0ZW5lcignZW5kZWQnLCBfcmVzZXRJbnRlcm5hbFN0YXRlVG9QYXNzaXZlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBrZXk6IFwic3RvcFwiLFxuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzdG9wKCkge1xuICAgICAgICAgICAgdmFyIHdoZW4gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDA7XG4gICAgICAgICAgICB0aGlzLl9uYXRpdmVPc2NpbGxhdG9yTm9kZS5zdG9wKHdoZW4pO1xuICAgICAgICAgICAgaWYgKHRoaXMuX29zY2lsbGF0b3JOb2RlUmVuZGVyZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgdGhpcy5fb3NjaWxsYXRvck5vZGVSZW5kZXJlci5zdG9wID0gd2hlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1dKTtcbiAgICAgIH0oYXVkaW9Ob2RlQ29uc3RydWN0b3IpO1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlT3NjaWxsYXRvck5vZGVSZW5kZXJlckZhY3RvcnkgPSBmdW5jdGlvbiBjcmVhdGVPc2NpbGxhdG9yTm9kZVJlbmRlcmVyRmFjdG9yeShjb25uZWN0QXVkaW9QYXJhbSwgY3JlYXRlTmF0aXZlT3NjaWxsYXRvck5vZGUsIGdldE5hdGl2ZUF1ZGlvTm9kZSwgcmVuZGVyQXV0b21hdGlvbiwgcmVuZGVySW5wdXRzT2ZBdWRpb05vZGUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZW5kZXJlZE5hdGl2ZU9zY2lsbGF0b3JOb2RlcyA9IG5ldyBXZWFrTWFwKCk7XG4gICAgICAgIHZhciBwZXJpb2RpY1dhdmUgPSBudWxsO1xuICAgICAgICB2YXIgc3RhcnQgPSBudWxsO1xuICAgICAgICB2YXIgc3RvcCA9IG51bGw7XG4gICAgICAgIHZhciBjcmVhdGVPc2NpbGxhdG9yTm9kZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIF9yZWYgPSBfYXN5bmNUb0dlbmVyYXRvcigvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUocHJveHksIG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciBuYXRpdmVPc2NpbGxhdG9yTm9kZSwgbmF0aXZlT3NjaWxsYXRvck5vZGVJc093bmVkQnlDb250ZXh0LCBvcHRpb25zO1xuICAgICAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgICAgICAgICB3aGlsZSAoMSkgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgIG5hdGl2ZU9zY2lsbGF0b3JOb2RlID0gZ2V0TmF0aXZlQXVkaW9Ob2RlKHByb3h5KTsgLy8gSWYgdGhlIGluaXRpYWxseSB1c2VkIG5hdGl2ZU9zY2lsbGF0b3JOb2RlIHdhcyBub3QgY29uc3RydWN0ZWQgb24gdGhlIHNhbWUgT2ZmbGluZUF1ZGlvQ29udGV4dCBpdCBuZWVkcyB0byBiZSBjcmVhdGVkIGFnYWluLlxuICAgICAgICAgICAgICAgICAgbmF0aXZlT3NjaWxsYXRvck5vZGVJc093bmVkQnlDb250ZXh0ID0gaXNPd25lZEJ5Q29udGV4dChuYXRpdmVPc2NpbGxhdG9yTm9kZSwgbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCk7XG4gICAgICAgICAgICAgICAgICBpZiAoIW5hdGl2ZU9zY2lsbGF0b3JOb2RlSXNPd25lZEJ5Q29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zID0ge1xuICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWxDb3VudDogbmF0aXZlT3NjaWxsYXRvck5vZGUuY2hhbm5lbENvdW50LFxuICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWxDb3VudE1vZGU6IG5hdGl2ZU9zY2lsbGF0b3JOb2RlLmNoYW5uZWxDb3VudE1vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbEludGVycHJldGF0aW9uOiBuYXRpdmVPc2NpbGxhdG9yTm9kZS5jaGFubmVsSW50ZXJwcmV0YXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgZGV0dW5lOiBuYXRpdmVPc2NpbGxhdG9yTm9kZS5kZXR1bmUudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgZnJlcXVlbmN5OiBuYXRpdmVPc2NpbGxhdG9yTm9kZS5mcmVxdWVuY3kudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgcGVyaW9kaWNXYXZlOiBwZXJpb2RpY1dhdmUgPT09IG51bGwgPyB1bmRlZmluZWQgOiBwZXJpb2RpY1dhdmUsXG4gICAgICAgICAgICAgICAgICAgICAgdHlwZTogbmF0aXZlT3NjaWxsYXRvck5vZGUudHlwZVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBuYXRpdmVPc2NpbGxhdG9yTm9kZSA9IGNyZWF0ZU5hdGl2ZU9zY2lsbGF0b3JOb2RlKG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhcnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICBuYXRpdmVPc2NpbGxhdG9yTm9kZS5zdGFydChzdGFydCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0b3AgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICBuYXRpdmVPc2NpbGxhdG9yTm9kZS5zdG9wKHN0b3ApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICByZW5kZXJlZE5hdGl2ZU9zY2lsbGF0b3JOb2Rlcy5zZXQobmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCwgbmF0aXZlT3NjaWxsYXRvck5vZGUpO1xuICAgICAgICAgICAgICAgICAgaWYgKG5hdGl2ZU9zY2lsbGF0b3JOb2RlSXNPd25lZEJ5Q29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTE7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDc7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcmVuZGVyQXV0b21hdGlvbihuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LCBwcm94eS5kZXR1bmUsIG5hdGl2ZU9zY2lsbGF0b3JOb2RlLmRldHVuZSk7XG4gICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcmVuZGVyQXV0b21hdGlvbihuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LCBwcm94eS5mcmVxdWVuY3ksIG5hdGl2ZU9zY2lsbGF0b3JOb2RlLmZyZXF1ZW5jeSk7XG4gICAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDE1O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxMztcbiAgICAgICAgICAgICAgICAgIHJldHVybiBjb25uZWN0QXVkaW9QYXJhbShuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LCBwcm94eS5kZXR1bmUsIG5hdGl2ZU9zY2lsbGF0b3JOb2RlLmRldHVuZSk7XG4gICAgICAgICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxNTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBjb25uZWN0QXVkaW9QYXJhbShuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LCBwcm94eS5mcmVxdWVuY3ksIG5hdGl2ZU9zY2lsbGF0b3JOb2RlLmZyZXF1ZW5jeSk7XG4gICAgICAgICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxNztcbiAgICAgICAgICAgICAgICAgIHJldHVybiByZW5kZXJJbnB1dHNPZkF1ZGlvTm9kZShwcm94eSwgbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCwgbmF0aXZlT3NjaWxsYXRvck5vZGUpO1xuICAgICAgICAgICAgICAgIGNhc2UgMTc6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIG5hdGl2ZU9zY2lsbGF0b3JOb2RlKTtcbiAgICAgICAgICAgICAgICBjYXNlIDE4OlxuICAgICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIF9jYWxsZWUpO1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlT3NjaWxsYXRvck5vZGUoX3gsIF94Mikge1xuICAgICAgICAgICAgcmV0dXJuIF9yZWYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9KCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc2V0IHBlcmlvZGljV2F2ZSh2YWx1ZSkge1xuICAgICAgICAgICAgcGVyaW9kaWNXYXZlID0gdmFsdWU7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzZXQgc3RhcnQodmFsdWUpIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gdmFsdWU7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzZXQgc3RvcCh2YWx1ZSkge1xuICAgICAgICAgICAgc3RvcCA9IHZhbHVlO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIocHJveHksIG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciByZW5kZXJlZE5hdGl2ZU9zY2lsbGF0b3JOb2RlID0gcmVuZGVyZWROYXRpdmVPc2NpbGxhdG9yTm9kZXMuZ2V0KG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQpO1xuICAgICAgICAgICAgaWYgKHJlbmRlcmVkTmF0aXZlT3NjaWxsYXRvck5vZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlbmRlcmVkTmF0aXZlT3NjaWxsYXRvck5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZU9zY2lsbGF0b3JOb2RlKHByb3h5LCBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9O1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBvd25LZXlzJDcoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuICAgIGZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkNyhlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzJDcoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzJDcoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTsgfSk7IH0gcmV0dXJuIGU7IH1cbiAgICBmdW5jdGlvbiBfY2FsbFN1cGVyJDIodCwgbywgZSkgeyByZXR1cm4gbyA9IF9nZXRQcm90b3R5cGVPZihvKSwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odCwgX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCQyKCkgPyBSZWZsZWN0LmNvbnN0cnVjdChvLCBlIHx8IFtdLCBfZ2V0UHJvdG90eXBlT2YodCkuY29uc3RydWN0b3IpIDogby5hcHBseSh0LCBlKSk7IH1cbiAgICBmdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JDIoKSB7IHRyeSB7IHZhciB0ID0gIUJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgfSBjYXRjaCAodCkge30gcmV0dXJuIChfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JDIgPSBmdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyByZXR1cm4gISF0OyB9KSgpOyB9XG4gICAgdmFyIERFRkFVTFRfT1BUSU9OUyQzID0ge1xuICAgICAgY2hhbm5lbENvdW50OiAyLFxuICAgICAgY2hhbm5lbENvdW50TW9kZTogJ2NsYW1wZWQtbWF4JyxcbiAgICAgIGNoYW5uZWxJbnRlcnByZXRhdGlvbjogJ3NwZWFrZXJzJyxcbiAgICAgIGNvbmVJbm5lckFuZ2xlOiAzNjAsXG4gICAgICBjb25lT3V0ZXJBbmdsZTogMzYwLFxuICAgICAgY29uZU91dGVyR2FpbjogMCxcbiAgICAgIGRpc3RhbmNlTW9kZWw6ICdpbnZlcnNlJyxcbiAgICAgIG1heERpc3RhbmNlOiAxMDAwMCxcbiAgICAgIG9yaWVudGF0aW9uWDogMSxcbiAgICAgIG9yaWVudGF0aW9uWTogMCxcbiAgICAgIG9yaWVudGF0aW9uWjogMCxcbiAgICAgIHBhbm5pbmdNb2RlbDogJ2VxdWFscG93ZXInLFxuICAgICAgcG9zaXRpb25YOiAwLFxuICAgICAgcG9zaXRpb25ZOiAwLFxuICAgICAgcG9zaXRpb25aOiAwLFxuICAgICAgcmVmRGlzdGFuY2U6IDEsXG4gICAgICByb2xsb2ZmRmFjdG9yOiAxXG4gICAgfTtcbiAgICB2YXIgY3JlYXRlUGFubmVyTm9kZUNvbnN0cnVjdG9yID0gZnVuY3Rpb24gY3JlYXRlUGFubmVyTm9kZUNvbnN0cnVjdG9yKGF1ZGlvTm9kZUNvbnN0cnVjdG9yLCBjcmVhdGVBdWRpb1BhcmFtLCBjcmVhdGVOYXRpdmVQYW5uZXJOb2RlLCBjcmVhdGVQYW5uZXJOb2RlUmVuZGVyZXIsIGdldE5hdGl2ZUNvbnRleHQsIGlzTmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCwgc2V0QXVkaW9Ob2RlVGFpbFRpbWUpIHtcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9hdWRpb05vZGVDb25zdHJ1Y3Rvcikge1xuICAgICAgICBmdW5jdGlvbiBQYW5uZXJOb2RlKGNvbnRleHQsIG9wdGlvbnMpIHtcbiAgICAgICAgICB2YXIgX3RoaXM7XG4gICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBhbm5lck5vZGUpO1xuICAgICAgICAgIHZhciBuYXRpdmVDb250ZXh0ID0gZ2V0TmF0aXZlQ29udGV4dChjb250ZXh0KTtcbiAgICAgICAgICB2YXIgbWVyZ2VkT3B0aW9ucyA9IF9vYmplY3RTcHJlYWQkNyhfb2JqZWN0U3ByZWFkJDcoe30sIERFRkFVTFRfT1BUSU9OUyQzKSwgb3B0aW9ucyk7XG4gICAgICAgICAgdmFyIG5hdGl2ZVBhbm5lck5vZGUgPSBjcmVhdGVOYXRpdmVQYW5uZXJOb2RlKG5hdGl2ZUNvbnRleHQsIG1lcmdlZE9wdGlvbnMpO1xuICAgICAgICAgIHZhciBpc09mZmxpbmUgPSBpc05hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQobmF0aXZlQ29udGV4dCk7XG4gICAgICAgICAgdmFyIHBhbm5lck5vZGVSZW5kZXJlciA9IGlzT2ZmbGluZSA/IGNyZWF0ZVBhbm5lck5vZGVSZW5kZXJlcigpIDogbnVsbDtcbiAgICAgICAgICBfdGhpcyA9IF9jYWxsU3VwZXIkMih0aGlzLCBQYW5uZXJOb2RlLCBbY29udGV4dCwgZmFsc2UsIG5hdGl2ZVBhbm5lck5vZGUsIHBhbm5lck5vZGVSZW5kZXJlcl0pO1xuICAgICAgICAgIF90aGlzLl9uYXRpdmVQYW5uZXJOb2RlID0gbmF0aXZlUGFubmVyTm9kZTtcbiAgICAgICAgICAvLyBCdWcgIzc0OiBTYWZhcmkgZG9lcyBub3QgZXhwb3J0IHRoZSBjb3JyZWN0IHZhbHVlcyBmb3IgbWF4VmFsdWUgYW5kIG1pblZhbHVlLlxuICAgICAgICAgIF90aGlzLl9vcmllbnRhdGlvblggPSBjcmVhdGVBdWRpb1BhcmFtKF90aGlzLCBpc09mZmxpbmUsIG5hdGl2ZVBhbm5lck5vZGUub3JpZW50YXRpb25YLCBNT1NUX1BPU0lUSVZFX1NJTkdMRV9GTE9BVCwgTU9TVF9ORUdBVElWRV9TSU5HTEVfRkxPQVQpO1xuICAgICAgICAgIF90aGlzLl9vcmllbnRhdGlvblkgPSBjcmVhdGVBdWRpb1BhcmFtKF90aGlzLCBpc09mZmxpbmUsIG5hdGl2ZVBhbm5lck5vZGUub3JpZW50YXRpb25ZLCBNT1NUX1BPU0lUSVZFX1NJTkdMRV9GTE9BVCwgTU9TVF9ORUdBVElWRV9TSU5HTEVfRkxPQVQpO1xuICAgICAgICAgIF90aGlzLl9vcmllbnRhdGlvblogPSBjcmVhdGVBdWRpb1BhcmFtKF90aGlzLCBpc09mZmxpbmUsIG5hdGl2ZVBhbm5lck5vZGUub3JpZW50YXRpb25aLCBNT1NUX1BPU0lUSVZFX1NJTkdMRV9GTE9BVCwgTU9TVF9ORUdBVElWRV9TSU5HTEVfRkxPQVQpO1xuICAgICAgICAgIF90aGlzLl9wb3NpdGlvblggPSBjcmVhdGVBdWRpb1BhcmFtKF90aGlzLCBpc09mZmxpbmUsIG5hdGl2ZVBhbm5lck5vZGUucG9zaXRpb25YLCBNT1NUX1BPU0lUSVZFX1NJTkdMRV9GTE9BVCwgTU9TVF9ORUdBVElWRV9TSU5HTEVfRkxPQVQpO1xuICAgICAgICAgIF90aGlzLl9wb3NpdGlvblkgPSBjcmVhdGVBdWRpb1BhcmFtKF90aGlzLCBpc09mZmxpbmUsIG5hdGl2ZVBhbm5lck5vZGUucG9zaXRpb25ZLCBNT1NUX1BPU0lUSVZFX1NJTkdMRV9GTE9BVCwgTU9TVF9ORUdBVElWRV9TSU5HTEVfRkxPQVQpO1xuICAgICAgICAgIF90aGlzLl9wb3NpdGlvblogPSBjcmVhdGVBdWRpb1BhcmFtKF90aGlzLCBpc09mZmxpbmUsIG5hdGl2ZVBhbm5lck5vZGUucG9zaXRpb25aLCBNT1NUX1BPU0lUSVZFX1NJTkdMRV9GTE9BVCwgTU9TVF9ORUdBVElWRV9TSU5HTEVfRkxPQVQpO1xuICAgICAgICAgIC8vIEB0b2RvIERldGVybWluZSBhIG1lYW5pbmdmdWwgdGFpbC10aW1lIGluc3RlYWQgb2YganVzdCB1c2luZyBvbmUgc2Vjb25kLlxuICAgICAgICAgIHNldEF1ZGlvTm9kZVRhaWxUaW1lKF90aGlzLCAxKTtcbiAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgIH1cbiAgICAgICAgX2luaGVyaXRzKFBhbm5lck5vZGUsIF9hdWRpb05vZGVDb25zdHJ1Y3Rvcik7XG4gICAgICAgIHJldHVybiBfY3JlYXRlQ2xhc3MoUGFubmVyTm9kZSwgW3tcbiAgICAgICAgICBrZXk6IFwiY29uZUlubmVyQW5nbGVcIixcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9uYXRpdmVQYW5uZXJOb2RlLmNvbmVJbm5lckFuZ2xlO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX25hdGl2ZVBhbm5lck5vZGUuY29uZUlubmVyQW5nbGUgPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBrZXk6IFwiY29uZU91dGVyQW5nbGVcIixcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9uYXRpdmVQYW5uZXJOb2RlLmNvbmVPdXRlckFuZ2xlO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX25hdGl2ZVBhbm5lck5vZGUuY29uZU91dGVyQW5nbGUgPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBrZXk6IFwiY29uZU91dGVyR2FpblwiLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25hdGl2ZVBhbm5lck5vZGUuY29uZU91dGVyR2FpbjtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9uYXRpdmVQYW5uZXJOb2RlLmNvbmVPdXRlckdhaW4gPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBrZXk6IFwiZGlzdGFuY2VNb2RlbFwiLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25hdGl2ZVBhbm5lck5vZGUuZGlzdGFuY2VNb2RlbDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9uYXRpdmVQYW5uZXJOb2RlLmRpc3RhbmNlTW9kZWwgPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBrZXk6IFwibWF4RGlzdGFuY2VcIixcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9uYXRpdmVQYW5uZXJOb2RlLm1heERpc3RhbmNlO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX25hdGl2ZVBhbm5lck5vZGUubWF4RGlzdGFuY2UgPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBrZXk6IFwib3JpZW50YXRpb25YXCIsXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fb3JpZW50YXRpb25YO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIGtleTogXCJvcmllbnRhdGlvbllcIixcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9vcmllbnRhdGlvblk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcIm9yaWVudGF0aW9uWlwiLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX29yaWVudGF0aW9uWjtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBrZXk6IFwicGFubmluZ01vZGVsXCIsXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbmF0aXZlUGFubmVyTm9kZS5wYW5uaW5nTW9kZWw7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fbmF0aXZlUGFubmVyTm9kZS5wYW5uaW5nTW9kZWwgPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBrZXk6IFwicG9zaXRpb25YXCIsXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcG9zaXRpb25YO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIGtleTogXCJwb3NpdGlvbllcIixcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wb3NpdGlvblk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcInBvc2l0aW9uWlwiLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Bvc2l0aW9uWjtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBrZXk6IFwicmVmRGlzdGFuY2VcIixcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9uYXRpdmVQYW5uZXJOb2RlLnJlZkRpc3RhbmNlO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX25hdGl2ZVBhbm5lck5vZGUucmVmRGlzdGFuY2UgPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBrZXk6IFwicm9sbG9mZkZhY3RvclwiLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25hdGl2ZVBhbm5lck5vZGUucm9sbG9mZkZhY3RvcjtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9uYXRpdmVQYW5uZXJOb2RlLnJvbGxvZmZGYWN0b3IgPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1dKTtcbiAgICAgIH0oYXVkaW9Ob2RlQ29uc3RydWN0b3IpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBvd25LZXlzJDYoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuICAgIGZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkNihlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzJDYoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzJDYoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTsgfSk7IH0gcmV0dXJuIGU7IH1cbiAgICB2YXIgY3JlYXRlUGFubmVyTm9kZVJlbmRlcmVyRmFjdG9yeSA9IGZ1bmN0aW9uIGNyZWF0ZVBhbm5lck5vZGVSZW5kZXJlckZhY3RvcnkoY29ubmVjdEF1ZGlvUGFyYW0sIGNyZWF0ZU5hdGl2ZUNoYW5uZWxNZXJnZXJOb2RlLCBjcmVhdGVOYXRpdmVDb25zdGFudFNvdXJjZU5vZGUsIGNyZWF0ZU5hdGl2ZUdhaW5Ob2RlLCBjcmVhdGVOYXRpdmVQYW5uZXJOb2RlLCBnZXROYXRpdmVBdWRpb05vZGUsIG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHRDb25zdHJ1Y3RvciwgcmVuZGVyQXV0b21hdGlvbiwgcmVuZGVySW5wdXRzT2ZBdWRpb05vZGUsIHJlbmRlck5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZW5kZXJlZE5hdGl2ZUF1ZGlvTm9kZXMgPSBuZXcgV2Vha01hcCgpO1xuICAgICAgICB2YXIgcmVuZGVyZWRCdWZmZXJQcm9taXNlID0gbnVsbDtcbiAgICAgICAgdmFyIGNyZWF0ZUF1ZGlvTm9kZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIF9yZWYgPSBfYXN5bmNUb0dlbmVyYXRvcigvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUzKHByb3h5LCBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KSB7XG4gICAgICAgICAgICB2YXIgbmF0aXZlR2Fpbk5vZGUsIG5hdGl2ZVBhbm5lck5vZGUsIGNvbW1vbkF1ZGlvTm9kZU9wdGlvbnMsIGNvbW1vbk5hdGl2ZVBhbm5lck5vZGVPcHRpb25zLCBuYXRpdmVQYW5uZXJOb2RlSXNPd25lZEJ5Q29udGV4dCwgb3B0aW9ucywgcGFydGlhbE9mZmxpbmVBdWRpb0NvbnRleHQsIG5hdGl2ZUNoYW5uZWxNZXJnZXJOb2RlLCByZW5kZXJlZEJ1ZmZlciwgaW5wdXRHYWluTm9kZSwgY2hhbm5lbERhdGFzLCBpLCBsYXN0T3JpZW50YXRpb24sIGxhc3RQb3NpdGlvbiwgZ2F0ZUdhaW5Ob2RlLCBwYXJ0aWFsUGFubmVyTm9kZSwgX2ksIG9yaWVudGF0aW9uLCBwb3NpdG9uLCBjdXJyZW50VGltZTtcbiAgICAgICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZTMkKF9jb250ZXh0Mykge1xuICAgICAgICAgICAgICB3aGlsZSAoMSkgc3dpdGNoIChfY29udGV4dDMucHJldiA9IF9jb250ZXh0My5uZXh0KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgbmF0aXZlR2Fpbk5vZGUgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgbmF0aXZlUGFubmVyTm9kZSA9IGdldE5hdGl2ZUF1ZGlvTm9kZShwcm94eSk7XG4gICAgICAgICAgICAgICAgICBjb21tb25BdWRpb05vZGVPcHRpb25zID0ge1xuICAgICAgICAgICAgICAgICAgICBjaGFubmVsQ291bnQ6IG5hdGl2ZVBhbm5lck5vZGUuY2hhbm5lbENvdW50LFxuICAgICAgICAgICAgICAgICAgICBjaGFubmVsQ291bnRNb2RlOiBuYXRpdmVQYW5uZXJOb2RlLmNoYW5uZWxDb3VudE1vZGUsXG4gICAgICAgICAgICAgICAgICAgIGNoYW5uZWxJbnRlcnByZXRhdGlvbjogbmF0aXZlUGFubmVyTm9kZS5jaGFubmVsSW50ZXJwcmV0YXRpb25cbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICBjb21tb25OYXRpdmVQYW5uZXJOb2RlT3B0aW9ucyA9IF9vYmplY3RTcHJlYWQkNihfb2JqZWN0U3ByZWFkJDYoe30sIGNvbW1vbkF1ZGlvTm9kZU9wdGlvbnMpLCB7fSwge1xuICAgICAgICAgICAgICAgICAgICBjb25lSW5uZXJBbmdsZTogbmF0aXZlUGFubmVyTm9kZS5jb25lSW5uZXJBbmdsZSxcbiAgICAgICAgICAgICAgICAgICAgY29uZU91dGVyQW5nbGU6IG5hdGl2ZVBhbm5lck5vZGUuY29uZU91dGVyQW5nbGUsXG4gICAgICAgICAgICAgICAgICAgIGNvbmVPdXRlckdhaW46IG5hdGl2ZVBhbm5lck5vZGUuY29uZU91dGVyR2FpbixcbiAgICAgICAgICAgICAgICAgICAgZGlzdGFuY2VNb2RlbDogbmF0aXZlUGFubmVyTm9kZS5kaXN0YW5jZU1vZGVsLFxuICAgICAgICAgICAgICAgICAgICBtYXhEaXN0YW5jZTogbmF0aXZlUGFubmVyTm9kZS5tYXhEaXN0YW5jZSxcbiAgICAgICAgICAgICAgICAgICAgcGFubmluZ01vZGVsOiBuYXRpdmVQYW5uZXJOb2RlLnBhbm5pbmdNb2RlbCxcbiAgICAgICAgICAgICAgICAgICAgcmVmRGlzdGFuY2U6IG5hdGl2ZVBhbm5lck5vZGUucmVmRGlzdGFuY2UsXG4gICAgICAgICAgICAgICAgICAgIHJvbGxvZmZGYWN0b3I6IG5hdGl2ZVBhbm5lck5vZGUucm9sbG9mZkZhY3RvclxuICAgICAgICAgICAgICAgICAgfSk7IC8vIElmIHRoZSBpbml0aWFsbHkgdXNlZCBuYXRpdmVQYW5uZXJOb2RlIHdhcyBub3QgY29uc3RydWN0ZWQgb24gdGhlIHNhbWUgT2ZmbGluZUF1ZGlvQ29udGV4dCBpdCBuZWVkcyB0byBiZSBjcmVhdGVkIGFnYWluLlxuICAgICAgICAgICAgICAgICAgbmF0aXZlUGFubmVyTm9kZUlzT3duZWRCeUNvbnRleHQgPSBpc093bmVkQnlDb250ZXh0KG5hdGl2ZVBhbm5lck5vZGUsIG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQpOyAvLyBCdWcgIzEyNDogU2FmYXJpIGRvZXMgbm90IHN1cHBvcnQgbW9kaWZ5aW5nIHRoZSBvcmllbnRhdGlvbiBhbmQgdGhlIHBvc2l0aW9uIHdpdGggQXVkaW9QYXJhbXMuXG4gICAgICAgICAgICAgICAgICBpZiAoJ2J1ZmZlclNpemUnIGluIG5hdGl2ZVBhbm5lck5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbmF0aXZlR2Fpbk5vZGUgPSBjcmVhdGVOYXRpdmVHYWluTm9kZShuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LCBfb2JqZWN0U3ByZWFkJDYoX29iamVjdFNwcmVhZCQ2KHt9LCBjb21tb25BdWRpb05vZGVPcHRpb25zKSwge30sIHtcbiAgICAgICAgICAgICAgICAgICAgICBnYWluOiAxXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIW5hdGl2ZVBhbm5lck5vZGVJc093bmVkQnlDb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBfb2JqZWN0U3ByZWFkJDYoX29iamVjdFNwcmVhZCQ2KHt9LCBjb21tb25OYXRpdmVQYW5uZXJOb2RlT3B0aW9ucyksIHt9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgb3JpZW50YXRpb25YOiBuYXRpdmVQYW5uZXJOb2RlLm9yaWVudGF0aW9uWC52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICBvcmllbnRhdGlvblk6IG5hdGl2ZVBhbm5lck5vZGUub3JpZW50YXRpb25ZLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgIG9yaWVudGF0aW9uWjogbmF0aXZlUGFubmVyTm9kZS5vcmllbnRhdGlvbloudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25YOiBuYXRpdmVQYW5uZXJOb2RlLnBvc2l0aW9uWC52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvblk6IG5hdGl2ZVBhbm5lck5vZGUucG9zaXRpb25ZLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uWjogbmF0aXZlUGFubmVyTm9kZS5wb3NpdGlvbloudmFsdWVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIG5hdGl2ZVBhbm5lck5vZGUgPSBjcmVhdGVOYXRpdmVQYW5uZXJOb2RlKG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgcmVuZGVyZWROYXRpdmVBdWRpb05vZGVzLnNldChuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LCBuYXRpdmVHYWluTm9kZSA9PT0gbnVsbCA/IG5hdGl2ZVBhbm5lck5vZGUgOiBuYXRpdmVHYWluTm9kZSk7XG4gICAgICAgICAgICAgICAgICBpZiAoIShuYXRpdmVHYWluTm9kZSAhPT0gbnVsbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSAzMTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAoIShyZW5kZXJlZEJ1ZmZlclByb21pc2UgPT09IG51bGwpKSB7XG4gICAgICAgICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMTU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKCEobmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dENvbnN0cnVjdG9yID09PSBudWxsKSkge1xuICAgICAgICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDExO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyB0aGUgbmF0aXZlIE9mZmxpbmVBdWRpb0NvbnRleHQgY29uc3RydWN0b3IuJyk7XG4gICAgICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgICAgIHBhcnRpYWxPZmZsaW5lQXVkaW9Db250ZXh0ID0gbmV3IG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHRDb25zdHJ1Y3Rvcig2LFxuICAgICAgICAgICAgICAgICAgLy8gQnVnICMxNzogU2FmYXJpIGRvZXMgbm90IHlldCBleHBvc2UgdGhlIGxlbmd0aC5cbiAgICAgICAgICAgICAgICAgIHByb3h5LmNvbnRleHQubGVuZ3RoLCBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LnNhbXBsZVJhdGUpO1xuICAgICAgICAgICAgICAgICAgbmF0aXZlQ2hhbm5lbE1lcmdlck5vZGUgPSBjcmVhdGVOYXRpdmVDaGFubmVsTWVyZ2VyTm9kZShwYXJ0aWFsT2ZmbGluZUF1ZGlvQ29udGV4dCwge1xuICAgICAgICAgICAgICAgICAgICBjaGFubmVsQ291bnQ6IDEsXG4gICAgICAgICAgICAgICAgICAgIGNoYW5uZWxDb3VudE1vZGU6ICdleHBsaWNpdCcsXG4gICAgICAgICAgICAgICAgICAgIGNoYW5uZWxJbnRlcnByZXRhdGlvbjogJ3NwZWFrZXJzJyxcbiAgICAgICAgICAgICAgICAgICAgbnVtYmVyT2ZJbnB1dHM6IDZcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgbmF0aXZlQ2hhbm5lbE1lcmdlck5vZGUuY29ubmVjdChwYXJ0aWFsT2ZmbGluZUF1ZGlvQ29udGV4dC5kZXN0aW5hdGlvbik7XG4gICAgICAgICAgICAgICAgICByZW5kZXJlZEJ1ZmZlclByb21pc2UgPSBfYXN5bmNUb0dlbmVyYXRvcigvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmF0aXZlQ29uc3RhbnRTb3VyY2VOb2RlcywgaTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlMiQoX2NvbnRleHQyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQyLnByZXYgPSBfY29udGV4dDIubmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChbcHJveHkub3JpZW50YXRpb25YLCBwcm94eS5vcmllbnRhdGlvblksIHByb3h5Lm9yaWVudGF0aW9uWiwgcHJveHkucG9zaXRpb25YLCBwcm94eS5wb3NpdGlvblksIHByb3h5LnBvc2l0aW9uWl0ubWFwKC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9yZWYzID0gX2FzeW5jVG9HZW5lcmF0b3IoLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlKGF1ZGlvUGFyYW0sIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmF0aXZlQ29uc3RhbnRTb3VyY2VOb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoMSkgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hdGl2ZUNvbnN0YW50U291cmNlTm9kZSA9IGNyZWF0ZU5hdGl2ZUNvbnN0YW50U291cmNlTm9kZShwYXJ0aWFsT2ZmbGluZUF1ZGlvQ29udGV4dCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFubmVsQ291bnQ6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWxDb3VudE1vZGU6ICdleHBsaWNpdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWxJbnRlcnByZXRhdGlvbjogJ2Rpc2NyZXRlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiBpbmRleCA9PT0gMCA/IDEgOiAwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlbmRlckF1dG9tYXRpb24ocGFydGlhbE9mZmxpbmVBdWRpb0NvbnRleHQsIGF1ZGlvUGFyYW0sIG5hdGl2ZUNvbnN0YW50U291cmNlTm9kZS5vZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgbmF0aXZlQ29uc3RhbnRTb3VyY2VOb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgX2NhbGxlZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoX3gzLCBfeDQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfcmVmMy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0oKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICBuYXRpdmVDb25zdGFudFNvdXJjZU5vZGVzID0gX2NvbnRleHQyLnNlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCA2OyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYXRpdmVDb25zdGFudFNvdXJjZU5vZGVzW2ldLmNvbm5lY3QobmF0aXZlQ2hhbm5lbE1lcmdlck5vZGUsIDAsIGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hdGl2ZUNvbnN0YW50U291cmNlTm9kZXNbaV0uc3RhcnQoMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwgcmVuZGVyTmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dChwYXJ0aWFsT2ZmbGluZUF1ZGlvQ29udGV4dCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIF9jYWxsZWUyKTtcbiAgICAgICAgICAgICAgICAgIH0pKSgpO1xuICAgICAgICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDE3O1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlbmRlcmVkQnVmZmVyUHJvbWlzZTtcbiAgICAgICAgICAgICAgICBjYXNlIDE3OlxuICAgICAgICAgICAgICAgICAgcmVuZGVyZWRCdWZmZXIgPSBfY29udGV4dDMuc2VudDtcbiAgICAgICAgICAgICAgICAgIGlucHV0R2Fpbk5vZGUgPSBjcmVhdGVOYXRpdmVHYWluTm9kZShuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LCBfb2JqZWN0U3ByZWFkJDYoX29iamVjdFNwcmVhZCQ2KHt9LCBjb21tb25BdWRpb05vZGVPcHRpb25zKSwge30sIHtcbiAgICAgICAgICAgICAgICAgICAgZ2FpbjogMVxuICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSAyMTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiByZW5kZXJJbnB1dHNPZkF1ZGlvTm9kZShwcm94eSwgbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCwgaW5wdXRHYWluTm9kZSk7XG4gICAgICAgICAgICAgICAgY2FzZSAyMTpcbiAgICAgICAgICAgICAgICAgIGNoYW5uZWxEYXRhcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHJlbmRlcmVkQnVmZmVyLm51bWJlck9mQ2hhbm5lbHM7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICBjaGFubmVsRGF0YXMucHVzaChyZW5kZXJlZEJ1ZmZlci5nZXRDaGFubmVsRGF0YShpKSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBsYXN0T3JpZW50YXRpb24gPSBbY2hhbm5lbERhdGFzWzBdWzBdLCBjaGFubmVsRGF0YXNbMV1bMF0sIGNoYW5uZWxEYXRhc1syXVswXV07XG4gICAgICAgICAgICAgICAgICBsYXN0UG9zaXRpb24gPSBbY2hhbm5lbERhdGFzWzNdWzBdLCBjaGFubmVsRGF0YXNbNF1bMF0sIGNoYW5uZWxEYXRhc1s1XVswXV07XG4gICAgICAgICAgICAgICAgICBnYXRlR2Fpbk5vZGUgPSBjcmVhdGVOYXRpdmVHYWluTm9kZShuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LCBfb2JqZWN0U3ByZWFkJDYoX29iamVjdFNwcmVhZCQ2KHt9LCBjb21tb25BdWRpb05vZGVPcHRpb25zKSwge30sIHtcbiAgICAgICAgICAgICAgICAgICAgZ2FpbjogMVxuICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgcGFydGlhbFBhbm5lck5vZGUgPSBjcmVhdGVOYXRpdmVQYW5uZXJOb2RlKG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQsIF9vYmplY3RTcHJlYWQkNihfb2JqZWN0U3ByZWFkJDYoe30sIGNvbW1vbk5hdGl2ZVBhbm5lck5vZGVPcHRpb25zKSwge30sIHtcbiAgICAgICAgICAgICAgICAgICAgb3JpZW50YXRpb25YOiBsYXN0T3JpZW50YXRpb25bMF0sXG4gICAgICAgICAgICAgICAgICAgIG9yaWVudGF0aW9uWTogbGFzdE9yaWVudGF0aW9uWzFdLFxuICAgICAgICAgICAgICAgICAgICBvcmllbnRhdGlvblo6IGxhc3RPcmllbnRhdGlvblsyXSxcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25YOiBsYXN0UG9zaXRpb25bMF0sXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uWTogbGFzdFBvc2l0aW9uWzFdLFxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvblo6IGxhc3RQb3NpdGlvblsyXVxuICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgaW5wdXRHYWluTm9kZS5jb25uZWN0KGdhdGVHYWluTm9kZSkuY29ubmVjdChwYXJ0aWFsUGFubmVyTm9kZS5pbnB1dHNbMF0pO1xuICAgICAgICAgICAgICAgICAgcGFydGlhbFBhbm5lck5vZGUuY29ubmVjdChuYXRpdmVHYWluTm9kZSk7XG4gICAgICAgICAgICAgICAgICBmb3IgKF9pID0gMTI4OyBfaSA8IHJlbmRlcmVkQnVmZmVyLmxlbmd0aDsgX2kgKz0gMTI4KSB7XG4gICAgICAgICAgICAgICAgICAgIG9yaWVudGF0aW9uID0gW2NoYW5uZWxEYXRhc1swXVtfaV0sIGNoYW5uZWxEYXRhc1sxXVtfaV0sIGNoYW5uZWxEYXRhc1syXVtfaV1dO1xuICAgICAgICAgICAgICAgICAgICBwb3NpdG9uID0gW2NoYW5uZWxEYXRhc1szXVtfaV0sIGNoYW5uZWxEYXRhc1s0XVtfaV0sIGNoYW5uZWxEYXRhc1s1XVtfaV1dO1xuICAgICAgICAgICAgICAgICAgICBpZiAob3JpZW50YXRpb24uc29tZShmdW5jdGlvbiAodmFsdWUsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlICE9PSBsYXN0T3JpZW50YXRpb25baW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICB9KSB8fCBwb3NpdG9uLnNvbWUoZnVuY3Rpb24gKHZhbHVlLCBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSAhPT0gbGFzdFBvc2l0aW9uW2luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICBsYXN0T3JpZW50YXRpb24gPSBvcmllbnRhdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgICBsYXN0UG9zaXRpb24gPSBwb3NpdG9uO1xuICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUaW1lID0gX2kgLyBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LnNhbXBsZVJhdGU7XG4gICAgICAgICAgICAgICAgICAgICAgZ2F0ZUdhaW5Ob2RlLmdhaW4uc2V0VmFsdWVBdFRpbWUoMCwgY3VycmVudFRpbWUpO1xuICAgICAgICAgICAgICAgICAgICAgIGdhdGVHYWluTm9kZSA9IGNyZWF0ZU5hdGl2ZUdhaW5Ob2RlKG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQsIF9vYmplY3RTcHJlYWQkNihfb2JqZWN0U3ByZWFkJDYoe30sIGNvbW1vbkF1ZGlvTm9kZU9wdGlvbnMpLCB7fSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2FpbjogMFxuICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICBwYXJ0aWFsUGFubmVyTm9kZSA9IGNyZWF0ZU5hdGl2ZVBhbm5lck5vZGUobmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCwgX29iamVjdFNwcmVhZCQ2KF9vYmplY3RTcHJlYWQkNih7fSwgY29tbW9uTmF0aXZlUGFubmVyTm9kZU9wdGlvbnMpLCB7fSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3JpZW50YXRpb25YOiBsYXN0T3JpZW50YXRpb25bMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBvcmllbnRhdGlvblk6IGxhc3RPcmllbnRhdGlvblsxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9yaWVudGF0aW9uWjogbGFzdE9yaWVudGF0aW9uWzJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25YOiBsYXN0UG9zaXRpb25bMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvblk6IGxhc3RQb3NpdGlvblsxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uWjogbGFzdFBvc2l0aW9uWzJdXG4gICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgIGdhdGVHYWluTm9kZS5nYWluLnNldFZhbHVlQXRUaW1lKDEsIGN1cnJlbnRUaW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICBpbnB1dEdhaW5Ob2RlLmNvbm5lY3QoZ2F0ZUdhaW5Ob2RlKS5jb25uZWN0KHBhcnRpYWxQYW5uZXJOb2RlLmlucHV0c1swXSk7XG4gICAgICAgICAgICAgICAgICAgICAgcGFydGlhbFBhbm5lck5vZGUuY29ubmVjdChuYXRpdmVHYWluTm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuYWJydXB0KFwicmV0dXJuXCIsIG5hdGl2ZUdhaW5Ob2RlKTtcbiAgICAgICAgICAgICAgICBjYXNlIDMxOlxuICAgICAgICAgICAgICAgICAgaWYgKG5hdGl2ZVBhbm5lck5vZGVJc093bmVkQnlDb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gNDY7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSAzNDtcbiAgICAgICAgICAgICAgICAgIHJldHVybiByZW5kZXJBdXRvbWF0aW9uKG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQsIHByb3h5Lm9yaWVudGF0aW9uWCwgbmF0aXZlUGFubmVyTm9kZS5vcmllbnRhdGlvblgpO1xuICAgICAgICAgICAgICAgIGNhc2UgMzQ6XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDM2O1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlbmRlckF1dG9tYXRpb24obmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCwgcHJveHkub3JpZW50YXRpb25ZLCBuYXRpdmVQYW5uZXJOb2RlLm9yaWVudGF0aW9uWSk7XG4gICAgICAgICAgICAgICAgY2FzZSAzNjpcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMzg7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcmVuZGVyQXV0b21hdGlvbihuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LCBwcm94eS5vcmllbnRhdGlvblosIG5hdGl2ZVBhbm5lck5vZGUub3JpZW50YXRpb25aKTtcbiAgICAgICAgICAgICAgICBjYXNlIDM4OlxuICAgICAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSA0MDtcbiAgICAgICAgICAgICAgICAgIHJldHVybiByZW5kZXJBdXRvbWF0aW9uKG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQsIHByb3h5LnBvc2l0aW9uWCwgbmF0aXZlUGFubmVyTm9kZS5wb3NpdGlvblgpO1xuICAgICAgICAgICAgICAgIGNhc2UgNDA6XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDQyO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlbmRlckF1dG9tYXRpb24obmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCwgcHJveHkucG9zaXRpb25ZLCBuYXRpdmVQYW5uZXJOb2RlLnBvc2l0aW9uWSk7XG4gICAgICAgICAgICAgICAgY2FzZSA0MjpcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gNDQ7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcmVuZGVyQXV0b21hdGlvbihuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LCBwcm94eS5wb3NpdGlvblosIG5hdGl2ZVBhbm5lck5vZGUucG9zaXRpb25aKTtcbiAgICAgICAgICAgICAgICBjYXNlIDQ0OlxuICAgICAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSA1ODtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDY6XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDQ4O1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbm5lY3RBdWRpb1BhcmFtKG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQsIHByb3h5Lm9yaWVudGF0aW9uWCwgbmF0aXZlUGFubmVyTm9kZS5vcmllbnRhdGlvblgpO1xuICAgICAgICAgICAgICAgIGNhc2UgNDg6XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDUwO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbm5lY3RBdWRpb1BhcmFtKG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQsIHByb3h5Lm9yaWVudGF0aW9uWSwgbmF0aXZlUGFubmVyTm9kZS5vcmllbnRhdGlvblkpO1xuICAgICAgICAgICAgICAgIGNhc2UgNTA6XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDUyO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbm5lY3RBdWRpb1BhcmFtKG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQsIHByb3h5Lm9yaWVudGF0aW9uWiwgbmF0aXZlUGFubmVyTm9kZS5vcmllbnRhdGlvblopO1xuICAgICAgICAgICAgICAgIGNhc2UgNTI6XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDU0O1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbm5lY3RBdWRpb1BhcmFtKG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQsIHByb3h5LnBvc2l0aW9uWCwgbmF0aXZlUGFubmVyTm9kZS5wb3NpdGlvblgpO1xuICAgICAgICAgICAgICAgIGNhc2UgNTQ6XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDU2O1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbm5lY3RBdWRpb1BhcmFtKG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQsIHByb3h5LnBvc2l0aW9uWSwgbmF0aXZlUGFubmVyTm9kZS5wb3NpdGlvblkpO1xuICAgICAgICAgICAgICAgIGNhc2UgNTY6XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDU4O1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbm5lY3RBdWRpb1BhcmFtKG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQsIHByb3h5LnBvc2l0aW9uWiwgbmF0aXZlUGFubmVyTm9kZS5wb3NpdGlvblopO1xuICAgICAgICAgICAgICAgIGNhc2UgNTg6XG4gICAgICAgICAgICAgICAgICBpZiAoIWlzTmF0aXZlQXVkaW9Ob2RlRmFrZXIobmF0aXZlUGFubmVyTm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSA2MztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDYxO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlbmRlcklucHV0c09mQXVkaW9Ob2RlKHByb3h5LCBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LCBuYXRpdmVQYW5uZXJOb2RlLmlucHV0c1swXSk7XG4gICAgICAgICAgICAgICAgY2FzZSA2MTpcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gNjU7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDYzOlxuICAgICAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSA2NTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiByZW5kZXJJbnB1dHNPZkF1ZGlvTm9kZShwcm94eSwgbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCwgbmF0aXZlUGFubmVyTm9kZSk7XG4gICAgICAgICAgICAgICAgY2FzZSA2NTpcbiAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuYWJydXB0KFwicmV0dXJuXCIsIG5hdGl2ZVBhbm5lck5vZGUpO1xuICAgICAgICAgICAgICAgIGNhc2UgNjY6XG4gICAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5zdG9wKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIF9jYWxsZWUzKTtcbiAgICAgICAgICB9KSk7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZUF1ZGlvTm9kZShfeCwgX3gyKSB7XG4gICAgICAgICAgICByZXR1cm4gX3JlZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgIH07XG4gICAgICAgIH0oKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihwcm94eSwgbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCkge1xuICAgICAgICAgICAgdmFyIHJlbmRlcmVkTmF0aXZlR2Fpbk5vZGVPck5hdGl2ZVBhbm5lck5vZGUgPSByZW5kZXJlZE5hdGl2ZUF1ZGlvTm9kZXMuZ2V0KG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQpO1xuICAgICAgICAgICAgaWYgKHJlbmRlcmVkTmF0aXZlR2Fpbk5vZGVPck5hdGl2ZVBhbm5lck5vZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlbmRlcmVkTmF0aXZlR2Fpbk5vZGVPck5hdGl2ZVBhbm5lck5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUF1ZGlvTm9kZShwcm94eSwgbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gb3duS2V5cyQ1KGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cbiAgICBmdW5jdGlvbiBfb2JqZWN0U3ByZWFkJDUoZSkgeyBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykgeyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gb3duS2V5cyQ1KE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyQ1KE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XG4gICAgdmFyIERFRkFVTFRfT1BUSU9OUyQyID0ge1xuICAgICAgZGlzYWJsZU5vcm1hbGl6YXRpb246IGZhbHNlXG4gICAgfTtcbiAgICB2YXIgY3JlYXRlUGVyaW9kaWNXYXZlQ29uc3RydWN0b3IgPSBmdW5jdGlvbiBjcmVhdGVQZXJpb2RpY1dhdmVDb25zdHJ1Y3RvcihjcmVhdGVOYXRpdmVQZXJpb2RpY1dhdmUsIGdldE5hdGl2ZUNvbnRleHQsIHBlcmlvZGljV2F2ZVN0b3JlLCBzYW5pdGl6ZVBlcmlvZGljV2F2ZU9wdGlvbnMpIHtcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBQZXJpb2RpY1dhdmUoY29udGV4dCwgb3B0aW9ucykge1xuICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQZXJpb2RpY1dhdmUpO1xuICAgICAgICAgIHZhciBuYXRpdmVDb250ZXh0ID0gZ2V0TmF0aXZlQ29udGV4dChjb250ZXh0KTtcbiAgICAgICAgICB2YXIgbWVyZ2VkT3B0aW9ucyA9IHNhbml0aXplUGVyaW9kaWNXYXZlT3B0aW9ucyhfb2JqZWN0U3ByZWFkJDUoX29iamVjdFNwcmVhZCQ1KHt9LCBERUZBVUxUX09QVElPTlMkMiksIG9wdGlvbnMpKTtcbiAgICAgICAgICB2YXIgcGVyaW9kaWNXYXZlID0gY3JlYXRlTmF0aXZlUGVyaW9kaWNXYXZlKG5hdGl2ZUNvbnRleHQsIG1lcmdlZE9wdGlvbnMpO1xuICAgICAgICAgIHBlcmlvZGljV2F2ZVN0b3JlLmFkZChwZXJpb2RpY1dhdmUpO1xuICAgICAgICAgIC8vIFRoaXMgZG9lcyB2aW9sYXRlIGFsbCBnb29kIHByYXRpY2VzIGJ1dCBpdCBpcyB1c2VkIGhlcmUgdG8gc2ltcGxpZnkgdGhlIGhhbmRsaW5nIG9mIHBlcmlvZGljIHdhdmVzLlxuICAgICAgICAgIHJldHVybiBwZXJpb2RpY1dhdmU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9jcmVhdGVDbGFzcyhQZXJpb2RpY1dhdmUsIG51bGwsIFt7XG4gICAgICAgICAga2V5OiBTeW1ib2wuaGFzSW5zdGFuY2UsXG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKGluc3RhbmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5zdGFuY2UgIT09IG51bGwgJiYgX3R5cGVvZihpbnN0YW5jZSkgPT09ICdvYmplY3QnICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihpbnN0YW5jZSkgPT09IFBlcmlvZGljV2F2ZS5wcm90b3R5cGUgfHwgcGVyaW9kaWNXYXZlU3RvcmUuaGFzKGluc3RhbmNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1dKTtcbiAgICAgIH0oKTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZVJlbmRlckF1dG9tYXRpb24gPSBmdW5jdGlvbiBjcmVhdGVSZW5kZXJBdXRvbWF0aW9uKGdldEF1ZGlvUGFyYW1SZW5kZXJlciwgcmVuZGVySW5wdXRzT2ZBdWRpb1BhcmFtKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQsIGF1ZGlvUGFyYW0sIG5hdGl2ZUF1ZGlvUGFyYW0pIHtcbiAgICAgICAgdmFyIGF1ZGlvUGFyYW1SZW5kZXJlciA9IGdldEF1ZGlvUGFyYW1SZW5kZXJlcihhdWRpb1BhcmFtKTtcbiAgICAgICAgYXVkaW9QYXJhbVJlbmRlcmVyLnJlcGxheShuYXRpdmVBdWRpb1BhcmFtKTtcbiAgICAgICAgcmV0dXJuIHJlbmRlcklucHV0c09mQXVkaW9QYXJhbShhdWRpb1BhcmFtLCBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LCBuYXRpdmVBdWRpb1BhcmFtKTtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVSZW5kZXJJbnB1dHNPZkF1ZGlvTm9kZSA9IGZ1bmN0aW9uIGNyZWF0ZVJlbmRlcklucHV0c09mQXVkaW9Ob2RlKGdldEF1ZGlvTm9kZUNvbm5lY3Rpb25zLCBnZXRBdWRpb05vZGVSZW5kZXJlciwgaXNQYXJ0T2ZBQ3ljbGUpIHtcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3JlZiA9IF9hc3luY1RvR2VuZXJhdG9yKC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIoYXVkaW9Ob2RlLCBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LCBuYXRpdmVBdWRpb05vZGUpIHtcbiAgICAgICAgICB2YXIgYXVkaW9Ob2RlQ29ubmVjdGlvbnM7XG4gICAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlMiQoX2NvbnRleHQyKSB7XG4gICAgICAgICAgICB3aGlsZSAoMSkgc3dpdGNoIChfY29udGV4dDIucHJldiA9IF9jb250ZXh0Mi5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBhdWRpb05vZGVDb25uZWN0aW9ucyA9IGdldEF1ZGlvTm9kZUNvbm5lY3Rpb25zKGF1ZGlvTm9kZSk7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAzO1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChhdWRpb05vZGVDb25uZWN0aW9ucy5hY3RpdmVJbnB1dHMubWFwKGZ1bmN0aW9uIChjb25uZWN0aW9ucywgaW5wdXQpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBBcnJheS5mcm9tKGNvbm5lY3Rpb25zKS5tYXAoLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9yZWYzID0gX2FzeW5jVG9HZW5lcmF0b3IoLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlKF9yZWYyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIF9yZWY0LCBzb3VyY2UsIG91dHB1dCwgYXVkaW9Ob2RlUmVuZGVyZXIsIHJlbmRlcmVkTmF0aXZlQXVkaW9Ob2RlLCBkZXN0aW5hdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoMSkgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3JlZjQgPSBfc2xpY2VkVG9BcnJheShfcmVmMiwgMiksIHNvdXJjZSA9IF9yZWY0WzBdLCBvdXRwdXQgPSBfcmVmNFsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdWRpb05vZGVSZW5kZXJlciA9IGdldEF1ZGlvTm9kZVJlbmRlcmVyKHNvdXJjZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF1ZGlvTm9kZVJlbmRlcmVyLnJlbmRlcihzb3VyY2UsIG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyZWROYXRpdmVBdWRpb05vZGUgPSBfY29udGV4dC5zZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uID0gYXVkaW9Ob2RlLmNvbnRleHQuZGVzdGluYXRpb247XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1BhcnRPZkFDeWNsZShzb3VyY2UpICYmIChhdWRpb05vZGUgIT09IGRlc3RpbmF0aW9uIHx8ICFpc1BhcnRPZkFDeWNsZShhdWRpb05vZGUpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyZWROYXRpdmVBdWRpb05vZGUuY29ubmVjdChuYXRpdmVBdWRpb05vZGUsIG91dHB1dCwgaW5wdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9LCBfY2FsbGVlKTtcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKF94NCkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfcmVmMy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgfSgpKTtcbiAgICAgICAgICAgICAgICB9KS5yZWR1Y2UoZnVuY3Rpb24gKGFsbFJlbmRlcmluZ1Byb21pc2VzLCByZW5kZXJpbmdQcm9taXNlcykge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkoYWxsUmVuZGVyaW5nUHJvbWlzZXMpLCBfdG9Db25zdW1hYmxlQXJyYXkocmVuZGVyaW5nUHJvbWlzZXMpKTtcbiAgICAgICAgICAgICAgICB9LCBbXSkpO1xuICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCBfY2FsbGVlMik7XG4gICAgICAgIH0pKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChfeCwgX3gyLCBfeDMpIHtcbiAgICAgICAgICByZXR1cm4gX3JlZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9O1xuICAgICAgfSgpO1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlUmVuZGVySW5wdXRzT2ZBdWRpb1BhcmFtID0gZnVuY3Rpb24gY3JlYXRlUmVuZGVySW5wdXRzT2ZBdWRpb1BhcmFtKGdldEF1ZGlvTm9kZVJlbmRlcmVyLCBnZXRBdWRpb1BhcmFtQ29ubmVjdGlvbnMsIGlzUGFydE9mQUN5Y2xlKSB7XG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9yZWYgPSBfYXN5bmNUb0dlbmVyYXRvcigvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyKGF1ZGlvUGFyYW0sIG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQsIG5hdGl2ZUF1ZGlvUGFyYW0pIHtcbiAgICAgICAgICB2YXIgYXVkaW9QYXJhbUNvbm5lY3Rpb25zO1xuICAgICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0Mikge1xuICAgICAgICAgICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQyLnByZXYgPSBfY29udGV4dDIubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgYXVkaW9QYXJhbUNvbm5lY3Rpb25zID0gZ2V0QXVkaW9QYXJhbUNvbm5lY3Rpb25zKGF1ZGlvUGFyYW0pO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMztcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoQXJyYXkuZnJvbShhdWRpb1BhcmFtQ29ubmVjdGlvbnMuYWN0aXZlSW5wdXRzKS5tYXAoLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBfcmVmMyA9IF9hc3luY1RvR2VuZXJhdG9yKC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZShfcmVmMikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX3JlZjQsIHNvdXJjZSwgb3V0cHV0LCBhdWRpb05vZGVSZW5kZXJlciwgcmVuZGVyZWROYXRpdmVBdWRpb05vZGU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoMSkgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICBfcmVmNCA9IF9zbGljZWRUb0FycmF5KF9yZWYyLCAyKSwgc291cmNlID0gX3JlZjRbMF0sIG91dHB1dCA9IF9yZWY0WzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBhdWRpb05vZGVSZW5kZXJlciA9IGdldEF1ZGlvTm9kZVJlbmRlcmVyKHNvdXJjZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXVkaW9Ob2RlUmVuZGVyZXIucmVuZGVyKHNvdXJjZSwgbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlcmVkTmF0aXZlQXVkaW9Ob2RlID0gX2NvbnRleHQuc2VudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1BhcnRPZkFDeWNsZShzb3VyY2UpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyZWROYXRpdmVBdWRpb05vZGUuY29ubmVjdChuYXRpdmVBdWRpb1BhcmFtLCBvdXRwdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCBfY2FsbGVlKTtcbiAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoX3g0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfcmVmMy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KCkpKTtcbiAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgX2NhbGxlZTIpO1xuICAgICAgICB9KSk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoX3gsIF94MiwgX3gzKSB7XG4gICAgICAgICAgcmV0dXJuIF9yZWYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICAgIH0oKTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZVJlbmRlck5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQgPSBmdW5jdGlvbiBjcmVhdGVSZW5kZXJOYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KGNhY2hlVGVzdFJlc3VsdCwgY3JlYXRlTmF0aXZlR2Fpbk5vZGUsIGNyZWF0ZU5hdGl2ZVNjcmlwdFByb2Nlc3Nvck5vZGUsIHRlc3RPZmZsaW5lQXVkaW9Db250ZXh0Q3VycmVudFRpbWVTdXBwb3J0KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQpIHtcbiAgICAgICAgLy8gQnVnICMyMTogU2FmYXJpIGRvZXMgbm90IHN1cHBvcnQgcHJvbWlzZXMgeWV0LlxuICAgICAgICBpZiAoY2FjaGVUZXN0UmVzdWx0KHRlc3RQcm9taXNlU3VwcG9ydCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB0ZXN0UHJvbWlzZVN1cHBvcnQobmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCk7XG4gICAgICAgIH0pKSB7XG4gICAgICAgICAgLy8gQnVnICMxNTg6IENocm9tZSBhbmQgRWRnZSBkbyBub3QgYWR2YW5jZSBjdXJyZW50VGltZSBpZiBpdCBpcyBub3QgYWNjZXNzZWQgd2hpbGUgcmVuZGVyaW5nIHRoZSBhdWRpby5cbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGNhY2hlVGVzdFJlc3VsdCh0ZXN0T2ZmbGluZUF1ZGlvQ29udGV4dEN1cnJlbnRUaW1lU3VwcG9ydCwgdGVzdE9mZmxpbmVBdWRpb0NvbnRleHRDdXJyZW50VGltZVN1cHBvcnQpKS50aGVuKGZ1bmN0aW9uIChpc09mZmxpbmVBdWRpb0NvbnRleHRDdXJyZW50VGltZVN1cHBvcnRlZCkge1xuICAgICAgICAgICAgaWYgKCFpc09mZmxpbmVBdWRpb0NvbnRleHRDdXJyZW50VGltZVN1cHBvcnRlZCkge1xuICAgICAgICAgICAgICB2YXIgc2NyaXB0UHJvY2Vzc29yTm9kZSA9IGNyZWF0ZU5hdGl2ZVNjcmlwdFByb2Nlc3Nvck5vZGUobmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCwgNTEyLCAwLCAxKTtcbiAgICAgICAgICAgICAgbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dC5vbmNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHNjcmlwdFByb2Nlc3Nvck5vZGUub25hdWRpb3Byb2Nlc3MgPSBudWxsOyAvLyB0c2xpbnQ6ZGlzYWJsZS1saW5lOmRlcHJlY2F0aW9uXG4gICAgICAgICAgICAgICAgc2NyaXB0UHJvY2Vzc29yTm9kZS5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIHNjcmlwdFByb2Nlc3Nvck5vZGUub25hdWRpb3Byb2Nlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQuY3VycmVudFRpbWU7XG4gICAgICAgICAgICAgIH07IC8vIHRzbGludDpkaXNhYmxlLWxpbmU6ZGVwcmVjYXRpb25cbiAgICAgICAgICAgICAgc2NyaXB0UHJvY2Vzc29yTm9kZS5jb25uZWN0KG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQuZGVzdGluYXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQuc3RhcnRSZW5kZXJpbmcoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICAvLyBCdWcgIzQ4OiBTYWZhcmkgZG9lcyBub3QgcmVuZGVyIGFuIE9mZmxpbmVBdWRpb0NvbnRleHQgd2l0aG91dCBhbnkgY29ubmVjdGVkIG5vZGUuXG4gICAgICAgICAgdmFyIGdhaW5Ob2RlID0gY3JlYXRlTmF0aXZlR2Fpbk5vZGUobmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCwge1xuICAgICAgICAgICAgY2hhbm5lbENvdW50OiAxLFxuICAgICAgICAgICAgY2hhbm5lbENvdW50TW9kZTogJ2V4cGxpY2l0JyxcbiAgICAgICAgICAgIGNoYW5uZWxJbnRlcnByZXRhdGlvbjogJ2Rpc2NyZXRlJyxcbiAgICAgICAgICAgIGdhaW46IDBcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0Lm9uY29tcGxldGUgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGdhaW5Ob2RlLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIHJlc29sdmUoZXZlbnQucmVuZGVyZWRCdWZmZXIpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgZ2Fpbk5vZGUuY29ubmVjdChuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LmRlc3RpbmF0aW9uKTtcbiAgICAgICAgICBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LnN0YXJ0UmVuZGVyaW5nKCk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZVNldEFjdGl2ZUF1ZGlvV29ya2xldE5vZGVJbnB1dHMgPSBmdW5jdGlvbiBjcmVhdGVTZXRBY3RpdmVBdWRpb1dvcmtsZXROb2RlSW5wdXRzKGFjdGl2ZUF1ZGlvV29ya2xldE5vZGVJbnB1dHNTdG9yZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChuYXRpdmVBdWRpb1dvcmtsZXROb2RlLCBhY3RpdmVJbnB1dHMpIHtcbiAgICAgICAgYWN0aXZlQXVkaW9Xb3JrbGV0Tm9kZUlucHV0c1N0b3JlLnNldChuYXRpdmVBdWRpb1dvcmtsZXROb2RlLCBhY3RpdmVJbnB1dHMpO1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZVNldEF1ZGlvTm9kZVRhaWxUaW1lID0gZnVuY3Rpb24gY3JlYXRlU2V0QXVkaW9Ob2RlVGFpbFRpbWUoYXVkaW9Ob2RlVGFpbFRpbWVTdG9yZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhdWRpb05vZGUsIHRhaWxUaW1lKSB7XG4gICAgICAgIHJldHVybiBhdWRpb05vZGVUYWlsVGltZVN0b3JlLnNldChhdWRpb05vZGUsIHRhaWxUaW1lKTtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVTdGFydFJlbmRlcmluZyA9IGZ1bmN0aW9uIGNyZWF0ZVN0YXJ0UmVuZGVyaW5nKGF1ZGlvQnVmZmVyU3RvcmUsIGNhY2hlVGVzdFJlc3VsdCwgZ2V0QXVkaW9Ob2RlUmVuZGVyZXIsIGdldFVucmVuZGVyZWRBdWRpb1dvcmtsZXROb2RlcywgcmVuZGVyTmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCwgdGVzdEF1ZGlvQnVmZmVyQ29weUNoYW5uZWxNZXRob2RzT3V0T2ZCb3VuZHNTdXBwb3J0LCB3cmFwQXVkaW9CdWZmZXJDb3B5Q2hhbm5lbE1ldGhvZHMsIHdyYXBBdWRpb0J1ZmZlckNvcHlDaGFubmVsTWV0aG9kc091dE9mQm91bmRzKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGRlc3RpbmF0aW9uLCBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KSB7XG4gICAgICAgIHJldHVybiBnZXRBdWRpb05vZGVSZW5kZXJlcihkZXN0aW5hdGlvbikucmVuZGVyKGRlc3RpbmF0aW9uLCBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KVxuICAgICAgICAvKlxuICAgICAgICAgKiBCdWcgIzg2ICYgIzg3OiBJbnZva2luZyB0aGUgcmVuZGVyZXIgb2YgYW4gQXVkaW9Xb3JrbGV0Tm9kZSBtaWdodCBiZSBuZWNlc3NhcnkgaWYgaXQgaGFzIG5vIGRpcmVjdCBvciBpbmRpcmVjdCBjb25uZWN0aW9uIHRvIHRoZVxuICAgICAgICAgKiBkZXN0aW5hdGlvbi5cbiAgICAgICAgICovLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChBcnJheS5mcm9tKGdldFVucmVuZGVyZWRBdWRpb1dvcmtsZXROb2RlcyhuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KSkubWFwKGZ1bmN0aW9uIChhdWRpb1dvcmtsZXROb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0QXVkaW9Ob2RlUmVuZGVyZXIoYXVkaW9Xb3JrbGV0Tm9kZSkucmVuZGVyKGF1ZGlvV29ya2xldE5vZGUsIG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQpO1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHJlbmRlck5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQobmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCk7XG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKGF1ZGlvQnVmZmVyKSB7XG4gICAgICAgICAgLy8gQnVnICM1OiBTYWZhcmkgZG9lcyBub3Qgc3VwcG9ydCBjb3B5RnJvbUNoYW5uZWwoKSBhbmQgY29weVRvQ2hhbm5lbCgpLlxuICAgICAgICAgIC8vIEJ1ZyAjMTAwOiBTYWZhcmkgZG9lcyB0aHJvdyBhIHdyb25nIGVycm9yIHdoZW4gY2FsbGluZyBnZXRDaGFubmVsRGF0YSgpIHdpdGggYW4gb3V0LW9mLWJvdW5kcyB2YWx1ZS5cbiAgICAgICAgICBpZiAodHlwZW9mIGF1ZGlvQnVmZmVyLmNvcHlGcm9tQ2hhbm5lbCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgd3JhcEF1ZGlvQnVmZmVyQ29weUNoYW5uZWxNZXRob2RzKGF1ZGlvQnVmZmVyKTtcbiAgICAgICAgICAgIHdyYXBBdWRpb0J1ZmZlckdldENoYW5uZWxEYXRhTWV0aG9kKGF1ZGlvQnVmZmVyKTtcbiAgICAgICAgICAgIC8vIEJ1ZyAjMTU3OiBGaXJlZm94IGRvZXMgbm90IGFsbG93IHRoZSBidWZmZXJPZmZzZXQgdG8gYmUgb3V0LW9mLWJvdW5kcy5cbiAgICAgICAgICB9IGVsc2UgaWYgKCFjYWNoZVRlc3RSZXN1bHQodGVzdEF1ZGlvQnVmZmVyQ29weUNoYW5uZWxNZXRob2RzT3V0T2ZCb3VuZHNTdXBwb3J0LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGVzdEF1ZGlvQnVmZmVyQ29weUNoYW5uZWxNZXRob2RzT3V0T2ZCb3VuZHNTdXBwb3J0KGF1ZGlvQnVmZmVyKTtcbiAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgd3JhcEF1ZGlvQnVmZmVyQ29weUNoYW5uZWxNZXRob2RzT3V0T2ZCb3VuZHMoYXVkaW9CdWZmZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhdWRpb0J1ZmZlclN0b3JlLmFkZChhdWRpb0J1ZmZlcik7XG4gICAgICAgICAgcmV0dXJuIGF1ZGlvQnVmZmVyO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIG93bktleXMkNChlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XG4gICAgZnVuY3Rpb24gX29iamVjdFNwcmVhZCQ0KGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMkNChPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMkNChPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxuICAgIGZ1bmN0aW9uIF9jYWxsU3VwZXIkMSh0LCBvLCBlKSB7IHJldHVybiBvID0gX2dldFByb3RvdHlwZU9mKG8pLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0LCBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JDEoKSA/IFJlZmxlY3QuY29uc3RydWN0KG8sIGUgfHwgW10sIF9nZXRQcm90b3R5cGVPZih0KS5jb25zdHJ1Y3RvcikgOiBvLmFwcGx5KHQsIGUpKTsgfVxuICAgIGZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkMSgpIHsgdHJ5IHsgdmFyIHQgPSAhQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyB9IGNhdGNoICh0KSB7fSByZXR1cm4gKF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkMSA9IGZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IHJldHVybiAhIXQ7IH0pKCk7IH1cbiAgICB2YXIgREVGQVVMVF9PUFRJT05TJDEgPSB7XG4gICAgICBjaGFubmVsQ291bnQ6IDIsXG4gICAgICAvKlxuICAgICAgICogQnVnICMxMDU6IFRoZSBjaGFubmVsQ291bnRNb2RlIHNob3VsZCBiZSAnY2xhbXBlZC1tYXgnIGFjY29yZGluZyB0byB0aGUgc3BlYyBidXQgaXMgc2V0IHRvICdleHBsaWNpdCcgdG8gYWNoaWV2ZSBjb25zaXN0ZW50XG4gICAgICAgKiBiZWhhdmlvci5cbiAgICAgICAqL1xuICAgICAgY2hhbm5lbENvdW50TW9kZTogJ2V4cGxpY2l0JyxcbiAgICAgIGNoYW5uZWxJbnRlcnByZXRhdGlvbjogJ3NwZWFrZXJzJyxcbiAgICAgIHBhbjogMFxuICAgIH07XG4gICAgdmFyIGNyZWF0ZVN0ZXJlb1Bhbm5lck5vZGVDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uIGNyZWF0ZVN0ZXJlb1Bhbm5lck5vZGVDb25zdHJ1Y3RvcihhdWRpb05vZGVDb25zdHJ1Y3RvciwgY3JlYXRlQXVkaW9QYXJhbSwgY3JlYXRlTmF0aXZlU3RlcmVvUGFubmVyTm9kZSwgY3JlYXRlU3RlcmVvUGFubmVyTm9kZVJlbmRlcmVyLCBnZXROYXRpdmVDb250ZXh0LCBpc05hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQpIHtcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9hdWRpb05vZGVDb25zdHJ1Y3Rvcikge1xuICAgICAgICBmdW5jdGlvbiBTdGVyZW9QYW5uZXJOb2RlKGNvbnRleHQsIG9wdGlvbnMpIHtcbiAgICAgICAgICB2YXIgX3RoaXM7XG4gICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFN0ZXJlb1Bhbm5lck5vZGUpO1xuICAgICAgICAgIHZhciBuYXRpdmVDb250ZXh0ID0gZ2V0TmF0aXZlQ29udGV4dChjb250ZXh0KTtcbiAgICAgICAgICB2YXIgbWVyZ2VkT3B0aW9ucyA9IF9vYmplY3RTcHJlYWQkNChfb2JqZWN0U3ByZWFkJDQoe30sIERFRkFVTFRfT1BUSU9OUyQxKSwgb3B0aW9ucyk7XG4gICAgICAgICAgdmFyIG5hdGl2ZVN0ZXJlb1Bhbm5lck5vZGUgPSBjcmVhdGVOYXRpdmVTdGVyZW9QYW5uZXJOb2RlKG5hdGl2ZUNvbnRleHQsIG1lcmdlZE9wdGlvbnMpO1xuICAgICAgICAgIHZhciBpc09mZmxpbmUgPSBpc05hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQobmF0aXZlQ29udGV4dCk7XG4gICAgICAgICAgdmFyIHN0ZXJlb1Bhbm5lck5vZGVSZW5kZXJlciA9IGlzT2ZmbGluZSA/IGNyZWF0ZVN0ZXJlb1Bhbm5lck5vZGVSZW5kZXJlcigpIDogbnVsbDtcbiAgICAgICAgICBfdGhpcyA9IF9jYWxsU3VwZXIkMSh0aGlzLCBTdGVyZW9QYW5uZXJOb2RlLCBbY29udGV4dCwgZmFsc2UsIG5hdGl2ZVN0ZXJlb1Bhbm5lck5vZGUsIHN0ZXJlb1Bhbm5lck5vZGVSZW5kZXJlcl0pO1xuICAgICAgICAgIF90aGlzLl9wYW4gPSBjcmVhdGVBdWRpb1BhcmFtKF90aGlzLCBpc09mZmxpbmUsIG5hdGl2ZVN0ZXJlb1Bhbm5lck5vZGUucGFuKTtcbiAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgIH1cbiAgICAgICAgX2luaGVyaXRzKFN0ZXJlb1Bhbm5lck5vZGUsIF9hdWRpb05vZGVDb25zdHJ1Y3Rvcik7XG4gICAgICAgIHJldHVybiBfY3JlYXRlQ2xhc3MoU3RlcmVvUGFubmVyTm9kZSwgW3tcbiAgICAgICAgICBrZXk6IFwicGFuXCIsXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcGFuO1xuICAgICAgICAgIH1cbiAgICAgICAgfV0pO1xuICAgICAgfShhdWRpb05vZGVDb25zdHJ1Y3Rvcik7XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVTdGVyZW9QYW5uZXJOb2RlUmVuZGVyZXJGYWN0b3J5ID0gZnVuY3Rpb24gY3JlYXRlU3RlcmVvUGFubmVyTm9kZVJlbmRlcmVyRmFjdG9yeShjb25uZWN0QXVkaW9QYXJhbSwgY3JlYXRlTmF0aXZlU3RlcmVvUGFubmVyTm9kZSwgZ2V0TmF0aXZlQXVkaW9Ob2RlLCByZW5kZXJBdXRvbWF0aW9uLCByZW5kZXJJbnB1dHNPZkF1ZGlvTm9kZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlbmRlcmVkTmF0aXZlU3RlcmVvUGFubmVyTm9kZXMgPSBuZXcgV2Vha01hcCgpO1xuICAgICAgICB2YXIgY3JlYXRlU3RlcmVvUGFubmVyTm9kZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIF9yZWYgPSBfYXN5bmNUb0dlbmVyYXRvcigvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUocHJveHksIG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciBuYXRpdmVTdGVyZW9QYW5uZXJOb2RlLCBuYXRpdmVTdGVyZW9QYW5uZXJOb2RlSXNPd25lZEJ5Q29udGV4dCwgb3B0aW9ucztcbiAgICAgICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgICAgICAgICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICBuYXRpdmVTdGVyZW9QYW5uZXJOb2RlID0gZ2V0TmF0aXZlQXVkaW9Ob2RlKHByb3h5KTtcbiAgICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICAgKiBJZiB0aGUgaW5pdGlhbGx5IHVzZWQgbmF0aXZlU3RlcmVvUGFubmVyTm9kZSB3YXMgbm90IGNvbnN0cnVjdGVkIG9uIHRoZSBzYW1lIE9mZmxpbmVBdWRpb0NvbnRleHQgaXQgbmVlZHMgdG8gYmUgY3JlYXRlZFxuICAgICAgICAgICAgICAgICAgICogYWdhaW4uXG4gICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgIG5hdGl2ZVN0ZXJlb1Bhbm5lck5vZGVJc093bmVkQnlDb250ZXh0ID0gaXNPd25lZEJ5Q29udGV4dChuYXRpdmVTdGVyZW9QYW5uZXJOb2RlLCBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KTtcbiAgICAgICAgICAgICAgICAgIGlmICghbmF0aXZlU3RlcmVvUGFubmVyTm9kZUlzT3duZWRCeUNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICBjaGFubmVsQ291bnQ6IG5hdGl2ZVN0ZXJlb1Bhbm5lck5vZGUuY2hhbm5lbENvdW50LFxuICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWxDb3VudE1vZGU6IG5hdGl2ZVN0ZXJlb1Bhbm5lck5vZGUuY2hhbm5lbENvdW50TW9kZSxcbiAgICAgICAgICAgICAgICAgICAgICBjaGFubmVsSW50ZXJwcmV0YXRpb246IG5hdGl2ZVN0ZXJlb1Bhbm5lck5vZGUuY2hhbm5lbEludGVycHJldGF0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgIHBhbjogbmF0aXZlU3RlcmVvUGFubmVyTm9kZS5wYW4udmFsdWVcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgbmF0aXZlU3RlcmVvUGFubmVyTm9kZSA9IGNyZWF0ZU5hdGl2ZVN0ZXJlb1Bhbm5lck5vZGUobmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICByZW5kZXJlZE5hdGl2ZVN0ZXJlb1Bhbm5lck5vZGVzLnNldChuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LCBuYXRpdmVTdGVyZW9QYW5uZXJOb2RlKTtcbiAgICAgICAgICAgICAgICAgIGlmIChuYXRpdmVTdGVyZW9QYW5uZXJOb2RlSXNPd25lZEJ5Q29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gOTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNztcbiAgICAgICAgICAgICAgICAgIHJldHVybiByZW5kZXJBdXRvbWF0aW9uKG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQsIHByb3h5LnBhbiwgbmF0aXZlU3RlcmVvUGFubmVyTm9kZS5wYW4pO1xuICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxMTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxMTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBjb25uZWN0QXVkaW9QYXJhbShuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LCBwcm94eS5wYW4sIG5hdGl2ZVN0ZXJlb1Bhbm5lck5vZGUucGFuKTtcbiAgICAgICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgICAgICAgaWYgKCFpc05hdGl2ZUF1ZGlvTm9kZUZha2VyKG5hdGl2ZVN0ZXJlb1Bhbm5lck5vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxNjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTQ7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcmVuZGVySW5wdXRzT2ZBdWRpb05vZGUocHJveHksIG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQsIG5hdGl2ZVN0ZXJlb1Bhbm5lck5vZGUuaW5wdXRzWzBdKTtcbiAgICAgICAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDE4O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxODtcbiAgICAgICAgICAgICAgICAgIHJldHVybiByZW5kZXJJbnB1dHNPZkF1ZGlvTm9kZShwcm94eSwgbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCwgbmF0aXZlU3RlcmVvUGFubmVyTm9kZSk7XG4gICAgICAgICAgICAgICAgY2FzZSAxODpcbiAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgbmF0aXZlU3RlcmVvUGFubmVyTm9kZSk7XG4gICAgICAgICAgICAgICAgY2FzZSAxOTpcbiAgICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBfY2FsbGVlKTtcbiAgICAgICAgICB9KSk7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZVN0ZXJlb1Bhbm5lck5vZGUoX3gsIF94Mikge1xuICAgICAgICAgICAgcmV0dXJuIF9yZWYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9KCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIocHJveHksIG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciByZW5kZXJlZE5hdGl2ZVN0ZXJlb1Bhbm5lck5vZGUgPSByZW5kZXJlZE5hdGl2ZVN0ZXJlb1Bhbm5lck5vZGVzLmdldChuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KTtcbiAgICAgICAgICAgIGlmIChyZW5kZXJlZE5hdGl2ZVN0ZXJlb1Bhbm5lck5vZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlbmRlcmVkTmF0aXZlU3RlcmVvUGFubmVyTm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlU3RlcmVvUGFubmVyTm9kZShwcm94eSwgbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgLy8gQnVnICMzMzogU2FmYXJpIGV4cG9zZXMgYW4gQXVkaW9CdWZmZXIgYnV0IGl0IGNhbid0IGJlIHVzZWQgYXMgYSBjb25zdHJ1Y3Rvci5cbiAgICB2YXIgY3JlYXRlVGVzdEF1ZGlvQnVmZmVyQ29uc3RydWN0b3JTdXBwb3J0ID0gZnVuY3Rpb24gY3JlYXRlVGVzdEF1ZGlvQnVmZmVyQ29uc3RydWN0b3JTdXBwb3J0KG5hdGl2ZUF1ZGlvQnVmZmVyQ29uc3RydWN0b3IpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChuYXRpdmVBdWRpb0J1ZmZlckNvbnN0cnVjdG9yID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbmV3IG5hdGl2ZUF1ZGlvQnVmZmVyQ29uc3RydWN0b3Ioe1xuICAgICAgICAgICAgbGVuZ3RoOiAxLFxuICAgICAgICAgICAgc2FtcGxlUmF0ZTogNDQxMDBcbiAgICAgICAgICB9KTsgLy8gdHNsaW50OmRpc2FibGUtbGluZTpuby11bnVzZWQtZXhwcmVzc2lvblxuICAgICAgICB9IGNhdGNoIChfdW51c2VkKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgLypcbiAgICAgKiBGaXJlZm94IHVwIHRvIHZlcnNpb24gNjcgZGlkbid0IGZ1bGx5IHN1cHBvcnQgdGhlIGNvcHlGcm9tQ2hhbm5lbCgpIGFuZCBjb3B5VG9DaGFubmVsKCkgbWV0aG9kcy4gVGhlcmVmb3JlIHRlc3Rpbmcgb25lIG9mIHRob3NlIG1ldGhvZHNcbiAgICAgKiBpcyBlbm91Z2ggdG8ga25vdyBpZiB0aGUgb3RoZXIgb25lIGlzIHN1cHBvcnRlZCBhcyB3ZWxsLlxuICAgICAqL1xuICAgIHZhciBjcmVhdGVUZXN0QXVkaW9CdWZmZXJDb3B5Q2hhbm5lbE1ldGhvZHNTdWJhcnJheVN1cHBvcnQgPSBmdW5jdGlvbiBjcmVhdGVUZXN0QXVkaW9CdWZmZXJDb3B5Q2hhbm5lbE1ldGhvZHNTdWJhcnJheVN1cHBvcnQobmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dENvbnN0cnVjdG9yKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAobmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dENvbnN0cnVjdG9yID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0ID0gbmV3IG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHRDb25zdHJ1Y3RvcigxLCAxLCA0NDEwMCk7XG4gICAgICAgIHZhciBuYXRpdmVBdWRpb0J1ZmZlciA9IG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQuY3JlYXRlQnVmZmVyKDEsIDEsIDQ0MTAwKTtcbiAgICAgICAgLy8gQnVnICM1OiBTYWZhcmkgZG9lcyBub3Qgc3VwcG9ydCBjb3B5RnJvbUNoYW5uZWwoKSBhbmQgY29weVRvQ2hhbm5lbCgpLlxuICAgICAgICBpZiAobmF0aXZlQXVkaW9CdWZmZXIuY29weVRvQ2hhbm5lbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNvdXJjZSA9IG5ldyBGbG9hdDMyQXJyYXkoMik7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbmF0aXZlQXVkaW9CdWZmZXIuY29weUZyb21DaGFubmVsKHNvdXJjZSwgMCwgMCk7XG4gICAgICAgIH0gY2F0Y2ggKF91bnVzZWQpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlVGVzdEF1ZGlvQ29udGV4dENsb3NlTWV0aG9kU3VwcG9ydCA9IGZ1bmN0aW9uIGNyZWF0ZVRlc3RBdWRpb0NvbnRleHRDbG9zZU1ldGhvZFN1cHBvcnQobmF0aXZlQXVkaW9Db250ZXh0Q29uc3RydWN0b3IpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChuYXRpdmVBdWRpb0NvbnRleHRDb25zdHJ1Y3RvciA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUcnkgdG8gY2hlY2sgdGhlIHByb3RvdHlwZSBiZWZvcmUgY29uc3RydWN0aW5nIHRoZSBBdWRpb0NvbnRleHQuXG4gICAgICAgIGlmIChuYXRpdmVBdWRpb0NvbnRleHRDb25zdHJ1Y3Rvci5wcm90b3R5cGUgIT09IHVuZGVmaW5lZCAmJiBuYXRpdmVBdWRpb0NvbnRleHRDb25zdHJ1Y3Rvci5wcm90b3R5cGUuY2xvc2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhdWRpb0NvbnRleHQgPSBuZXcgbmF0aXZlQXVkaW9Db250ZXh0Q29uc3RydWN0b3IoKTtcbiAgICAgICAgdmFyIGlzQXVkaW9Db250ZXh0Q2xvc2FibGUgPSBhdWRpb0NvbnRleHQuY2xvc2UgIT09IHVuZGVmaW5lZDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhdWRpb0NvbnRleHQuY2xvc2UoKTtcbiAgICAgICAgfSBjYXRjaCAoX3VudXNlZCkge1xuICAgICAgICAgIC8vIElnbm9yZSBlcnJvcnMuXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzQXVkaW9Db250ZXh0Q2xvc2FibGU7XG4gICAgICB9O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBFZGdlIHVwIHRvIHZlcnNpb24gMTQsIEZpcmVmb3ggdXAgdG8gdmVyc2lvbiA1MiwgU2FmYXJpIHVwIHRvIHZlcnNpb24gOSBhbmQgbWF5YmUgb3RoZXIgYnJvd3NlcnNcbiAgICAgKiBkaWQgbm90IHJlZnVzZSB0byBkZWNvZGUgaW52YWxpZCBwYXJhbWV0ZXJzIHdpdGggYSBUeXBlRXJyb3IuXG4gICAgICovXG4gICAgdmFyIGNyZWF0ZVRlc3RBdWRpb0NvbnRleHREZWNvZGVBdWRpb0RhdGFNZXRob2RUeXBlRXJyb3JTdXBwb3J0ID0gZnVuY3Rpb24gY3JlYXRlVGVzdEF1ZGlvQ29udGV4dERlY29kZUF1ZGlvRGF0YU1ldGhvZFR5cGVFcnJvclN1cHBvcnQobmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dENvbnN0cnVjdG9yKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAobmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dENvbnN0cnVjdG9yID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9mZmxpbmVBdWRpb0NvbnRleHQgPSBuZXcgbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dENvbnN0cnVjdG9yKDEsIDEsIDQ0MTAwKTtcbiAgICAgICAgLy8gQnVnICMyMTogU2FmYXJpIGRvZXMgbm90IHN1cHBvcnQgcHJvbWlzZXMgeWV0LlxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICB2YXIgaXNQZW5kaW5nID0gdHJ1ZTtcbiAgICAgICAgICB2YXIgcmVzb2x2ZVByb21pc2UgPSBmdW5jdGlvbiByZXNvbHZlUHJvbWlzZShlcnIpIHtcbiAgICAgICAgICAgIGlmIChpc1BlbmRpbmcpIHtcbiAgICAgICAgICAgICAgaXNQZW5kaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgIG9mZmxpbmVBdWRpb0NvbnRleHQuc3RhcnRSZW5kZXJpbmcoKTtcbiAgICAgICAgICAgICAgcmVzb2x2ZShlcnIgaW5zdGFuY2VvZiBUeXBlRXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgdmFyIHByb21pc2U7XG4gICAgICAgICAgLy8gQnVnICMyNjogU2FmYXJpIHRocm93cyBhIHN5bmNocm9ub3VzIGVycm9yLlxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBwcm9taXNlID0gb2ZmbGluZUF1ZGlvQ29udGV4dFxuICAgICAgICAgICAgLy8gQnVnICMxOiBTYWZhcmkgcmVxdWlyZXMgYSBzdWNjZXNzQ2FsbGJhY2suXG4gICAgICAgICAgICAuZGVjb2RlQXVkaW9EYXRhKG51bGwsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgLy8gSWdub3JlIHRoZSBzdWNjZXNzIGNhbGxiYWNrLlxuICAgICAgICAgICAgfSwgcmVzb2x2ZVByb21pc2UpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgcmVzb2x2ZVByb21pc2UoZXJyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gQnVnICMyMTogU2FmYXJpIGRvZXMgbm90IHN1cHBvcnQgcHJvbWlzZXMgeWV0LlxuICAgICAgICAgIGlmIChwcm9taXNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIEJ1ZyAjNjogQ2hyb21lLCBFZGdlIGFuZCBGaXJlZm94IGRvIG5vdCBjYWxsIHRoZSBlcnJvckNhbGxiYWNrLlxuICAgICAgICAgICAgcHJvbWlzZVtcImNhdGNoXCJdKHJlc29sdmVQcm9taXNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZVRlc3RBdWRpb0NvbnRleHRPcHRpb25zU3VwcG9ydCA9IGZ1bmN0aW9uIGNyZWF0ZVRlc3RBdWRpb0NvbnRleHRPcHRpb25zU3VwcG9ydChuYXRpdmVBdWRpb0NvbnRleHRDb25zdHJ1Y3Rvcikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKG5hdGl2ZUF1ZGlvQ29udGV4dENvbnN0cnVjdG9yID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhdWRpb0NvbnRleHQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYXVkaW9Db250ZXh0ID0gbmV3IG5hdGl2ZUF1ZGlvQ29udGV4dENvbnN0cnVjdG9yKHtcbiAgICAgICAgICAgIGxhdGVuY3lIaW50OiAnYmFsYW5jZWQnXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gY2F0Y2ggKF91bnVzZWQpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgYXVkaW9Db250ZXh0LmNsb3NlKCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgLy8gU2FmYXJpIHVwIHRvIHZlcnNpb24gMTIuMCAoYnV0IG5vdCB2MTIuMSkgZGlkbid0IHJldHVybiB0aGUgZGVzdGluYXRpb24gaW4gY2FzZSBpdCB3YXMgYW4gQXVkaW9Ob2RlLlxuICAgIHZhciBjcmVhdGVUZXN0QXVkaW9Ob2RlQ29ubmVjdE1ldGhvZFN1cHBvcnQgPSBmdW5jdGlvbiBjcmVhdGVUZXN0QXVkaW9Ob2RlQ29ubmVjdE1ldGhvZFN1cHBvcnQobmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dENvbnN0cnVjdG9yKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAobmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dENvbnN0cnVjdG9yID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0ID0gbmV3IG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHRDb25zdHJ1Y3RvcigxLCAxLCA0NDEwMCk7XG4gICAgICAgIHZhciBuYXRpdmVHYWluTm9kZSA9IG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQuY3JlYXRlR2FpbigpO1xuICAgICAgICB2YXIgaXNTdXBwb3J0ZWQgPSBuYXRpdmVHYWluTm9kZS5jb25uZWN0KG5hdGl2ZUdhaW5Ob2RlKSA9PT0gbmF0aXZlR2Fpbk5vZGU7XG4gICAgICAgIG5hdGl2ZUdhaW5Ob2RlLmRpc2Nvbm5lY3QobmF0aXZlR2Fpbk5vZGUpO1xuICAgICAgICByZXR1cm4gaXNTdXBwb3J0ZWQ7XG4gICAgICB9O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDaHJvbWUgdmVyc2lvbiA2NiBhbmQgNjcgZGlkIG5vdCBjYWxsIHRoZSBwcm9jZXNzKCkgZnVuY3Rpb24gb2YgYW4gQXVkaW9Xb3JrbGV0UHJvY2Vzc29yIGlmIGl0IGhhZCBubyBvdXRwdXRzLiBBdWRpb1dvcmtsZXQgc3VwcG9ydCB3YXNcbiAgICAgKiBlbmFibGVkIGJ5IGRlZmF1bHQgaW4gdmVyc2lvbiA2Ni5cbiAgICAgKi9cbiAgICB2YXIgY3JlYXRlVGVzdEF1ZGlvV29ya2xldFByb2Nlc3Nvck5vT3V0cHV0c1N1cHBvcnQgPSBmdW5jdGlvbiBjcmVhdGVUZXN0QXVkaW9Xb3JrbGV0UHJvY2Vzc29yTm9PdXRwdXRzU3VwcG9ydChuYXRpdmVBdWRpb1dvcmtsZXROb2RlQ29uc3RydWN0b3IsIG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHRDb25zdHJ1Y3Rvcikge1xuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fYXN5bmNUb0dlbmVyYXRvcigvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoKSB7XG4gICAgICAgIHZhciBibG9iLCBtZXNzYWdlQ2hhbm5lbCwgb2ZmbGluZUF1ZGlvQ29udGV4dCwgdXJsLCBpc0NhbGxpbmdQcm9jZXNzLCBhdWRpb1dvcmtsZXROb2RlLCBvc2NpbGxhdG9yO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgaWYgKCEobmF0aXZlQXVkaW9Xb3JrbGV0Tm9kZUNvbnN0cnVjdG9yID09PSBudWxsKSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgdHJ1ZSk7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgIGlmICghKG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHRDb25zdHJ1Y3RvciA9PT0gbnVsbCkpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGZhbHNlKTtcbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgYmxvYiA9IG5ldyBCbG9iKFsnbGV0IGMscDtjbGFzcyBBIGV4dGVuZHMgQXVkaW9Xb3JrbGV0UHJvY2Vzc29ye2NvbnN0cnVjdG9yKCl7c3VwZXIoKTt0aGlzLnBvcnQub25tZXNzYWdlPShlKT0+e3A9ZS5kYXRhO3Aub25tZXNzYWdlPSgpPT57cC5wb3N0TWVzc2FnZShjKTtwLmNsb3NlKCl9O3RoaXMucG9ydC5wb3N0TWVzc2FnZSgwKX19cHJvY2Vzcygpe2M9MX19cmVnaXN0ZXJQcm9jZXNzb3IoXCJhXCIsQSknXSwge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdhcHBsaWNhdGlvbi9qYXZhc2NyaXB0OyBjaGFyc2V0PXV0Zi04J1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgbWVzc2FnZUNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTsgLy8gQnVnICMxNDE6IFNhZmFyaSBkb2VzIG5vdCBzdXBwb3J0IGNyZWF0aW5nIGFuIE9mZmxpbmVBdWRpb0NvbnRleHQgd2l0aCBsZXNzIHRoYW4gNDQxMDAgSHouXG4gICAgICAgICAgICAgIG9mZmxpbmVBdWRpb0NvbnRleHQgPSBuZXcgbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dENvbnN0cnVjdG9yKDEsIDEyOCwgNDQxMDApO1xuICAgICAgICAgICAgICB1cmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuICAgICAgICAgICAgICBpc0NhbGxpbmdQcm9jZXNzID0gZmFsc2U7XG4gICAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSA5O1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTI7XG4gICAgICAgICAgICAgIHJldHVybiBvZmZsaW5lQXVkaW9Db250ZXh0LmF1ZGlvV29ya2xldC5hZGRNb2R1bGUodXJsKTtcbiAgICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICAgIGF1ZGlvV29ya2xldE5vZGUgPSBuZXcgbmF0aXZlQXVkaW9Xb3JrbGV0Tm9kZUNvbnN0cnVjdG9yKG9mZmxpbmVBdWRpb0NvbnRleHQsICdhJywge1xuICAgICAgICAgICAgICAgIG51bWJlck9mT3V0cHV0czogMFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgb3NjaWxsYXRvciA9IG9mZmxpbmVBdWRpb0NvbnRleHQuY3JlYXRlT3NjaWxsYXRvcigpO1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTY7XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgICAgICAgIGF1ZGlvV29ya2xldE5vZGUucG9ydC5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgYXVkaW9Xb3JrbGV0Tm9kZS5wb3J0LnBvc3RNZXNzYWdlKG1lc3NhZ2VDaGFubmVsLnBvcnQyLCBbbWVzc2FnZUNoYW5uZWwucG9ydDJdKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgICAgICBhdWRpb1dvcmtsZXROb2RlLnBvcnQub25tZXNzYWdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc0NhbGxpbmdQcm9jZXNzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgb3NjaWxsYXRvci5jb25uZWN0KGF1ZGlvV29ya2xldE5vZGUpO1xuICAgICAgICAgICAgICBvc2NpbGxhdG9yLnN0YXJ0KDApO1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjE7XG4gICAgICAgICAgICAgIHJldHVybiBvZmZsaW5lQXVkaW9Db250ZXh0LnN0YXJ0UmVuZGVyaW5nKCk7XG4gICAgICAgICAgICBjYXNlIDIxOlxuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjM7XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2VDaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChfcmVmMikge1xuICAgICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBfcmVmMi5kYXRhO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoZGF0YSA9PT0gMSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBtZXNzYWdlQ2hhbm5lbC5wb3J0MS5wb3N0TWVzc2FnZSgwKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjYXNlIDIzOlxuICAgICAgICAgICAgICBpc0NhbGxpbmdQcm9jZXNzID0gX2NvbnRleHQuc2VudDtcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDI4O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMjY6XG4gICAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAyNjtcbiAgICAgICAgICAgICAgX2NvbnRleHQudDAgPSBfY29udGV4dFtcImNhdGNoXCJdKDkpO1xuICAgICAgICAgICAgY2FzZSAyODpcbiAgICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDI4O1xuICAgICAgICAgICAgICBtZXNzYWdlQ2hhbm5lbC5wb3J0MS5jbG9zZSgpO1xuICAgICAgICAgICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKHVybCk7XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5maW5pc2goMjgpO1xuICAgICAgICAgICAgY2FzZSAzMjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCBpc0NhbGxpbmdQcm9jZXNzKTtcbiAgICAgICAgICAgIGNhc2UgMzM6XG4gICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlLCBudWxsLCBbWzksIDI2LCAyOCwgMzJdXSk7XG4gICAgICB9KSk7XG4gICAgfTtcblxuICAgIC8vIEJ1ZyAjMTc5OiBGaXJlZm94IGRvZXMgbm90IGFsbG93IHRvIHRyYW5zZmVyIGFueSBidWZmZXIgd2hpY2ggaGFzIGJlZW4gcGFzc2VkIHRvIHRoZSBwcm9jZXNzKCkgbWV0aG9kIGFzIGFuIGFyZ3VtZW50LlxuICAgIHZhciBjcmVhdGVUZXN0QXVkaW9Xb3JrbGV0UHJvY2Vzc29yUG9zdE1lc3NhZ2VTdXBwb3J0ID0gZnVuY3Rpb24gY3JlYXRlVGVzdEF1ZGlvV29ya2xldFByb2Nlc3NvclBvc3RNZXNzYWdlU3VwcG9ydChuYXRpdmVBdWRpb1dvcmtsZXROb2RlQ29uc3RydWN0b3IsIG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHRDb25zdHJ1Y3Rvcikge1xuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fYXN5bmNUb0dlbmVyYXRvcigvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoKSB7XG4gICAgICAgIHZhciBibG9iLCBvZmZsaW5lQXVkaW9Db250ZXh0LCB1cmwsIGlzRW1pdHRpbmdNZXNzYWdlRXZlbnRzLCBpc0VtaXR0aW5nUHJvY2Vzc29yRXJyb3JFdmVudHMsIGF1ZGlvV29ya2xldE5vZGUsIG9zY2lsbGF0b3I7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgICAgICB3aGlsZSAoMSkgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBpZiAoIShuYXRpdmVBdWRpb1dvcmtsZXROb2RlQ29uc3RydWN0b3IgPT09IG51bGwpKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCB0cnVlKTtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgaWYgKCEobmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dENvbnN0cnVjdG9yID09PSBudWxsKSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgZmFsc2UpO1xuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICBibG9iID0gbmV3IEJsb2IoWydjbGFzcyBBIGV4dGVuZHMgQXVkaW9Xb3JrbGV0UHJvY2Vzc29ye3Byb2Nlc3MoaSl7dGhpcy5wb3J0LnBvc3RNZXNzYWdlKGksW2lbMF1bMF0uYnVmZmVyXSl9fXJlZ2lzdGVyUHJvY2Vzc29yKFwiYVwiLEEpJ10sIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnYXBwbGljYXRpb24vamF2YXNjcmlwdDsgY2hhcnNldD11dGYtOCdcbiAgICAgICAgICAgICAgfSk7IC8vIEJ1ZyAjMTQxOiBTYWZhcmkgZG9lcyBub3Qgc3VwcG9ydCBjcmVhdGluZyBhbiBPZmZsaW5lQXVkaW9Db250ZXh0IHdpdGggbGVzcyB0aGFuIDQ0MTAwIEh6LlxuICAgICAgICAgICAgICBvZmZsaW5lQXVkaW9Db250ZXh0ID0gbmV3IG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHRDb25zdHJ1Y3RvcigxLCAxMjgsIDQ0MTAwKTtcbiAgICAgICAgICAgICAgdXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcbiAgICAgICAgICAgICAgaXNFbWl0dGluZ01lc3NhZ2VFdmVudHMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgaXNFbWl0dGluZ1Byb2Nlc3NvckVycm9yRXZlbnRzID0gZmFsc2U7XG4gICAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSA5O1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTI7XG4gICAgICAgICAgICAgIHJldHVybiBvZmZsaW5lQXVkaW9Db250ZXh0LmF1ZGlvV29ya2xldC5hZGRNb2R1bGUodXJsKTtcbiAgICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICAgIGF1ZGlvV29ya2xldE5vZGUgPSBuZXcgbmF0aXZlQXVkaW9Xb3JrbGV0Tm9kZUNvbnN0cnVjdG9yKG9mZmxpbmVBdWRpb0NvbnRleHQsICdhJywge1xuICAgICAgICAgICAgICAgIG51bWJlck9mT3V0cHV0czogMFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgb3NjaWxsYXRvciA9IG9mZmxpbmVBdWRpb0NvbnRleHQuY3JlYXRlT3NjaWxsYXRvcigpO1xuICAgICAgICAgICAgICBhdWRpb1dvcmtsZXROb2RlLnBvcnQub25tZXNzYWdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc0VtaXR0aW5nTWVzc2FnZUV2ZW50cyA9IHRydWU7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIGF1ZGlvV29ya2xldE5vZGUub25wcm9jZXNzb3JlcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNFbWl0dGluZ1Byb2Nlc3NvckVycm9yRXZlbnRzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgb3NjaWxsYXRvci5jb25uZWN0KGF1ZGlvV29ya2xldE5vZGUpO1xuICAgICAgICAgICAgICBvc2NpbGxhdG9yLnN0YXJ0KDApO1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjA7XG4gICAgICAgICAgICAgIHJldHVybiBvZmZsaW5lQXVkaW9Db250ZXh0LnN0YXJ0UmVuZGVyaW5nKCk7XG4gICAgICAgICAgICBjYXNlIDIwOlxuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjI7XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZXRUaW1lb3V0KHJlc29sdmUpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNhc2UgMjI6XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAyNjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDI0OlxuICAgICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMjQ7XG4gICAgICAgICAgICAgIF9jb250ZXh0LnQwID0gX2NvbnRleHRbXCJjYXRjaFwiXSg5KTtcbiAgICAgICAgICAgIGNhc2UgMjY6XG4gICAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAyNjtcbiAgICAgICAgICAgICAgVVJMLnJldm9rZU9iamVjdFVSTCh1cmwpO1xuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuZmluaXNoKDI2KTtcbiAgICAgICAgICAgIGNhc2UgMjk6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgaXNFbWl0dGluZ01lc3NhZ2VFdmVudHMgJiYgIWlzRW1pdHRpbmdQcm9jZXNzb3JFcnJvckV2ZW50cyk7XG4gICAgICAgICAgICBjYXNlIDMwOlxuICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZSwgbnVsbCwgW1s5LCAyNCwgMjYsIDI5XV0pO1xuICAgICAgfSkpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBGaXJlZm94IHVwIHRvIHZlcnNpb24gNjkgZGlkIG5vdCB0aHJvdyBhbiBlcnJvciB3aGVuIHNldHRpbmcgYSBkaWZmZXJlbnQgY2hhbm5lbENvdW50IG9yIGNoYW5uZWxDb3VudE1vZGUuXG4gICAgICovXG4gICAgdmFyIGNyZWF0ZVRlc3RDaGFubmVsTWVyZ2VyTm9kZUNoYW5uZWxDb3VudFN1cHBvcnQgPSBmdW5jdGlvbiBjcmVhdGVUZXN0Q2hhbm5lbE1lcmdlck5vZGVDaGFubmVsQ291bnRTdXBwb3J0KG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHRDb25zdHJ1Y3Rvcikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHRDb25zdHJ1Y3RvciA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb2ZmbGluZUF1ZGlvQ29udGV4dCA9IG5ldyBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0Q29uc3RydWN0b3IoMSwgMSwgNDQxMDApO1xuICAgICAgICB2YXIgbmF0aXZlQ2hhbm5lbE1lcmdlck5vZGUgPSBvZmZsaW5lQXVkaW9Db250ZXh0LmNyZWF0ZUNoYW5uZWxNZXJnZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJ1ZyAjMTU6IFNhZmFyaSBkb2VzIG5vdCByZXR1cm4gdGhlIGRlZmF1bHQgcHJvcGVydGllcy4gSXQgc3RpbGwgbmVlZHMgdG8gYmUgcGF0Y2hlZC4gVGhpcyB0ZXN0IGlzIHN1cHBvc2VkIHRvIHRlc3QgdGhlIHN1cHBvcnRcbiAgICAgICAgICogaW4gb3RoZXIgYnJvd3NlcnMuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAobmF0aXZlQ2hhbm5lbE1lcmdlck5vZGUuY2hhbm5lbENvdW50TW9kZSA9PT0gJ21heCcpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgIG5hdGl2ZUNoYW5uZWxNZXJnZXJOb2RlLmNoYW5uZWxDb3VudCA9IDI7XG4gICAgICAgIH0gY2F0Y2ggKF91bnVzZWQpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlVGVzdENvbnN0YW50U291cmNlTm9kZUFjY3VyYXRlU2NoZWR1bGluZ1N1cHBvcnQgPSBmdW5jdGlvbiBjcmVhdGVUZXN0Q29uc3RhbnRTb3VyY2VOb2RlQWNjdXJhdGVTY2hlZHVsaW5nU3VwcG9ydChuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0Q29uc3RydWN0b3IpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0Q29uc3RydWN0b3IgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQgPSBuZXcgbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dENvbnN0cnVjdG9yKDEsIDEsIDQ0MTAwKTtcbiAgICAgICAgLy8gQnVnICM2MjogU2FmYXJpIGRvZXMgbm90IHN1cHBvcnQgQ29uc3RhbnRTb3VyY2VOb2Rlcy5cbiAgICAgICAgaWYgKG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQuY3JlYXRlQ29uc3RhbnRTb3VyY2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuYXRpdmVDb25zdGFudFNvdXJjZU5vZGUgPSBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LmNyZWF0ZUNvbnN0YW50U291cmNlKCk7XG4gICAgICAgIC8qXG4gICAgICAgICAqIEB0b2RvIFRoaXMgaXMgdXNpbmcgYnVnICM3NSB0byBkZXRlY3QgYnVnICM3MC4gVGhhdCB3b3JrcyBiZWNhdXNlIGJvdGggYnVncyB3ZXJlIHVuaXF1ZSB0b1xuICAgICAgICAgKiB0aGUgaW1wbGVtZW50YXRpb24gb2YgRmlyZWZveCByaWdodCBub3csIGJ1dCBpdCBjb3VsZCBwcm9iYWJseSBiZSBkb25lIGluIGEgYmV0dGVyIHdheS5cbiAgICAgICAgICovXG4gICAgICAgIHJldHVybiBuYXRpdmVDb25zdGFudFNvdXJjZU5vZGUub2Zmc2V0Lm1heFZhbHVlICE9PSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgICB9O1xuICAgIH07XG5cbiAgICAvLyBPcGVyYSB1cCB0byB2ZXJzaW9uIDU3IGRpZCBub3QgYWxsb3cgdG8gcmVhc3NpZ24gdGhlIGJ1ZmZlciBvZiBhIENvbnZvbHZlck5vZGUuXG4gICAgdmFyIGNyZWF0ZVRlc3RDb252b2x2ZXJOb2RlQnVmZmVyUmVhc3NpZ25hYmlsaXR5U3VwcG9ydCA9IGZ1bmN0aW9uIGNyZWF0ZVRlc3RDb252b2x2ZXJOb2RlQnVmZmVyUmVhc3NpZ25hYmlsaXR5U3VwcG9ydChuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0Q29uc3RydWN0b3IpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0Q29uc3RydWN0b3IgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9mZmxpbmVBdWRpb0NvbnRleHQgPSBuZXcgbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dENvbnN0cnVjdG9yKDEsIDEsIDQ0MTAwKTtcbiAgICAgICAgdmFyIG5hdGl2ZUNvbnZvbHZlck5vZGUgPSBvZmZsaW5lQXVkaW9Db250ZXh0LmNyZWF0ZUNvbnZvbHZlcigpO1xuICAgICAgICBuYXRpdmVDb252b2x2ZXJOb2RlLmJ1ZmZlciA9IG9mZmxpbmVBdWRpb0NvbnRleHQuY3JlYXRlQnVmZmVyKDEsIDEsIG9mZmxpbmVBdWRpb0NvbnRleHQuc2FtcGxlUmF0ZSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbmF0aXZlQ29udm9sdmVyTm9kZS5idWZmZXIgPSBvZmZsaW5lQXVkaW9Db250ZXh0LmNyZWF0ZUJ1ZmZlcigxLCAxLCBvZmZsaW5lQXVkaW9Db250ZXh0LnNhbXBsZVJhdGUpO1xuICAgICAgICB9IGNhdGNoIChfdW51c2VkKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgLy8gQ2hyb21lIHVwIHRvIHZlcnNpb24gdjgwLCBFZGdlIHVwIHRvIHZlcnNpb24gdjgwIGFuZCBPcGVyYSB1cCB0byB2ZXJzaW9uIHY2NyBkaWQgbm90IGFsbG93IHRvIHNldCB0aGUgY2hhbm5lbENvdW50IHByb3BlcnR5IG9mIGEgQ29udm9sdmVyTm9kZSB0byAxLiBUaGV5IGFsc28gZGlkIG5vdCBhbGxvdyB0byBzZXQgdGhlIGNoYW5uZWxDb3VudE1vZGUgdG8gJ2V4cGxpY2l0Jy5cbiAgICB2YXIgY3JlYXRlVGVzdENvbnZvbHZlck5vZGVDaGFubmVsQ291bnRTdXBwb3J0ID0gZnVuY3Rpb24gY3JlYXRlVGVzdENvbnZvbHZlck5vZGVDaGFubmVsQ291bnRTdXBwb3J0KG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHRDb25zdHJ1Y3Rvcikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHRDb25zdHJ1Y3RvciA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb2ZmbGluZUF1ZGlvQ29udGV4dCA9IG5ldyBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0Q29uc3RydWN0b3IoMSwgMSwgNDQxMDApO1xuICAgICAgICB2YXIgbmF0aXZlQ29udm9sdmVyTm9kZSA9IG9mZmxpbmVBdWRpb0NvbnRleHQuY3JlYXRlQ29udm9sdmVyKCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbmF0aXZlQ29udm9sdmVyTm9kZS5jaGFubmVsQ291bnQgPSAxO1xuICAgICAgICB9IGNhdGNoIChfdW51c2VkKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZVRlc3RJc1NlY3VyZUNvbnRleHRTdXBwb3J0ID0gZnVuY3Rpb24gY3JlYXRlVGVzdElzU2VjdXJlQ29udGV4dFN1cHBvcnQod2luZG93KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gd2luZG93ICE9PSBudWxsICYmIHdpbmRvdy5oYXNPd25Qcm9wZXJ0eSgnaXNTZWN1cmVDb250ZXh0Jyk7XG4gICAgICB9O1xuICAgIH07XG5cbiAgICAvLyBGaXJlZm94IHVwIHRvIHZlcnNpb24gNjggZGlkIG5vdCB0aHJvdyBhbiBlcnJvciB3aGVuIGNyZWF0aW5nIGEgTWVkaWFTdHJlYW1BdWRpb1NvdXJjZU5vZGUgd2l0aCBhIG1lZGlhU3RyZWFtIHRoYXQgaGFkIG5vIGF1ZGlvIHRyYWNrLlxuICAgIHZhciBjcmVhdGVUZXN0TWVkaWFTdHJlYW1BdWRpb1NvdXJjZU5vZGVNZWRpYVN0cmVhbVdpdGhvdXRBdWRpb1RyYWNrU3VwcG9ydCA9IGZ1bmN0aW9uIGNyZWF0ZVRlc3RNZWRpYVN0cmVhbUF1ZGlvU291cmNlTm9kZU1lZGlhU3RyZWFtV2l0aG91dEF1ZGlvVHJhY2tTdXBwb3J0KG5hdGl2ZUF1ZGlvQ29udGV4dENvbnN0cnVjdG9yKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAobmF0aXZlQXVkaW9Db250ZXh0Q29uc3RydWN0b3IgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGF1ZGlvQ29udGV4dCA9IG5ldyBuYXRpdmVBdWRpb0NvbnRleHRDb25zdHJ1Y3RvcigpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGF1ZGlvQ29udGV4dC5jcmVhdGVNZWRpYVN0cmVhbVNvdXJjZShuZXcgTWVkaWFTdHJlYW0oKSk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBhdWRpb0NvbnRleHQuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZVRlc3RPZmZsaW5lQXVkaW9Db250ZXh0Q3VycmVudFRpbWVTdXBwb3J0ID0gZnVuY3Rpb24gY3JlYXRlVGVzdE9mZmxpbmVBdWRpb0NvbnRleHRDdXJyZW50VGltZVN1cHBvcnQoY3JlYXRlTmF0aXZlR2Fpbk5vZGUsIG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHRDb25zdHJ1Y3Rvcikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHRDb25zdHJ1Y3RvciA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0ID0gbmV3IG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHRDb25zdHJ1Y3RvcigxLCAxLCA0NDEwMCk7XG4gICAgICAgIC8vIEJ1ZyAjNDg6IFNhZmFyaSBkb2VzIG5vdCByZW5kZXIgYW4gT2ZmbGluZUF1ZGlvQ29udGV4dCB3aXRob3V0IGFueSBjb25uZWN0ZWQgbm9kZS5cbiAgICAgICAgdmFyIGdhaW5Ob2RlID0gY3JlYXRlTmF0aXZlR2Fpbk5vZGUobmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCwge1xuICAgICAgICAgIGNoYW5uZWxDb3VudDogMSxcbiAgICAgICAgICBjaGFubmVsQ291bnRNb2RlOiAnZXhwbGljaXQnLFxuICAgICAgICAgIGNoYW5uZWxJbnRlcnByZXRhdGlvbjogJ2Rpc2NyZXRlJyxcbiAgICAgICAgICBnYWluOiAwXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBCdWcgIzIxOiBTYWZhcmkgZG9lcyBub3Qgc3VwcG9ydCBwcm9taXNlcyB5ZXQuXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgIG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQub25jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGdhaW5Ob2RlLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIHJlc29sdmUobmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dC5jdXJyZW50VGltZSAhPT0gMCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LnN0YXJ0UmVuZGVyaW5nKCk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRmlyZWZveCB1cCB0byB2ZXJzaW9uIDYyIGRpZCBub3Qga2ljayBvZmYgdGhlIHByb2Nlc3Npbmcgb2YgdGhlIFN0ZXJlb1Bhbm5lck5vZGUgaWYgdGhlIHZhbHVlIG9mIHBhbiB3YXMgemVyby5cbiAgICAgKi9cbiAgICB2YXIgY3JlYXRlVGVzdFN0ZXJlb1Bhbm5lck5vZGVEZWZhdWx0VmFsdWVTdXBwb3J0ID0gZnVuY3Rpb24gY3JlYXRlVGVzdFN0ZXJlb1Bhbm5lck5vZGVEZWZhdWx0VmFsdWVTdXBwb3J0KG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHRDb25zdHJ1Y3Rvcikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHRDb25zdHJ1Y3RvciA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0ID0gbmV3IG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHRDb25zdHJ1Y3RvcigxLCAxLCA0NDEwMCk7XG4gICAgICAgIC8qXG4gICAgICAgICAqIEJ1ZyAjMTA1OiBTYWZhcmkgZG9lcyBub3Qgc3VwcG9ydCB0aGUgU3RlcmVvUGFubmVyTm9kZS4gVGhlcmVmb3JlIHRoZSByZXR1cm5lZCB2YWx1ZSBzaG91bGQgbm9ybWFsbHkgYmUgZmFsc2UgYnV0IHRoZSBmYWtlciBkb2VzXG4gICAgICAgICAqIHN1cHBvcnQgdGhlIHRlc3RlZCBiZWhhdmlvdXIuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAobmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dC5jcmVhdGVTdGVyZW9QYW5uZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQnVnICM2MjogU2FmYXJpIGRvZXMgbm90IHN1cHBvcnQgQ29uc3RhbnRTb3VyY2VOb2Rlcy5cbiAgICAgICAgaWYgKG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQuY3JlYXRlQ29uc3RhbnRTb3VyY2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvbnN0YW50U291cmNlTm9kZSA9IG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQuY3JlYXRlQ29uc3RhbnRTb3VyY2UoKTtcbiAgICAgICAgdmFyIHN0ZXJlb1Bhbm5lciA9IG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQuY3JlYXRlU3RlcmVvUGFubmVyKCk7XG4gICAgICAgIGNvbnN0YW50U291cmNlTm9kZS5jaGFubmVsQ291bnQgPSAxO1xuICAgICAgICBjb25zdGFudFNvdXJjZU5vZGUub2Zmc2V0LnZhbHVlID0gMTtcbiAgICAgICAgc3RlcmVvUGFubmVyLmNoYW5uZWxDb3VudCA9IDE7XG4gICAgICAgIGNvbnN0YW50U291cmNlTm9kZS5zdGFydCgpO1xuICAgICAgICBjb25zdGFudFNvdXJjZU5vZGUuY29ubmVjdChzdGVyZW9QYW5uZXIpLmNvbm5lY3QobmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dC5kZXN0aW5hdGlvbik7XG4gICAgICAgIHJldHVybiBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LnN0YXJ0UmVuZGVyaW5nKCkudGhlbihmdW5jdGlvbiAoYnVmZmVyKSB7XG4gICAgICAgICAgcmV0dXJuIGJ1ZmZlci5nZXRDaGFubmVsRGF0YSgwKVswXSAhPT0gMTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlVW5rbm93bkVycm9yID0gZnVuY3Rpb24gY3JlYXRlVW5rbm93bkVycm9yKCkge1xuICAgICAgcmV0dXJuIG5ldyBET01FeGNlcHRpb24oJycsICdVbmtub3duRXJyb3InKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gb3duS2V5cyQzKGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cbiAgICBmdW5jdGlvbiBfb2JqZWN0U3ByZWFkJDMoZSkgeyBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykgeyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gb3duS2V5cyQzKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyQzKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XG4gICAgZnVuY3Rpb24gX2NhbGxTdXBlcih0LCBvLCBlKSB7IHJldHVybiBvID0gX2dldFByb3RvdHlwZU9mKG8pLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0LCBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgPyBSZWZsZWN0LmNvbnN0cnVjdChvLCBlIHx8IFtdLCBfZ2V0UHJvdG90eXBlT2YodCkuY29uc3RydWN0b3IpIDogby5hcHBseSh0LCBlKSk7IH1cbiAgICBmdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyB0cnkgeyB2YXIgdCA9ICFCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IH0gY2F0Y2ggKHQpIHt9IHJldHVybiAoX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IGZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IHJldHVybiAhIXQ7IH0pKCk7IH1cbiAgICB2YXIgREVGQVVMVF9PUFRJT05TID0ge1xuICAgICAgY2hhbm5lbENvdW50OiAyLFxuICAgICAgY2hhbm5lbENvdW50TW9kZTogJ21heCcsXG4gICAgICBjaGFubmVsSW50ZXJwcmV0YXRpb246ICdzcGVha2VycycsXG4gICAgICBjdXJ2ZTogbnVsbCxcbiAgICAgIG92ZXJzYW1wbGU6ICdub25lJ1xuICAgIH07XG4gICAgdmFyIGNyZWF0ZVdhdmVTaGFwZXJOb2RlQ29uc3RydWN0b3IgPSBmdW5jdGlvbiBjcmVhdGVXYXZlU2hhcGVyTm9kZUNvbnN0cnVjdG9yKGF1ZGlvTm9kZUNvbnN0cnVjdG9yLCBjcmVhdGVJbnZhbGlkU3RhdGVFcnJvciwgY3JlYXRlTmF0aXZlV2F2ZVNoYXBlck5vZGUsIGNyZWF0ZVdhdmVTaGFwZXJOb2RlUmVuZGVyZXIsIGdldE5hdGl2ZUNvbnRleHQsIGlzTmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCwgc2V0QXVkaW9Ob2RlVGFpbFRpbWUpIHtcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9hdWRpb05vZGVDb25zdHJ1Y3Rvcikge1xuICAgICAgICBmdW5jdGlvbiBXYXZlU2hhcGVyTm9kZShjb250ZXh0LCBvcHRpb25zKSB7XG4gICAgICAgICAgdmFyIF90aGlzO1xuICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBXYXZlU2hhcGVyTm9kZSk7XG4gICAgICAgICAgdmFyIG5hdGl2ZUNvbnRleHQgPSBnZXROYXRpdmVDb250ZXh0KGNvbnRleHQpO1xuICAgICAgICAgIHZhciBtZXJnZWRPcHRpb25zID0gX29iamVjdFNwcmVhZCQzKF9vYmplY3RTcHJlYWQkMyh7fSwgREVGQVVMVF9PUFRJT05TKSwgb3B0aW9ucyk7XG4gICAgICAgICAgdmFyIG5hdGl2ZVdhdmVTaGFwZXJOb2RlID0gY3JlYXRlTmF0aXZlV2F2ZVNoYXBlck5vZGUobmF0aXZlQ29udGV4dCwgbWVyZ2VkT3B0aW9ucyk7XG4gICAgICAgICAgdmFyIGlzT2ZmbGluZSA9IGlzTmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dChuYXRpdmVDb250ZXh0KTtcbiAgICAgICAgICB2YXIgd2F2ZVNoYXBlck5vZGVSZW5kZXJlciA9IGlzT2ZmbGluZSA/IGNyZWF0ZVdhdmVTaGFwZXJOb2RlUmVuZGVyZXIoKSA6IG51bGw7XG4gICAgICAgICAgLy8gQHRvZG8gQWRkIGEgbWVjaGFuaXNtIHRvIG9ubHkgc3dpdGNoIGEgV2F2ZVNoYXBlck5vZGUgdG8gYWN0aXZlIHdoaWxlIGl0IGlzIGNvbm5lY3RlZC5cbiAgICAgICAgICBfdGhpcyA9IF9jYWxsU3VwZXIodGhpcywgV2F2ZVNoYXBlck5vZGUsIFtjb250ZXh0LCB0cnVlLCBuYXRpdmVXYXZlU2hhcGVyTm9kZSwgd2F2ZVNoYXBlck5vZGVSZW5kZXJlcl0pO1xuICAgICAgICAgIF90aGlzLl9pc0N1cnZlTnVsbGlmaWVkID0gZmFsc2U7XG4gICAgICAgICAgX3RoaXMuX25hdGl2ZVdhdmVTaGFwZXJOb2RlID0gbmF0aXZlV2F2ZVNoYXBlck5vZGU7XG4gICAgICAgICAgLy8gQHRvZG8gRGV0ZXJtaW5lIGEgbWVhbmluZ2Z1bCB0YWlsLXRpbWUgaW5zdGVhZCBvZiBqdXN0IHVzaW5nIG9uZSBzZWNvbmQuXG4gICAgICAgICAgc2V0QXVkaW9Ob2RlVGFpbFRpbWUoX3RoaXMsIDEpO1xuICAgICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgICAgfVxuICAgICAgICBfaW5oZXJpdHMoV2F2ZVNoYXBlck5vZGUsIF9hdWRpb05vZGVDb25zdHJ1Y3Rvcik7XG4gICAgICAgIHJldHVybiBfY3JlYXRlQ2xhc3MoV2F2ZVNoYXBlck5vZGUsIFt7XG4gICAgICAgICAga2V5OiBcImN1cnZlXCIsXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5faXNDdXJ2ZU51bGxpZmllZCkge1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9uYXRpdmVXYXZlU2hhcGVyTm9kZS5jdXJ2ZTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgICAgICAvLyBCdWcgIzEwMzogU2FmYXJpIGRvZXMgbm90IGFsbG93IHRvIHNldCB0aGUgY3VydmUgdG8gbnVsbC5cbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICB0aGlzLl9pc0N1cnZlTnVsbGlmaWVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgdGhpcy5fbmF0aXZlV2F2ZVNoYXBlck5vZGUuY3VydmUgPSBuZXcgRmxvYXQzMkFycmF5KFswLCAwXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBCdWcgIzEwMjogU2FmYXJpIGRvZXMgbm90IHRocm93IGFuIEludmFsaWRTdGF0ZUVycm9yIHdoZW4gdGhlIGN1cnZlIGhhcyBsZXNzIHRoYW4gdHdvIHNhbXBsZXMuXG4gICAgICAgICAgICAgIC8vIEJ1ZyAjMTA0OiBDaHJvbWUgYW5kIEVkZ2Ugd2lsbCB0aHJvdyBhbiBJbnZhbGlkQWNjZXNzRXJyb3Igd2hlbiB0aGUgY3VydmUgaGFzIGxlc3MgdGhhbiB0d28gc2FtcGxlcy5cbiAgICAgICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBjcmVhdGVJbnZhbGlkU3RhdGVFcnJvcigpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRoaXMuX2lzQ3VydmVOdWxsaWZpZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgdGhpcy5fbmF0aXZlV2F2ZVNoYXBlck5vZGUuY3VydmUgPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBrZXk6IFwib3ZlcnNhbXBsZVwiLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25hdGl2ZVdhdmVTaGFwZXJOb2RlLm92ZXJzYW1wbGU7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fbmF0aXZlV2F2ZVNoYXBlck5vZGUub3ZlcnNhbXBsZSA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfV0pO1xuICAgICAgfShhdWRpb05vZGVDb25zdHJ1Y3Rvcik7XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVXYXZlU2hhcGVyTm9kZVJlbmRlcmVyRmFjdG9yeSA9IGZ1bmN0aW9uIGNyZWF0ZVdhdmVTaGFwZXJOb2RlUmVuZGVyZXJGYWN0b3J5KGNyZWF0ZU5hdGl2ZVdhdmVTaGFwZXJOb2RlLCBnZXROYXRpdmVBdWRpb05vZGUsIHJlbmRlcklucHV0c09mQXVkaW9Ob2RlKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVuZGVyZWROYXRpdmVXYXZlU2hhcGVyTm9kZXMgPSBuZXcgV2Vha01hcCgpO1xuICAgICAgICB2YXIgY3JlYXRlV2F2ZVNoYXBlck5vZGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBfcmVmID0gX2FzeW5jVG9HZW5lcmF0b3IoLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlKHByb3h5LCBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KSB7XG4gICAgICAgICAgICB2YXIgbmF0aXZlV2F2ZVNoYXBlck5vZGUsIG5hdGl2ZVdhdmVTaGFwZXJOb2RlSXNPd25lZEJ5Q29udGV4dCwgb3B0aW9ucztcbiAgICAgICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgICAgICAgICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICBuYXRpdmVXYXZlU2hhcGVyTm9kZSA9IGdldE5hdGl2ZUF1ZGlvTm9kZShwcm94eSk7IC8vIElmIHRoZSBpbml0aWFsbHkgdXNlZCBuYXRpdmVXYXZlU2hhcGVyTm9kZSB3YXMgbm90IGNvbnN0cnVjdGVkIG9uIHRoZSBzYW1lIE9mZmxpbmVBdWRpb0NvbnRleHQgaXQgbmVlZHMgdG8gYmUgY3JlYXRlZCBhZ2Fpbi5cbiAgICAgICAgICAgICAgICAgIG5hdGl2ZVdhdmVTaGFwZXJOb2RlSXNPd25lZEJ5Q29udGV4dCA9IGlzT3duZWRCeUNvbnRleHQobmF0aXZlV2F2ZVNoYXBlck5vZGUsIG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgaWYgKCFuYXRpdmVXYXZlU2hhcGVyTm9kZUlzT3duZWRCeUNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICBjaGFubmVsQ291bnQ6IG5hdGl2ZVdhdmVTaGFwZXJOb2RlLmNoYW5uZWxDb3VudCxcbiAgICAgICAgICAgICAgICAgICAgICBjaGFubmVsQ291bnRNb2RlOiBuYXRpdmVXYXZlU2hhcGVyTm9kZS5jaGFubmVsQ291bnRNb2RlLFxuICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWxJbnRlcnByZXRhdGlvbjogbmF0aXZlV2F2ZVNoYXBlck5vZGUuY2hhbm5lbEludGVycHJldGF0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgIGN1cnZlOiBuYXRpdmVXYXZlU2hhcGVyTm9kZS5jdXJ2ZSxcbiAgICAgICAgICAgICAgICAgICAgICBvdmVyc2FtcGxlOiBuYXRpdmVXYXZlU2hhcGVyTm9kZS5vdmVyc2FtcGxlXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIG5hdGl2ZVdhdmVTaGFwZXJOb2RlID0gY3JlYXRlTmF0aXZlV2F2ZVNoYXBlck5vZGUobmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICByZW5kZXJlZE5hdGl2ZVdhdmVTaGFwZXJOb2Rlcy5zZXQobmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCwgbmF0aXZlV2F2ZVNoYXBlck5vZGUpO1xuICAgICAgICAgICAgICAgICAgaWYgKCFpc05hdGl2ZUF1ZGlvTm9kZUZha2VyKG5hdGl2ZVdhdmVTaGFwZXJOb2RlKSkge1xuICAgICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gOTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNztcbiAgICAgICAgICAgICAgICAgIHJldHVybiByZW5kZXJJbnB1dHNPZkF1ZGlvTm9kZShwcm94eSwgbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCwgbmF0aXZlV2F2ZVNoYXBlck5vZGUuaW5wdXRzWzBdKTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTE7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTE7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcmVuZGVySW5wdXRzT2ZBdWRpb05vZGUocHJveHksIG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQsIG5hdGl2ZVdhdmVTaGFwZXJOb2RlKTtcbiAgICAgICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCBuYXRpdmVXYXZlU2hhcGVyTm9kZSk7XG4gICAgICAgICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBfY2FsbGVlKTtcbiAgICAgICAgICB9KSk7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZVdhdmVTaGFwZXJOb2RlKF94LCBfeDIpIHtcbiAgICAgICAgICAgIHJldHVybiBfcmVmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKHByb3h5LCBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KSB7XG4gICAgICAgICAgICB2YXIgcmVuZGVyZWROYXRpdmVXYXZlU2hhcGVyTm9kZSA9IHJlbmRlcmVkTmF0aXZlV2F2ZVNoYXBlck5vZGVzLmdldChuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KTtcbiAgICAgICAgICAgIGlmIChyZW5kZXJlZE5hdGl2ZVdhdmVTaGFwZXJOb2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZW5kZXJlZE5hdGl2ZVdhdmVTaGFwZXJOb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVXYXZlU2hhcGVyTm9kZShwcm94eSwgbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZVdpbmRvdyA9IGZ1bmN0aW9uIGNyZWF0ZVdpbmRvdygpIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiB3aW5kb3c7XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVXcmFwQXVkaW9CdWZmZXJDb3B5Q2hhbm5lbE1ldGhvZHMgPSBmdW5jdGlvbiBjcmVhdGVXcmFwQXVkaW9CdWZmZXJDb3B5Q2hhbm5lbE1ldGhvZHMoY29udmVydE51bWJlclRvVW5zaWduZWRMb25nLCBjcmVhdGVJbmRleFNpemVFcnJvcikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhdWRpb0J1ZmZlcikge1xuICAgICAgICBhdWRpb0J1ZmZlci5jb3B5RnJvbUNoYW5uZWwgPSBmdW5jdGlvbiAoZGVzdGluYXRpb24sIGNoYW5uZWxOdW1iZXJBc051bWJlcikge1xuICAgICAgICAgIHZhciBidWZmZXJPZmZzZXRBc051bWJlciA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMDtcbiAgICAgICAgICB2YXIgYnVmZmVyT2Zmc2V0ID0gY29udmVydE51bWJlclRvVW5zaWduZWRMb25nKGJ1ZmZlck9mZnNldEFzTnVtYmVyKTtcbiAgICAgICAgICB2YXIgY2hhbm5lbE51bWJlciA9IGNvbnZlcnROdW1iZXJUb1Vuc2lnbmVkTG9uZyhjaGFubmVsTnVtYmVyQXNOdW1iZXIpO1xuICAgICAgICAgIGlmIChjaGFubmVsTnVtYmVyID49IGF1ZGlvQnVmZmVyLm51bWJlck9mQ2hhbm5lbHMpIHtcbiAgICAgICAgICAgIHRocm93IGNyZWF0ZUluZGV4U2l6ZUVycm9yKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBhdWRpb0J1ZmZlckxlbmd0aCA9IGF1ZGlvQnVmZmVyLmxlbmd0aDtcbiAgICAgICAgICB2YXIgY2hhbm5lbERhdGEgPSBhdWRpb0J1ZmZlci5nZXRDaGFubmVsRGF0YShjaGFubmVsTnVtYmVyKTtcbiAgICAgICAgICB2YXIgZGVzdGluYXRpb25MZW5ndGggPSBkZXN0aW5hdGlvbi5sZW5ndGg7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IGJ1ZmZlck9mZnNldCA8IDAgPyAtYnVmZmVyT2Zmc2V0IDogMDsgaSArIGJ1ZmZlck9mZnNldCA8IGF1ZGlvQnVmZmVyTGVuZ3RoICYmIGkgPCBkZXN0aW5hdGlvbkxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbltpXSA9IGNoYW5uZWxEYXRhW2kgKyBidWZmZXJPZmZzZXRdO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgYXVkaW9CdWZmZXIuY29weVRvQ2hhbm5lbCA9IGZ1bmN0aW9uIChzb3VyY2UsIGNoYW5uZWxOdW1iZXJBc051bWJlcikge1xuICAgICAgICAgIHZhciBidWZmZXJPZmZzZXRBc051bWJlciA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMDtcbiAgICAgICAgICB2YXIgYnVmZmVyT2Zmc2V0ID0gY29udmVydE51bWJlclRvVW5zaWduZWRMb25nKGJ1ZmZlck9mZnNldEFzTnVtYmVyKTtcbiAgICAgICAgICB2YXIgY2hhbm5lbE51bWJlciA9IGNvbnZlcnROdW1iZXJUb1Vuc2lnbmVkTG9uZyhjaGFubmVsTnVtYmVyQXNOdW1iZXIpO1xuICAgICAgICAgIGlmIChjaGFubmVsTnVtYmVyID49IGF1ZGlvQnVmZmVyLm51bWJlck9mQ2hhbm5lbHMpIHtcbiAgICAgICAgICAgIHRocm93IGNyZWF0ZUluZGV4U2l6ZUVycm9yKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBhdWRpb0J1ZmZlckxlbmd0aCA9IGF1ZGlvQnVmZmVyLmxlbmd0aDtcbiAgICAgICAgICB2YXIgY2hhbm5lbERhdGEgPSBhdWRpb0J1ZmZlci5nZXRDaGFubmVsRGF0YShjaGFubmVsTnVtYmVyKTtcbiAgICAgICAgICB2YXIgc291cmNlTGVuZ3RoID0gc291cmNlLmxlbmd0aDtcbiAgICAgICAgICBmb3IgKHZhciBpID0gYnVmZmVyT2Zmc2V0IDwgMCA/IC1idWZmZXJPZmZzZXQgOiAwOyBpICsgYnVmZmVyT2Zmc2V0IDwgYXVkaW9CdWZmZXJMZW5ndGggJiYgaSA8IHNvdXJjZUxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBjaGFubmVsRGF0YVtpICsgYnVmZmVyT2Zmc2V0XSA9IHNvdXJjZVtpXTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlV3JhcEF1ZGlvQnVmZmVyQ29weUNoYW5uZWxNZXRob2RzT3V0T2ZCb3VuZHMgPSBmdW5jdGlvbiBjcmVhdGVXcmFwQXVkaW9CdWZmZXJDb3B5Q2hhbm5lbE1ldGhvZHNPdXRPZkJvdW5kcyhjb252ZXJ0TnVtYmVyVG9VbnNpZ25lZExvbmcpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoYXVkaW9CdWZmZXIpIHtcbiAgICAgICAgYXVkaW9CdWZmZXIuY29weUZyb21DaGFubmVsID0gZnVuY3Rpb24gKGNvcHlGcm9tQ2hhbm5lbCkge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZGVzdGluYXRpb24sIGNoYW5uZWxOdW1iZXJBc051bWJlcikge1xuICAgICAgICAgICAgdmFyIGJ1ZmZlck9mZnNldEFzTnVtYmVyID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAwO1xuICAgICAgICAgICAgdmFyIGJ1ZmZlck9mZnNldCA9IGNvbnZlcnROdW1iZXJUb1Vuc2lnbmVkTG9uZyhidWZmZXJPZmZzZXRBc051bWJlcik7XG4gICAgICAgICAgICB2YXIgY2hhbm5lbE51bWJlciA9IGNvbnZlcnROdW1iZXJUb1Vuc2lnbmVkTG9uZyhjaGFubmVsTnVtYmVyQXNOdW1iZXIpO1xuICAgICAgICAgICAgaWYgKGJ1ZmZlck9mZnNldCA8IGF1ZGlvQnVmZmVyLmxlbmd0aCkge1xuICAgICAgICAgICAgICByZXR1cm4gY29weUZyb21DaGFubmVsLmNhbGwoYXVkaW9CdWZmZXIsIGRlc3RpbmF0aW9uLCBjaGFubmVsTnVtYmVyLCBidWZmZXJPZmZzZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH0oYXVkaW9CdWZmZXIuY29weUZyb21DaGFubmVsKTtcbiAgICAgICAgYXVkaW9CdWZmZXIuY29weVRvQ2hhbm5lbCA9IGZ1bmN0aW9uIChjb3B5VG9DaGFubmVsKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChzb3VyY2UsIGNoYW5uZWxOdW1iZXJBc051bWJlcikge1xuICAgICAgICAgICAgdmFyIGJ1ZmZlck9mZnNldEFzTnVtYmVyID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAwO1xuICAgICAgICAgICAgdmFyIGJ1ZmZlck9mZnNldCA9IGNvbnZlcnROdW1iZXJUb1Vuc2lnbmVkTG9uZyhidWZmZXJPZmZzZXRBc051bWJlcik7XG4gICAgICAgICAgICB2YXIgY2hhbm5lbE51bWJlciA9IGNvbnZlcnROdW1iZXJUb1Vuc2lnbmVkTG9uZyhjaGFubmVsTnVtYmVyQXNOdW1iZXIpO1xuICAgICAgICAgICAgaWYgKGJ1ZmZlck9mZnNldCA8IGF1ZGlvQnVmZmVyLmxlbmd0aCkge1xuICAgICAgICAgICAgICByZXR1cm4gY29weVRvQ2hhbm5lbC5jYWxsKGF1ZGlvQnVmZmVyLCBzb3VyY2UsIGNoYW5uZWxOdW1iZXIsIGJ1ZmZlck9mZnNldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfShhdWRpb0J1ZmZlci5jb3B5VG9DaGFubmVsKTtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVXcmFwQXVkaW9CdWZmZXJTb3VyY2VOb2RlU3RvcE1ldGhvZE51bGxpZmllZEJ1ZmZlciA9IGZ1bmN0aW9uIGNyZWF0ZVdyYXBBdWRpb0J1ZmZlclNvdXJjZU5vZGVTdG9wTWV0aG9kTnVsbGlmaWVkQnVmZmVyKG92ZXJ3cml0ZUFjY2Vzc29ycykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChuYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGUsIG5hdGl2ZUNvbnRleHQpIHtcbiAgICAgICAgdmFyIG51bGxpZmllZEJ1ZmZlciA9IG5hdGl2ZUNvbnRleHQuY3JlYXRlQnVmZmVyKDEsIDEsIDQ0MTAwKTtcbiAgICAgICAgaWYgKG5hdGl2ZUF1ZGlvQnVmZmVyU291cmNlTm9kZS5idWZmZXIgPT09IG51bGwpIHtcbiAgICAgICAgICBuYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGUuYnVmZmVyID0gbnVsbGlmaWVkQnVmZmVyO1xuICAgICAgICB9XG4gICAgICAgIG92ZXJ3cml0ZUFjY2Vzc29ycyhuYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGUsICdidWZmZXInLCBmdW5jdGlvbiAoZ2V0KSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGdldC5jYWxsKG5hdGl2ZUF1ZGlvQnVmZmVyU291cmNlTm9kZSk7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgPT09IG51bGxpZmllZEJ1ZmZlciA/IG51bGwgOiB2YWx1ZTtcbiAgICAgICAgICB9O1xuICAgICAgICB9LCBmdW5jdGlvbiAoc2V0KSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHNldC5jYWxsKG5hdGl2ZUF1ZGlvQnVmZmVyU291cmNlTm9kZSwgdmFsdWUgPT09IG51bGwgPyBudWxsaWZpZWRCdWZmZXIgOiB2YWx1ZSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlV3JhcENoYW5uZWxNZXJnZXJOb2RlID0gZnVuY3Rpb24gY3JlYXRlV3JhcENoYW5uZWxNZXJnZXJOb2RlKGNyZWF0ZUludmFsaWRTdGF0ZUVycm9yLCBtb25pdG9yQ29ubmVjdGlvbnMpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAobmF0aXZlQ29udGV4dCwgY2hhbm5lbE1lcmdlck5vZGUpIHtcbiAgICAgICAgLy8gQnVnICMxNTogU2FmYXJpIGRvZXMgbm90IHJldHVybiB0aGUgZGVmYXVsdCBwcm9wZXJ0aWVzLlxuICAgICAgICBjaGFubmVsTWVyZ2VyTm9kZS5jaGFubmVsQ291bnQgPSAxO1xuICAgICAgICBjaGFubmVsTWVyZ2VyTm9kZS5jaGFubmVsQ291bnRNb2RlID0gJ2V4cGxpY2l0JztcbiAgICAgICAgLy8gQnVnICMxNjogU2FmYXJpIGRvZXMgbm90IHRocm93IGFuIGVycm9yIHdoZW4gc2V0dGluZyBhIGRpZmZlcmVudCBjaGFubmVsQ291bnQgb3IgY2hhbm5lbENvdW50TW9kZS5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNoYW5uZWxNZXJnZXJOb2RlLCAnY2hhbm5lbENvdW50Jywge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCgpIHtcbiAgICAgICAgICAgIHRocm93IGNyZWF0ZUludmFsaWRTdGF0ZUVycm9yKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNoYW5uZWxNZXJnZXJOb2RlLCAnY2hhbm5lbENvdW50TW9kZScsIHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiAnZXhwbGljaXQnO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoKSB7XG4gICAgICAgICAgICB0aHJvdyBjcmVhdGVJbnZhbGlkU3RhdGVFcnJvcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEJ1ZyAjMjA6IFNhZmFyaSByZXF1aXJlcyBhIGNvbm5lY3Rpb24gb2YgYW55IGtpbmQgdG8gdHJlYXQgdGhlIGlucHV0IHNpZ25hbCBjb3JyZWN0bHkuXG4gICAgICAgIHZhciBhdWRpb0J1ZmZlclNvdXJjZU5vZGUgPSBuYXRpdmVDb250ZXh0LmNyZWF0ZUJ1ZmZlclNvdXJjZSgpO1xuICAgICAgICB2YXIgd2hlbkNvbm5lY3RlZCA9IGZ1bmN0aW9uIHdoZW5Db25uZWN0ZWQoKSB7XG4gICAgICAgICAgdmFyIGxlbmd0aCA9IGNoYW5uZWxNZXJnZXJOb2RlLm51bWJlck9mSW5wdXRzO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGF1ZGlvQnVmZmVyU291cmNlTm9kZS5jb25uZWN0KGNoYW5uZWxNZXJnZXJOb2RlLCAwLCBpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHZhciB3aGVuRGlzY29ubmVjdGVkID0gZnVuY3Rpb24gd2hlbkRpc2Nvbm5lY3RlZCgpIHtcbiAgICAgICAgICByZXR1cm4gYXVkaW9CdWZmZXJTb3VyY2VOb2RlLmRpc2Nvbm5lY3QoY2hhbm5lbE1lcmdlck5vZGUpO1xuICAgICAgICB9O1xuICAgICAgICBtb25pdG9yQ29ubmVjdGlvbnMoY2hhbm5lbE1lcmdlck5vZGUsIHdoZW5Db25uZWN0ZWQsIHdoZW5EaXNjb25uZWN0ZWQpO1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIGdldEZpcnN0U2FtcGxlID0gZnVuY3Rpb24gZ2V0Rmlyc3RTYW1wbGUoYXVkaW9CdWZmZXIsIGJ1ZmZlciwgY2hhbm5lbE51bWJlcikge1xuICAgICAgLy8gQnVnICM1OiBTYWZhcmkgZG9lcyBub3Qgc3VwcG9ydCBjb3B5RnJvbUNoYW5uZWwoKSBhbmQgY29weVRvQ2hhbm5lbCgpLlxuICAgICAgaWYgKGF1ZGlvQnVmZmVyLmNvcHlGcm9tQ2hhbm5lbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBhdWRpb0J1ZmZlci5nZXRDaGFubmVsRGF0YShjaGFubmVsTnVtYmVyKVswXTtcbiAgICAgIH1cbiAgICAgIGF1ZGlvQnVmZmVyLmNvcHlGcm9tQ2hhbm5lbChidWZmZXIsIGNoYW5uZWxOdW1iZXIpO1xuICAgICAgcmV0dXJuIGJ1ZmZlclswXTtcbiAgICB9O1xuXG4gICAgdmFyIGlzRENDdXJ2ZSA9IGZ1bmN0aW9uIGlzRENDdXJ2ZShjdXJ2ZSkge1xuICAgICAgaWYgKGN1cnZlID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBsZW5ndGggPSBjdXJ2ZS5sZW5ndGg7XG4gICAgICBpZiAobGVuZ3RoICUgMiAhPT0gMCkge1xuICAgICAgICByZXR1cm4gY3VydmVbTWF0aC5mbG9vcihsZW5ndGggLyAyKV0gIT09IDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gY3VydmVbbGVuZ3RoIC8gMiAtIDFdICsgY3VydmVbbGVuZ3RoIC8gMl0gIT09IDA7XG4gICAgfTtcblxuICAgIHZhciBvdmVyd3JpdGVBY2Nlc3NvcnMgPSBmdW5jdGlvbiBvdmVyd3JpdGVBY2Nlc3NvcnMob2JqZWN0LCBwcm9wZXJ0eSwgY3JlYXRlR2V0dGVyLCBjcmVhdGVTZXR0ZXIpIHtcbiAgICAgIHZhciBwcm90b3R5cGUgPSBvYmplY3Q7XG4gICAgICB3aGlsZSAoIXByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eSkpIHtcbiAgICAgICAgcHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvdHlwZSk7XG4gICAgICB9XG4gICAgICB2YXIgX09iamVjdCRnZXRPd25Qcm9wZXJ0ID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihwcm90b3R5cGUsIHByb3BlcnR5KSxcbiAgICAgICAgZ2V0ID0gX09iamVjdCRnZXRPd25Qcm9wZXJ0LmdldCxcbiAgICAgICAgc2V0ID0gX09iamVjdCRnZXRPd25Qcm9wZXJ0LnNldDtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsIHByb3BlcnR5LCB7XG4gICAgICAgIGdldDogY3JlYXRlR2V0dGVyKGdldCksXG4gICAgICAgIHNldDogY3JlYXRlU2V0dGVyKHNldClcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBvd25LZXlzJDIoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuICAgIGZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkMihlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzJDIoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzJDIoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTsgfSk7IH0gcmV0dXJuIGU7IH1cbiAgICB2YXIgc2FuaXRpemVBdWRpb1dvcmtsZXROb2RlT3B0aW9ucyA9IGZ1bmN0aW9uIHNhbml0aXplQXVkaW9Xb3JrbGV0Tm9kZU9wdGlvbnMob3B0aW9ucykge1xuICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQkMihfb2JqZWN0U3ByZWFkJDIoe30sIG9wdGlvbnMpLCB7fSwge1xuICAgICAgICBvdXRwdXRDaGFubmVsQ291bnQ6IG9wdGlvbnMub3V0cHV0Q2hhbm5lbENvdW50ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm91dHB1dENoYW5uZWxDb3VudCA6IG9wdGlvbnMubnVtYmVyT2ZJbnB1dHMgPT09IDEgJiYgb3B0aW9ucy5udW1iZXJPZk91dHB1dHMgPT09IDEgP1xuICAgICAgICAvKlxuICAgICAgICAgKiBCdWcgIzYxOiBUaGlzIHNob3VsZCBiZSB0aGUgY29tcHV0ZWROdW1iZXJPZkNoYW5uZWxzLCBidXQgdW5mb3J0dW5hdGVseSB0aGF0IGlzIGFsbW9zdCBpbXBvc3NpYmxlIHRvIGZha2UuIFRoYXQncyB3aHlcbiAgICAgICAgICogdGhlIGNoYW5uZWxDb3VudE1vZGUgaXMgcmVxdWlyZWQgdG8gYmUgJ2V4cGxpY2l0JyBhcyBsb25nIGFzIHRoZXJlIGlzIG5vdCBhIG5hdGl2ZSBpbXBsZW1lbnRhdGlvbiBpbiBldmVyeSBicm93c2VyLiBUaGF0XG4gICAgICAgICAqIG1ha2VzIHN1cmUgdGhlIGNvbXB1dGVkTnVtYmVyT2ZDaGFubmVscyBpcyBlcXVpdmlsYW50IHRvIHRoZSBjaGFubmVsQ291bnQgd2hpY2ggbWFrZXMgaXQgbXVjaCBlYXNpZXIgdG8gY29tcHV0ZS5cbiAgICAgICAgICovXG4gICAgICAgIFtvcHRpb25zLmNoYW5uZWxDb3VudF0gOiBBcnJheS5mcm9tKHtcbiAgICAgICAgICBsZW5ndGg6IG9wdGlvbnMubnVtYmVyT2ZPdXRwdXRzXG4gICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBvd25LZXlzJDEoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuICAgIGZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkMShlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzJDEoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzJDEoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTsgfSk7IH0gcmV0dXJuIGU7IH1cbiAgICB2YXIgc2FuaXRpemVDaGFubmVsU3BsaXR0ZXJPcHRpb25zID0gZnVuY3Rpb24gc2FuaXRpemVDaGFubmVsU3BsaXR0ZXJPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkJDEoX29iamVjdFNwcmVhZCQxKHt9LCBvcHRpb25zKSwge30sIHtcbiAgICAgICAgY2hhbm5lbENvdW50OiBvcHRpb25zLm51bWJlck9mT3V0cHV0c1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIG93bktleXMoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuICAgIGZ1bmN0aW9uIF9vYmplY3RTcHJlYWQoZSkgeyBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykgeyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gb3duS2V5cyhPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTsgfSk7IH0gcmV0dXJuIGU7IH1cbiAgICB2YXIgc2FuaXRpemVQZXJpb2RpY1dhdmVPcHRpb25zID0gZnVuY3Rpb24gc2FuaXRpemVQZXJpb2RpY1dhdmVPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgIHZhciBpbWFnID0gb3B0aW9ucy5pbWFnLFxuICAgICAgICByZWFsID0gb3B0aW9ucy5yZWFsO1xuICAgICAgaWYgKGltYWcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAocmVhbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgb3B0aW9ucyksIHt9LCB7XG4gICAgICAgICAgICBpbWFnOiBbMCwgMF0sXG4gICAgICAgICAgICByZWFsOiBbMCwgMF1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBvcHRpb25zKSwge30sIHtcbiAgICAgICAgICBpbWFnOiBBcnJheS5mcm9tKHJlYWwsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgIH0pLFxuICAgICAgICAgIHJlYWw6IHJlYWxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAocmVhbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIG9wdGlvbnMpLCB7fSwge1xuICAgICAgICAgIGltYWc6IGltYWcsXG4gICAgICAgICAgcmVhbDogQXJyYXkuZnJvbShpbWFnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICB9KVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIG9wdGlvbnMpLCB7fSwge1xuICAgICAgICBpbWFnOiBpbWFnLFxuICAgICAgICByZWFsOiByZWFsXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgdmFyIF9zZXRWYWx1ZUF0VGltZVVudGlsUG9zc2libGUgPSBmdW5jdGlvbiBzZXRWYWx1ZUF0VGltZVVudGlsUG9zc2libGUoYXVkaW9QYXJhbSwgdmFsdWUsIHN0YXJ0VGltZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXVkaW9QYXJhbS5zZXRWYWx1ZUF0VGltZSh2YWx1ZSwgc3RhcnRUaW1lKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAoZXJyLmNvZGUgIT09IDkpIHtcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICAgICAgX3NldFZhbHVlQXRUaW1lVW50aWxQb3NzaWJsZShhdWRpb1BhcmFtLCB2YWx1ZSwgc3RhcnRUaW1lICsgMWUtNyk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciB0ZXN0QXVkaW9CdWZmZXJTb3VyY2VOb2RlU3RhcnRNZXRob2RDb25zZWN1dGl2ZUNhbGxzU3VwcG9ydCA9IGZ1bmN0aW9uIHRlc3RBdWRpb0J1ZmZlclNvdXJjZU5vZGVTdGFydE1ldGhvZENvbnNlY3V0aXZlQ2FsbHNTdXBwb3J0KG5hdGl2ZUNvbnRleHQpIHtcbiAgICAgIHZhciBuYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGUgPSBuYXRpdmVDb250ZXh0LmNyZWF0ZUJ1ZmZlclNvdXJjZSgpO1xuICAgICAgbmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2RlLnN0YXJ0KCk7XG4gICAgICB0cnkge1xuICAgICAgICBuYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGUuc3RhcnQoKTtcbiAgICAgIH0gY2F0Y2ggKF91bnVzZWQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIHZhciB0ZXN0QXVkaW9CdWZmZXJTb3VyY2VOb2RlU3RhcnRNZXRob2RPZmZzZXRDbGFtcGluZ1N1cHBvcnQgPSBmdW5jdGlvbiB0ZXN0QXVkaW9CdWZmZXJTb3VyY2VOb2RlU3RhcnRNZXRob2RPZmZzZXRDbGFtcGluZ1N1cHBvcnQobmF0aXZlQ29udGV4dCkge1xuICAgICAgdmFyIG5hdGl2ZUF1ZGlvQnVmZmVyU291cmNlTm9kZSA9IG5hdGl2ZUNvbnRleHQuY3JlYXRlQnVmZmVyU291cmNlKCk7XG4gICAgICB2YXIgbmF0aXZlQXVkaW9CdWZmZXIgPSBuYXRpdmVDb250ZXh0LmNyZWF0ZUJ1ZmZlcigxLCAxLCA0NDEwMCk7XG4gICAgICBuYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGUuYnVmZmVyID0gbmF0aXZlQXVkaW9CdWZmZXI7XG4gICAgICB0cnkge1xuICAgICAgICBuYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGUuc3RhcnQoMCwgMSk7XG4gICAgICB9IGNhdGNoIChfdW51c2VkKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICB2YXIgdGVzdEF1ZGlvQnVmZmVyU291cmNlTm9kZVN0b3BNZXRob2ROdWxsaWZpZWRCdWZmZXJTdXBwb3J0ID0gZnVuY3Rpb24gdGVzdEF1ZGlvQnVmZmVyU291cmNlTm9kZVN0b3BNZXRob2ROdWxsaWZpZWRCdWZmZXJTdXBwb3J0KG5hdGl2ZUNvbnRleHQpIHtcbiAgICAgIHZhciBuYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGUgPSBuYXRpdmVDb250ZXh0LmNyZWF0ZUJ1ZmZlclNvdXJjZSgpO1xuICAgICAgbmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2RlLnN0YXJ0KCk7XG4gICAgICB0cnkge1xuICAgICAgICBuYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGUuc3RvcCgpO1xuICAgICAgfSBjYXRjaCAoX3VudXNlZCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgdmFyIHRlc3RBdWRpb1NjaGVkdWxlZFNvdXJjZU5vZGVTdGFydE1ldGhvZE5lZ2F0aXZlUGFyYW1ldGVyc1N1cHBvcnQgPSBmdW5jdGlvbiB0ZXN0QXVkaW9TY2hlZHVsZWRTb3VyY2VOb2RlU3RhcnRNZXRob2ROZWdhdGl2ZVBhcmFtZXRlcnNTdXBwb3J0KG5hdGl2ZUNvbnRleHQpIHtcbiAgICAgIHZhciBuYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGUgPSBuYXRpdmVDb250ZXh0LmNyZWF0ZU9zY2lsbGF0b3IoKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIG5hdGl2ZUF1ZGlvQnVmZmVyU291cmNlTm9kZS5zdGFydCgtMSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIGVyciBpbnN0YW5jZW9mIFJhbmdlRXJyb3I7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIHZhciB0ZXN0QXVkaW9TY2hlZHVsZWRTb3VyY2VOb2RlU3RvcE1ldGhvZENvbnNlY3V0aXZlQ2FsbHNTdXBwb3J0ID0gZnVuY3Rpb24gdGVzdEF1ZGlvU2NoZWR1bGVkU291cmNlTm9kZVN0b3BNZXRob2RDb25zZWN1dGl2ZUNhbGxzU3VwcG9ydChuYXRpdmVDb250ZXh0KSB7XG4gICAgICB2YXIgbmF0aXZlQXVkaW9CdWZmZXIgPSBuYXRpdmVDb250ZXh0LmNyZWF0ZUJ1ZmZlcigxLCAxLCA0NDEwMCk7XG4gICAgICB2YXIgbmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2RlID0gbmF0aXZlQ29udGV4dC5jcmVhdGVCdWZmZXJTb3VyY2UoKTtcbiAgICAgIG5hdGl2ZUF1ZGlvQnVmZmVyU291cmNlTm9kZS5idWZmZXIgPSBuYXRpdmVBdWRpb0J1ZmZlcjtcbiAgICAgIG5hdGl2ZUF1ZGlvQnVmZmVyU291cmNlTm9kZS5zdGFydCgpO1xuICAgICAgbmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2RlLnN0b3AoKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIG5hdGl2ZUF1ZGlvQnVmZmVyU291cmNlTm9kZS5zdG9wKCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBjYXRjaCAoX3VudXNlZCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciB0ZXN0QXVkaW9TY2hlZHVsZWRTb3VyY2VOb2RlU3RvcE1ldGhvZE5lZ2F0aXZlUGFyYW1ldGVyc1N1cHBvcnQgPSBmdW5jdGlvbiB0ZXN0QXVkaW9TY2hlZHVsZWRTb3VyY2VOb2RlU3RvcE1ldGhvZE5lZ2F0aXZlUGFyYW1ldGVyc1N1cHBvcnQobmF0aXZlQ29udGV4dCkge1xuICAgICAgdmFyIG5hdGl2ZUF1ZGlvQnVmZmVyU291cmNlTm9kZSA9IG5hdGl2ZUNvbnRleHQuY3JlYXRlT3NjaWxsYXRvcigpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgbmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2RlLnN0b3AoLTEpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJldHVybiBlcnIgaW5zdGFuY2VvZiBSYW5nZUVycm9yO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICB2YXIgdGVzdEF1ZGlvV29ya2xldE5vZGVPcHRpb25zQ2xvbmFiaWxpdHkgPSBmdW5jdGlvbiB0ZXN0QXVkaW9Xb3JrbGV0Tm9kZU9wdGlvbnNDbG9uYWJpbGl0eShhdWRpb1dvcmtsZXROb2RlT3B0aW9ucykge1xuICAgICAgdmFyIF9NZXNzYWdlQ2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpLFxuICAgICAgICBwb3J0MSA9IF9NZXNzYWdlQ2hhbm5lbC5wb3J0MSxcbiAgICAgICAgcG9ydDIgPSBfTWVzc2FnZUNoYW5uZWwucG9ydDI7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBUaGlzIHdpbGwgdGhyb3cgYW4gZXJyb3IgaWYgdGhlIGF1ZGlvV29ya2xldE5vZGVPcHRpb25zIGFyZSBub3QgY2xvbmFibGUuXG4gICAgICAgIHBvcnQxLnBvc3RNZXNzYWdlKGF1ZGlvV29ya2xldE5vZGVPcHRpb25zKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHBvcnQxLmNsb3NlKCk7XG4gICAgICAgIHBvcnQyLmNsb3NlKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qXG4gICAgICogQnVnICMxMjI6IEVkZ2UgdXAgdG8gdmVyc2lvbiB2MTggZGlkIG5vdCBhbGxvdyB0byBjb25zdHJ1Y3QgYSBET01FeGNlcHRpb24nLiBJdCBhbHNvIGhhZCBhIGNvdXBsZSBtb3JlIGJ1Z3MgYnV0IHNpbmNlIHRoaXMgaXMgZWFzeSB0b1xuICAgICAqIHRlc3QgaXQncyB1c2VkIGhlcmUgYXMgYSBwbGFjZWhvbGRlci5cbiAgICAgKlxuICAgICAqIEJ1ZyAjMjc6IEVkZ2UgdXAgdG8gdmVyc2lvbiB2MTggZGlkIHJlamVjdCBhbiBpbnZhbGlkIGFycmF5QnVmZmVyIHBhc3NlZCB0byBkZWNvZGVBdWRpb0RhdGEoKSB3aXRoIGEgRE9NRXhjZXB0aW9uLlxuICAgICAqXG4gICAgICogQnVnICM1MDogRWRnZSB1cCB0byB2ZXJzaW9uIHYxOCBkaWQgbm90IGFsbG93IHRvIGNyZWF0ZSBBdWRpb05vZGVzIG9uIGEgY2xvc2VkIGNvbnRleHQuXG4gICAgICpcbiAgICAgKiBCdWcgIzU3OiBFZGdlIHVwIHRvIHZlcnNpb24gdjE4IGRpZCBub3QgdGhyb3cgYW4gZXJyb3Igd2hlbiBhc3NpZ25pbmcgdGhlIHR5cGUgb2YgYW4gT3NjaWxsYXRvck5vZGUgdG8gJ2N1c3RvbScuXG4gICAgICpcbiAgICAgKiBCdWcgIzYzOiBFZGdlIHVwIHRvIHZlcnNpb24gdjE4IGRpZCBub3QgZXhwb3NlIHRoZSBtZWRpYUVsZW1lbnQgcHJvcGVydHkgb2YgYSBNZWRpYUVsZW1lbnRBdWRpb1NvdXJjZU5vZGUuXG4gICAgICpcbiAgICAgKiBCdWcgIzY0OiBFZGdlIHVwIHRvIHZlcnNpb24gdjE4IGRpZCBub3Qgc3VwcG9ydCB0aGUgTWVkaWFTdHJlYW1BdWRpb0Rlc3RpbmF0aW9uTm9kZS5cbiAgICAgKlxuICAgICAqIEJ1ZyAjNzE6IEVkZ2UgdXAgdG8gdmVyc2lvbiB2MTggZGlkIG5vdCBhbGxvdyB0byBzZXQgdGhlIGJ1ZmZlciBvZiBhbiBBdWRpb0J1ZmZlclNvdXJjZU5vZGUgdG8gbnVsbC5cbiAgICAgKlxuICAgICAqIEJ1ZyAjOTM6IEVkZ2UgdXAgdG8gdmVyc2lvbiB2MTggZGlkIHNldCB0aGUgc2FtcGxlUmF0ZSBvZiBhbiBBdWRpb0NvbnRleHQgdG8gemVybyB3aGVuIGl0IHdhcyBjbG9zZWQuXG4gICAgICpcbiAgICAgKiBCdWcgIzEwMTogRWRnZSB1cCB0byB2ZXJzaW9uIHYxOCByZWZ1c2VkIHRvIGV4ZWN1dGUgZGVjb2RlQXVkaW9EYXRhKCkgb24gYSBjbG9zZWQgY29udGV4dC5cbiAgICAgKlxuICAgICAqIEJ1ZyAjMTA2OiBFZGdlIHVwIHRvIHZlcnNpb24gdjE4IGRpZCBub3QgZXhwb3NlIHRoZSBtYXhWYWx1ZSBhbmQgbWluVmFsdWUgcHJvcGVydGllcyBvZiB0aGUgcGFuIEF1ZGlvUGFyYW0gb2YgYSBTdGVyZW9QYW5uZXJOb2RlLlxuICAgICAqXG4gICAgICogQnVnICMxMTA6IEVkZ2UgdXAgdG8gdmVyc2lvbiB2MTggZGlkIG5vdCBleHBvc2UgdGhlIG1heFZhbHVlIGFuZCBtaW5WYWx1ZSBwcm9wZXJ0aWVzIG9mIHRoZSBhdHRhY2ssIGtuZWUsIHJhdGlvLCByZWxlYXNlIGFuZCB0aHJlc2hvbGQgQXVkaW9QYXJhbXMgb2YgYSBEeW5hbWljc0NvbXByZXNzb3JOb2RlLlxuICAgICAqXG4gICAgICogQnVnICMxMjM6IEVkZ2UgdXAgdG8gdmVyc2lvbiB2MTggZGlkIG5vdCBzdXBwb3J0IEhSVEYgYXMgdGhlIHBhbm5pbmdNb2RlbCBmb3IgYSBQYW5uZXJOb2RlLlxuICAgICAqXG4gICAgICogQnVnICMxNDU6IEVkZ2UgdXAgdG8gdmVyc2lvbiB2MTggZGlkIHRocm93IGFuIEluZGV4U2l6ZUVycm9yIHdoZW4gYW4gT2ZmbGluZUF1ZGlvQ29udGV4dCB3YXMgY3JlYXRlZCB3aXRoIGEgc2FtcGxlUmF0ZSBvZiB6ZXJvLlxuICAgICAqXG4gICAgICogQnVnICMxNjE6IEVkZ2UgdXAgdG8gdmVyc2lvbiB2MTggZGlkIG5vdCBleHBvc2UgdGhlIG1heFZhbHVlIGFuZCBtaW5WYWx1ZSBwcm9wZXJ0aWVzIG9mIHRoZSBkZWxheVRpbWUgQXVkaW9QYXJhbSBvZiBhIERlbGF5Tm9kZS5cbiAgICAgKi9cbiAgICB2YXIgdGVzdERvbUV4Y2VwdGlvbkNvbnN0cnVjdG9yU3VwcG9ydCA9IGZ1bmN0aW9uIHRlc3REb21FeGNlcHRpb25Db25zdHJ1Y3RvclN1cHBvcnQoKSB7XG4gICAgICB0cnkge1xuICAgICAgICBuZXcgRE9NRXhjZXB0aW9uKCk7IC8vIHRzbGludDpkaXNhYmxlLWxpbmU6bm8tdW51c2VkLWV4cHJlc3Npb25cbiAgICAgIH0gY2F0Y2ggKF91bnVzZWQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcblxuICAgIC8vIFNhZmFyaSBhdCB2ZXJzaW9uIDExIGRpZCBub3Qgc3VwcG9ydCB0cmFuc2ZlcmFibGVzLlxuICAgIHZhciB0ZXN0VHJhbnNmZXJhYmxlc1N1cHBvcnQgPSBmdW5jdGlvbiB0ZXN0VHJhbnNmZXJhYmxlc1N1cHBvcnQoKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgdmFyIGFycmF5QnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKDApO1xuICAgICAgICB2YXIgX01lc3NhZ2VDaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCksXG4gICAgICAgICAgcG9ydDEgPSBfTWVzc2FnZUNoYW5uZWwucG9ydDEsXG4gICAgICAgICAgcG9ydDIgPSBfTWVzc2FnZUNoYW5uZWwucG9ydDI7XG4gICAgICAgIHBvcnQxLm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICAgICAgdmFyIGRhdGEgPSBfcmVmLmRhdGE7XG4gICAgICAgICAgcmV0dXJuIHJlc29sdmUoZGF0YSAhPT0gbnVsbCk7XG4gICAgICAgIH07XG4gICAgICAgIHBvcnQyLnBvc3RNZXNzYWdlKGFycmF5QnVmZmVyLCBbYXJyYXlCdWZmZXJdKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICB2YXIgd3JhcEF1ZGlvQnVmZmVyU291cmNlTm9kZVN0YXJ0TWV0aG9kT2Zmc2V0Q2xhbXBpbmcgPSBmdW5jdGlvbiB3cmFwQXVkaW9CdWZmZXJTb3VyY2VOb2RlU3RhcnRNZXRob2RPZmZzZXRDbGFtcGluZyhuYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGUpIHtcbiAgICAgIG5hdGl2ZUF1ZGlvQnVmZmVyU291cmNlTm9kZS5zdGFydCA9IGZ1bmN0aW9uIChzdGFydCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciB3aGVuID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAwO1xuICAgICAgICAgIHZhciBvZmZzZXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDA7XG4gICAgICAgICAgdmFyIGR1cmF0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgdmFyIGJ1ZmZlciA9IG5hdGl2ZUF1ZGlvQnVmZmVyU291cmNlTm9kZS5idWZmZXI7XG4gICAgICAgICAgLy8gQnVnICMxNTQ6IFNhZmFyaSBkb2VzIG5vdCBjbGFtcCB0aGUgb2Zmc2V0IGlmIGl0IGlzIGVxdWFsIHRvIG9yIGdyZWF0ZXIgdGhhbiB0aGUgZHVyYXRpb24gb2YgdGhlIGJ1ZmZlci5cbiAgICAgICAgICB2YXIgY2xhbXBlZE9mZnNldCA9IGJ1ZmZlciA9PT0gbnVsbCA/IG9mZnNldCA6IE1hdGgubWluKGJ1ZmZlci5kdXJhdGlvbiwgb2Zmc2V0KTtcbiAgICAgICAgICAvLyBCdWcgIzE1NTogU2FmYXJpIGRvZXMgbm90IGhhbmRsZSB0aGUgb2Zmc2V0IGNvcnJlY3RseSBpZiBpdCB3b3VsZCBjYXVzZSB0aGUgYnVmZmVyIHRvIGJlIG5vdCBiZSBwbGF5ZWQgYXQgYWxsLlxuICAgICAgICAgIGlmIChidWZmZXIgIT09IG51bGwgJiYgY2xhbXBlZE9mZnNldCA+IGJ1ZmZlci5kdXJhdGlvbiAtIDAuNSAvIG5hdGl2ZUF1ZGlvQnVmZmVyU291cmNlTm9kZS5jb250ZXh0LnNhbXBsZVJhdGUpIHtcbiAgICAgICAgICAgIHN0YXJ0LmNhbGwobmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2RlLCB3aGVuLCAwLCAwKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RhcnQuY2FsbChuYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGUsIHdoZW4sIGNsYW1wZWRPZmZzZXQsIGR1cmF0aW9uKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9KG5hdGl2ZUF1ZGlvQnVmZmVyU291cmNlTm9kZS5zdGFydCk7XG4gICAgfTtcblxuICAgIHZhciB3cmFwQXVkaW9TY2hlZHVsZWRTb3VyY2VOb2RlU3RvcE1ldGhvZENvbnNlY3V0aXZlQ2FsbHMgPSBmdW5jdGlvbiB3cmFwQXVkaW9TY2hlZHVsZWRTb3VyY2VOb2RlU3RvcE1ldGhvZENvbnNlY3V0aXZlQ2FsbHMobmF0aXZlQXVkaW9TY2hlZHVsZWRTb3VyY2VOb2RlLCBuYXRpdmVDb250ZXh0KSB7XG4gICAgICB2YXIgbmF0aXZlR2Fpbk5vZGUgPSBuYXRpdmVDb250ZXh0LmNyZWF0ZUdhaW4oKTtcbiAgICAgIG5hdGl2ZUF1ZGlvU2NoZWR1bGVkU291cmNlTm9kZS5jb25uZWN0KG5hdGl2ZUdhaW5Ob2RlKTtcbiAgICAgIHZhciBkaXNjb25uZWN0R2Fpbk5vZGUgPSBmdW5jdGlvbiAoZGlzY29ubmVjdCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIC8vIEB0b2RvIFR5cGVTY3JpcHQgY2Fubm90IGluZmVyIHRoZSBvdmVybG9hZGVkIHNpZ25hdHVyZSB3aXRoIDEgYXJndW1lbnQgeWV0LlxuICAgICAgICAgIGRpc2Nvbm5lY3QuY2FsbChuYXRpdmVBdWRpb1NjaGVkdWxlZFNvdXJjZU5vZGUsIG5hdGl2ZUdhaW5Ob2RlKTtcbiAgICAgICAgICBuYXRpdmVBdWRpb1NjaGVkdWxlZFNvdXJjZU5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcignZW5kZWQnLCBkaXNjb25uZWN0R2Fpbk5vZGUpO1xuICAgICAgICB9O1xuICAgICAgfShuYXRpdmVBdWRpb1NjaGVkdWxlZFNvdXJjZU5vZGUuZGlzY29ubmVjdCk7XG4gICAgICBuYXRpdmVBdWRpb1NjaGVkdWxlZFNvdXJjZU5vZGUuYWRkRXZlbnRMaXN0ZW5lcignZW5kZWQnLCBkaXNjb25uZWN0R2Fpbk5vZGUpO1xuICAgICAgaW50ZXJjZXB0Q29ubmVjdGlvbnMobmF0aXZlQXVkaW9TY2hlZHVsZWRTb3VyY2VOb2RlLCBuYXRpdmVHYWluTm9kZSk7XG4gICAgICBuYXRpdmVBdWRpb1NjaGVkdWxlZFNvdXJjZU5vZGUuc3RvcCA9IGZ1bmN0aW9uIChzdG9wKSB7XG4gICAgICAgIHZhciBpc1N0b3BwZWQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgd2hlbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogMDtcbiAgICAgICAgICBpZiAoaXNTdG9wcGVkKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBzdG9wLmNhbGwobmF0aXZlQXVkaW9TY2hlZHVsZWRTb3VyY2VOb2RlLCB3aGVuKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKF91bnVzZWQpIHtcbiAgICAgICAgICAgICAgbmF0aXZlR2Fpbk5vZGUuZ2Fpbi5zZXRWYWx1ZUF0VGltZSgwLCB3aGVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RvcC5jYWxsKG5hdGl2ZUF1ZGlvU2NoZWR1bGVkU291cmNlTm9kZSwgd2hlbik7XG4gICAgICAgICAgICBpc1N0b3BwZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH0obmF0aXZlQXVkaW9TY2hlZHVsZWRTb3VyY2VOb2RlLnN0b3ApO1xuICAgIH07XG5cbiAgICB2YXIgd3JhcEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiB3cmFwRXZlbnRMaXN0ZW5lcih0YXJnZXQsIGV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIGRlc2NyaXB0b3IgPSB7XG4gICAgICAgICAgdmFsdWU6IHRhcmdldFxuICAgICAgICB9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhldmVudCwge1xuICAgICAgICAgIGN1cnJlbnRUYXJnZXQ6IGRlc2NyaXB0b3IsXG4gICAgICAgICAgdGFyZ2V0OiBkZXNjcmlwdG9yXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodHlwZW9mIGV2ZW50TGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICByZXR1cm4gZXZlbnRMaXN0ZW5lci5jYWxsKHRhcmdldCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBldmVudExpc3RlbmVyLmhhbmRsZUV2ZW50LmNhbGwodGFyZ2V0LCBldmVudCk7XG4gICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgYWRkQWN0aXZlSW5wdXRDb25uZWN0aW9uVG9BdWRpb05vZGUgPSBjcmVhdGVBZGRBY3RpdmVJbnB1dENvbm5lY3Rpb25Ub0F1ZGlvTm9kZShpbnNlcnRFbGVtZW50SW5TZXQpO1xuICAgIHZhciBhZGRQYXNzaXZlSW5wdXRDb25uZWN0aW9uVG9BdWRpb05vZGUgPSBjcmVhdGVBZGRQYXNzaXZlSW5wdXRDb25uZWN0aW9uVG9BdWRpb05vZGUoaW5zZXJ0RWxlbWVudEluU2V0KTtcbiAgICB2YXIgZGVsZXRlQWN0aXZlSW5wdXRDb25uZWN0aW9uVG9BdWRpb05vZGUgPSBjcmVhdGVEZWxldGVBY3RpdmVJbnB1dENvbm5lY3Rpb25Ub0F1ZGlvTm9kZShwaWNrRWxlbWVudEZyb21TZXQpO1xuICAgIHZhciBhdWRpb05vZGVUYWlsVGltZVN0b3JlID0gbmV3IFdlYWtNYXAoKTtcbiAgICB2YXIgZ2V0QXVkaW9Ob2RlVGFpbFRpbWUgPSBjcmVhdGVHZXRBdWRpb05vZGVUYWlsVGltZShhdWRpb05vZGVUYWlsVGltZVN0b3JlKTtcbiAgICB2YXIgY2FjaGVUZXN0UmVzdWx0ID0gY3JlYXRlQ2FjaGVUZXN0UmVzdWx0KG5ldyBNYXAoKSwgbmV3IFdlYWtNYXAoKSk7XG4gICAgdmFyIHdpbmRvdyQxID0gY3JlYXRlV2luZG93KCk7XG4gICAgdmFyIGNyZWF0ZU5hdGl2ZUFuYWx5c2VyTm9kZSA9IGNyZWF0ZU5hdGl2ZUFuYWx5c2VyTm9kZUZhY3RvcnkoY2FjaGVUZXN0UmVzdWx0LCBjcmVhdGVJbmRleFNpemVFcnJvcik7XG4gICAgdmFyIGdldEF1ZGlvTm9kZVJlbmRlcmVyID0gY3JlYXRlR2V0QXVkaW9Ob2RlUmVuZGVyZXIoZ2V0QXVkaW9Ob2RlQ29ubmVjdGlvbnMpO1xuICAgIHZhciByZW5kZXJJbnB1dHNPZkF1ZGlvTm9kZSA9IGNyZWF0ZVJlbmRlcklucHV0c09mQXVkaW9Ob2RlKGdldEF1ZGlvTm9kZUNvbm5lY3Rpb25zLCBnZXRBdWRpb05vZGVSZW5kZXJlciwgaXNQYXJ0T2ZBQ3ljbGUpO1xuICAgIHZhciBjcmVhdGVBbmFseXNlck5vZGVSZW5kZXJlciA9IGNyZWF0ZUFuYWx5c2VyTm9kZVJlbmRlcmVyRmFjdG9yeShjcmVhdGVOYXRpdmVBbmFseXNlck5vZGUsIGdldE5hdGl2ZUF1ZGlvTm9kZSwgcmVuZGVySW5wdXRzT2ZBdWRpb05vZGUpO1xuICAgIHZhciBnZXROYXRpdmVDb250ZXh0ID0gY3JlYXRlR2V0TmF0aXZlQ29udGV4dChDT05URVhUX1NUT1JFKTtcbiAgICB2YXIgbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dENvbnN0cnVjdG9yID0gY3JlYXRlTmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dENvbnN0cnVjdG9yKHdpbmRvdyQxKTtcbiAgICB2YXIgaXNOYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0ID0gY3JlYXRlSXNOYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHRDb25zdHJ1Y3Rvcik7XG4gICAgdmFyIGF1ZGlvUGFyYW1BdWRpb05vZGVTdG9yZSA9IG5ldyBXZWFrTWFwKCk7XG4gICAgdmFyIGV2ZW50VGFyZ2V0Q29uc3RydWN0b3IgPSBjcmVhdGVFdmVudFRhcmdldENvbnN0cnVjdG9yKHdyYXBFdmVudExpc3RlbmVyKTtcbiAgICB2YXIgbmF0aXZlQXVkaW9Db250ZXh0Q29uc3RydWN0b3IgPSBjcmVhdGVOYXRpdmVBdWRpb0NvbnRleHRDb25zdHJ1Y3Rvcih3aW5kb3ckMSk7XG4gICAgdmFyIGlzTmF0aXZlQXVkaW9Db250ZXh0ID0gY3JlYXRlSXNOYXRpdmVBdWRpb0NvbnRleHQobmF0aXZlQXVkaW9Db250ZXh0Q29uc3RydWN0b3IpO1xuICAgIHZhciBpc05hdGl2ZUF1ZGlvTm9kZSA9IGNyZWF0ZUlzTmF0aXZlQXVkaW9Ob2RlKHdpbmRvdyQxKTtcbiAgICB2YXIgaXNOYXRpdmVBdWRpb1BhcmFtID0gY3JlYXRlSXNOYXRpdmVBdWRpb1BhcmFtKHdpbmRvdyQxKTtcbiAgICB2YXIgbmF0aXZlQXVkaW9Xb3JrbGV0Tm9kZUNvbnN0cnVjdG9yID0gY3JlYXRlTmF0aXZlQXVkaW9Xb3JrbGV0Tm9kZUNvbnN0cnVjdG9yKHdpbmRvdyQxKTtcbiAgICB2YXIgYXVkaW9Ob2RlQ29uc3RydWN0b3IgPSBjcmVhdGVBdWRpb05vZGVDb25zdHJ1Y3RvcihjcmVhdGVBZGRBdWRpb05vZGVDb25uZWN0aW9ucyhBVURJT19OT0RFX0NPTk5FQ1RJT05TX1NUT1JFKSwgY3JlYXRlQWRkQ29ubmVjdGlvblRvQXVkaW9Ob2RlKGFkZEFjdGl2ZUlucHV0Q29ubmVjdGlvblRvQXVkaW9Ob2RlLCBhZGRQYXNzaXZlSW5wdXRDb25uZWN0aW9uVG9BdWRpb05vZGUsIGNvbm5lY3ROYXRpdmVBdWRpb05vZGVUb05hdGl2ZUF1ZGlvTm9kZSwgZGVsZXRlQWN0aXZlSW5wdXRDb25uZWN0aW9uVG9BdWRpb05vZGUsIGRpc2Nvbm5lY3ROYXRpdmVBdWRpb05vZGVGcm9tTmF0aXZlQXVkaW9Ob2RlLCBnZXRBdWRpb05vZGVDb25uZWN0aW9ucywgZ2V0QXVkaW9Ob2RlVGFpbFRpbWUsIGdldEV2ZW50TGlzdGVuZXJzT2ZBdWRpb05vZGUsIGdldE5hdGl2ZUF1ZGlvTm9kZSwgaW5zZXJ0RWxlbWVudEluU2V0LCBpc0FjdGl2ZUF1ZGlvTm9kZSwgaXNQYXJ0T2ZBQ3ljbGUsIGlzUGFzc2l2ZUF1ZGlvTm9kZSksIGNhY2hlVGVzdFJlc3VsdCwgY3JlYXRlSW5jcmVtZW50Q3ljbGVDb3VudGVyRmFjdG9yeShDWUNMRV9DT1VOVEVSUywgZGlzY29ubmVjdE5hdGl2ZUF1ZGlvTm9kZUZyb21OYXRpdmVBdWRpb05vZGUsIGdldEF1ZGlvTm9kZUNvbm5lY3Rpb25zLCBnZXROYXRpdmVBdWRpb05vZGUsIGdldE5hdGl2ZUF1ZGlvUGFyYW0sIGlzQWN0aXZlQXVkaW9Ob2RlKSwgY3JlYXRlSW5kZXhTaXplRXJyb3IsIGNyZWF0ZUludmFsaWRBY2Nlc3NFcnJvciwgY3JlYXRlTm90U3VwcG9ydGVkRXJyb3IsIGNyZWF0ZURlY3JlbWVudEN5Y2xlQ291bnRlcihjb25uZWN0TmF0aXZlQXVkaW9Ob2RlVG9OYXRpdmVBdWRpb05vZGUsIENZQ0xFX0NPVU5URVJTLCBnZXRBdWRpb05vZGVDb25uZWN0aW9ucywgZ2V0TmF0aXZlQXVkaW9Ob2RlLCBnZXROYXRpdmVBdWRpb1BhcmFtLCBnZXROYXRpdmVDb250ZXh0LCBpc0FjdGl2ZUF1ZGlvTm9kZSwgaXNOYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KSwgY3JlYXRlRGV0ZWN0Q3ljbGVzKGF1ZGlvUGFyYW1BdWRpb05vZGVTdG9yZSwgZ2V0QXVkaW9Ob2RlQ29ubmVjdGlvbnMsIGdldFZhbHVlRm9yS2V5KSwgZXZlbnRUYXJnZXRDb25zdHJ1Y3RvciwgZ2V0TmF0aXZlQ29udGV4dCwgaXNOYXRpdmVBdWRpb0NvbnRleHQsIGlzTmF0aXZlQXVkaW9Ob2RlLCBpc05hdGl2ZUF1ZGlvUGFyYW0sIGlzTmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCwgbmF0aXZlQXVkaW9Xb3JrbGV0Tm9kZUNvbnN0cnVjdG9yKTtcbiAgICB2YXIgYW5hbHlzZXJOb2RlQ29uc3RydWN0b3IgPSBjcmVhdGVBbmFseXNlck5vZGVDb25zdHJ1Y3RvcihhdWRpb05vZGVDb25zdHJ1Y3RvciwgY3JlYXRlQW5hbHlzZXJOb2RlUmVuZGVyZXIsIGNyZWF0ZUluZGV4U2l6ZUVycm9yLCBjcmVhdGVOYXRpdmVBbmFseXNlck5vZGUsIGdldE5hdGl2ZUNvbnRleHQsIGlzTmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCk7XG4gICAgdmFyIGF1ZGlvQnVmZmVyU3RvcmUgPSBuZXcgV2Vha1NldCgpO1xuICAgIHZhciBuYXRpdmVBdWRpb0J1ZmZlckNvbnN0cnVjdG9yID0gY3JlYXRlTmF0aXZlQXVkaW9CdWZmZXJDb25zdHJ1Y3Rvcih3aW5kb3ckMSk7XG4gICAgdmFyIGNvbnZlcnROdW1iZXJUb1Vuc2lnbmVkTG9uZyA9IGNyZWF0ZUNvbnZlcnROdW1iZXJUb1Vuc2lnbmVkTG9uZyhuZXcgVWludDMyQXJyYXkoMSkpO1xuICAgIHZhciB3cmFwQXVkaW9CdWZmZXJDb3B5Q2hhbm5lbE1ldGhvZHMgPSBjcmVhdGVXcmFwQXVkaW9CdWZmZXJDb3B5Q2hhbm5lbE1ldGhvZHMoY29udmVydE51bWJlclRvVW5zaWduZWRMb25nLCBjcmVhdGVJbmRleFNpemVFcnJvcik7XG4gICAgdmFyIHdyYXBBdWRpb0J1ZmZlckNvcHlDaGFubmVsTWV0aG9kc091dE9mQm91bmRzID0gY3JlYXRlV3JhcEF1ZGlvQnVmZmVyQ29weUNoYW5uZWxNZXRob2RzT3V0T2ZCb3VuZHMoY29udmVydE51bWJlclRvVW5zaWduZWRMb25nKTtcbiAgICB2YXIgYXVkaW9CdWZmZXJDb25zdHJ1Y3RvciA9IGNyZWF0ZUF1ZGlvQnVmZmVyQ29uc3RydWN0b3IoYXVkaW9CdWZmZXJTdG9yZSwgY2FjaGVUZXN0UmVzdWx0LCBjcmVhdGVOb3RTdXBwb3J0ZWRFcnJvciwgbmF0aXZlQXVkaW9CdWZmZXJDb25zdHJ1Y3RvciwgbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dENvbnN0cnVjdG9yLCBjcmVhdGVUZXN0QXVkaW9CdWZmZXJDb25zdHJ1Y3RvclN1cHBvcnQobmF0aXZlQXVkaW9CdWZmZXJDb25zdHJ1Y3RvciksIHdyYXBBdWRpb0J1ZmZlckNvcHlDaGFubmVsTWV0aG9kcywgd3JhcEF1ZGlvQnVmZmVyQ29weUNoYW5uZWxNZXRob2RzT3V0T2ZCb3VuZHMpO1xuICAgIHZhciBhZGRTaWxlbnRDb25uZWN0aW9uID0gY3JlYXRlQWRkU2lsZW50Q29ubmVjdGlvbihjcmVhdGVOYXRpdmVHYWluTm9kZSk7XG4gICAgdmFyIHJlbmRlcklucHV0c09mQXVkaW9QYXJhbSA9IGNyZWF0ZVJlbmRlcklucHV0c09mQXVkaW9QYXJhbShnZXRBdWRpb05vZGVSZW5kZXJlciwgZ2V0QXVkaW9QYXJhbUNvbm5lY3Rpb25zLCBpc1BhcnRPZkFDeWNsZSk7XG4gICAgdmFyIGNvbm5lY3RBdWRpb1BhcmFtID0gY3JlYXRlQ29ubmVjdEF1ZGlvUGFyYW0ocmVuZGVySW5wdXRzT2ZBdWRpb1BhcmFtKTtcbiAgICB2YXIgY3JlYXRlTmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2RlID0gY3JlYXRlTmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2RlRmFjdG9yeShhZGRTaWxlbnRDb25uZWN0aW9uLCBjYWNoZVRlc3RSZXN1bHQsIHRlc3RBdWRpb0J1ZmZlclNvdXJjZU5vZGVTdGFydE1ldGhvZENvbnNlY3V0aXZlQ2FsbHNTdXBwb3J0LCB0ZXN0QXVkaW9CdWZmZXJTb3VyY2VOb2RlU3RhcnRNZXRob2RPZmZzZXRDbGFtcGluZ1N1cHBvcnQsIHRlc3RBdWRpb0J1ZmZlclNvdXJjZU5vZGVTdG9wTWV0aG9kTnVsbGlmaWVkQnVmZmVyU3VwcG9ydCwgdGVzdEF1ZGlvU2NoZWR1bGVkU291cmNlTm9kZVN0YXJ0TWV0aG9kTmVnYXRpdmVQYXJhbWV0ZXJzU3VwcG9ydCwgdGVzdEF1ZGlvU2NoZWR1bGVkU291cmNlTm9kZVN0b3BNZXRob2RDb25zZWN1dGl2ZUNhbGxzU3VwcG9ydCwgdGVzdEF1ZGlvU2NoZWR1bGVkU291cmNlTm9kZVN0b3BNZXRob2ROZWdhdGl2ZVBhcmFtZXRlcnNTdXBwb3J0LCB3cmFwQXVkaW9CdWZmZXJTb3VyY2VOb2RlU3RhcnRNZXRob2RPZmZzZXRDbGFtcGluZywgY3JlYXRlV3JhcEF1ZGlvQnVmZmVyU291cmNlTm9kZVN0b3BNZXRob2ROdWxsaWZpZWRCdWZmZXIob3ZlcndyaXRlQWNjZXNzb3JzKSwgd3JhcEF1ZGlvU2NoZWR1bGVkU291cmNlTm9kZVN0b3BNZXRob2RDb25zZWN1dGl2ZUNhbGxzKTtcbiAgICB2YXIgcmVuZGVyQXV0b21hdGlvbiA9IGNyZWF0ZVJlbmRlckF1dG9tYXRpb24oY3JlYXRlR2V0QXVkaW9QYXJhbVJlbmRlcmVyKGdldEF1ZGlvUGFyYW1Db25uZWN0aW9ucyksIHJlbmRlcklucHV0c09mQXVkaW9QYXJhbSk7XG4gICAgdmFyIGNyZWF0ZUF1ZGlvQnVmZmVyU291cmNlTm9kZVJlbmRlcmVyID0gY3JlYXRlQXVkaW9CdWZmZXJTb3VyY2VOb2RlUmVuZGVyZXJGYWN0b3J5KGNvbm5lY3RBdWRpb1BhcmFtLCBjcmVhdGVOYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGUsIGdldE5hdGl2ZUF1ZGlvTm9kZSwgcmVuZGVyQXV0b21hdGlvbiwgcmVuZGVySW5wdXRzT2ZBdWRpb05vZGUpO1xuICAgIHZhciBjcmVhdGVBdWRpb1BhcmFtID0gY3JlYXRlQXVkaW9QYXJhbUZhY3RvcnkoY3JlYXRlQWRkQXVkaW9QYXJhbUNvbm5lY3Rpb25zKEFVRElPX1BBUkFNX0NPTk5FQ1RJT05TX1NUT1JFKSwgYXVkaW9QYXJhbUF1ZGlvTm9kZVN0b3JlLCBBVURJT19QQVJBTV9TVE9SRSwgY3JlYXRlQXVkaW9QYXJhbVJlbmRlcmVyLCBhdXRvbWF0aW9uRXZlbnRzLmNyZWF0ZUNhbmNlbEFuZEhvbGRBdXRvbWF0aW9uRXZlbnQsIGF1dG9tYXRpb25FdmVudHMuY3JlYXRlQ2FuY2VsU2NoZWR1bGVkVmFsdWVzQXV0b21hdGlvbkV2ZW50LCBhdXRvbWF0aW9uRXZlbnRzLmNyZWF0ZUV4cG9uZW50aWFsUmFtcFRvVmFsdWVBdXRvbWF0aW9uRXZlbnQsIGF1dG9tYXRpb25FdmVudHMuY3JlYXRlTGluZWFyUmFtcFRvVmFsdWVBdXRvbWF0aW9uRXZlbnQsIGF1dG9tYXRpb25FdmVudHMuY3JlYXRlU2V0VGFyZ2V0QXV0b21hdGlvbkV2ZW50LCBhdXRvbWF0aW9uRXZlbnRzLmNyZWF0ZVNldFZhbHVlQXV0b21hdGlvbkV2ZW50LCBhdXRvbWF0aW9uRXZlbnRzLmNyZWF0ZVNldFZhbHVlQ3VydmVBdXRvbWF0aW9uRXZlbnQsIG5hdGl2ZUF1ZGlvQ29udGV4dENvbnN0cnVjdG9yLCBfc2V0VmFsdWVBdFRpbWVVbnRpbFBvc3NpYmxlKTtcbiAgICB2YXIgYXVkaW9CdWZmZXJTb3VyY2VOb2RlQ29uc3RydWN0b3IgPSBjcmVhdGVBdWRpb0J1ZmZlclNvdXJjZU5vZGVDb25zdHJ1Y3RvcihhdWRpb05vZGVDb25zdHJ1Y3RvciwgY3JlYXRlQXVkaW9CdWZmZXJTb3VyY2VOb2RlUmVuZGVyZXIsIGNyZWF0ZUF1ZGlvUGFyYW0sIGNyZWF0ZUludmFsaWRTdGF0ZUVycm9yLCBjcmVhdGVOYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGUsIGdldE5hdGl2ZUNvbnRleHQsIGlzTmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCwgd3JhcEV2ZW50TGlzdGVuZXIpO1xuICAgIHZhciBhdWRpb0Rlc3RpbmF0aW9uTm9kZUNvbnN0cnVjdG9yID0gY3JlYXRlQXVkaW9EZXN0aW5hdGlvbk5vZGVDb25zdHJ1Y3RvcihhdWRpb05vZGVDb25zdHJ1Y3RvciwgY3JlYXRlQXVkaW9EZXN0aW5hdGlvbk5vZGVSZW5kZXJlciwgY3JlYXRlSW5kZXhTaXplRXJyb3IsIGNyZWF0ZUludmFsaWRTdGF0ZUVycm9yLCBjcmVhdGVOYXRpdmVBdWRpb0Rlc3RpbmF0aW9uTm9kZUZhY3RvcnkoY3JlYXRlTmF0aXZlR2Fpbk5vZGUsIG92ZXJ3cml0ZUFjY2Vzc29ycyksIGdldE5hdGl2ZUNvbnRleHQsIGlzTmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCwgcmVuZGVySW5wdXRzT2ZBdWRpb05vZGUpO1xuICAgIHZhciBjcmVhdGVCaXF1YWRGaWx0ZXJOb2RlUmVuZGVyZXIgPSBjcmVhdGVCaXF1YWRGaWx0ZXJOb2RlUmVuZGVyZXJGYWN0b3J5KGNvbm5lY3RBdWRpb1BhcmFtLCBjcmVhdGVOYXRpdmVCaXF1YWRGaWx0ZXJOb2RlLCBnZXROYXRpdmVBdWRpb05vZGUsIHJlbmRlckF1dG9tYXRpb24sIHJlbmRlcklucHV0c09mQXVkaW9Ob2RlKTtcbiAgICB2YXIgc2V0QXVkaW9Ob2RlVGFpbFRpbWUgPSBjcmVhdGVTZXRBdWRpb05vZGVUYWlsVGltZShhdWRpb05vZGVUYWlsVGltZVN0b3JlKTtcbiAgICB2YXIgYmlxdWFkRmlsdGVyTm9kZUNvbnN0cnVjdG9yID0gY3JlYXRlQmlxdWFkRmlsdGVyTm9kZUNvbnN0cnVjdG9yKGF1ZGlvTm9kZUNvbnN0cnVjdG9yLCBjcmVhdGVBdWRpb1BhcmFtLCBjcmVhdGVCaXF1YWRGaWx0ZXJOb2RlUmVuZGVyZXIsIGNyZWF0ZUludmFsaWRBY2Nlc3NFcnJvciwgY3JlYXRlTmF0aXZlQmlxdWFkRmlsdGVyTm9kZSwgZ2V0TmF0aXZlQ29udGV4dCwgaXNOYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LCBzZXRBdWRpb05vZGVUYWlsVGltZSk7XG4gICAgdmFyIG1vbml0b3JDb25uZWN0aW9ucyA9IGNyZWF0ZU1vbml0b3JDb25uZWN0aW9ucyhpbnNlcnRFbGVtZW50SW5TZXQsIGlzTmF0aXZlQXVkaW9Ob2RlKTtcbiAgICB2YXIgd3JhcENoYW5uZWxNZXJnZXJOb2RlID0gY3JlYXRlV3JhcENoYW5uZWxNZXJnZXJOb2RlKGNyZWF0ZUludmFsaWRTdGF0ZUVycm9yLCBtb25pdG9yQ29ubmVjdGlvbnMpO1xuICAgIHZhciBjcmVhdGVOYXRpdmVDaGFubmVsTWVyZ2VyTm9kZSA9IGNyZWF0ZU5hdGl2ZUNoYW5uZWxNZXJnZXJOb2RlRmFjdG9yeShuYXRpdmVBdWRpb0NvbnRleHRDb25zdHJ1Y3Rvciwgd3JhcENoYW5uZWxNZXJnZXJOb2RlKTtcbiAgICB2YXIgY3JlYXRlQ2hhbm5lbE1lcmdlck5vZGVSZW5kZXJlciA9IGNyZWF0ZUNoYW5uZWxNZXJnZXJOb2RlUmVuZGVyZXJGYWN0b3J5KGNyZWF0ZU5hdGl2ZUNoYW5uZWxNZXJnZXJOb2RlLCBnZXROYXRpdmVBdWRpb05vZGUsIHJlbmRlcklucHV0c09mQXVkaW9Ob2RlKTtcbiAgICB2YXIgY2hhbm5lbE1lcmdlck5vZGVDb25zdHJ1Y3RvciA9IGNyZWF0ZUNoYW5uZWxNZXJnZXJOb2RlQ29uc3RydWN0b3IoYXVkaW9Ob2RlQ29uc3RydWN0b3IsIGNyZWF0ZUNoYW5uZWxNZXJnZXJOb2RlUmVuZGVyZXIsIGNyZWF0ZU5hdGl2ZUNoYW5uZWxNZXJnZXJOb2RlLCBnZXROYXRpdmVDb250ZXh0LCBpc05hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQpO1xuICAgIHZhciBjcmVhdGVDaGFubmVsU3BsaXR0ZXJOb2RlUmVuZGVyZXIgPSBjcmVhdGVDaGFubmVsU3BsaXR0ZXJOb2RlUmVuZGVyZXJGYWN0b3J5KGNyZWF0ZU5hdGl2ZUNoYW5uZWxTcGxpdHRlck5vZGUsIGdldE5hdGl2ZUF1ZGlvTm9kZSwgcmVuZGVySW5wdXRzT2ZBdWRpb05vZGUpO1xuICAgIHZhciBjaGFubmVsU3BsaXR0ZXJOb2RlQ29uc3RydWN0b3IgPSBjcmVhdGVDaGFubmVsU3BsaXR0ZXJOb2RlQ29uc3RydWN0b3IoYXVkaW9Ob2RlQ29uc3RydWN0b3IsIGNyZWF0ZUNoYW5uZWxTcGxpdHRlck5vZGVSZW5kZXJlciwgY3JlYXRlTmF0aXZlQ2hhbm5lbFNwbGl0dGVyTm9kZSwgZ2V0TmF0aXZlQ29udGV4dCwgaXNOYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LCBzYW5pdGl6ZUNoYW5uZWxTcGxpdHRlck9wdGlvbnMpO1xuICAgIHZhciBjcmVhdGVOYXRpdmVDb25zdGFudFNvdXJjZU5vZGVGYWtlciA9IGNyZWF0ZU5hdGl2ZUNvbnN0YW50U291cmNlTm9kZUZha2VyRmFjdG9yeShhZGRTaWxlbnRDb25uZWN0aW9uLCBjcmVhdGVOYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGUsIGNyZWF0ZU5hdGl2ZUdhaW5Ob2RlLCBtb25pdG9yQ29ubmVjdGlvbnMpO1xuICAgIHZhciBjcmVhdGVOYXRpdmVDb25zdGFudFNvdXJjZU5vZGUgPSBjcmVhdGVOYXRpdmVDb25zdGFudFNvdXJjZU5vZGVGYWN0b3J5KGFkZFNpbGVudENvbm5lY3Rpb24sIGNhY2hlVGVzdFJlc3VsdCwgY3JlYXRlTmF0aXZlQ29uc3RhbnRTb3VyY2VOb2RlRmFrZXIsIHRlc3RBdWRpb1NjaGVkdWxlZFNvdXJjZU5vZGVTdGFydE1ldGhvZE5lZ2F0aXZlUGFyYW1ldGVyc1N1cHBvcnQsIHRlc3RBdWRpb1NjaGVkdWxlZFNvdXJjZU5vZGVTdG9wTWV0aG9kTmVnYXRpdmVQYXJhbWV0ZXJzU3VwcG9ydCk7XG4gICAgdmFyIGNyZWF0ZUNvbnN0YW50U291cmNlTm9kZVJlbmRlcmVyID0gY3JlYXRlQ29uc3RhbnRTb3VyY2VOb2RlUmVuZGVyZXJGYWN0b3J5KGNvbm5lY3RBdWRpb1BhcmFtLCBjcmVhdGVOYXRpdmVDb25zdGFudFNvdXJjZU5vZGUsIGdldE5hdGl2ZUF1ZGlvTm9kZSwgcmVuZGVyQXV0b21hdGlvbiwgcmVuZGVySW5wdXRzT2ZBdWRpb05vZGUpO1xuICAgIHZhciBjb25zdGFudFNvdXJjZU5vZGVDb25zdHJ1Y3RvciA9IGNyZWF0ZUNvbnN0YW50U291cmNlTm9kZUNvbnN0cnVjdG9yKGF1ZGlvTm9kZUNvbnN0cnVjdG9yLCBjcmVhdGVBdWRpb1BhcmFtLCBjcmVhdGVDb25zdGFudFNvdXJjZU5vZGVSZW5kZXJlciwgY3JlYXRlTmF0aXZlQ29uc3RhbnRTb3VyY2VOb2RlLCBnZXROYXRpdmVDb250ZXh0LCBpc05hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQsIHdyYXBFdmVudExpc3RlbmVyKTtcbiAgICB2YXIgY3JlYXRlTmF0aXZlQ29udm9sdmVyTm9kZSA9IGNyZWF0ZU5hdGl2ZUNvbnZvbHZlck5vZGVGYWN0b3J5KGNyZWF0ZU5vdFN1cHBvcnRlZEVycm9yLCBvdmVyd3JpdGVBY2Nlc3NvcnMpO1xuICAgIHZhciBjcmVhdGVDb252b2x2ZXJOb2RlUmVuZGVyZXIgPSBjcmVhdGVDb252b2x2ZXJOb2RlUmVuZGVyZXJGYWN0b3J5KGNyZWF0ZU5hdGl2ZUNvbnZvbHZlck5vZGUsIGdldE5hdGl2ZUF1ZGlvTm9kZSwgcmVuZGVySW5wdXRzT2ZBdWRpb05vZGUpO1xuICAgIHZhciBjb252b2x2ZXJOb2RlQ29uc3RydWN0b3IgPSBjcmVhdGVDb252b2x2ZXJOb2RlQ29uc3RydWN0b3IoYXVkaW9Ob2RlQ29uc3RydWN0b3IsIGNyZWF0ZUNvbnZvbHZlck5vZGVSZW5kZXJlciwgY3JlYXRlTmF0aXZlQ29udm9sdmVyTm9kZSwgZ2V0TmF0aXZlQ29udGV4dCwgaXNOYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LCBzZXRBdWRpb05vZGVUYWlsVGltZSk7XG4gICAgdmFyIGNyZWF0ZURlbGF5Tm9kZVJlbmRlcmVyID0gY3JlYXRlRGVsYXlOb2RlUmVuZGVyZXJGYWN0b3J5KGNvbm5lY3RBdWRpb1BhcmFtLCBjcmVhdGVOYXRpdmVEZWxheU5vZGUsIGdldE5hdGl2ZUF1ZGlvTm9kZSwgcmVuZGVyQXV0b21hdGlvbiwgcmVuZGVySW5wdXRzT2ZBdWRpb05vZGUpO1xuICAgIHZhciBkZWxheU5vZGVDb25zdHJ1Y3RvciA9IGNyZWF0ZURlbGF5Tm9kZUNvbnN0cnVjdG9yKGF1ZGlvTm9kZUNvbnN0cnVjdG9yLCBjcmVhdGVBdWRpb1BhcmFtLCBjcmVhdGVEZWxheU5vZGVSZW5kZXJlciwgY3JlYXRlTmF0aXZlRGVsYXlOb2RlLCBnZXROYXRpdmVDb250ZXh0LCBpc05hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQsIHNldEF1ZGlvTm9kZVRhaWxUaW1lKTtcbiAgICB2YXIgY3JlYXRlTmF0aXZlRHluYW1pY3NDb21wcmVzc29yTm9kZSA9IGNyZWF0ZU5hdGl2ZUR5bmFtaWNzQ29tcHJlc3Nvck5vZGVGYWN0b3J5KGNyZWF0ZU5vdFN1cHBvcnRlZEVycm9yKTtcbiAgICB2YXIgY3JlYXRlRHluYW1pY3NDb21wcmVzc29yTm9kZVJlbmRlcmVyID0gY3JlYXRlRHluYW1pY3NDb21wcmVzc29yTm9kZVJlbmRlcmVyRmFjdG9yeShjb25uZWN0QXVkaW9QYXJhbSwgY3JlYXRlTmF0aXZlRHluYW1pY3NDb21wcmVzc29yTm9kZSwgZ2V0TmF0aXZlQXVkaW9Ob2RlLCByZW5kZXJBdXRvbWF0aW9uLCByZW5kZXJJbnB1dHNPZkF1ZGlvTm9kZSk7XG4gICAgdmFyIGR5bmFtaWNzQ29tcHJlc3Nvck5vZGVDb25zdHJ1Y3RvciA9IGNyZWF0ZUR5bmFtaWNzQ29tcHJlc3Nvck5vZGVDb25zdHJ1Y3RvcihhdWRpb05vZGVDb25zdHJ1Y3RvciwgY3JlYXRlQXVkaW9QYXJhbSwgY3JlYXRlRHluYW1pY3NDb21wcmVzc29yTm9kZVJlbmRlcmVyLCBjcmVhdGVOYXRpdmVEeW5hbWljc0NvbXByZXNzb3JOb2RlLCBjcmVhdGVOb3RTdXBwb3J0ZWRFcnJvciwgZ2V0TmF0aXZlQ29udGV4dCwgaXNOYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LCBzZXRBdWRpb05vZGVUYWlsVGltZSk7XG4gICAgdmFyIGNyZWF0ZUdhaW5Ob2RlUmVuZGVyZXIgPSBjcmVhdGVHYWluTm9kZVJlbmRlcmVyRmFjdG9yeShjb25uZWN0QXVkaW9QYXJhbSwgY3JlYXRlTmF0aXZlR2Fpbk5vZGUsIGdldE5hdGl2ZUF1ZGlvTm9kZSwgcmVuZGVyQXV0b21hdGlvbiwgcmVuZGVySW5wdXRzT2ZBdWRpb05vZGUpO1xuICAgIHZhciBnYWluTm9kZUNvbnN0cnVjdG9yID0gY3JlYXRlR2Fpbk5vZGVDb25zdHJ1Y3RvcihhdWRpb05vZGVDb25zdHJ1Y3RvciwgY3JlYXRlQXVkaW9QYXJhbSwgY3JlYXRlR2Fpbk5vZGVSZW5kZXJlciwgY3JlYXRlTmF0aXZlR2Fpbk5vZGUsIGdldE5hdGl2ZUNvbnRleHQsIGlzTmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCk7XG4gICAgdmFyIGNyZWF0ZU5hdGl2ZUlJUkZpbHRlck5vZGVGYWtlciA9IGNyZWF0ZU5hdGl2ZUlJUkZpbHRlck5vZGVGYWtlckZhY3RvcnkoY3JlYXRlSW52YWxpZEFjY2Vzc0Vycm9yLCBjcmVhdGVJbnZhbGlkU3RhdGVFcnJvciwgY3JlYXRlTmF0aXZlU2NyaXB0UHJvY2Vzc29yTm9kZSwgY3JlYXRlTm90U3VwcG9ydGVkRXJyb3IpO1xuICAgIHZhciByZW5kZXJOYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0ID0gY3JlYXRlUmVuZGVyTmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dChjYWNoZVRlc3RSZXN1bHQsIGNyZWF0ZU5hdGl2ZUdhaW5Ob2RlLCBjcmVhdGVOYXRpdmVTY3JpcHRQcm9jZXNzb3JOb2RlLCBjcmVhdGVUZXN0T2ZmbGluZUF1ZGlvQ29udGV4dEN1cnJlbnRUaW1lU3VwcG9ydChjcmVhdGVOYXRpdmVHYWluTm9kZSwgbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dENvbnN0cnVjdG9yKSk7XG4gICAgdmFyIGNyZWF0ZUlJUkZpbHRlck5vZGVSZW5kZXJlciA9IGNyZWF0ZUlJUkZpbHRlck5vZGVSZW5kZXJlckZhY3RvcnkoY3JlYXRlTmF0aXZlQXVkaW9CdWZmZXJTb3VyY2VOb2RlLCBnZXROYXRpdmVBdWRpb05vZGUsIG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHRDb25zdHJ1Y3RvciwgcmVuZGVySW5wdXRzT2ZBdWRpb05vZGUsIHJlbmRlck5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQpO1xuICAgIHZhciBjcmVhdGVOYXRpdmVJSVJGaWx0ZXJOb2RlID0gY3JlYXRlTmF0aXZlSUlSRmlsdGVyTm9kZUZhY3RvcnkoY3JlYXRlTmF0aXZlSUlSRmlsdGVyTm9kZUZha2VyKTtcbiAgICB2YXIgaUlSRmlsdGVyTm9kZUNvbnN0cnVjdG9yID0gY3JlYXRlSUlSRmlsdGVyTm9kZUNvbnN0cnVjdG9yKGF1ZGlvTm9kZUNvbnN0cnVjdG9yLCBjcmVhdGVOYXRpdmVJSVJGaWx0ZXJOb2RlLCBjcmVhdGVJSVJGaWx0ZXJOb2RlUmVuZGVyZXIsIGdldE5hdGl2ZUNvbnRleHQsIGlzTmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCwgc2V0QXVkaW9Ob2RlVGFpbFRpbWUpO1xuICAgIHZhciBjcmVhdGVBdWRpb0xpc3RlbmVyID0gY3JlYXRlQXVkaW9MaXN0ZW5lckZhY3RvcnkoY3JlYXRlQXVkaW9QYXJhbSwgY3JlYXRlTmF0aXZlQ2hhbm5lbE1lcmdlck5vZGUsIGNyZWF0ZU5hdGl2ZUNvbnN0YW50U291cmNlTm9kZSwgY3JlYXRlTmF0aXZlU2NyaXB0UHJvY2Vzc29yTm9kZSwgY3JlYXRlTm90U3VwcG9ydGVkRXJyb3IsIGdldEZpcnN0U2FtcGxlLCBpc05hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQsIG92ZXJ3cml0ZUFjY2Vzc29ycyk7XG4gICAgdmFyIHVucmVuZGVyZWRBdWRpb1dvcmtsZXROb2RlU3RvcmUgPSBuZXcgV2Vha01hcCgpO1xuICAgIHZhciBtaW5pbWFsQmFzZUF1ZGlvQ29udGV4dENvbnN0cnVjdG9yID0gY3JlYXRlTWluaW1hbEJhc2VBdWRpb0NvbnRleHRDb25zdHJ1Y3RvcihhdWRpb0Rlc3RpbmF0aW9uTm9kZUNvbnN0cnVjdG9yLCBjcmVhdGVBdWRpb0xpc3RlbmVyLCBldmVudFRhcmdldENvbnN0cnVjdG9yLCBpc05hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQsIHVucmVuZGVyZWRBdWRpb1dvcmtsZXROb2RlU3RvcmUsIHdyYXBFdmVudExpc3RlbmVyKTtcbiAgICB2YXIgY3JlYXRlTmF0aXZlT3NjaWxsYXRvck5vZGUgPSBjcmVhdGVOYXRpdmVPc2NpbGxhdG9yTm9kZUZhY3RvcnkoYWRkU2lsZW50Q29ubmVjdGlvbiwgY2FjaGVUZXN0UmVzdWx0LCB0ZXN0QXVkaW9TY2hlZHVsZWRTb3VyY2VOb2RlU3RhcnRNZXRob2ROZWdhdGl2ZVBhcmFtZXRlcnNTdXBwb3J0LCB0ZXN0QXVkaW9TY2hlZHVsZWRTb3VyY2VOb2RlU3RvcE1ldGhvZENvbnNlY3V0aXZlQ2FsbHNTdXBwb3J0LCB0ZXN0QXVkaW9TY2hlZHVsZWRTb3VyY2VOb2RlU3RvcE1ldGhvZE5lZ2F0aXZlUGFyYW1ldGVyc1N1cHBvcnQsIHdyYXBBdWRpb1NjaGVkdWxlZFNvdXJjZU5vZGVTdG9wTWV0aG9kQ29uc2VjdXRpdmVDYWxscyk7XG4gICAgdmFyIGNyZWF0ZU9zY2lsbGF0b3JOb2RlUmVuZGVyZXIgPSBjcmVhdGVPc2NpbGxhdG9yTm9kZVJlbmRlcmVyRmFjdG9yeShjb25uZWN0QXVkaW9QYXJhbSwgY3JlYXRlTmF0aXZlT3NjaWxsYXRvck5vZGUsIGdldE5hdGl2ZUF1ZGlvTm9kZSwgcmVuZGVyQXV0b21hdGlvbiwgcmVuZGVySW5wdXRzT2ZBdWRpb05vZGUpO1xuICAgIHZhciBvc2NpbGxhdG9yTm9kZUNvbnN0cnVjdG9yID0gY3JlYXRlT3NjaWxsYXRvck5vZGVDb25zdHJ1Y3RvcihhdWRpb05vZGVDb25zdHJ1Y3RvciwgY3JlYXRlQXVkaW9QYXJhbSwgY3JlYXRlTmF0aXZlT3NjaWxsYXRvck5vZGUsIGNyZWF0ZU9zY2lsbGF0b3JOb2RlUmVuZGVyZXIsIGdldE5hdGl2ZUNvbnRleHQsIGlzTmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCwgd3JhcEV2ZW50TGlzdGVuZXIpO1xuICAgIHZhciBjcmVhdGVDb25uZWN0ZWROYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGUgPSBjcmVhdGVDb25uZWN0ZWROYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGVGYWN0b3J5KGNyZWF0ZU5hdGl2ZUF1ZGlvQnVmZmVyU291cmNlTm9kZSk7XG4gICAgdmFyIGNyZWF0ZU5hdGl2ZVdhdmVTaGFwZXJOb2RlRmFrZXIgPSBjcmVhdGVOYXRpdmVXYXZlU2hhcGVyTm9kZUZha2VyRmFjdG9yeShjcmVhdGVDb25uZWN0ZWROYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGUsIGNyZWF0ZUludmFsaWRTdGF0ZUVycm9yLCBjcmVhdGVOYXRpdmVHYWluTm9kZSwgaXNEQ0N1cnZlLCBtb25pdG9yQ29ubmVjdGlvbnMpO1xuICAgIHZhciBjcmVhdGVOYXRpdmVXYXZlU2hhcGVyTm9kZSA9IGNyZWF0ZU5hdGl2ZVdhdmVTaGFwZXJOb2RlRmFjdG9yeShjcmVhdGVDb25uZWN0ZWROYXRpdmVBdWRpb0J1ZmZlclNvdXJjZU5vZGUsIGNyZWF0ZUludmFsaWRTdGF0ZUVycm9yLCBjcmVhdGVOYXRpdmVXYXZlU2hhcGVyTm9kZUZha2VyLCBpc0RDQ3VydmUsIG1vbml0b3JDb25uZWN0aW9ucywgbmF0aXZlQXVkaW9Db250ZXh0Q29uc3RydWN0b3IsIG92ZXJ3cml0ZUFjY2Vzc29ycyk7XG4gICAgdmFyIGNyZWF0ZU5hdGl2ZVBhbm5lck5vZGVGYWtlciA9IGNyZWF0ZU5hdGl2ZVBhbm5lck5vZGVGYWtlckZhY3RvcnkoY29ubmVjdE5hdGl2ZUF1ZGlvTm9kZVRvTmF0aXZlQXVkaW9Ob2RlLCBjcmVhdGVJbnZhbGlkU3RhdGVFcnJvciwgY3JlYXRlTmF0aXZlQ2hhbm5lbE1lcmdlck5vZGUsIGNyZWF0ZU5hdGl2ZUdhaW5Ob2RlLCBjcmVhdGVOYXRpdmVTY3JpcHRQcm9jZXNzb3JOb2RlLCBjcmVhdGVOYXRpdmVXYXZlU2hhcGVyTm9kZSwgY3JlYXRlTm90U3VwcG9ydGVkRXJyb3IsIGRpc2Nvbm5lY3ROYXRpdmVBdWRpb05vZGVGcm9tTmF0aXZlQXVkaW9Ob2RlLCBnZXRGaXJzdFNhbXBsZSwgbW9uaXRvckNvbm5lY3Rpb25zKTtcbiAgICB2YXIgY3JlYXRlTmF0aXZlUGFubmVyTm9kZSA9IGNyZWF0ZU5hdGl2ZVBhbm5lck5vZGVGYWN0b3J5KGNyZWF0ZU5hdGl2ZVBhbm5lck5vZGVGYWtlcik7XG4gICAgdmFyIGNyZWF0ZVBhbm5lck5vZGVSZW5kZXJlciA9IGNyZWF0ZVBhbm5lck5vZGVSZW5kZXJlckZhY3RvcnkoY29ubmVjdEF1ZGlvUGFyYW0sIGNyZWF0ZU5hdGl2ZUNoYW5uZWxNZXJnZXJOb2RlLCBjcmVhdGVOYXRpdmVDb25zdGFudFNvdXJjZU5vZGUsIGNyZWF0ZU5hdGl2ZUdhaW5Ob2RlLCBjcmVhdGVOYXRpdmVQYW5uZXJOb2RlLCBnZXROYXRpdmVBdWRpb05vZGUsIG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHRDb25zdHJ1Y3RvciwgcmVuZGVyQXV0b21hdGlvbiwgcmVuZGVySW5wdXRzT2ZBdWRpb05vZGUsIHJlbmRlck5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQpO1xuICAgIHZhciBwYW5uZXJOb2RlQ29uc3RydWN0b3IgPSBjcmVhdGVQYW5uZXJOb2RlQ29uc3RydWN0b3IoYXVkaW9Ob2RlQ29uc3RydWN0b3IsIGNyZWF0ZUF1ZGlvUGFyYW0sIGNyZWF0ZU5hdGl2ZVBhbm5lck5vZGUsIGNyZWF0ZVBhbm5lck5vZGVSZW5kZXJlciwgZ2V0TmF0aXZlQ29udGV4dCwgaXNOYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LCBzZXRBdWRpb05vZGVUYWlsVGltZSk7XG4gICAgdmFyIGNyZWF0ZU5hdGl2ZVBlcmlvZGljV2F2ZSA9IGNyZWF0ZU5hdGl2ZVBlcmlvZGljV2F2ZUZhY3RvcnkoY3JlYXRlSW5kZXhTaXplRXJyb3IpO1xuICAgIHZhciBwZXJpb2RpY1dhdmVDb25zdHJ1Y3RvciA9IGNyZWF0ZVBlcmlvZGljV2F2ZUNvbnN0cnVjdG9yKGNyZWF0ZU5hdGl2ZVBlcmlvZGljV2F2ZSwgZ2V0TmF0aXZlQ29udGV4dCwgbmV3IFdlYWtTZXQoKSwgc2FuaXRpemVQZXJpb2RpY1dhdmVPcHRpb25zKTtcbiAgICB2YXIgbmF0aXZlU3RlcmVvUGFubmVyTm9kZUZha2VyRmFjdG9yeSA9IGNyZWF0ZU5hdGl2ZVN0ZXJlb1Bhbm5lck5vZGVGYWtlckZhY3RvcnkoY3JlYXRlTmF0aXZlQ2hhbm5lbE1lcmdlck5vZGUsIGNyZWF0ZU5hdGl2ZUNoYW5uZWxTcGxpdHRlck5vZGUsIGNyZWF0ZU5hdGl2ZUdhaW5Ob2RlLCBjcmVhdGVOYXRpdmVXYXZlU2hhcGVyTm9kZSwgY3JlYXRlTm90U3VwcG9ydGVkRXJyb3IsIG1vbml0b3JDb25uZWN0aW9ucyk7XG4gICAgdmFyIGNyZWF0ZU5hdGl2ZVN0ZXJlb1Bhbm5lck5vZGUgPSBjcmVhdGVOYXRpdmVTdGVyZW9QYW5uZXJOb2RlRmFjdG9yeShuYXRpdmVTdGVyZW9QYW5uZXJOb2RlRmFrZXJGYWN0b3J5LCBjcmVhdGVOb3RTdXBwb3J0ZWRFcnJvcik7XG4gICAgdmFyIGNyZWF0ZVN0ZXJlb1Bhbm5lck5vZGVSZW5kZXJlciA9IGNyZWF0ZVN0ZXJlb1Bhbm5lck5vZGVSZW5kZXJlckZhY3RvcnkoY29ubmVjdEF1ZGlvUGFyYW0sIGNyZWF0ZU5hdGl2ZVN0ZXJlb1Bhbm5lck5vZGUsIGdldE5hdGl2ZUF1ZGlvTm9kZSwgcmVuZGVyQXV0b21hdGlvbiwgcmVuZGVySW5wdXRzT2ZBdWRpb05vZGUpO1xuICAgIHZhciBzdGVyZW9QYW5uZXJOb2RlQ29uc3RydWN0b3IgPSBjcmVhdGVTdGVyZW9QYW5uZXJOb2RlQ29uc3RydWN0b3IoYXVkaW9Ob2RlQ29uc3RydWN0b3IsIGNyZWF0ZUF1ZGlvUGFyYW0sIGNyZWF0ZU5hdGl2ZVN0ZXJlb1Bhbm5lck5vZGUsIGNyZWF0ZVN0ZXJlb1Bhbm5lck5vZGVSZW5kZXJlciwgZ2V0TmF0aXZlQ29udGV4dCwgaXNOYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KTtcbiAgICB2YXIgY3JlYXRlV2F2ZVNoYXBlck5vZGVSZW5kZXJlciA9IGNyZWF0ZVdhdmVTaGFwZXJOb2RlUmVuZGVyZXJGYWN0b3J5KGNyZWF0ZU5hdGl2ZVdhdmVTaGFwZXJOb2RlLCBnZXROYXRpdmVBdWRpb05vZGUsIHJlbmRlcklucHV0c09mQXVkaW9Ob2RlKTtcbiAgICB2YXIgd2F2ZVNoYXBlck5vZGVDb25zdHJ1Y3RvciA9IGNyZWF0ZVdhdmVTaGFwZXJOb2RlQ29uc3RydWN0b3IoYXVkaW9Ob2RlQ29uc3RydWN0b3IsIGNyZWF0ZUludmFsaWRTdGF0ZUVycm9yLCBjcmVhdGVOYXRpdmVXYXZlU2hhcGVyTm9kZSwgY3JlYXRlV2F2ZVNoYXBlck5vZGVSZW5kZXJlciwgZ2V0TmF0aXZlQ29udGV4dCwgaXNOYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LCBzZXRBdWRpb05vZGVUYWlsVGltZSk7XG4gICAgdmFyIGlzU2VjdXJlQ29udGV4dCA9IGNyZWF0ZUlzU2VjdXJlQ29udGV4dCh3aW5kb3ckMSk7XG4gICAgdmFyIGV4cG9zZUN1cnJlbnRGcmFtZUFuZEN1cnJlbnRUaW1lID0gY3JlYXRlRXhwb3NlQ3VycmVudEZyYW1lQW5kQ3VycmVudFRpbWUod2luZG93JDEpO1xuICAgIHZhciBiYWNrdXBPZmZsaW5lQXVkaW9Db250ZXh0U3RvcmUgPSBuZXcgV2Vha01hcCgpO1xuICAgIHZhciBnZXRPckNyZWF0ZUJhY2t1cE9mZmxpbmVBdWRpb0NvbnRleHQgPSBjcmVhdGVHZXRPckNyZWF0ZUJhY2t1cE9mZmxpbmVBdWRpb0NvbnRleHQoYmFja3VwT2ZmbGluZUF1ZGlvQ29udGV4dFN0b3JlLCBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0Q29uc3RydWN0b3IpO1xuICAgIC8vIFRoZSBhZGRBdWRpb1dvcmtsZXRNb2R1bGUoKSBmdW5jdGlvbiBpcyBvbmx5IGF2YWlsYWJsZSBpbiBhIFNlY3VyZUNvbnRleHQuXG4gICAgdmFyIGFkZEF1ZGlvV29ya2xldE1vZHVsZSA9IGlzU2VjdXJlQ29udGV4dCA/IGNyZWF0ZUFkZEF1ZGlvV29ya2xldE1vZHVsZShjYWNoZVRlc3RSZXN1bHQsIGNyZWF0ZU5vdFN1cHBvcnRlZEVycm9yLCBjcmVhdGVFdmFsdWF0ZVNvdXJjZSh3aW5kb3ckMSksIGV4cG9zZUN1cnJlbnRGcmFtZUFuZEN1cnJlbnRUaW1lLCBjcmVhdGVGZXRjaFNvdXJjZShjcmVhdGVBYm9ydEVycm9yKSwgZ2V0TmF0aXZlQ29udGV4dCwgZ2V0T3JDcmVhdGVCYWNrdXBPZmZsaW5lQXVkaW9Db250ZXh0LCBpc05hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQsIG5hdGl2ZUF1ZGlvV29ya2xldE5vZGVDb25zdHJ1Y3RvciwgbmV3IFdlYWtNYXAoKSwgbmV3IFdlYWtNYXAoKSwgY3JlYXRlVGVzdEF1ZGlvV29ya2xldFByb2Nlc3NvclBvc3RNZXNzYWdlU3VwcG9ydChuYXRpdmVBdWRpb1dvcmtsZXROb2RlQ29uc3RydWN0b3IsIG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHRDb25zdHJ1Y3RvciksXG4gICAgLy8gQHRvZG8gd2luZG93IGlzIGd1YXJhbnRlZWQgdG8gYmUgZGVmaW5lZCBiZWNhdXNlIGlzU2VjdXJlQ29udGV4dCBjaGVja3MgdGhhdCBhcyB3ZWxsLlxuICAgIHdpbmRvdyQxKSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgaXNOYXRpdmVDb250ZXh0ID0gY3JlYXRlSXNOYXRpdmVDb250ZXh0KGlzTmF0aXZlQXVkaW9Db250ZXh0LCBpc05hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQpO1xuICAgIHZhciBkZWNvZGVBdWRpb0RhdGEgPSBjcmVhdGVEZWNvZGVBdWRpb0RhdGEoYXVkaW9CdWZmZXJTdG9yZSwgY2FjaGVUZXN0UmVzdWx0LCBjcmVhdGVEYXRhQ2xvbmVFcnJvciwgY3JlYXRlRW5jb2RpbmdFcnJvciwgbmV3IFdlYWtTZXQoKSwgZ2V0TmF0aXZlQ29udGV4dCwgaXNOYXRpdmVDb250ZXh0LCB0ZXN0QXVkaW9CdWZmZXJDb3B5Q2hhbm5lbE1ldGhvZHNPdXRPZkJvdW5kc1N1cHBvcnQsIHRlc3RQcm9taXNlU3VwcG9ydCwgd3JhcEF1ZGlvQnVmZmVyQ29weUNoYW5uZWxNZXRob2RzLCB3cmFwQXVkaW9CdWZmZXJDb3B5Q2hhbm5lbE1ldGhvZHNPdXRPZkJvdW5kcyk7XG4gICAgdmFyIGJhc2VBdWRpb0NvbnRleHRDb25zdHJ1Y3RvciA9IGNyZWF0ZUJhc2VBdWRpb0NvbnRleHRDb25zdHJ1Y3RvcihhZGRBdWRpb1dvcmtsZXRNb2R1bGUsIGFuYWx5c2VyTm9kZUNvbnN0cnVjdG9yLCBhdWRpb0J1ZmZlckNvbnN0cnVjdG9yLCBhdWRpb0J1ZmZlclNvdXJjZU5vZGVDb25zdHJ1Y3RvciwgYmlxdWFkRmlsdGVyTm9kZUNvbnN0cnVjdG9yLCBjaGFubmVsTWVyZ2VyTm9kZUNvbnN0cnVjdG9yLCBjaGFubmVsU3BsaXR0ZXJOb2RlQ29uc3RydWN0b3IsIGNvbnN0YW50U291cmNlTm9kZUNvbnN0cnVjdG9yLCBjb252b2x2ZXJOb2RlQ29uc3RydWN0b3IsIGRlY29kZUF1ZGlvRGF0YSwgZGVsYXlOb2RlQ29uc3RydWN0b3IsIGR5bmFtaWNzQ29tcHJlc3Nvck5vZGVDb25zdHJ1Y3RvciwgZ2Fpbk5vZGVDb25zdHJ1Y3RvciwgaUlSRmlsdGVyTm9kZUNvbnN0cnVjdG9yLCBtaW5pbWFsQmFzZUF1ZGlvQ29udGV4dENvbnN0cnVjdG9yLCBvc2NpbGxhdG9yTm9kZUNvbnN0cnVjdG9yLCBwYW5uZXJOb2RlQ29uc3RydWN0b3IsIHBlcmlvZGljV2F2ZUNvbnN0cnVjdG9yLCBzdGVyZW9QYW5uZXJOb2RlQ29uc3RydWN0b3IsIHdhdmVTaGFwZXJOb2RlQ29uc3RydWN0b3IpO1xuICAgIHZhciBtZWRpYUVsZW1lbnRBdWRpb1NvdXJjZU5vZGVDb25zdHJ1Y3RvciA9IGNyZWF0ZU1lZGlhRWxlbWVudEF1ZGlvU291cmNlTm9kZUNvbnN0cnVjdG9yKGF1ZGlvTm9kZUNvbnN0cnVjdG9yLCBjcmVhdGVOYXRpdmVNZWRpYUVsZW1lbnRBdWRpb1NvdXJjZU5vZGUsIGdldE5hdGl2ZUNvbnRleHQsIGlzTmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCk7XG4gICAgdmFyIG1lZGlhU3RyZWFtQXVkaW9EZXN0aW5hdGlvbk5vZGVDb25zdHJ1Y3RvciA9IGNyZWF0ZU1lZGlhU3RyZWFtQXVkaW9EZXN0aW5hdGlvbk5vZGVDb25zdHJ1Y3RvcihhdWRpb05vZGVDb25zdHJ1Y3RvciwgY3JlYXRlTmF0aXZlTWVkaWFTdHJlYW1BdWRpb0Rlc3RpbmF0aW9uTm9kZSwgZ2V0TmF0aXZlQ29udGV4dCwgaXNOYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0KTtcbiAgICB2YXIgbWVkaWFTdHJlYW1BdWRpb1NvdXJjZU5vZGVDb25zdHJ1Y3RvciA9IGNyZWF0ZU1lZGlhU3RyZWFtQXVkaW9Tb3VyY2VOb2RlQ29uc3RydWN0b3IoYXVkaW9Ob2RlQ29uc3RydWN0b3IsIGNyZWF0ZU5hdGl2ZU1lZGlhU3RyZWFtQXVkaW9Tb3VyY2VOb2RlLCBnZXROYXRpdmVDb250ZXh0LCBpc05hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQpO1xuICAgIHZhciBjcmVhdGVOYXRpdmVNZWRpYVN0cmVhbVRyYWNrQXVkaW9Tb3VyY2VOb2RlID0gY3JlYXRlTmF0aXZlTWVkaWFTdHJlYW1UcmFja0F1ZGlvU291cmNlTm9kZUZhY3RvcnkoY3JlYXRlSW52YWxpZFN0YXRlRXJyb3IsIGlzTmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCk7XG4gICAgdmFyIG1lZGlhU3RyZWFtVHJhY2tBdWRpb1NvdXJjZU5vZGVDb25zdHJ1Y3RvciA9IGNyZWF0ZU1lZGlhU3RyZWFtVHJhY2tBdWRpb1NvdXJjZU5vZGVDb25zdHJ1Y3RvcihhdWRpb05vZGVDb25zdHJ1Y3RvciwgY3JlYXRlTmF0aXZlTWVkaWFTdHJlYW1UcmFja0F1ZGlvU291cmNlTm9kZSwgZ2V0TmF0aXZlQ29udGV4dCk7XG4gICAgdmFyIGF1ZGlvQ29udGV4dENvbnN0cnVjdG9yID0gY3JlYXRlQXVkaW9Db250ZXh0Q29uc3RydWN0b3IoYmFzZUF1ZGlvQ29udGV4dENvbnN0cnVjdG9yLCBjcmVhdGVJbnZhbGlkU3RhdGVFcnJvciwgY3JlYXRlTm90U3VwcG9ydGVkRXJyb3IsIGNyZWF0ZVVua25vd25FcnJvciwgbWVkaWFFbGVtZW50QXVkaW9Tb3VyY2VOb2RlQ29uc3RydWN0b3IsIG1lZGlhU3RyZWFtQXVkaW9EZXN0aW5hdGlvbk5vZGVDb25zdHJ1Y3RvciwgbWVkaWFTdHJlYW1BdWRpb1NvdXJjZU5vZGVDb25zdHJ1Y3RvciwgbWVkaWFTdHJlYW1UcmFja0F1ZGlvU291cmNlTm9kZUNvbnN0cnVjdG9yLCBuYXRpdmVBdWRpb0NvbnRleHRDb25zdHJ1Y3Rvcik7XG4gICAgdmFyIGdldFVucmVuZGVyZWRBdWRpb1dvcmtsZXROb2RlcyA9IGNyZWF0ZUdldFVucmVuZGVyZWRBdWRpb1dvcmtsZXROb2Rlcyh1bnJlbmRlcmVkQXVkaW9Xb3JrbGV0Tm9kZVN0b3JlKTtcbiAgICB2YXIgYWRkVW5yZW5kZXJlZEF1ZGlvV29ya2xldE5vZGUgPSBjcmVhdGVBZGRVbnJlbmRlcmVkQXVkaW9Xb3JrbGV0Tm9kZShnZXRVbnJlbmRlcmVkQXVkaW9Xb3JrbGV0Tm9kZXMpO1xuICAgIHZhciBjb25uZWN0TXVsdGlwbGVPdXRwdXRzID0gY3JlYXRlQ29ubmVjdE11bHRpcGxlT3V0cHV0cyhjcmVhdGVJbmRleFNpemVFcnJvcik7XG4gICAgdmFyIGRlbGV0ZVVucmVuZGVyZWRBdWRpb1dvcmtsZXROb2RlID0gY3JlYXRlRGVsZXRlVW5yZW5kZXJlZEF1ZGlvV29ya2xldE5vZGUoZ2V0VW5yZW5kZXJlZEF1ZGlvV29ya2xldE5vZGVzKTtcbiAgICB2YXIgZGlzY29ubmVjdE11bHRpcGxlT3V0cHV0cyA9IGNyZWF0ZURpc2Nvbm5lY3RNdWx0aXBsZU91dHB1dHMoY3JlYXRlSW5kZXhTaXplRXJyb3IpO1xuICAgIHZhciBhY3RpdmVBdWRpb1dvcmtsZXROb2RlSW5wdXRzU3RvcmUgPSBuZXcgV2Vha01hcCgpO1xuICAgIHZhciBnZXRBY3RpdmVBdWRpb1dvcmtsZXROb2RlSW5wdXRzID0gY3JlYXRlR2V0QWN0aXZlQXVkaW9Xb3JrbGV0Tm9kZUlucHV0cyhhY3RpdmVBdWRpb1dvcmtsZXROb2RlSW5wdXRzU3RvcmUsIGdldFZhbHVlRm9yS2V5KTtcbiAgICB2YXIgY3JlYXRlTmF0aXZlQXVkaW9Xb3JrbGV0Tm9kZUZha2VyID0gY3JlYXRlTmF0aXZlQXVkaW9Xb3JrbGV0Tm9kZUZha2VyRmFjdG9yeShjb25uZWN0TXVsdGlwbGVPdXRwdXRzLCBjcmVhdGVJbmRleFNpemVFcnJvciwgY3JlYXRlSW52YWxpZFN0YXRlRXJyb3IsIGNyZWF0ZU5hdGl2ZUNoYW5uZWxNZXJnZXJOb2RlLCBjcmVhdGVOYXRpdmVDaGFubmVsU3BsaXR0ZXJOb2RlLCBjcmVhdGVOYXRpdmVDb25zdGFudFNvdXJjZU5vZGUsIGNyZWF0ZU5hdGl2ZUdhaW5Ob2RlLCBjcmVhdGVOYXRpdmVTY3JpcHRQcm9jZXNzb3JOb2RlLCBjcmVhdGVOb3RTdXBwb3J0ZWRFcnJvciwgZGlzY29ubmVjdE11bHRpcGxlT3V0cHV0cywgZXhwb3NlQ3VycmVudEZyYW1lQW5kQ3VycmVudFRpbWUsIGdldEFjdGl2ZUF1ZGlvV29ya2xldE5vZGVJbnB1dHMsIG1vbml0b3JDb25uZWN0aW9ucyk7XG4gICAgdmFyIGNyZWF0ZU5hdGl2ZUF1ZGlvV29ya2xldE5vZGUgPSBjcmVhdGVOYXRpdmVBdWRpb1dvcmtsZXROb2RlRmFjdG9yeShjcmVhdGVJbnZhbGlkU3RhdGVFcnJvciwgY3JlYXRlTmF0aXZlQXVkaW9Xb3JrbGV0Tm9kZUZha2VyLCBjcmVhdGVOYXRpdmVHYWluTm9kZSwgY3JlYXRlTm90U3VwcG9ydGVkRXJyb3IsIG1vbml0b3JDb25uZWN0aW9ucyk7XG4gICAgdmFyIGNyZWF0ZUF1ZGlvV29ya2xldE5vZGVSZW5kZXJlciA9IGNyZWF0ZUF1ZGlvV29ya2xldE5vZGVSZW5kZXJlckZhY3RvcnkoY29ubmVjdEF1ZGlvUGFyYW0sIGNvbm5lY3RNdWx0aXBsZU91dHB1dHMsIGNyZWF0ZU5hdGl2ZUF1ZGlvQnVmZmVyU291cmNlTm9kZSwgY3JlYXRlTmF0aXZlQ2hhbm5lbE1lcmdlck5vZGUsIGNyZWF0ZU5hdGl2ZUNoYW5uZWxTcGxpdHRlck5vZGUsIGNyZWF0ZU5hdGl2ZUNvbnN0YW50U291cmNlTm9kZSwgY3JlYXRlTmF0aXZlR2Fpbk5vZGUsIGRlbGV0ZVVucmVuZGVyZWRBdWRpb1dvcmtsZXROb2RlLCBkaXNjb25uZWN0TXVsdGlwbGVPdXRwdXRzLCBleHBvc2VDdXJyZW50RnJhbWVBbmRDdXJyZW50VGltZSwgZ2V0TmF0aXZlQXVkaW9Ob2RlLCBuYXRpdmVBdWRpb1dvcmtsZXROb2RlQ29uc3RydWN0b3IsIG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHRDb25zdHJ1Y3RvciwgcmVuZGVyQXV0b21hdGlvbiwgcmVuZGVySW5wdXRzT2ZBdWRpb05vZGUsIHJlbmRlck5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQpO1xuICAgIHZhciBnZXRCYWNrdXBPZmZsaW5lQXVkaW9Db250ZXh0ID0gY3JlYXRlR2V0QmFja3VwT2ZmbGluZUF1ZGlvQ29udGV4dChiYWNrdXBPZmZsaW5lQXVkaW9Db250ZXh0U3RvcmUpO1xuICAgIHZhciBzZXRBY3RpdmVBdWRpb1dvcmtsZXROb2RlSW5wdXRzID0gY3JlYXRlU2V0QWN0aXZlQXVkaW9Xb3JrbGV0Tm9kZUlucHV0cyhhY3RpdmVBdWRpb1dvcmtsZXROb2RlSW5wdXRzU3RvcmUpO1xuICAgIC8vIFRoZSBBdWRpb1dvcmtsZXROb2RlIGNvbnN0cnVjdG9yIGlzIG9ubHkgYXZhaWxhYmxlIGluIGEgU2VjdXJlQ29udGV4dC5cbiAgICB2YXIgYXVkaW9Xb3JrbGV0Tm9kZUNvbnN0cnVjdG9yID0gaXNTZWN1cmVDb250ZXh0ID8gY3JlYXRlQXVkaW9Xb3JrbGV0Tm9kZUNvbnN0cnVjdG9yKGFkZFVucmVuZGVyZWRBdWRpb1dvcmtsZXROb2RlLCBhdWRpb05vZGVDb25zdHJ1Y3RvciwgY3JlYXRlQXVkaW9QYXJhbSwgY3JlYXRlQXVkaW9Xb3JrbGV0Tm9kZVJlbmRlcmVyLCBjcmVhdGVOYXRpdmVBdWRpb1dvcmtsZXROb2RlLCBnZXRBdWRpb05vZGVDb25uZWN0aW9ucywgZ2V0QmFja3VwT2ZmbGluZUF1ZGlvQ29udGV4dCwgZ2V0TmF0aXZlQ29udGV4dCwgaXNOYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0LCBuYXRpdmVBdWRpb1dvcmtsZXROb2RlQ29uc3RydWN0b3IsIHNhbml0aXplQXVkaW9Xb3JrbGV0Tm9kZU9wdGlvbnMsIHNldEFjdGl2ZUF1ZGlvV29ya2xldE5vZGVJbnB1dHMsIHRlc3RBdWRpb1dvcmtsZXROb2RlT3B0aW9uc0Nsb25hYmlsaXR5LCB3cmFwRXZlbnRMaXN0ZW5lcikgOiB1bmRlZmluZWQ7XG4gICAgdmFyIG1pbmltYWxBdWRpb0NvbnRleHRDb25zdHJ1Y3RvciA9IGNyZWF0ZU1pbmltYWxBdWRpb0NvbnRleHRDb25zdHJ1Y3RvcihjcmVhdGVJbnZhbGlkU3RhdGVFcnJvciwgY3JlYXRlTm90U3VwcG9ydGVkRXJyb3IsIGNyZWF0ZVVua25vd25FcnJvciwgbWluaW1hbEJhc2VBdWRpb0NvbnRleHRDb25zdHJ1Y3RvciwgbmF0aXZlQXVkaW9Db250ZXh0Q29uc3RydWN0b3IpO1xuICAgIHZhciBjcmVhdGVOYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0ID0gY3JlYXRlQ3JlYXRlTmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dChjcmVhdGVOb3RTdXBwb3J0ZWRFcnJvciwgbmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dENvbnN0cnVjdG9yKTtcbiAgICB2YXIgc3RhcnRSZW5kZXJpbmcgPSBjcmVhdGVTdGFydFJlbmRlcmluZyhhdWRpb0J1ZmZlclN0b3JlLCBjYWNoZVRlc3RSZXN1bHQsIGdldEF1ZGlvTm9kZVJlbmRlcmVyLCBnZXRVbnJlbmRlcmVkQXVkaW9Xb3JrbGV0Tm9kZXMsIHJlbmRlck5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQsIHRlc3RBdWRpb0J1ZmZlckNvcHlDaGFubmVsTWV0aG9kc091dE9mQm91bmRzU3VwcG9ydCwgd3JhcEF1ZGlvQnVmZmVyQ29weUNoYW5uZWxNZXRob2RzLCB3cmFwQXVkaW9CdWZmZXJDb3B5Q2hhbm5lbE1ldGhvZHNPdXRPZkJvdW5kcyk7XG4gICAgdmFyIG1pbmltYWxPZmZsaW5lQXVkaW9Db250ZXh0Q29uc3RydWN0b3IgPSBjcmVhdGVNaW5pbWFsT2ZmbGluZUF1ZGlvQ29udGV4dENvbnN0cnVjdG9yKGNhY2hlVGVzdFJlc3VsdCwgY3JlYXRlSW52YWxpZFN0YXRlRXJyb3IsIGNyZWF0ZU5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHQsIG1pbmltYWxCYXNlQXVkaW9Db250ZXh0Q29uc3RydWN0b3IsIHN0YXJ0UmVuZGVyaW5nKTtcbiAgICB2YXIgb2ZmbGluZUF1ZGlvQ29udGV4dENvbnN0cnVjdG9yID0gY3JlYXRlT2ZmbGluZUF1ZGlvQ29udGV4dENvbnN0cnVjdG9yKGJhc2VBdWRpb0NvbnRleHRDb25zdHJ1Y3RvciwgY2FjaGVUZXN0UmVzdWx0LCBjcmVhdGVJbnZhbGlkU3RhdGVFcnJvciwgY3JlYXRlTmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCwgc3RhcnRSZW5kZXJpbmcpO1xuICAgIHZhciBpc0FueUF1ZGlvQ29udGV4dCA9IGNyZWF0ZUlzQW55QXVkaW9Db250ZXh0KENPTlRFWFRfU1RPUkUsIGlzTmF0aXZlQXVkaW9Db250ZXh0KTtcbiAgICB2YXIgaXNBbnlBdWRpb05vZGUgPSBjcmVhdGVJc0FueUF1ZGlvTm9kZShBVURJT19OT0RFX1NUT1JFLCBpc05hdGl2ZUF1ZGlvTm9kZSk7XG4gICAgdmFyIGlzQW55QXVkaW9QYXJhbSA9IGNyZWF0ZUlzQW55QXVkaW9QYXJhbShBVURJT19QQVJBTV9TVE9SRSwgaXNOYXRpdmVBdWRpb1BhcmFtKTtcbiAgICB2YXIgaXNBbnlPZmZsaW5lQXVkaW9Db250ZXh0ID0gY3JlYXRlSXNBbnlPZmZsaW5lQXVkaW9Db250ZXh0KENPTlRFWFRfU1RPUkUsIGlzTmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dCk7XG4gICAgdmFyIGlzU3VwcG9ydGVkID0gZnVuY3Rpb24gaXNTdXBwb3J0ZWQoKSB7XG4gICAgICByZXR1cm4gY3JlYXRlSXNTdXBwb3J0ZWRQcm9taXNlKGNhY2hlVGVzdFJlc3VsdCwgY3JlYXRlVGVzdEF1ZGlvQnVmZmVyQ29weUNoYW5uZWxNZXRob2RzU3ViYXJyYXlTdXBwb3J0KG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHRDb25zdHJ1Y3RvciksIGNyZWF0ZVRlc3RBdWRpb0NvbnRleHRDbG9zZU1ldGhvZFN1cHBvcnQobmF0aXZlQXVkaW9Db250ZXh0Q29uc3RydWN0b3IpLCBjcmVhdGVUZXN0QXVkaW9Db250ZXh0RGVjb2RlQXVkaW9EYXRhTWV0aG9kVHlwZUVycm9yU3VwcG9ydChuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0Q29uc3RydWN0b3IpLCBjcmVhdGVUZXN0QXVkaW9Db250ZXh0T3B0aW9uc1N1cHBvcnQobmF0aXZlQXVkaW9Db250ZXh0Q29uc3RydWN0b3IpLCBjcmVhdGVUZXN0QXVkaW9Ob2RlQ29ubmVjdE1ldGhvZFN1cHBvcnQobmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dENvbnN0cnVjdG9yKSwgY3JlYXRlVGVzdEF1ZGlvV29ya2xldFByb2Nlc3Nvck5vT3V0cHV0c1N1cHBvcnQobmF0aXZlQXVkaW9Xb3JrbGV0Tm9kZUNvbnN0cnVjdG9yLCBuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0Q29uc3RydWN0b3IpLCBjcmVhdGVUZXN0Q2hhbm5lbE1lcmdlck5vZGVDaGFubmVsQ291bnRTdXBwb3J0KG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHRDb25zdHJ1Y3RvciksIGNyZWF0ZVRlc3RDb25zdGFudFNvdXJjZU5vZGVBY2N1cmF0ZVNjaGVkdWxpbmdTdXBwb3J0KG5hdGl2ZU9mZmxpbmVBdWRpb0NvbnRleHRDb25zdHJ1Y3RvciksIGNyZWF0ZVRlc3RDb252b2x2ZXJOb2RlQnVmZmVyUmVhc3NpZ25hYmlsaXR5U3VwcG9ydChuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0Q29uc3RydWN0b3IpLCBjcmVhdGVUZXN0Q29udm9sdmVyTm9kZUNoYW5uZWxDb3VudFN1cHBvcnQobmF0aXZlT2ZmbGluZUF1ZGlvQ29udGV4dENvbnN0cnVjdG9yKSwgdGVzdERvbUV4Y2VwdGlvbkNvbnN0cnVjdG9yU3VwcG9ydCwgY3JlYXRlVGVzdElzU2VjdXJlQ29udGV4dFN1cHBvcnQod2luZG93JDEpLCBjcmVhdGVUZXN0TWVkaWFTdHJlYW1BdWRpb1NvdXJjZU5vZGVNZWRpYVN0cmVhbVdpdGhvdXRBdWRpb1RyYWNrU3VwcG9ydChuYXRpdmVBdWRpb0NvbnRleHRDb25zdHJ1Y3RvciksIGNyZWF0ZVRlc3RTdGVyZW9QYW5uZXJOb2RlRGVmYXVsdFZhbHVlU3VwcG9ydChuYXRpdmVPZmZsaW5lQXVkaW9Db250ZXh0Q29uc3RydWN0b3IpLCB0ZXN0VHJhbnNmZXJhYmxlc1N1cHBvcnQpO1xuICAgIH07XG5cbiAgICBleHBvcnRzLkFuYWx5c2VyTm9kZSA9IGFuYWx5c2VyTm9kZUNvbnN0cnVjdG9yO1xuICAgIGV4cG9ydHMuQXVkaW9CdWZmZXIgPSBhdWRpb0J1ZmZlckNvbnN0cnVjdG9yO1xuICAgIGV4cG9ydHMuQXVkaW9CdWZmZXJTb3VyY2VOb2RlID0gYXVkaW9CdWZmZXJTb3VyY2VOb2RlQ29uc3RydWN0b3I7XG4gICAgZXhwb3J0cy5BdWRpb0NvbnRleHQgPSBhdWRpb0NvbnRleHRDb25zdHJ1Y3RvcjtcbiAgICBleHBvcnRzLkF1ZGlvV29ya2xldE5vZGUgPSBhdWRpb1dvcmtsZXROb2RlQ29uc3RydWN0b3I7XG4gICAgZXhwb3J0cy5CaXF1YWRGaWx0ZXJOb2RlID0gYmlxdWFkRmlsdGVyTm9kZUNvbnN0cnVjdG9yO1xuICAgIGV4cG9ydHMuQ2hhbm5lbE1lcmdlck5vZGUgPSBjaGFubmVsTWVyZ2VyTm9kZUNvbnN0cnVjdG9yO1xuICAgIGV4cG9ydHMuQ2hhbm5lbFNwbGl0dGVyTm9kZSA9IGNoYW5uZWxTcGxpdHRlck5vZGVDb25zdHJ1Y3RvcjtcbiAgICBleHBvcnRzLkNvbnN0YW50U291cmNlTm9kZSA9IGNvbnN0YW50U291cmNlTm9kZUNvbnN0cnVjdG9yO1xuICAgIGV4cG9ydHMuQ29udm9sdmVyTm9kZSA9IGNvbnZvbHZlck5vZGVDb25zdHJ1Y3RvcjtcbiAgICBleHBvcnRzLkRlbGF5Tm9kZSA9IGRlbGF5Tm9kZUNvbnN0cnVjdG9yO1xuICAgIGV4cG9ydHMuRHluYW1pY3NDb21wcmVzc29yTm9kZSA9IGR5bmFtaWNzQ29tcHJlc3Nvck5vZGVDb25zdHJ1Y3RvcjtcbiAgICBleHBvcnRzLkdhaW5Ob2RlID0gZ2Fpbk5vZGVDb25zdHJ1Y3RvcjtcbiAgICBleHBvcnRzLklJUkZpbHRlck5vZGUgPSBpSVJGaWx0ZXJOb2RlQ29uc3RydWN0b3I7XG4gICAgZXhwb3J0cy5NZWRpYUVsZW1lbnRBdWRpb1NvdXJjZU5vZGUgPSBtZWRpYUVsZW1lbnRBdWRpb1NvdXJjZU5vZGVDb25zdHJ1Y3RvcjtcbiAgICBleHBvcnRzLk1lZGlhU3RyZWFtQXVkaW9EZXN0aW5hdGlvbk5vZGUgPSBtZWRpYVN0cmVhbUF1ZGlvRGVzdGluYXRpb25Ob2RlQ29uc3RydWN0b3I7XG4gICAgZXhwb3J0cy5NZWRpYVN0cmVhbUF1ZGlvU291cmNlTm9kZSA9IG1lZGlhU3RyZWFtQXVkaW9Tb3VyY2VOb2RlQ29uc3RydWN0b3I7XG4gICAgZXhwb3J0cy5NZWRpYVN0cmVhbVRyYWNrQXVkaW9Tb3VyY2VOb2RlID0gbWVkaWFTdHJlYW1UcmFja0F1ZGlvU291cmNlTm9kZUNvbnN0cnVjdG9yO1xuICAgIGV4cG9ydHMuTWluaW1hbEF1ZGlvQ29udGV4dCA9IG1pbmltYWxBdWRpb0NvbnRleHRDb25zdHJ1Y3RvcjtcbiAgICBleHBvcnRzLk1pbmltYWxPZmZsaW5lQXVkaW9Db250ZXh0ID0gbWluaW1hbE9mZmxpbmVBdWRpb0NvbnRleHRDb25zdHJ1Y3RvcjtcbiAgICBleHBvcnRzLk9mZmxpbmVBdWRpb0NvbnRleHQgPSBvZmZsaW5lQXVkaW9Db250ZXh0Q29uc3RydWN0b3I7XG4gICAgZXhwb3J0cy5Pc2NpbGxhdG9yTm9kZSA9IG9zY2lsbGF0b3JOb2RlQ29uc3RydWN0b3I7XG4gICAgZXhwb3J0cy5QYW5uZXJOb2RlID0gcGFubmVyTm9kZUNvbnN0cnVjdG9yO1xuICAgIGV4cG9ydHMuUGVyaW9kaWNXYXZlID0gcGVyaW9kaWNXYXZlQ29uc3RydWN0b3I7XG4gICAgZXhwb3J0cy5TdGVyZW9QYW5uZXJOb2RlID0gc3RlcmVvUGFubmVyTm9kZUNvbnN0cnVjdG9yO1xuICAgIGV4cG9ydHMuV2F2ZVNoYXBlck5vZGUgPSB3YXZlU2hhcGVyTm9kZUNvbnN0cnVjdG9yO1xuICAgIGV4cG9ydHMuYWRkQXVkaW9Xb3JrbGV0TW9kdWxlID0gYWRkQXVkaW9Xb3JrbGV0TW9kdWxlO1xuICAgIGV4cG9ydHMuZGVjb2RlQXVkaW9EYXRhID0gZGVjb2RlQXVkaW9EYXRhO1xuICAgIGV4cG9ydHMuaXNBbnlBdWRpb0NvbnRleHQgPSBpc0FueUF1ZGlvQ29udGV4dDtcbiAgICBleHBvcnRzLmlzQW55QXVkaW9Ob2RlID0gaXNBbnlBdWRpb05vZGU7XG4gICAgZXhwb3J0cy5pc0FueUF1ZGlvUGFyYW0gPSBpc0FueUF1ZGlvUGFyYW07XG4gICAgZXhwb3J0cy5pc0FueU9mZmxpbmVBdWRpb0NvbnRleHQgPSBpc0FueU9mZmxpbmVBdWRpb0NvbnRleHQ7XG4gICAgZXhwb3J0cy5pc1N1cHBvcnRlZCA9IGlzU3VwcG9ydGVkO1xuXG59KSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/standardized-audio-context/build/es5/bundle.js\n");

/***/ })

};
;