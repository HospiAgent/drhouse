/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/extendable-media-recorder";
exports.ids = ["vendor-chunks/extendable-media-recorder"];
exports.modules = {

/***/ "(ssr)/./node_modules/extendable-media-recorder/build/es5/bundle.js":
/*!********************************************************************!*\
  !*** ./node_modules/extendable-media-recorder/build/es5/bundle.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("(function (global, factory) {\n     true ? factory(exports, __webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ \"(ssr)/./node_modules/@babel/runtime/helpers/asyncToGenerator.js\"), __webpack_require__(/*! @babel/runtime/regenerator */ \"(ssr)/./node_modules/@babel/runtime/regenerator/index.js\"), __webpack_require__(/*! media-encoder-host */ \"(ssr)/./node_modules/media-encoder-host/build/es5/bundle.js\"), __webpack_require__(/*! @babel/runtime/helpers/objectWithoutProperties */ \"(ssr)/./node_modules/@babel/runtime/helpers/objectWithoutProperties.js\"), __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ \"(ssr)/./node_modules/@babel/runtime/helpers/classCallCheck.js\"), __webpack_require__(/*! @babel/runtime/helpers/createClass */ \"(ssr)/./node_modules/@babel/runtime/helpers/createClass.js\"), __webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ \"(ssr)/./node_modules/@babel/runtime/helpers/assertThisInitialized.js\"), __webpack_require__(/*! @babel/runtime/helpers/inherits */ \"(ssr)/./node_modules/@babel/runtime/helpers/inherits.js\"), __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ \"(ssr)/./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js\"), __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ \"(ssr)/./node_modules/@babel/runtime/helpers/getPrototypeOf.js\"), __webpack_require__(/*! @babel/runtime/helpers/slicedToArray */ \"(ssr)/./node_modules/@babel/runtime/helpers/slicedToArray.js\"), __webpack_require__(/*! @babel/runtime/helpers/toConsumableArray */ \"(ssr)/./node_modules/@babel/runtime/helpers/toConsumableArray.js\"), __webpack_require__(/*! recorder-audio-worklet */ \"(ssr)/./node_modules/recorder-audio-worklet/build/es5/bundle.js\"), __webpack_require__(/*! standardized-audio-context */ \"(ssr)/./node_modules/standardized-audio-context/build/es5/bundle.js\"), __webpack_require__(/*! multi-buffer-data-view */ \"(ssr)/./node_modules/multi-buffer-data-view/build/node/module.js\"), __webpack_require__(/*! subscribable-things */ \"(ssr)/./node_modules/subscribable-things/build/es5/bundle.js\")) :\n    0;\n})(this, (function (exports, _asyncToGenerator, _regeneratorRuntime, mediaEncoderHost, _objectWithoutProperties, _classCallCheck, _createClass, _assertThisInitialized, _inherits, _possibleConstructorReturn, _getPrototypeOf, _slicedToArray, _toConsumableArray, recorderAudioWorklet, standardizedAudioContext, multiBufferDataView, subscribableThings) { 'use strict';\n\n    function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\n    var _asyncToGenerator__default = /*#__PURE__*/_interopDefaultLegacy(_asyncToGenerator);\n    var _regeneratorRuntime__default = /*#__PURE__*/_interopDefaultLegacy(_regeneratorRuntime);\n    var _objectWithoutProperties__default = /*#__PURE__*/_interopDefaultLegacy(_objectWithoutProperties);\n    var _classCallCheck__default = /*#__PURE__*/_interopDefaultLegacy(_classCallCheck);\n    var _createClass__default = /*#__PURE__*/_interopDefaultLegacy(_createClass);\n    var _assertThisInitialized__default = /*#__PURE__*/_interopDefaultLegacy(_assertThisInitialized);\n    var _inherits__default = /*#__PURE__*/_interopDefaultLegacy(_inherits);\n    var _possibleConstructorReturn__default = /*#__PURE__*/_interopDefaultLegacy(_possibleConstructorReturn);\n    var _getPrototypeOf__default = /*#__PURE__*/_interopDefaultLegacy(_getPrototypeOf);\n    var _slicedToArray__default = /*#__PURE__*/_interopDefaultLegacy(_slicedToArray);\n    var _toConsumableArray__default = /*#__PURE__*/_interopDefaultLegacy(_toConsumableArray);\n\n    var _excluded = [\"data\"];\n    var createBlobEventFactory = function createBlobEventFactory(nativeBlobEventConstructor) {\n      return function (type, blobEventInit) {\n        // Bug #14: Safari does not yet support the BlobEvent.\n        if (nativeBlobEventConstructor === null) {\n          var data = blobEventInit.data,\n              eventInit = _objectWithoutProperties__default[\"default\"](blobEventInit, _excluded);\n\n          var fakeBlobEvent = new Event(type, eventInit);\n          fakeBlobEvent.data = data;\n          return fakeBlobEvent;\n        }\n\n        return new nativeBlobEventConstructor(type, blobEventInit);\n      };\n    };\n\n    var createDecodeWebMChunk = function createDecodeWebMChunk(readElementContent, readElementType) {\n      return function (dataView, elementType, channelCount) {\n        var contents = [];\n        var currentElementType = elementType;\n        var offset = 0;\n\n        while (offset < dataView.byteLength) {\n          if (currentElementType === null) {\n            var lengthAndType = readElementType(dataView, offset);\n\n            if (lengthAndType === null) {\n              break;\n            }\n\n            var length = lengthAndType.length,\n                type = lengthAndType.type;\n            currentElementType = type;\n            offset += length;\n          } else {\n            var contentAndLength = readElementContent(dataView, offset, currentElementType, channelCount);\n\n            if (contentAndLength === null) {\n              break;\n            }\n\n            var content = contentAndLength.content,\n                _length = contentAndLength.length;\n            currentElementType = null;\n            offset += _length;\n\n            if (content !== null) {\n              contents.push(content);\n            }\n          }\n        }\n\n        return {\n          contents: contents,\n          currentElementType: currentElementType,\n          offset: offset\n        };\n      };\n    };\n\n    var createEventTargetConstructor = function createEventTargetConstructor(createEventTarget, wrapEventListener) {\n      return /*#__PURE__*/function () {\n        function EventTarget() {\n          var nativeEventTarget = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n          _classCallCheck__default[\"default\"](this, EventTarget);\n\n          this._listeners = new WeakMap();\n          this._nativeEventTarget = nativeEventTarget === null ? createEventTarget() : nativeEventTarget;\n        }\n\n        _createClass__default[\"default\"](EventTarget, [{\n          key: \"addEventListener\",\n          value: function addEventListener(type, listener, options) {\n            if (listener !== null) {\n              var wrappedEventListener = this._listeners.get(listener);\n\n              if (wrappedEventListener === undefined) {\n                wrappedEventListener = wrapEventListener(this, listener);\n\n                if (typeof listener === 'function') {\n                  this._listeners.set(listener, wrappedEventListener);\n                }\n              }\n\n              this._nativeEventTarget.addEventListener(type, wrappedEventListener, options);\n            }\n          }\n        }, {\n          key: \"dispatchEvent\",\n          value: function dispatchEvent(event) {\n            return this._nativeEventTarget.dispatchEvent(event);\n          }\n        }, {\n          key: \"removeEventListener\",\n          value: function removeEventListener(type, listener, options) {\n            var wrappedEventListener = listener === null ? undefined : this._listeners.get(listener);\n\n            this._nativeEventTarget.removeEventListener(type, wrappedEventListener === undefined ? null : wrappedEventListener, options);\n          }\n        }]);\n\n        return EventTarget;\n      }();\n    };\n\n    var createEventTargetFactory = function createEventTargetFactory(window) {\n      return function () {\n        if (window === null) {\n          throw new Error('A native EventTarget could not be created.');\n        }\n\n        return window.document.createElement('p');\n      };\n    };\n\n    var createInvalidModificationError = function createInvalidModificationError() {\n      var message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n\n      try {\n        return new DOMException(message, 'InvalidModificationError');\n      } catch (err) {\n        // @todo Edge is the only browser that does not yet allow to construct a DOMException.\n        err.code = 13;\n        err.message = message;\n        err.name = 'InvalidModificationError';\n        return err;\n      }\n    };\n\n    var createInvalidStateError = function createInvalidStateError() {\n      try {\n        return new DOMException('', 'InvalidStateError');\n      } catch (err) {\n        // Bug #122: Edge is the only browser that does not yet allow to construct a DOMException.\n        err.code = 11;\n        err.name = 'InvalidStateError';\n        return err;\n      }\n    };\n\n    var createIsSupportedPromise = function createIsSupportedPromise(window) {\n      if (window !== null && window.MediaStream !== undefined && (\n      /*\n       * Bug #10: An early experimental implemenation in Safari did not provide the isTypeSupported() function.\n       */\n      window.MediaRecorder === undefined || window.MediaRecorder.isTypeSupported !== undefined)) {\n        /*\n         * Bug #5: Up until v70 Firefox did emit a blob of type video/webm when asked to encode a MediaStream with a video track into an\n         * audio codec.\n         */\n        return new Promise(function (resolve) {\n          // Bug #11 Safari does not yet support the MediaRecorder but that isn't tested here.\n          if (window.MediaRecorder === undefined) {\n            return resolve(true);\n          } // @todo captureStream() is not defined yet.\n\n\n          var canvasElement = document.createElement('canvas'); // @todo https://bugzilla.mozilla.org/show_bug.cgi?id=1388974\n\n          canvasElement.getContext('2d');\n\n          if (typeof canvasElement.captureStream !== 'function') {\n            return resolve(false);\n          }\n\n          var mediaStream = canvasElement.captureStream();\n          var mimeType = 'audio/webm';\n\n          try {\n            var mediaRecorder = new window.MediaRecorder(mediaStream, {\n              mimeType: mimeType\n            });\n            mediaRecorder.addEventListener('dataavailable', function (_ref) {\n              var data = _ref.data;\n              return resolve(data.type === mimeType);\n            });\n            mediaRecorder.start();\n            setTimeout(function () {\n              return mediaRecorder.stop();\n            }, 10);\n          } catch (err) {\n            resolve(err.name === 'NotSupportedError');\n          }\n        });\n      }\n\n      return Promise.resolve(false);\n    };\n\n    function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf__default[\"default\"](Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf__default[\"default\"](this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn__default[\"default\"](this, result); }; }\n\n    function _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\n    var createMediaRecorderConstructor = function createMediaRecorderConstructor(createNativeMediaRecorder, createNotSupportedError, createWebAudioMediaRecorder, createWebmPcmMediaRecorder, encoderRegexes, eventTargetConstructor, nativeMediaRecorderConstructor) {\n      return /*#__PURE__*/function (_eventTargetConstruct) {\n        _inherits__default[\"default\"](MediaRecorder, _eventTargetConstruct);\n\n        var _super = _createSuper(MediaRecorder);\n\n        function MediaRecorder(stream) {\n          var _this;\n\n          var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n          _classCallCheck__default[\"default\"](this, MediaRecorder);\n\n          var mimeType = options.mimeType;\n\n          if (nativeMediaRecorderConstructor !== null && ( // Bug #10: Safari does not yet implement the isTypeSupported() method.\n          mimeType === undefined || nativeMediaRecorderConstructor.isTypeSupported !== undefined && nativeMediaRecorderConstructor.isTypeSupported(mimeType))) {\n            var internalMediaRecorder = createNativeMediaRecorder(nativeMediaRecorderConstructor, stream, options);\n            _this = _super.call(this, internalMediaRecorder);\n            _this._internalMediaRecorder = internalMediaRecorder;\n          } else if (mimeType !== undefined && encoderRegexes.some(function (regex) {\n            return regex.test(mimeType);\n          })) {\n            _this = _super.call(this); // Bug #10: Safari does not yet implement the isTypeSupported() method.\n\n            if (nativeMediaRecorderConstructor !== null && nativeMediaRecorderConstructor.isTypeSupported !== undefined && nativeMediaRecorderConstructor.isTypeSupported('audio/webm;codecs=pcm')) {\n              _this._internalMediaRecorder = createWebmPcmMediaRecorder(_assertThisInitialized__default[\"default\"](_this), nativeMediaRecorderConstructor, stream, mimeType);\n            } else {\n              _this._internalMediaRecorder = createWebAudioMediaRecorder(_assertThisInitialized__default[\"default\"](_this), stream, mimeType);\n            }\n          } else {\n            // This is creating a native MediaRecorder just to provoke it to throw an error.\n            if (nativeMediaRecorderConstructor !== null) {\n              createNativeMediaRecorder(nativeMediaRecorderConstructor, stream, options);\n            }\n\n            throw createNotSupportedError();\n          }\n\n          _this._ondataavailable = null;\n          _this._onerror = null;\n          _this._onpause = null;\n          _this._onresume = null;\n          _this._onstart = null;\n          _this._onstop = null;\n          return _possibleConstructorReturn__default[\"default\"](_this);\n        }\n\n        _createClass__default[\"default\"](MediaRecorder, [{\n          key: \"mimeType\",\n          get: function get() {\n            return this._internalMediaRecorder.mimeType;\n          }\n        }, {\n          key: \"ondataavailable\",\n          get: function get() {\n            return this._ondataavailable === null ? this._ondataavailable : this._ondataavailable[0];\n          },\n          set: function set(value) {\n            if (this._ondataavailable !== null) {\n              this.removeEventListener('dataavailable', this._ondataavailable[1]);\n            }\n\n            if (typeof value === 'function') {\n              var boundListener = value.bind(this);\n              this.addEventListener('dataavailable', boundListener);\n              this._ondataavailable = [value, boundListener];\n            } else {\n              this._ondataavailable = null;\n            }\n          }\n        }, {\n          key: \"onerror\",\n          get: function get() {\n            return this._onerror === null ? this._onerror : this._onerror[0];\n          },\n          set: function set(value) {\n            if (this._onerror !== null) {\n              this.removeEventListener('error', this._onerror[1]);\n            }\n\n            if (typeof value === 'function') {\n              var boundListener = value.bind(this);\n              this.addEventListener('error', boundListener);\n              this._onerror = [value, boundListener];\n            } else {\n              this._onerror = null;\n            }\n          }\n        }, {\n          key: \"onpause\",\n          get: function get() {\n            return this._onpause === null ? this._onpause : this._onpause[0];\n          },\n          set: function set(value) {\n            if (this._onpause !== null) {\n              this.removeEventListener('pause', this._onpause[1]);\n            }\n\n            if (typeof value === 'function') {\n              var boundListener = value.bind(this);\n              this.addEventListener('pause', boundListener);\n              this._onpause = [value, boundListener];\n            } else {\n              this._onpause = null;\n            }\n          }\n        }, {\n          key: \"onresume\",\n          get: function get() {\n            return this._onresume === null ? this._onresume : this._onresume[0];\n          },\n          set: function set(value) {\n            if (this._onresume !== null) {\n              this.removeEventListener('resume', this._onresume[1]);\n            }\n\n            if (typeof value === 'function') {\n              var boundListener = value.bind(this);\n              this.addEventListener('resume', boundListener);\n              this._onresume = [value, boundListener];\n            } else {\n              this._onresume = null;\n            }\n          }\n        }, {\n          key: \"onstart\",\n          get: function get() {\n            return this._onstart === null ? this._onstart : this._onstart[0];\n          },\n          set: function set(value) {\n            if (this._onstart !== null) {\n              this.removeEventListener('start', this._onstart[1]);\n            }\n\n            if (typeof value === 'function') {\n              var boundListener = value.bind(this);\n              this.addEventListener('start', boundListener);\n              this._onstart = [value, boundListener];\n            } else {\n              this._onstart = null;\n            }\n          }\n        }, {\n          key: \"onstop\",\n          get: function get() {\n            return this._onstop === null ? this._onstop : this._onstop[0];\n          },\n          set: function set(value) {\n            if (this._onstop !== null) {\n              this.removeEventListener('stop', this._onstop[1]);\n            }\n\n            if (typeof value === 'function') {\n              var boundListener = value.bind(this);\n              this.addEventListener('stop', boundListener);\n              this._onstop = [value, boundListener];\n            } else {\n              this._onstop = null;\n            }\n          }\n        }, {\n          key: \"state\",\n          get: function get() {\n            return this._internalMediaRecorder.state;\n          }\n        }, {\n          key: \"pause\",\n          value: function pause() {\n            return this._internalMediaRecorder.pause();\n          }\n        }, {\n          key: \"resume\",\n          value: function resume() {\n            return this._internalMediaRecorder.resume();\n          }\n        }, {\n          key: \"start\",\n          value: function start(timeslice) {\n            return this._internalMediaRecorder.start(timeslice);\n          }\n        }, {\n          key: \"stop\",\n          value: function stop() {\n            return this._internalMediaRecorder.stop();\n          }\n        }], [{\n          key: \"isTypeSupported\",\n          value: function isTypeSupported(mimeType) {\n            return nativeMediaRecorderConstructor !== null && // Bug #10: Safari does not yet implement the isTypeSupported() method.\n            nativeMediaRecorderConstructor.isTypeSupported !== undefined && nativeMediaRecorderConstructor.isTypeSupported(mimeType) || encoderRegexes.some(function (regex) {\n              return regex.test(mimeType);\n            });\n          }\n        }]);\n\n        return MediaRecorder;\n      }(eventTargetConstructor);\n    };\n\n    var createNativeBlobEventConstructor = function createNativeBlobEventConstructor(window) {\n      if (window !== null && window.BlobEvent !== undefined) {\n        return window.BlobEvent;\n      }\n\n      return null;\n    };\n\n    var createNativeMediaRecorderFactory = function createNativeMediaRecorderFactory(createInvalidModificationError, createNotSupportedError) {\n      return function (nativeMediaRecorderConstructor, stream, mediaRecorderOptions) {\n        var bufferedBlobs = [];\n        var dataAvailableListeners = new WeakMap();\n        var errorListeners = new WeakMap();\n        var nativeMediaRecorder = new nativeMediaRecorderConstructor(stream, mediaRecorderOptions);\n        var stopListeners = new WeakMap();\n        var isActive = true;\n\n        nativeMediaRecorder.addEventListener = function (addEventListener) {\n          return function (type, listener, options) {\n            var patchedEventListener = listener;\n\n            if (typeof listener === 'function') {\n              if (type === 'dataavailable') {\n                // Bug #7 & #8: Chrome fires the dataavailable and stop events before it fires the error event.\n                patchedEventListener = function patchedEventListener(event) {\n                  setTimeout(function () {\n                    if (isActive && nativeMediaRecorder.state === 'inactive') {\n                      bufferedBlobs.push(event.data);\n                    } else {\n                      if (bufferedBlobs.length > 0) {\n                        var blob = event.data;\n                        Object.defineProperty(event, 'data', {\n                          value: new Blob([].concat(bufferedBlobs, [blob]), {\n                            type: blob.type\n                          })\n                        });\n                        bufferedBlobs.length = 0;\n                      }\n\n                      listener.call(nativeMediaRecorder, event);\n                    }\n                  });\n                };\n\n                dataAvailableListeners.set(listener, patchedEventListener);\n              } else if (type === 'error') {\n                // Bug #12 & #13: Firefox fires a regular event with an error property.\n                patchedEventListener = function patchedEventListener(event) {\n                  // Bug #3 & #4: Chrome throws an error event without any error.\n                  if (event.error === undefined) {\n                    listener.call(nativeMediaRecorder, new ErrorEvent('error', {\n                      error: createInvalidModificationError()\n                    })); // Bug #1 & #2: Firefox throws an error event with an UnknownError.\n                  } else if (event.error.name === 'UnknownError') {\n                    var message = event.error.message;\n                    listener.call(nativeMediaRecorder, new ErrorEvent('error', {\n                      error: createInvalidModificationError(message)\n                    }));\n                  } else if (event instanceof ErrorEvent) {\n                    listener.call(nativeMediaRecorder, event);\n                  } else {\n                    listener.call(nativeMediaRecorder, new ErrorEvent('error', {\n                      error: event.error\n                    }));\n                  }\n                };\n\n                errorListeners.set(listener, patchedEventListener);\n              } else if (type === 'stop') {\n                // Bug #7 & #8: Chrome fires the dataavailable and stop events before it fires the error event.\n                patchedEventListener = function patchedEventListener(event) {\n                  isActive = false;\n                  setTimeout(function () {\n                    return listener.call(nativeMediaRecorder, event);\n                  });\n                };\n\n                stopListeners.set(listener, patchedEventListener);\n              }\n            }\n\n            return addEventListener.call(nativeMediaRecorder, type, patchedEventListener, options);\n          };\n        }(nativeMediaRecorder.addEventListener);\n\n        nativeMediaRecorder.dispatchEvent = function (dispatchEvent) {\n          // Bug #7 & #8: Chrome fires the dataavailable and stop events before it fires the error event.\n          return function (event) {\n            var wasActive;\n            setTimeout(function () {\n              wasActive = isActive;\n              isActive = false;\n            });\n            var returnValue = dispatchEvent.call(nativeMediaRecorder, event);\n            setTimeout(function () {\n              return isActive = wasActive;\n            });\n            return returnValue;\n          };\n        }(nativeMediaRecorder.dispatchEvent);\n\n        nativeMediaRecorder.removeEventListener = function (removeEventListener) {\n          return function (type, listener, options) {\n            var patchedEventListener = listener;\n\n            if (typeof listener === 'function') {\n              if (type === 'dataavailable') {\n                var dataAvailableListener = dataAvailableListeners.get(listener);\n\n                if (dataAvailableListener !== undefined) {\n                  patchedEventListener = dataAvailableListener;\n                }\n              } else if (type === 'error') {\n                var errorListener = errorListeners.get(listener);\n\n                if (errorListener !== undefined) {\n                  patchedEventListener = errorListener;\n                }\n              } else if (type === 'stop') {\n                var stopListener = stopListeners.get(listener);\n\n                if (stopListener !== undefined) {\n                  patchedEventListener = stopListener;\n                }\n              }\n            }\n\n            return removeEventListener.call(nativeMediaRecorder, type, patchedEventListener, options);\n          };\n        }(nativeMediaRecorder.removeEventListener);\n\n        nativeMediaRecorder.start = function (start) {\n          return function (timeslice) {\n            /*\n             * Bug #6: Chrome will emit a blob without any data when asked to encode a MediaStream with a video track into an audio\n             * codec.\n             */\n            if (mediaRecorderOptions.mimeType !== undefined && mediaRecorderOptions.mimeType.startsWith('audio/') && stream.getVideoTracks().length > 0) {\n              throw createNotSupportedError();\n            }\n\n            isActive = timeslice !== undefined;\n            return timeslice === undefined ? start.call(nativeMediaRecorder) : start.call(nativeMediaRecorder, timeslice);\n          };\n        }(nativeMediaRecorder.start);\n\n        return nativeMediaRecorder;\n      };\n    };\n\n    var createNativeMediaRecorderConstructor = function createNativeMediaRecorderConstructor(window) {\n      if (window === null) {\n        return null;\n      }\n\n      return window.MediaRecorder === undefined ? null : window.MediaRecorder;\n    };\n\n    var createNotSupportedError = function createNotSupportedError() {\n      try {\n        return new DOMException('', 'NotSupportedError');\n      } catch (err) {\n        // @todo Edge is the only browser that does not yet allow to construct a DOMException.\n        err.code = 9;\n        err.name = 'NotSupportedError';\n        return err;\n      }\n    };\n\n    var createReadElementContent = function createReadElementContent(readVariableSizeInteger) {\n      return function (dataView, offset, type) {\n        var channelCount = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 2;\n        var lengthAndValue = readVariableSizeInteger(dataView, offset);\n\n        if (lengthAndValue === null) {\n          return lengthAndValue;\n        }\n\n        var length = lengthAndValue.length,\n            value = lengthAndValue.value;\n\n        if (type === 'master') {\n          return {\n            content: null,\n            length: length\n          };\n        }\n\n        if (offset + length + value > dataView.byteLength) {\n          return null;\n        }\n\n        if (type === 'binary') {\n          var numberOfSamples = (value / Float32Array.BYTES_PER_ELEMENT - 1) / channelCount;\n          var content = Array.from({\n            length: channelCount\n          }, function () {\n            return new Float32Array(numberOfSamples);\n          });\n\n          for (var i = 0; i < numberOfSamples; i += 1) {\n            var elementOffset = i * channelCount + 1;\n\n            for (var j = 0; j < channelCount; j += 1) {\n              content[j][i] = dataView.getFloat32(offset + length + (elementOffset + j) * Float32Array.BYTES_PER_ELEMENT, true);\n            }\n          }\n\n          return {\n            content: content,\n            length: length + value\n          };\n        }\n\n        return {\n          content: null,\n          length: length + value\n        };\n      };\n    };\n\n    var createReadElementType = function createReadElementType(readVariableSizeInteger) {\n      return function (dataView, offset) {\n        var lengthAndValue = readVariableSizeInteger(dataView, offset);\n\n        if (lengthAndValue === null) {\n          return lengthAndValue;\n        }\n\n        var length = lengthAndValue.length,\n            value = lengthAndValue.value;\n\n        if (value === 35) {\n          return {\n            length: length,\n            type: 'binary'\n          };\n        }\n\n        if (value === 46 || value === 97 || value === 88713574 || value === 106212971 || value === 139690087 || value === 172351395 || value === 256095861) {\n          return {\n            length: length,\n            type: 'master'\n          };\n        }\n\n        return {\n          length: length,\n          type: 'unknown'\n        };\n      };\n    };\n\n    var createReadVariableSizeInteger = function createReadVariableSizeInteger(readVariableSizeIntegerLength) {\n      return function (dataView, offset) {\n        var length = readVariableSizeIntegerLength(dataView, offset);\n\n        if (length === null) {\n          return length;\n        }\n\n        var firstDataByteOffset = offset + Math.floor((length - 1) / 8);\n\n        if (firstDataByteOffset + length > dataView.byteLength) {\n          return null;\n        }\n\n        var firstDataByte = dataView.getUint8(firstDataByteOffset);\n        var value = firstDataByte & (1 << 8 - length % 8) - 1; // tslint:disable-line:no-bitwise\n\n        for (var i = 1; i < length; i += 1) {\n          value = (value << 8) + dataView.getUint8(firstDataByteOffset + i); // tslint:disable-line:no-bitwise\n        }\n\n        return {\n          length: length,\n          value: value\n        };\n      };\n    };\n\n    var ERROR_MESSAGE = 'Missing AudioWorklet support. Maybe this is not running in a secure context.'; // @todo This should live in a separate file.\n\n    var createPromisedAudioNodesEncoderIdAndPort = /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator__default[\"default\"]( /*#__PURE__*/_regeneratorRuntime__default[\"default\"].mark(function _callee(audioBuffer, audioContext, channelCount, mediaStream, mimeType) {\n        var _yield$instantiate, encoderId, port, audioBufferSourceNode, mediaStreamAudioSourceNode, recorderAudioWorkletNode;\n\n        return _regeneratorRuntime__default[\"default\"].wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return mediaEncoderHost.instantiate(mimeType, audioContext.sampleRate);\n\n              case 2:\n                _yield$instantiate = _context.sent;\n                encoderId = _yield$instantiate.encoderId;\n                port = _yield$instantiate.port;\n\n                if (!(standardizedAudioContext.AudioWorkletNode === undefined)) {\n                  _context.next = 7;\n                  break;\n                }\n\n                throw new Error(ERROR_MESSAGE);\n\n              case 7:\n                audioBufferSourceNode = new standardizedAudioContext.AudioBufferSourceNode(audioContext, {\n                  buffer: audioBuffer\n                });\n                mediaStreamAudioSourceNode = new standardizedAudioContext.MediaStreamAudioSourceNode(audioContext, {\n                  mediaStream: mediaStream\n                });\n                recorderAudioWorkletNode = recorderAudioWorklet.createRecorderAudioWorkletNode(standardizedAudioContext.AudioWorkletNode, audioContext, {\n                  channelCount: channelCount\n                });\n                return _context.abrupt(\"return\", {\n                  audioBufferSourceNode: audioBufferSourceNode,\n                  encoderId: encoderId,\n                  mediaStreamAudioSourceNode: mediaStreamAudioSourceNode,\n                  port: port,\n                  recorderAudioWorkletNode: recorderAudioWorkletNode\n                });\n\n              case 11:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n\n      return function createPromisedAudioNodesEncoderIdAndPort(_x, _x2, _x3, _x4, _x5) {\n        return _ref.apply(this, arguments);\n      };\n    }();\n\n    var createWebAudioMediaRecorderFactory = function createWebAudioMediaRecorderFactory(createBlobEvent, createInvalidModificationError, createInvalidStateError, createNotSupportedError) {\n      return function (eventTarget, mediaStream, mimeType) {\n        var _a;\n\n        var sampleRate = (_a = mediaStream.getAudioTracks()[0]) === null || _a === void 0 ? void 0 : _a.getSettings().sampleRate;\n        var audioContext = new standardizedAudioContext.MinimalAudioContext({\n          latencyHint: 'playback',\n          sampleRate: sampleRate\n        });\n        var length = Math.max(1024, Math.ceil(audioContext.baseLatency * audioContext.sampleRate));\n        var audioBuffer = new standardizedAudioContext.AudioBuffer({\n          length: length,\n          sampleRate: audioContext.sampleRate\n        });\n        var bufferedArrayBuffers = [];\n        var promisedAudioWorkletModule = recorderAudioWorklet.addRecorderAudioWorkletModule(function (url) {\n          if (standardizedAudioContext.addAudioWorkletModule === undefined) {\n            throw new Error(ERROR_MESSAGE);\n          }\n\n          return standardizedAudioContext.addAudioWorkletModule(audioContext, url);\n        });\n        var abortRecording = null;\n        var intervalId = null;\n        var promisedAudioNodesAndEncoderId = null;\n        var promisedPartialRecording = null;\n        var isAudioContextRunning = true;\n\n        var dispatchDataAvailableEvent = function dispatchDataAvailableEvent(arrayBuffers) {\n          eventTarget.dispatchEvent(createBlobEvent('dataavailable', {\n            data: new Blob(arrayBuffers, {\n              type: mimeType\n            })\n          }));\n        };\n\n        var requestNextPartialRecording = /*#__PURE__*/function () {\n          var _ref2 = _asyncToGenerator__default[\"default\"]( /*#__PURE__*/_regeneratorRuntime__default[\"default\"].mark(function _callee2(encoderId, timeslice) {\n            var arrayBuffers;\n            return _regeneratorRuntime__default[\"default\"].wrap(function _callee2$(_context2) {\n              while (1) {\n                switch (_context2.prev = _context2.next) {\n                  case 0:\n                    _context2.next = 2;\n                    return mediaEncoderHost.encode(encoderId, timeslice);\n\n                  case 2:\n                    arrayBuffers = _context2.sent;\n\n                    if (promisedAudioNodesAndEncoderId === null) {\n                      bufferedArrayBuffers.push.apply(bufferedArrayBuffers, _toConsumableArray__default[\"default\"](arrayBuffers));\n                    } else {\n                      dispatchDataAvailableEvent(arrayBuffers);\n                      promisedPartialRecording = requestNextPartialRecording(encoderId, timeslice);\n                    }\n\n                  case 4:\n                  case \"end\":\n                    return _context2.stop();\n                }\n              }\n            }, _callee2);\n          }));\n\n          return function requestNextPartialRecording(_x6, _x7) {\n            return _ref2.apply(this, arguments);\n          };\n        }();\n\n        var _resume = function resume() {\n          isAudioContextRunning = true;\n          return audioContext.resume();\n        };\n\n        var stop = function stop() {\n          if (promisedAudioNodesAndEncoderId === null) {\n            return;\n          }\n\n          if (abortRecording !== null) {\n            mediaStream.removeEventListener('addtrack', abortRecording);\n            mediaStream.removeEventListener('removetrack', abortRecording);\n          }\n\n          if (intervalId !== null) {\n            clearTimeout(intervalId);\n          }\n\n          promisedAudioNodesAndEncoderId.then( /*#__PURE__*/function () {\n            var _ref4 = _asyncToGenerator__default[\"default\"]( /*#__PURE__*/_regeneratorRuntime__default[\"default\"].mark(function _callee3(_ref3) {\n              var constantSourceNode, encoderId, mediaStreamAudioSourceNode, recorderAudioWorkletNode, arrayBuffers;\n              return _regeneratorRuntime__default[\"default\"].wrap(function _callee3$(_context3) {\n                while (1) {\n                  switch (_context3.prev = _context3.next) {\n                    case 0:\n                      constantSourceNode = _ref3.constantSourceNode, encoderId = _ref3.encoderId, mediaStreamAudioSourceNode = _ref3.mediaStreamAudioSourceNode, recorderAudioWorkletNode = _ref3.recorderAudioWorkletNode;\n\n                      if (promisedPartialRecording !== null) {\n                        promisedPartialRecording[\"catch\"](function () {\n                          /* @todo Only catch the errors caused by a duplicate call to encode. */\n                        });\n                        promisedPartialRecording = null;\n                      }\n\n                      _context3.next = 4;\n                      return recorderAudioWorkletNode.stop();\n\n                    case 4:\n                      mediaStreamAudioSourceNode.disconnect(recorderAudioWorkletNode);\n                      constantSourceNode.stop();\n                      _context3.next = 8;\n                      return mediaEncoderHost.encode(encoderId, null);\n\n                    case 8:\n                      arrayBuffers = _context3.sent;\n\n                      if (!(promisedAudioNodesAndEncoderId === null)) {\n                        _context3.next = 12;\n                        break;\n                      }\n\n                      _context3.next = 12;\n                      return suspend();\n\n                    case 12:\n                      dispatchDataAvailableEvent([].concat(bufferedArrayBuffers, _toConsumableArray__default[\"default\"](arrayBuffers)));\n                      bufferedArrayBuffers.length = 0;\n                      eventTarget.dispatchEvent(new Event('stop'));\n\n                    case 15:\n                    case \"end\":\n                      return _context3.stop();\n                  }\n                }\n              }, _callee3);\n            }));\n\n            return function (_x8) {\n              return _ref4.apply(this, arguments);\n            };\n          }());\n          promisedAudioNodesAndEncoderId = null;\n        };\n\n        var suspend = function suspend() {\n          isAudioContextRunning = false;\n          return audioContext.suspend();\n        };\n\n        suspend();\n        return {\n          get mimeType() {\n            return mimeType;\n          },\n\n          get state() {\n            return promisedAudioNodesAndEncoderId === null ? 'inactive' : isAudioContextRunning ? 'recording' : 'paused';\n          },\n\n          pause: function pause() {\n            if (promisedAudioNodesAndEncoderId === null) {\n              throw createInvalidStateError();\n            }\n\n            if (isAudioContextRunning) {\n              suspend();\n              eventTarget.dispatchEvent(new Event('pause'));\n            }\n          },\n          resume: function resume() {\n            if (promisedAudioNodesAndEncoderId === null) {\n              throw createInvalidStateError();\n            }\n\n            if (!isAudioContextRunning) {\n              _resume();\n\n              eventTarget.dispatchEvent(new Event('resume'));\n            }\n          },\n          start: function start(timeslice) {\n            var _a;\n\n            if (promisedAudioNodesAndEncoderId !== null) {\n              throw createInvalidStateError();\n            }\n\n            if (mediaStream.getVideoTracks().length > 0) {\n              throw createNotSupportedError();\n            }\n\n            eventTarget.dispatchEvent(new Event('start'));\n            var audioTracks = mediaStream.getAudioTracks(); // @todo TypeScript v4.4.2 removed the channelCount property from the MediaTrackSettings interface.\n\n            var channelCount = audioTracks.length === 0 ? 2 : (_a = audioTracks[0].getSettings().channelCount) !== null && _a !== void 0 ? _a : 2;\n            promisedAudioNodesAndEncoderId = Promise.all([_resume(), promisedAudioWorkletModule.then(function () {\n              return createPromisedAudioNodesEncoderIdAndPort(audioBuffer, audioContext, channelCount, mediaStream, mimeType);\n            })]).then( /*#__PURE__*/function () {\n              var _ref6 = _asyncToGenerator__default[\"default\"]( /*#__PURE__*/_regeneratorRuntime__default[\"default\"].mark(function _callee4(_ref5) {\n                var _ref7, _ref7$, audioBufferSourceNode, encoderId, mediaStreamAudioSourceNode, port, recorderAudioWorkletNode, constantSourceNode;\n\n                return _regeneratorRuntime__default[\"default\"].wrap(function _callee4$(_context4) {\n                  while (1) {\n                    switch (_context4.prev = _context4.next) {\n                      case 0:\n                        _ref7 = _slicedToArray__default[\"default\"](_ref5, 2), _ref7$ = _ref7[1], audioBufferSourceNode = _ref7$.audioBufferSourceNode, encoderId = _ref7$.encoderId, mediaStreamAudioSourceNode = _ref7$.mediaStreamAudioSourceNode, port = _ref7$.port, recorderAudioWorkletNode = _ref7$.recorderAudioWorkletNode;\n                        mediaStreamAudioSourceNode.connect(recorderAudioWorkletNode);\n                        _context4.next = 4;\n                        return new Promise(function (resolve) {\n                          audioBufferSourceNode.onended = resolve;\n                          audioBufferSourceNode.connect(recorderAudioWorkletNode);\n                          audioBufferSourceNode.start(audioContext.currentTime + length / audioContext.sampleRate);\n                        });\n\n                      case 4:\n                        audioBufferSourceNode.disconnect(recorderAudioWorkletNode); // Bug #17: Safari does throttle the processing on hidden tabs if there is no active audio output.\n\n                        constantSourceNode = new standardizedAudioContext.ConstantSourceNode(audioContext, {\n                          offset: 0\n                        });\n\n                        constantSourceNode.onended = function () {\n                          return constantSourceNode.disconnect();\n                        };\n\n                        constantSourceNode.connect(audioContext.destination);\n                        constantSourceNode.start();\n                        _context4.next = 11;\n                        return recorderAudioWorkletNode.record(port);\n\n                      case 11:\n                        if (timeslice !== undefined) {\n                          promisedPartialRecording = requestNextPartialRecording(encoderId, timeslice);\n                        }\n\n                        return _context4.abrupt(\"return\", {\n                          constantSourceNode: constantSourceNode,\n                          encoderId: encoderId,\n                          mediaStreamAudioSourceNode: mediaStreamAudioSourceNode,\n                          recorderAudioWorkletNode: recorderAudioWorkletNode\n                        });\n\n                      case 13:\n                      case \"end\":\n                        return _context4.stop();\n                    }\n                  }\n                }, _callee4);\n              }));\n\n              return function (_x9) {\n                return _ref6.apply(this, arguments);\n              };\n            }());\n            var tracks = mediaStream.getTracks();\n\n            abortRecording = function abortRecording() {\n              stop();\n              eventTarget.dispatchEvent(new ErrorEvent('error', {\n                error: createInvalidModificationError()\n              }));\n            };\n\n            mediaStream.addEventListener('addtrack', abortRecording);\n            mediaStream.addEventListener('removetrack', abortRecording);\n            intervalId = setInterval(function () {\n              var currentTracks = mediaStream.getTracks();\n\n              if ((currentTracks.length !== tracks.length || currentTracks.some(function (track, index) {\n                return track !== tracks[index];\n              })) && abortRecording !== null) {\n                abortRecording();\n              }\n            }, 1000);\n          },\n          stop: stop\n        };\n      };\n    };\n\n    var createWebmPcmMediaRecorderFactory = function createWebmPcmMediaRecorderFactory(createBlobEvent, createInvalidModificationError, createNotSupportedError, decodeWebMChunk, readVariableSizeInteger) {\n      return function (eventTarget, nativeMediaRecorderConstructor, mediaStream, mimeType) {\n        var audioTracks = mediaStream.getAudioTracks();\n        var bufferedArrayBuffers = []; // @todo TypeScript v4.4.2 removed the channelCount property from the MediaTrackSettings interface.\n\n        var channelCount = audioTracks.length === 0 ? undefined : audioTracks[0].getSettings().channelCount;\n        var nativeMediaRecorder = new nativeMediaRecorderConstructor(mediaStream, {\n          mimeType: 'audio/webm;codecs=pcm'\n        });\n        var sampleRate = audioTracks.length === 0 ? undefined : audioTracks[0].getSettings().sampleRate;\n        var promisedPartialRecording = null;\n\n        var stopRecording = function stopRecording() {}; // tslint:disable-line:no-empty\n\n\n        var dispatchDataAvailableEvent = function dispatchDataAvailableEvent(arrayBuffers) {\n          eventTarget.dispatchEvent(createBlobEvent('dataavailable', {\n            data: new Blob(arrayBuffers, {\n              type: mimeType\n            })\n          }));\n        };\n\n        var requestNextPartialRecording = /*#__PURE__*/function () {\n          var _ref = _asyncToGenerator__default[\"default\"]( /*#__PURE__*/_regeneratorRuntime__default[\"default\"].mark(function _callee(encoderId, timeslice) {\n            var arrayBuffers;\n            return _regeneratorRuntime__default[\"default\"].wrap(function _callee$(_context) {\n              while (1) {\n                switch (_context.prev = _context.next) {\n                  case 0:\n                    _context.next = 2;\n                    return mediaEncoderHost.encode(encoderId, timeslice);\n\n                  case 2:\n                    arrayBuffers = _context.sent;\n\n                    if (nativeMediaRecorder.state === 'inactive') {\n                      bufferedArrayBuffers.push.apply(bufferedArrayBuffers, _toConsumableArray__default[\"default\"](arrayBuffers));\n                    } else {\n                      dispatchDataAvailableEvent(arrayBuffers);\n                      promisedPartialRecording = requestNextPartialRecording(encoderId, timeslice);\n                    }\n\n                  case 4:\n                  case \"end\":\n                    return _context.stop();\n                }\n              }\n            }, _callee);\n          }));\n\n          return function requestNextPartialRecording(_x, _x2) {\n            return _ref.apply(this, arguments);\n          };\n        }();\n\n        var stop = function stop() {\n          if (nativeMediaRecorder.state === 'inactive') {\n            return;\n          }\n\n          if (promisedPartialRecording !== null) {\n            promisedPartialRecording[\"catch\"](function () {\n              /* @todo Only catch the errors caused by a duplicate call to encode. */\n            });\n            promisedPartialRecording = null;\n          }\n\n          stopRecording();\n\n          stopRecording = function stopRecording() {}; // tslint:disable-line:no-empty\n\n\n          nativeMediaRecorder.stop();\n        };\n\n        nativeMediaRecorder.addEventListener('error', function () {\n          stop(); // Bug #3 & #4: Chrome throws an error event without any error.\n\n          eventTarget.dispatchEvent(new ErrorEvent('error', {\n            error: createInvalidModificationError()\n          }));\n        });\n        nativeMediaRecorder.addEventListener('start', function () {\n          return eventTarget.dispatchEvent(new Event('start'));\n        });\n        return {\n          get mimeType() {\n            return mimeType;\n          },\n\n          get state() {\n            return nativeMediaRecorder.state;\n          },\n\n          pause: function pause() {\n            return nativeMediaRecorder.pause();\n          },\n          resume: function resume() {\n            return nativeMediaRecorder.resume();\n          },\n          start: function start(timeslice) {\n            /*\n             * Bug #6: Chrome will emit a blob without any data when asked to encode a MediaStream with a video track into an audio\n             * codec.\n             */\n            if (mediaStream.getVideoTracks().length > 0) {\n              throw createNotSupportedError();\n            }\n\n            if (nativeMediaRecorder.state === 'inactive') {\n              if (sampleRate === undefined) {\n                throw new Error('The sampleRate is not defined.');\n              }\n\n              var isRecording = false;\n              var isStopped = false; // Bug #9: Chrome sometimes fires more than one dataavailable event while being inactive.\n\n              var pendingInvocations = 0;\n              var promisedDataViewElementTypeEncoderIdAndPort = mediaEncoderHost.instantiate(mimeType, sampleRate);\n\n              stopRecording = function stopRecording() {\n                isStopped = true;\n              };\n\n              var removeEventListener = subscribableThings.on(nativeMediaRecorder, 'dataavailable')(function (_ref2) {\n                var data = _ref2.data;\n                pendingInvocations += 1;\n                promisedDataViewElementTypeEncoderIdAndPort = promisedDataViewElementTypeEncoderIdAndPort.then( /*#__PURE__*/function () {\n                  var _ref4 = _asyncToGenerator__default[\"default\"]( /*#__PURE__*/_regeneratorRuntime__default[\"default\"].mark(function _callee2(_ref3) {\n                    var _ref3$dataView, dataView, _ref3$elementType, elementType, encoderId, port, arrayBuffer, currentDataView, lengthAndValue, value, _decodeWebMChunk, currentElementType, offset, contents, remainingDataView;\n\n                    return _regeneratorRuntime__default[\"default\"].wrap(function _callee2$(_context2) {\n                      while (1) {\n                        switch (_context2.prev = _context2.next) {\n                          case 0:\n                            _ref3$dataView = _ref3.dataView, dataView = _ref3$dataView === void 0 ? null : _ref3$dataView, _ref3$elementType = _ref3.elementType, elementType = _ref3$elementType === void 0 ? null : _ref3$elementType, encoderId = _ref3.encoderId, port = _ref3.port;\n                            _context2.next = 3;\n                            return data.arrayBuffer();\n\n                          case 3:\n                            arrayBuffer = _context2.sent;\n                            pendingInvocations -= 1;\n                            currentDataView = dataView === null ? new multiBufferDataView.MultiBufferDataView([arrayBuffer]) : new multiBufferDataView.MultiBufferDataView([].concat(_toConsumableArray__default[\"default\"](dataView.buffers), [arrayBuffer]), dataView.byteOffset);\n\n                            if (!(!isRecording && nativeMediaRecorder.state === 'recording' && !isStopped)) {\n                              _context2.next = 14;\n                              break;\n                            }\n\n                            lengthAndValue = readVariableSizeInteger(currentDataView, 0);\n\n                            if (!(lengthAndValue === null)) {\n                              _context2.next = 10;\n                              break;\n                            }\n\n                            return _context2.abrupt(\"return\", {\n                              dataView: currentDataView,\n                              elementType: elementType,\n                              encoderId: encoderId,\n                              port: port\n                            });\n\n                          case 10:\n                            value = lengthAndValue.value;\n\n                            if (!(value !== 172351395)) {\n                              _context2.next = 13;\n                              break;\n                            }\n\n                            return _context2.abrupt(\"return\", {\n                              dataView: dataView,\n                              elementType: elementType,\n                              encoderId: encoderId,\n                              port: port\n                            });\n\n                          case 13:\n                            isRecording = true;\n\n                          case 14:\n                            _decodeWebMChunk = decodeWebMChunk(currentDataView, elementType, channelCount), currentElementType = _decodeWebMChunk.currentElementType, offset = _decodeWebMChunk.offset, contents = _decodeWebMChunk.contents;\n                            remainingDataView = offset < currentDataView.byteLength ? new multiBufferDataView.MultiBufferDataView(currentDataView.buffers, currentDataView.byteOffset + offset) : null;\n                            contents.forEach(function (content) {\n                              return port.postMessage(content, content.map(function (_ref5) {\n                                var buffer = _ref5.buffer;\n                                return buffer;\n                              }));\n                            });\n\n                            if (pendingInvocations === 0 && (nativeMediaRecorder.state === 'inactive' || isStopped)) {\n                              mediaEncoderHost.encode(encoderId, null).then(function (arrayBuffers) {\n                                dispatchDataAvailableEvent([].concat(bufferedArrayBuffers, _toConsumableArray__default[\"default\"](arrayBuffers)));\n                                bufferedArrayBuffers.length = 0;\n                                eventTarget.dispatchEvent(new Event('stop'));\n                              });\n                              port.postMessage([]);\n                              port.close();\n                              removeEventListener();\n                            }\n\n                            return _context2.abrupt(\"return\", {\n                              dataView: remainingDataView,\n                              elementType: currentElementType,\n                              encoderId: encoderId,\n                              port: port\n                            });\n\n                          case 19:\n                          case \"end\":\n                            return _context2.stop();\n                        }\n                      }\n                    }, _callee2);\n                  }));\n\n                  return function (_x3) {\n                    return _ref4.apply(this, arguments);\n                  };\n                }());\n              });\n\n              if (timeslice !== undefined) {\n                promisedDataViewElementTypeEncoderIdAndPort.then(function (_ref6) {\n                  var encoderId = _ref6.encoderId;\n                  return promisedPartialRecording = requestNextPartialRecording(encoderId, timeslice);\n                });\n              }\n            }\n\n            nativeMediaRecorder.start(100);\n          },\n          stop: stop\n        };\n      };\n    };\n\n    var createWindow = function createWindow() {\n      return typeof window === 'undefined' ? null : window;\n    };\n\n    var readVariableSizeIntegerLength = function readVariableSizeIntegerLength(dataView, offset) {\n      if (offset >= dataView.byteLength) {\n        return null;\n      }\n\n      var _byte = dataView.getUint8(offset);\n\n      if (_byte > 127) {\n        return 1;\n      }\n\n      if (_byte > 63) {\n        return 2;\n      }\n\n      if (_byte > 31) {\n        return 3;\n      }\n\n      if (_byte > 15) {\n        return 4;\n      }\n\n      if (_byte > 7) {\n        return 5;\n      }\n\n      if (_byte > 3) {\n        return 6;\n      }\n\n      if (_byte > 1) {\n        return 7;\n      }\n\n      if (_byte > 0) {\n        return 8;\n      }\n\n      var length = readVariableSizeIntegerLength(dataView, offset + 1);\n      return length === null ? null : length + 8;\n    };\n\n    var wrapEventListener = function wrapEventListener(target, eventListener) {\n      return function (event) {\n        var descriptor = {\n          value: target\n        };\n        Object.defineProperties(event, {\n          currentTarget: descriptor,\n          target: descriptor\n        });\n\n        if (typeof eventListener === 'function') {\n          return eventListener.call(target, event);\n        }\n\n        return eventListener.handleEvent.call(target, event);\n      };\n    };\n\n    var encoderRegexes = [];\n    var window$1 = createWindow();\n    var nativeBlobEventConstructor = createNativeBlobEventConstructor(window$1);\n    var createBlobEvent = createBlobEventFactory(nativeBlobEventConstructor);\n    var createWebAudioMediaRecorder = createWebAudioMediaRecorderFactory(createBlobEvent, createInvalidModificationError, createInvalidStateError, createNotSupportedError);\n    var readVariableSizeInteger = createReadVariableSizeInteger(readVariableSizeIntegerLength);\n    var readElementContent = createReadElementContent(readVariableSizeInteger);\n    var readElementType = createReadElementType(readVariableSizeInteger);\n    var decodeWebMChunk = createDecodeWebMChunk(readElementContent, readElementType);\n    var createWebmPcmMediaRecorder = createWebmPcmMediaRecorderFactory(createBlobEvent, createInvalidModificationError, createNotSupportedError, decodeWebMChunk, readVariableSizeInteger);\n    var createEventTarget = createEventTargetFactory(window$1);\n    var nativeMediaRecorderConstructor = createNativeMediaRecorderConstructor(window$1);\n    var createNativeMediaRecorder = createNativeMediaRecorderFactory(createInvalidModificationError, createNotSupportedError);\n    var mediaRecorderConstructor = createMediaRecorderConstructor(createNativeMediaRecorder, createNotSupportedError, createWebAudioMediaRecorder, createWebmPcmMediaRecorder, encoderRegexes, createEventTargetConstructor(createEventTarget, wrapEventListener), nativeMediaRecorderConstructor);\n    var isSupported = function isSupported() {\n      return createIsSupportedPromise(window$1);\n    };\n    var register = /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator__default[\"default\"]( /*#__PURE__*/_regeneratorRuntime__default[\"default\"].mark(function _callee(port) {\n        return _regeneratorRuntime__default[\"default\"].wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.t0 = encoderRegexes;\n                _context.next = 3;\n                return mediaEncoderHost.register(port);\n\n              case 3:\n                _context.t1 = _context.sent;\n\n                _context.t0.push.call(_context.t0, _context.t1);\n\n              case 5:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n\n      return function register(_x) {\n        return _ref.apply(this, arguments);\n      };\n    }();\n\n    exports.MediaRecorder = mediaRecorderConstructor;\n    exports.isSupported = isSupported;\n    exports.register = register;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXh0ZW5kYWJsZS1tZWRpYS1yZWNvcmRlci9idWlsZC9lczUvYnVuZGxlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsSUFBSSxLQUE0RCxvQkFBb0IsbUJBQU8sQ0FBQyxnSEFBeUMsR0FBRyxtQkFBTyxDQUFDLDRGQUE0QixHQUFHLG1CQUFPLENBQUMsdUZBQW9CLEdBQUcsbUJBQU8sQ0FBQyw4SEFBZ0QsR0FBRyxtQkFBTyxDQUFDLDRHQUF1QyxHQUFHLG1CQUFPLENBQUMsc0dBQW9DLEdBQUcsbUJBQU8sQ0FBQywwSEFBOEMsR0FBRyxtQkFBTyxDQUFDLGdHQUFpQyxHQUFHLG1CQUFPLENBQUMsa0lBQWtELEdBQUcsbUJBQU8sQ0FBQyw0R0FBdUMsR0FBRyxtQkFBTyxDQUFDLDBHQUFzQyxHQUFHLG1CQUFPLENBQUMsa0hBQTBDLEdBQUcsbUJBQU8sQ0FBQywrRkFBd0IsR0FBRyxtQkFBTyxDQUFDLHVHQUE0QixHQUFHLG1CQUFPLENBQUMsZ0dBQXdCLEdBQUcsbUJBQU8sQ0FBQyx5RkFBcUI7QUFDOXlCLElBQUksQ0FDd2lCO0FBQzVpQixDQUFDLDhWQUE4Vjs7QUFFL1YseUNBQXlDLDREQUE0RDs7QUFFckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTs7O0FBR1osZ0VBQWdFOztBQUVoRTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixZQUFZO0FBQ1o7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBLHFDQUFxQyw2REFBNkQseUNBQXlDLGtFQUFrRSxpQ0FBaUMsdUVBQXVFLDJEQUEyRCxPQUFPLHlDQUF5Qzs7QUFFaGEsMkNBQTJDLHdFQUF3RSwwQ0FBMEMsOENBQThDLE1BQU0sNEVBQTRFLElBQUksZUFBZSxZQUFZOztBQUU1VDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsV0FBVztBQUNYLHVDQUF1Qzs7QUFFdkMsc0xBQXNMO0FBQ3RMO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCLHlCQUF5QjtBQUN6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7O0FBRUE7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLElBQUk7QUFDekIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixvQkFBb0I7QUFDcEI7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXOztBQUVYLDBCQUEwQixxQkFBcUI7QUFDL0M7O0FBRUEsNEJBQTRCLGtCQUFrQjtBQUM5QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0RBQStEOztBQUUvRCx3QkFBd0IsWUFBWTtBQUNwQyw2RUFBNkU7QUFDN0U7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdHQUF3Rzs7QUFFeEc7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0REFBNEQ7O0FBRTVEO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7O0FBRXpCO0FBQ0Esb0ZBQW9GOztBQUVwRjtBQUNBO0FBQ0EseUJBQXlCOztBQUV6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qjs7QUFFekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixlQUFlOztBQUVmO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qzs7QUFFdkM7QUFDQTtBQUNBLGdDQUFnQztBQUNoQyxTQUFTO0FBQ1Q7QUFDQTs7QUFFQSx5REFBeUQ7OztBQUd6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7O0FBRUEsdURBQXVEOzs7QUFHdkQ7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjs7QUFFbEI7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUNBQXFDOztBQUVyQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qjs7QUFFN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCOztBQUU3QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CLDZCQUE2Qjs7QUFFN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCOztBQUU3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLG1CQUFtQjs7QUFFbkI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGVBQWU7O0FBRWY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBLG1EQUFtRCxhQUFhOztBQUVoRSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLy4vbm9kZV9tb2R1bGVzL2V4dGVuZGFibGUtbWVkaWEtcmVjb3JkZXIvYnVpbGQvZXM1L2J1bmRsZS5qcz9lZTkwIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzLCByZXF1aXJlKCdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2FzeW5jVG9HZW5lcmF0b3InKSwgcmVxdWlyZSgnQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3InKSwgcmVxdWlyZSgnbWVkaWEtZW5jb2Rlci1ob3N0JyksIHJlcXVpcmUoJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvb2JqZWN0V2l0aG91dFByb3BlcnRpZXMnKSwgcmVxdWlyZSgnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVjaycpLCByZXF1aXJlKCdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzJyksIHJlcXVpcmUoJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXNzZXJ0VGhpc0luaXRpYWxpemVkJyksIHJlcXVpcmUoJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHMnKSwgcmVxdWlyZSgnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuJyksIHJlcXVpcmUoJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZ2V0UHJvdG90eXBlT2YnKSwgcmVxdWlyZSgnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9zbGljZWRUb0FycmF5JyksIHJlcXVpcmUoJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvdG9Db25zdW1hYmxlQXJyYXknKSwgcmVxdWlyZSgncmVjb3JkZXItYXVkaW8td29ya2xldCcpLCByZXF1aXJlKCdzdGFuZGFyZGl6ZWQtYXVkaW8tY29udGV4dCcpLCByZXF1aXJlKCdtdWx0aS1idWZmZXItZGF0YS12aWV3JyksIHJlcXVpcmUoJ3N1YnNjcmliYWJsZS10aGluZ3MnKSkgOlxuICAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnLCAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3luY1RvR2VuZXJhdG9yJywgJ0BiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yJywgJ21lZGlhLWVuY29kZXItaG9zdCcsICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzJywgJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2snLCAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzcycsICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2Fzc2VydFRoaXNJbml0aWFsaXplZCcsICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2luaGVyaXRzJywgJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVybicsICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2dldFByb3RvdHlwZU9mJywgJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvc2xpY2VkVG9BcnJheScsICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL3RvQ29uc3VtYWJsZUFycmF5JywgJ3JlY29yZGVyLWF1ZGlvLXdvcmtsZXQnLCAnc3RhbmRhcmRpemVkLWF1ZGlvLWNvbnRleHQnLCAnbXVsdGktYnVmZmVyLWRhdGEtdmlldycsICdzdWJzY3JpYmFibGUtdGhpbmdzJ10sIGZhY3RvcnkpIDpcbiAgICAoZ2xvYmFsID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcyA6IGdsb2JhbCB8fCBzZWxmLCBmYWN0b3J5KGdsb2JhbC5leHRlbmRhYmxlTWVkaWFSZWNvcmRlciA9IHt9LCBnbG9iYWwuX2FzeW5jVG9HZW5lcmF0b3IsIGdsb2JhbC5fcmVnZW5lcmF0b3JSdW50aW1lLCBnbG9iYWwubWVkaWFFbmNvZGVySG9zdCwgZ2xvYmFsLl9vYmplY3RXaXRob3V0UHJvcGVydGllcywgZ2xvYmFsLl9jbGFzc0NhbGxDaGVjaywgZ2xvYmFsLl9jcmVhdGVDbGFzcywgZ2xvYmFsLl9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQsIGdsb2JhbC5faW5oZXJpdHMsIGdsb2JhbC5fcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiwgZ2xvYmFsLl9nZXRQcm90b3R5cGVPZiwgZ2xvYmFsLl9zbGljZWRUb0FycmF5LCBnbG9iYWwuX3RvQ29uc3VtYWJsZUFycmF5LCBnbG9iYWwucmVjb3JkZXJBdWRpb1dvcmtsZXQsIGdsb2JhbC5zdGFuZGFyZGl6ZWRBdWRpb0NvbnRleHQsIGdsb2JhbC5tdWx0aUJ1ZmZlckRhdGFWaWV3LCBnbG9iYWwuc3Vic2NyaWJhYmxlVGhpbmdzKSk7XG59KSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMsIF9hc3luY1RvR2VuZXJhdG9yLCBfcmVnZW5lcmF0b3JSdW50aW1lLCBtZWRpYUVuY29kZXJIb3N0LCBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMsIF9jbGFzc0NhbGxDaGVjaywgX2NyZWF0ZUNsYXNzLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkLCBfaW5oZXJpdHMsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuLCBfZ2V0UHJvdG90eXBlT2YsIF9zbGljZWRUb0FycmF5LCBfdG9Db25zdW1hYmxlQXJyYXksIHJlY29yZGVyQXVkaW9Xb3JrbGV0LCBzdGFuZGFyZGl6ZWRBdWRpb0NvbnRleHQsIG11bHRpQnVmZmVyRGF0YVZpZXcsIHN1YnNjcmliYWJsZVRoaW5ncykgeyAndXNlIHN0cmljdCc7XG5cbiAgICBmdW5jdGlvbiBfaW50ZXJvcERlZmF1bHRMZWdhY3kgKGUpIHsgcmV0dXJuIGUgJiYgdHlwZW9mIGUgPT09ICdvYmplY3QnICYmICdkZWZhdWx0JyBpbiBlID8gZSA6IHsgJ2RlZmF1bHQnOiBlIH07IH1cblxuICAgIHZhciBfYXN5bmNUb0dlbmVyYXRvcl9fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9faW50ZXJvcERlZmF1bHRMZWdhY3koX2FzeW5jVG9HZW5lcmF0b3IpO1xuICAgIHZhciBfcmVnZW5lcmF0b3JSdW50aW1lX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19pbnRlcm9wRGVmYXVsdExlZ2FjeShfcmVnZW5lcmF0b3JSdW50aW1lKTtcbiAgICB2YXIgX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19pbnRlcm9wRGVmYXVsdExlZ2FjeShfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMpO1xuICAgIHZhciBfY2xhc3NDYWxsQ2hlY2tfX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BEZWZhdWx0TGVnYWN5KF9jbGFzc0NhbGxDaGVjayk7XG4gICAgdmFyIF9jcmVhdGVDbGFzc19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9faW50ZXJvcERlZmF1bHRMZWdhY3koX2NyZWF0ZUNsYXNzKTtcbiAgICB2YXIgX2Fzc2VydFRoaXNJbml0aWFsaXplZF9fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9faW50ZXJvcERlZmF1bHRMZWdhY3koX2Fzc2VydFRoaXNJbml0aWFsaXplZCk7XG4gICAgdmFyIF9pbmhlcml0c19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9faW50ZXJvcERlZmF1bHRMZWdhY3koX2luaGVyaXRzKTtcbiAgICB2YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm5fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BEZWZhdWx0TGVnYWN5KF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKTtcbiAgICB2YXIgX2dldFByb3RvdHlwZU9mX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19pbnRlcm9wRGVmYXVsdExlZ2FjeShfZ2V0UHJvdG90eXBlT2YpO1xuICAgIHZhciBfc2xpY2VkVG9BcnJheV9fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9faW50ZXJvcERlZmF1bHRMZWdhY3koX3NsaWNlZFRvQXJyYXkpO1xuICAgIHZhciBfdG9Db25zdW1hYmxlQXJyYXlfX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BEZWZhdWx0TGVnYWN5KF90b0NvbnN1bWFibGVBcnJheSk7XG5cbiAgICB2YXIgX2V4Y2x1ZGVkID0gW1wiZGF0YVwiXTtcbiAgICB2YXIgY3JlYXRlQmxvYkV2ZW50RmFjdG9yeSA9IGZ1bmN0aW9uIGNyZWF0ZUJsb2JFdmVudEZhY3RvcnkobmF0aXZlQmxvYkV2ZW50Q29uc3RydWN0b3IpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAodHlwZSwgYmxvYkV2ZW50SW5pdCkge1xuICAgICAgICAvLyBCdWcgIzE0OiBTYWZhcmkgZG9lcyBub3QgeWV0IHN1cHBvcnQgdGhlIEJsb2JFdmVudC5cbiAgICAgICAgaWYgKG5hdGl2ZUJsb2JFdmVudENvbnN0cnVjdG9yID09PSBudWxsKSB7XG4gICAgICAgICAgdmFyIGRhdGEgPSBibG9iRXZlbnRJbml0LmRhdGEsXG4gICAgICAgICAgICAgIGV2ZW50SW5pdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc19fZGVmYXVsdFtcImRlZmF1bHRcIl0oYmxvYkV2ZW50SW5pdCwgX2V4Y2x1ZGVkKTtcblxuICAgICAgICAgIHZhciBmYWtlQmxvYkV2ZW50ID0gbmV3IEV2ZW50KHR5cGUsIGV2ZW50SW5pdCk7XG4gICAgICAgICAgZmFrZUJsb2JFdmVudC5kYXRhID0gZGF0YTtcbiAgICAgICAgICByZXR1cm4gZmFrZUJsb2JFdmVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgbmF0aXZlQmxvYkV2ZW50Q29uc3RydWN0b3IodHlwZSwgYmxvYkV2ZW50SW5pdCk7XG4gICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlRGVjb2RlV2ViTUNodW5rID0gZnVuY3Rpb24gY3JlYXRlRGVjb2RlV2ViTUNodW5rKHJlYWRFbGVtZW50Q29udGVudCwgcmVhZEVsZW1lbnRUeXBlKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGRhdGFWaWV3LCBlbGVtZW50VHlwZSwgY2hhbm5lbENvdW50KSB7XG4gICAgICAgIHZhciBjb250ZW50cyA9IFtdO1xuICAgICAgICB2YXIgY3VycmVudEVsZW1lbnRUeXBlID0gZWxlbWVudFR5cGU7XG4gICAgICAgIHZhciBvZmZzZXQgPSAwO1xuXG4gICAgICAgIHdoaWxlIChvZmZzZXQgPCBkYXRhVmlldy5ieXRlTGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKGN1cnJlbnRFbGVtZW50VHlwZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGxlbmd0aEFuZFR5cGUgPSByZWFkRWxlbWVudFR5cGUoZGF0YVZpZXcsIG9mZnNldCk7XG5cbiAgICAgICAgICAgIGlmIChsZW5ndGhBbmRUeXBlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbGVuZ3RoID0gbGVuZ3RoQW5kVHlwZS5sZW5ndGgsXG4gICAgICAgICAgICAgICAgdHlwZSA9IGxlbmd0aEFuZFR5cGUudHlwZTtcbiAgICAgICAgICAgIGN1cnJlbnRFbGVtZW50VHlwZSA9IHR5cGU7XG4gICAgICAgICAgICBvZmZzZXQgKz0gbGVuZ3RoO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgY29udGVudEFuZExlbmd0aCA9IHJlYWRFbGVtZW50Q29udGVudChkYXRhVmlldywgb2Zmc2V0LCBjdXJyZW50RWxlbWVudFR5cGUsIGNoYW5uZWxDb3VudCk7XG5cbiAgICAgICAgICAgIGlmIChjb250ZW50QW5kTGVuZ3RoID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgY29udGVudCA9IGNvbnRlbnRBbmRMZW5ndGguY29udGVudCxcbiAgICAgICAgICAgICAgICBfbGVuZ3RoID0gY29udGVudEFuZExlbmd0aC5sZW5ndGg7XG4gICAgICAgICAgICBjdXJyZW50RWxlbWVudFR5cGUgPSBudWxsO1xuICAgICAgICAgICAgb2Zmc2V0ICs9IF9sZW5ndGg7XG5cbiAgICAgICAgICAgIGlmIChjb250ZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIGNvbnRlbnRzLnB1c2goY29udGVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBjb250ZW50czogY29udGVudHMsXG4gICAgICAgICAgY3VycmVudEVsZW1lbnRUeXBlOiBjdXJyZW50RWxlbWVudFR5cGUsXG4gICAgICAgICAgb2Zmc2V0OiBvZmZzZXRcbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVFdmVudFRhcmdldENvbnN0cnVjdG9yID0gZnVuY3Rpb24gY3JlYXRlRXZlbnRUYXJnZXRDb25zdHJ1Y3RvcihjcmVhdGVFdmVudFRhcmdldCwgd3JhcEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBFdmVudFRhcmdldCgpIHtcbiAgICAgICAgICB2YXIgbmF0aXZlRXZlbnRUYXJnZXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IG51bGw7XG5cbiAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2tfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHRoaXMsIEV2ZW50VGFyZ2V0KTtcblxuICAgICAgICAgIHRoaXMuX2xpc3RlbmVycyA9IG5ldyBXZWFrTWFwKCk7XG4gICAgICAgICAgdGhpcy5fbmF0aXZlRXZlbnRUYXJnZXQgPSBuYXRpdmVFdmVudFRhcmdldCA9PT0gbnVsbCA/IGNyZWF0ZUV2ZW50VGFyZ2V0KCkgOiBuYXRpdmVFdmVudFRhcmdldDtcbiAgICAgICAgfVxuXG4gICAgICAgIF9jcmVhdGVDbGFzc19fZGVmYXVsdFtcImRlZmF1bHRcIl0oRXZlbnRUYXJnZXQsIFt7XG4gICAgICAgICAga2V5OiBcImFkZEV2ZW50TGlzdGVuZXJcIixcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgb3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKGxpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHZhciB3cmFwcGVkRXZlbnRMaXN0ZW5lciA9IHRoaXMuX2xpc3RlbmVycy5nZXQobGlzdGVuZXIpO1xuXG4gICAgICAgICAgICAgIGlmICh3cmFwcGVkRXZlbnRMaXN0ZW5lciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgd3JhcHBlZEV2ZW50TGlzdGVuZXIgPSB3cmFwRXZlbnRMaXN0ZW5lcih0aGlzLCBsaXN0ZW5lcik7XG5cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9saXN0ZW5lcnMuc2V0KGxpc3RlbmVyLCB3cmFwcGVkRXZlbnRMaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdGhpcy5fbmF0aXZlRXZlbnRUYXJnZXQuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCB3cmFwcGVkRXZlbnRMaXN0ZW5lciwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcImRpc3BhdGNoRXZlbnRcIixcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZGlzcGF0Y2hFdmVudChldmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25hdGl2ZUV2ZW50VGFyZ2V0LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIGtleTogXCJyZW1vdmVFdmVudExpc3RlbmVyXCIsXG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciB3cmFwcGVkRXZlbnRMaXN0ZW5lciA9IGxpc3RlbmVyID09PSBudWxsID8gdW5kZWZpbmVkIDogdGhpcy5fbGlzdGVuZXJzLmdldChsaXN0ZW5lcik7XG5cbiAgICAgICAgICAgIHRoaXMuX25hdGl2ZUV2ZW50VGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgd3JhcHBlZEV2ZW50TGlzdGVuZXIgPT09IHVuZGVmaW5lZCA/IG51bGwgOiB3cmFwcGVkRXZlbnRMaXN0ZW5lciwgb3B0aW9ucyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XSk7XG5cbiAgICAgICAgcmV0dXJuIEV2ZW50VGFyZ2V0O1xuICAgICAgfSgpO1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlRXZlbnRUYXJnZXRGYWN0b3J5ID0gZnVuY3Rpb24gY3JlYXRlRXZlbnRUYXJnZXRGYWN0b3J5KHdpbmRvdykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHdpbmRvdyA9PT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQSBuYXRpdmUgRXZlbnRUYXJnZXQgY291bGQgbm90IGJlIGNyZWF0ZWQuJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3AnKTtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVJbnZhbGlkTW9kaWZpY2F0aW9uRXJyb3IgPSBmdW5jdGlvbiBjcmVhdGVJbnZhbGlkTW9kaWZpY2F0aW9uRXJyb3IoKSB7XG4gICAgICB2YXIgbWVzc2FnZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogJyc7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBuZXcgRE9NRXhjZXB0aW9uKG1lc3NhZ2UsICdJbnZhbGlkTW9kaWZpY2F0aW9uRXJyb3InKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAvLyBAdG9kbyBFZGdlIGlzIHRoZSBvbmx5IGJyb3dzZXIgdGhhdCBkb2VzIG5vdCB5ZXQgYWxsb3cgdG8gY29uc3RydWN0IGEgRE9NRXhjZXB0aW9uLlxuICAgICAgICBlcnIuY29kZSA9IDEzO1xuICAgICAgICBlcnIubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgIGVyci5uYW1lID0gJ0ludmFsaWRNb2RpZmljYXRpb25FcnJvcic7XG4gICAgICAgIHJldHVybiBlcnI7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVJbnZhbGlkU3RhdGVFcnJvciA9IGZ1bmN0aW9uIGNyZWF0ZUludmFsaWRTdGF0ZUVycm9yKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG5ldyBET01FeGNlcHRpb24oJycsICdJbnZhbGlkU3RhdGVFcnJvcicpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIC8vIEJ1ZyAjMTIyOiBFZGdlIGlzIHRoZSBvbmx5IGJyb3dzZXIgdGhhdCBkb2VzIG5vdCB5ZXQgYWxsb3cgdG8gY29uc3RydWN0IGEgRE9NRXhjZXB0aW9uLlxuICAgICAgICBlcnIuY29kZSA9IDExO1xuICAgICAgICBlcnIubmFtZSA9ICdJbnZhbGlkU3RhdGVFcnJvcic7XG4gICAgICAgIHJldHVybiBlcnI7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVJc1N1cHBvcnRlZFByb21pc2UgPSBmdW5jdGlvbiBjcmVhdGVJc1N1cHBvcnRlZFByb21pc2Uod2luZG93KSB7XG4gICAgICBpZiAod2luZG93ICE9PSBudWxsICYmIHdpbmRvdy5NZWRpYVN0cmVhbSAhPT0gdW5kZWZpbmVkICYmIChcbiAgICAgIC8qXG4gICAgICAgKiBCdWcgIzEwOiBBbiBlYXJseSBleHBlcmltZW50YWwgaW1wbGVtZW5hdGlvbiBpbiBTYWZhcmkgZGlkIG5vdCBwcm92aWRlIHRoZSBpc1R5cGVTdXBwb3J0ZWQoKSBmdW5jdGlvbi5cbiAgICAgICAqL1xuICAgICAgd2luZG93Lk1lZGlhUmVjb3JkZXIgPT09IHVuZGVmaW5lZCB8fCB3aW5kb3cuTWVkaWFSZWNvcmRlci5pc1R5cGVTdXBwb3J0ZWQgIT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgLypcbiAgICAgICAgICogQnVnICM1OiBVcCB1bnRpbCB2NzAgRmlyZWZveCBkaWQgZW1pdCBhIGJsb2Igb2YgdHlwZSB2aWRlby93ZWJtIHdoZW4gYXNrZWQgdG8gZW5jb2RlIGEgTWVkaWFTdHJlYW0gd2l0aCBhIHZpZGVvIHRyYWNrIGludG8gYW5cbiAgICAgICAgICogYXVkaW8gY29kZWMuXG4gICAgICAgICAqL1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICAvLyBCdWcgIzExIFNhZmFyaSBkb2VzIG5vdCB5ZXQgc3VwcG9ydCB0aGUgTWVkaWFSZWNvcmRlciBidXQgdGhhdCBpc24ndCB0ZXN0ZWQgaGVyZS5cbiAgICAgICAgICBpZiAod2luZG93Lk1lZGlhUmVjb3JkZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUodHJ1ZSk7XG4gICAgICAgICAgfSAvLyBAdG9kbyBjYXB0dXJlU3RyZWFtKCkgaXMgbm90IGRlZmluZWQgeWV0LlxuXG5cbiAgICAgICAgICB2YXIgY2FudmFzRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpOyAvLyBAdG9kbyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xMzg4OTc0XG5cbiAgICAgICAgICBjYW52YXNFbGVtZW50LmdldENvbnRleHQoJzJkJyk7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIGNhbnZhc0VsZW1lbnQuY2FwdHVyZVN0cmVhbSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoZmFsc2UpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBtZWRpYVN0cmVhbSA9IGNhbnZhc0VsZW1lbnQuY2FwdHVyZVN0cmVhbSgpO1xuICAgICAgICAgIHZhciBtaW1lVHlwZSA9ICdhdWRpby93ZWJtJztcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgbWVkaWFSZWNvcmRlciA9IG5ldyB3aW5kb3cuTWVkaWFSZWNvcmRlcihtZWRpYVN0cmVhbSwge1xuICAgICAgICAgICAgICBtaW1lVHlwZTogbWltZVR5cGVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbWVkaWFSZWNvcmRlci5hZGRFdmVudExpc3RlbmVyKCdkYXRhYXZhaWxhYmxlJywgZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgICAgICAgICAgdmFyIGRhdGEgPSBfcmVmLmRhdGE7XG4gICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKGRhdGEudHlwZSA9PT0gbWltZVR5cGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBtZWRpYVJlY29yZGVyLnN0YXJ0KCk7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG1lZGlhUmVjb3JkZXIuc3RvcCgpO1xuICAgICAgICAgICAgfSwgMTApO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgcmVzb2x2ZShlcnIubmFtZSA9PT0gJ05vdFN1cHBvcnRlZEVycm9yJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShmYWxzZSk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZl9fZGVmYXVsdFtcImRlZmF1bHRcIl0oRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZl9fZGVmYXVsdFtcImRlZmF1bHRcIl0odGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0aGlzLCByZXN1bHQpOyB9OyB9XG5cbiAgICBmdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuICAgIHZhciBjcmVhdGVNZWRpYVJlY29yZGVyQ29uc3RydWN0b3IgPSBmdW5jdGlvbiBjcmVhdGVNZWRpYVJlY29yZGVyQ29uc3RydWN0b3IoY3JlYXRlTmF0aXZlTWVkaWFSZWNvcmRlciwgY3JlYXRlTm90U3VwcG9ydGVkRXJyb3IsIGNyZWF0ZVdlYkF1ZGlvTWVkaWFSZWNvcmRlciwgY3JlYXRlV2VibVBjbU1lZGlhUmVjb3JkZXIsIGVuY29kZXJSZWdleGVzLCBldmVudFRhcmdldENvbnN0cnVjdG9yLCBuYXRpdmVNZWRpYVJlY29yZGVyQ29uc3RydWN0b3IpIHtcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9ldmVudFRhcmdldENvbnN0cnVjdCkge1xuICAgICAgICBfaW5oZXJpdHNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKE1lZGlhUmVjb3JkZXIsIF9ldmVudFRhcmdldENvbnN0cnVjdCk7XG5cbiAgICAgICAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihNZWRpYVJlY29yZGVyKTtcblxuICAgICAgICBmdW5jdGlvbiBNZWRpYVJlY29yZGVyKHN0cmVhbSkge1xuICAgICAgICAgIHZhciBfdGhpcztcblxuICAgICAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgICAgICAgIF9jbGFzc0NhbGxDaGVja19fZGVmYXVsdFtcImRlZmF1bHRcIl0odGhpcywgTWVkaWFSZWNvcmRlcik7XG5cbiAgICAgICAgICB2YXIgbWltZVR5cGUgPSBvcHRpb25zLm1pbWVUeXBlO1xuXG4gICAgICAgICAgaWYgKG5hdGl2ZU1lZGlhUmVjb3JkZXJDb25zdHJ1Y3RvciAhPT0gbnVsbCAmJiAoIC8vIEJ1ZyAjMTA6IFNhZmFyaSBkb2VzIG5vdCB5ZXQgaW1wbGVtZW50IHRoZSBpc1R5cGVTdXBwb3J0ZWQoKSBtZXRob2QuXG4gICAgICAgICAgbWltZVR5cGUgPT09IHVuZGVmaW5lZCB8fCBuYXRpdmVNZWRpYVJlY29yZGVyQ29uc3RydWN0b3IuaXNUeXBlU3VwcG9ydGVkICE9PSB1bmRlZmluZWQgJiYgbmF0aXZlTWVkaWFSZWNvcmRlckNvbnN0cnVjdG9yLmlzVHlwZVN1cHBvcnRlZChtaW1lVHlwZSkpKSB7XG4gICAgICAgICAgICB2YXIgaW50ZXJuYWxNZWRpYVJlY29yZGVyID0gY3JlYXRlTmF0aXZlTWVkaWFSZWNvcmRlcihuYXRpdmVNZWRpYVJlY29yZGVyQ29uc3RydWN0b3IsIHN0cmVhbSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGludGVybmFsTWVkaWFSZWNvcmRlcik7XG4gICAgICAgICAgICBfdGhpcy5faW50ZXJuYWxNZWRpYVJlY29yZGVyID0gaW50ZXJuYWxNZWRpYVJlY29yZGVyO1xuICAgICAgICAgIH0gZWxzZSBpZiAobWltZVR5cGUgIT09IHVuZGVmaW5lZCAmJiBlbmNvZGVyUmVnZXhlcy5zb21lKGZ1bmN0aW9uIChyZWdleCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlZ2V4LnRlc3QobWltZVR5cGUpO1xuICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpOyAvLyBCdWcgIzEwOiBTYWZhcmkgZG9lcyBub3QgeWV0IGltcGxlbWVudCB0aGUgaXNUeXBlU3VwcG9ydGVkKCkgbWV0aG9kLlxuXG4gICAgICAgICAgICBpZiAobmF0aXZlTWVkaWFSZWNvcmRlckNvbnN0cnVjdG9yICE9PSBudWxsICYmIG5hdGl2ZU1lZGlhUmVjb3JkZXJDb25zdHJ1Y3Rvci5pc1R5cGVTdXBwb3J0ZWQgIT09IHVuZGVmaW5lZCAmJiBuYXRpdmVNZWRpYVJlY29yZGVyQ29uc3RydWN0b3IuaXNUeXBlU3VwcG9ydGVkKCdhdWRpby93ZWJtO2NvZGVjcz1wY20nKSkge1xuICAgICAgICAgICAgICBfdGhpcy5faW50ZXJuYWxNZWRpYVJlY29yZGVyID0gY3JlYXRlV2VibVBjbU1lZGlhUmVjb3JkZXIoX2Fzc2VydFRoaXNJbml0aWFsaXplZF9fZGVmYXVsdFtcImRlZmF1bHRcIl0oX3RoaXMpLCBuYXRpdmVNZWRpYVJlY29yZGVyQ29uc3RydWN0b3IsIHN0cmVhbSwgbWltZVR5cGUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgX3RoaXMuX2ludGVybmFsTWVkaWFSZWNvcmRlciA9IGNyZWF0ZVdlYkF1ZGlvTWVkaWFSZWNvcmRlcihfYXNzZXJ0VGhpc0luaXRpYWxpemVkX19kZWZhdWx0W1wiZGVmYXVsdFwiXShfdGhpcyksIHN0cmVhbSwgbWltZVR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIGNyZWF0aW5nIGEgbmF0aXZlIE1lZGlhUmVjb3JkZXIganVzdCB0byBwcm92b2tlIGl0IHRvIHRocm93IGFuIGVycm9yLlxuICAgICAgICAgICAgaWYgKG5hdGl2ZU1lZGlhUmVjb3JkZXJDb25zdHJ1Y3RvciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICBjcmVhdGVOYXRpdmVNZWRpYVJlY29yZGVyKG5hdGl2ZU1lZGlhUmVjb3JkZXJDb25zdHJ1Y3Rvciwgc3RyZWFtLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhyb3cgY3JlYXRlTm90U3VwcG9ydGVkRXJyb3IoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBfdGhpcy5fb25kYXRhYXZhaWxhYmxlID0gbnVsbDtcbiAgICAgICAgICBfdGhpcy5fb25lcnJvciA9IG51bGw7XG4gICAgICAgICAgX3RoaXMuX29ucGF1c2UgPSBudWxsO1xuICAgICAgICAgIF90aGlzLl9vbnJlc3VtZSA9IG51bGw7XG4gICAgICAgICAgX3RoaXMuX29uc3RhcnQgPSBudWxsO1xuICAgICAgICAgIF90aGlzLl9vbnN0b3AgPSBudWxsO1xuICAgICAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybl9fZGVmYXVsdFtcImRlZmF1bHRcIl0oX3RoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgX2NyZWF0ZUNsYXNzX19kZWZhdWx0W1wiZGVmYXVsdFwiXShNZWRpYVJlY29yZGVyLCBbe1xuICAgICAgICAgIGtleTogXCJtaW1lVHlwZVwiLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ludGVybmFsTWVkaWFSZWNvcmRlci5taW1lVHlwZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBrZXk6IFwib25kYXRhYXZhaWxhYmxlXCIsXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fb25kYXRhYXZhaWxhYmxlID09PSBudWxsID8gdGhpcy5fb25kYXRhYXZhaWxhYmxlIDogdGhpcy5fb25kYXRhYXZhaWxhYmxlWzBdO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9vbmRhdGFhdmFpbGFibGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdkYXRhYXZhaWxhYmxlJywgdGhpcy5fb25kYXRhYXZhaWxhYmxlWzFdKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICB2YXIgYm91bmRMaXN0ZW5lciA9IHZhbHVlLmJpbmQodGhpcyk7XG4gICAgICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignZGF0YWF2YWlsYWJsZScsIGJvdW5kTGlzdGVuZXIpO1xuICAgICAgICAgICAgICB0aGlzLl9vbmRhdGFhdmFpbGFibGUgPSBbdmFsdWUsIGJvdW5kTGlzdGVuZXJdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5fb25kYXRhYXZhaWxhYmxlID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBrZXk6IFwib25lcnJvclwiLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX29uZXJyb3IgPT09IG51bGwgPyB0aGlzLl9vbmVycm9yIDogdGhpcy5fb25lcnJvclswXTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fb25lcnJvciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgdGhpcy5fb25lcnJvclsxXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgdmFyIGJvdW5kTGlzdGVuZXIgPSB2YWx1ZS5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgYm91bmRMaXN0ZW5lcik7XG4gICAgICAgICAgICAgIHRoaXMuX29uZXJyb3IgPSBbdmFsdWUsIGJvdW5kTGlzdGVuZXJdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5fb25lcnJvciA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcIm9ucGF1c2VcIixcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9vbnBhdXNlID09PSBudWxsID8gdGhpcy5fb25wYXVzZSA6IHRoaXMuX29ucGF1c2VbMF07XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX29ucGF1c2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdwYXVzZScsIHRoaXMuX29ucGF1c2VbMV0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIHZhciBib3VuZExpc3RlbmVyID0gdmFsdWUuYmluZCh0aGlzKTtcbiAgICAgICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdwYXVzZScsIGJvdW5kTGlzdGVuZXIpO1xuICAgICAgICAgICAgICB0aGlzLl9vbnBhdXNlID0gW3ZhbHVlLCBib3VuZExpc3RlbmVyXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuX29ucGF1c2UgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIGtleTogXCJvbnJlc3VtZVwiLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX29ucmVzdW1lID09PSBudWxsID8gdGhpcy5fb25yZXN1bWUgOiB0aGlzLl9vbnJlc3VtZVswXTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fb25yZXN1bWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXN1bWUnLCB0aGlzLl9vbnJlc3VtZVsxXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgdmFyIGJvdW5kTGlzdGVuZXIgPSB2YWx1ZS5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc3VtZScsIGJvdW5kTGlzdGVuZXIpO1xuICAgICAgICAgICAgICB0aGlzLl9vbnJlc3VtZSA9IFt2YWx1ZSwgYm91bmRMaXN0ZW5lcl07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLl9vbnJlc3VtZSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcIm9uc3RhcnRcIixcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9vbnN0YXJ0ID09PSBudWxsID8gdGhpcy5fb25zdGFydCA6IHRoaXMuX29uc3RhcnRbMF07XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX29uc3RhcnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdzdGFydCcsIHRoaXMuX29uc3RhcnRbMV0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIHZhciBib3VuZExpc3RlbmVyID0gdmFsdWUuYmluZCh0aGlzKTtcbiAgICAgICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdzdGFydCcsIGJvdW5kTGlzdGVuZXIpO1xuICAgICAgICAgICAgICB0aGlzLl9vbnN0YXJ0ID0gW3ZhbHVlLCBib3VuZExpc3RlbmVyXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuX29uc3RhcnQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIGtleTogXCJvbnN0b3BcIixcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9vbnN0b3AgPT09IG51bGwgPyB0aGlzLl9vbnN0b3AgOiB0aGlzLl9vbnN0b3BbMF07XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX29uc3RvcCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3N0b3AnLCB0aGlzLl9vbnN0b3BbMV0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIHZhciBib3VuZExpc3RlbmVyID0gdmFsdWUuYmluZCh0aGlzKTtcbiAgICAgICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdzdG9wJywgYm91bmRMaXN0ZW5lcik7XG4gICAgICAgICAgICAgIHRoaXMuX29uc3RvcCA9IFt2YWx1ZSwgYm91bmRMaXN0ZW5lcl07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLl9vbnN0b3AgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIGtleTogXCJzdGF0ZVwiLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ludGVybmFsTWVkaWFSZWNvcmRlci5zdGF0ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBrZXk6IFwicGF1c2VcIixcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcGF1c2UoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faW50ZXJuYWxNZWRpYVJlY29yZGVyLnBhdXNlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcInJlc3VtZVwiLFxuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZXN1bWUoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faW50ZXJuYWxNZWRpYVJlY29yZGVyLnJlc3VtZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIGtleTogXCJzdGFydFwiLFxuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzdGFydCh0aW1lc2xpY2UpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pbnRlcm5hbE1lZGlhUmVjb3JkZXIuc3RhcnQodGltZXNsaWNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBrZXk6IFwic3RvcFwiLFxuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzdG9wKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ludGVybmFsTWVkaWFSZWNvcmRlci5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XSwgW3tcbiAgICAgICAgICBrZXk6IFwiaXNUeXBlU3VwcG9ydGVkXCIsXG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGlzVHlwZVN1cHBvcnRlZChtaW1lVHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5hdGl2ZU1lZGlhUmVjb3JkZXJDb25zdHJ1Y3RvciAhPT0gbnVsbCAmJiAvLyBCdWcgIzEwOiBTYWZhcmkgZG9lcyBub3QgeWV0IGltcGxlbWVudCB0aGUgaXNUeXBlU3VwcG9ydGVkKCkgbWV0aG9kLlxuICAgICAgICAgICAgbmF0aXZlTWVkaWFSZWNvcmRlckNvbnN0cnVjdG9yLmlzVHlwZVN1cHBvcnRlZCAhPT0gdW5kZWZpbmVkICYmIG5hdGl2ZU1lZGlhUmVjb3JkZXJDb25zdHJ1Y3Rvci5pc1R5cGVTdXBwb3J0ZWQobWltZVR5cGUpIHx8IGVuY29kZXJSZWdleGVzLnNvbWUoZnVuY3Rpb24gKHJlZ2V4KSB7XG4gICAgICAgICAgICAgIHJldHVybiByZWdleC50ZXN0KG1pbWVUeXBlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfV0pO1xuXG4gICAgICAgIHJldHVybiBNZWRpYVJlY29yZGVyO1xuICAgICAgfShldmVudFRhcmdldENvbnN0cnVjdG9yKTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZU5hdGl2ZUJsb2JFdmVudENvbnN0cnVjdG9yID0gZnVuY3Rpb24gY3JlYXRlTmF0aXZlQmxvYkV2ZW50Q29uc3RydWN0b3Iod2luZG93KSB7XG4gICAgICBpZiAod2luZG93ICE9PSBudWxsICYmIHdpbmRvdy5CbG9iRXZlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gd2luZG93LkJsb2JFdmVudDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVOYXRpdmVNZWRpYVJlY29yZGVyRmFjdG9yeSA9IGZ1bmN0aW9uIGNyZWF0ZU5hdGl2ZU1lZGlhUmVjb3JkZXJGYWN0b3J5KGNyZWF0ZUludmFsaWRNb2RpZmljYXRpb25FcnJvciwgY3JlYXRlTm90U3VwcG9ydGVkRXJyb3IpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAobmF0aXZlTWVkaWFSZWNvcmRlckNvbnN0cnVjdG9yLCBzdHJlYW0sIG1lZGlhUmVjb3JkZXJPcHRpb25zKSB7XG4gICAgICAgIHZhciBidWZmZXJlZEJsb2JzID0gW107XG4gICAgICAgIHZhciBkYXRhQXZhaWxhYmxlTGlzdGVuZXJzID0gbmV3IFdlYWtNYXAoKTtcbiAgICAgICAgdmFyIGVycm9yTGlzdGVuZXJzID0gbmV3IFdlYWtNYXAoKTtcbiAgICAgICAgdmFyIG5hdGl2ZU1lZGlhUmVjb3JkZXIgPSBuZXcgbmF0aXZlTWVkaWFSZWNvcmRlckNvbnN0cnVjdG9yKHN0cmVhbSwgbWVkaWFSZWNvcmRlck9wdGlvbnMpO1xuICAgICAgICB2YXIgc3RvcExpc3RlbmVycyA9IG5ldyBXZWFrTWFwKCk7XG4gICAgICAgIHZhciBpc0FjdGl2ZSA9IHRydWU7XG5cbiAgICAgICAgbmF0aXZlTWVkaWFSZWNvcmRlci5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKGFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHR5cGUsIGxpc3RlbmVyLCBvcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgcGF0Y2hlZEV2ZW50TGlzdGVuZXIgPSBsaXN0ZW5lcjtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gJ2RhdGFhdmFpbGFibGUnKSB7XG4gICAgICAgICAgICAgICAgLy8gQnVnICM3ICYgIzg6IENocm9tZSBmaXJlcyB0aGUgZGF0YWF2YWlsYWJsZSBhbmQgc3RvcCBldmVudHMgYmVmb3JlIGl0IGZpcmVzIHRoZSBlcnJvciBldmVudC5cbiAgICAgICAgICAgICAgICBwYXRjaGVkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIHBhdGNoZWRFdmVudExpc3RlbmVyKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzQWN0aXZlICYmIG5hdGl2ZU1lZGlhUmVjb3JkZXIuc3RhdGUgPT09ICdpbmFjdGl2ZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICBidWZmZXJlZEJsb2JzLnB1c2goZXZlbnQuZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGJ1ZmZlcmVkQmxvYnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJsb2IgPSBldmVudC5kYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV2ZW50LCAnZGF0YScsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG5ldyBCbG9iKFtdLmNvbmNhdChidWZmZXJlZEJsb2JzLCBbYmxvYl0pLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogYmxvYi50eXBlXG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlcmVkQmxvYnMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lci5jYWxsKG5hdGl2ZU1lZGlhUmVjb3JkZXIsIGV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGRhdGFBdmFpbGFibGVMaXN0ZW5lcnMuc2V0KGxpc3RlbmVyLCBwYXRjaGVkRXZlbnRMaXN0ZW5lcik7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2Vycm9yJykge1xuICAgICAgICAgICAgICAgIC8vIEJ1ZyAjMTIgJiAjMTM6IEZpcmVmb3ggZmlyZXMgYSByZWd1bGFyIGV2ZW50IHdpdGggYW4gZXJyb3IgcHJvcGVydHkuXG4gICAgICAgICAgICAgICAgcGF0Y2hlZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiBwYXRjaGVkRXZlbnRMaXN0ZW5lcihldmVudCkge1xuICAgICAgICAgICAgICAgICAgLy8gQnVnICMzICYgIzQ6IENocm9tZSB0aHJvd3MgYW4gZXJyb3IgZXZlbnQgd2l0aG91dCBhbnkgZXJyb3IuXG4gICAgICAgICAgICAgICAgICBpZiAoZXZlbnQuZXJyb3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lci5jYWxsKG5hdGl2ZU1lZGlhUmVjb3JkZXIsIG5ldyBFcnJvckV2ZW50KCdlcnJvcicsIHtcbiAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogY3JlYXRlSW52YWxpZE1vZGlmaWNhdGlvbkVycm9yKClcbiAgICAgICAgICAgICAgICAgICAgfSkpOyAvLyBCdWcgIzEgJiAjMjogRmlyZWZveCB0aHJvd3MgYW4gZXJyb3IgZXZlbnQgd2l0aCBhbiBVbmtub3duRXJyb3IuXG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGV2ZW50LmVycm9yLm5hbWUgPT09ICdVbmtub3duRXJyb3InKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlID0gZXZlbnQuZXJyb3IubWVzc2FnZTtcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXIuY2FsbChuYXRpdmVNZWRpYVJlY29yZGVyLCBuZXcgRXJyb3JFdmVudCgnZXJyb3InLCB7XG4gICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGNyZWF0ZUludmFsaWRNb2RpZmljYXRpb25FcnJvcihtZXNzYWdlKVxuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGV2ZW50IGluc3RhbmNlb2YgRXJyb3JFdmVudCkge1xuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lci5jYWxsKG5hdGl2ZU1lZGlhUmVjb3JkZXIsIGV2ZW50KTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyLmNhbGwobmF0aXZlTWVkaWFSZWNvcmRlciwgbmV3IEVycm9yRXZlbnQoJ2Vycm9yJywge1xuICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBldmVudC5lcnJvclxuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGVycm9yTGlzdGVuZXJzLnNldChsaXN0ZW5lciwgcGF0Y2hlZEV2ZW50TGlzdGVuZXIpO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdzdG9wJykge1xuICAgICAgICAgICAgICAgIC8vIEJ1ZyAjNyAmICM4OiBDaHJvbWUgZmlyZXMgdGhlIGRhdGFhdmFpbGFibGUgYW5kIHN0b3AgZXZlbnRzIGJlZm9yZSBpdCBmaXJlcyB0aGUgZXJyb3IgZXZlbnQuXG4gICAgICAgICAgICAgICAgcGF0Y2hlZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiBwYXRjaGVkRXZlbnRMaXN0ZW5lcihldmVudCkge1xuICAgICAgICAgICAgICAgICAgaXNBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGlzdGVuZXIuY2FsbChuYXRpdmVNZWRpYVJlY29yZGVyLCBldmVudCk7XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgc3RvcExpc3RlbmVycy5zZXQobGlzdGVuZXIsIHBhdGNoZWRFdmVudExpc3RlbmVyKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gYWRkRXZlbnRMaXN0ZW5lci5jYWxsKG5hdGl2ZU1lZGlhUmVjb3JkZXIsIHR5cGUsIHBhdGNoZWRFdmVudExpc3RlbmVyLCBvcHRpb25zKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9KG5hdGl2ZU1lZGlhUmVjb3JkZXIuYWRkRXZlbnRMaXN0ZW5lcik7XG5cbiAgICAgICAgbmF0aXZlTWVkaWFSZWNvcmRlci5kaXNwYXRjaEV2ZW50ID0gZnVuY3Rpb24gKGRpc3BhdGNoRXZlbnQpIHtcbiAgICAgICAgICAvLyBCdWcgIzcgJiAjODogQ2hyb21lIGZpcmVzIHRoZSBkYXRhYXZhaWxhYmxlIGFuZCBzdG9wIGV2ZW50cyBiZWZvcmUgaXQgZmlyZXMgdGhlIGVycm9yIGV2ZW50LlxuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciB3YXNBY3RpdmU7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgd2FzQWN0aXZlID0gaXNBY3RpdmU7XG4gICAgICAgICAgICAgIGlzQWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciByZXR1cm5WYWx1ZSA9IGRpc3BhdGNoRXZlbnQuY2FsbChuYXRpdmVNZWRpYVJlY29yZGVyLCBldmVudCk7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGlzQWN0aXZlID0gd2FzQWN0aXZlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gICAgICAgICAgfTtcbiAgICAgICAgfShuYXRpdmVNZWRpYVJlY29yZGVyLmRpc3BhdGNoRXZlbnQpO1xuXG4gICAgICAgIG5hdGl2ZU1lZGlhUmVjb3JkZXIucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIChyZW1vdmVFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh0eXBlLCBsaXN0ZW5lciwgb3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIHBhdGNoZWRFdmVudExpc3RlbmVyID0gbGlzdGVuZXI7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdkYXRhYXZhaWxhYmxlJykge1xuICAgICAgICAgICAgICAgIHZhciBkYXRhQXZhaWxhYmxlTGlzdGVuZXIgPSBkYXRhQXZhaWxhYmxlTGlzdGVuZXJzLmdldChsaXN0ZW5lcik7XG5cbiAgICAgICAgICAgICAgICBpZiAoZGF0YUF2YWlsYWJsZUxpc3RlbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgIHBhdGNoZWRFdmVudExpc3RlbmVyID0gZGF0YUF2YWlsYWJsZUxpc3RlbmVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnZXJyb3InKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVycm9yTGlzdGVuZXIgPSBlcnJvckxpc3RlbmVycy5nZXQobGlzdGVuZXIpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGVycm9yTGlzdGVuZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgcGF0Y2hlZEV2ZW50TGlzdGVuZXIgPSBlcnJvckxpc3RlbmVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnc3RvcCcpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RvcExpc3RlbmVyID0gc3RvcExpc3RlbmVycy5nZXQobGlzdGVuZXIpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHN0b3BMaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICBwYXRjaGVkRXZlbnRMaXN0ZW5lciA9IHN0b3BMaXN0ZW5lcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJlbW92ZUV2ZW50TGlzdGVuZXIuY2FsbChuYXRpdmVNZWRpYVJlY29yZGVyLCB0eXBlLCBwYXRjaGVkRXZlbnRMaXN0ZW5lciwgb3B0aW9ucyk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfShuYXRpdmVNZWRpYVJlY29yZGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIpO1xuXG4gICAgICAgIG5hdGl2ZU1lZGlhUmVjb3JkZXIuc3RhcnQgPSBmdW5jdGlvbiAoc3RhcnQpIHtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHRpbWVzbGljZSkge1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIEJ1ZyAjNjogQ2hyb21lIHdpbGwgZW1pdCBhIGJsb2Igd2l0aG91dCBhbnkgZGF0YSB3aGVuIGFza2VkIHRvIGVuY29kZSBhIE1lZGlhU3RyZWFtIHdpdGggYSB2aWRlbyB0cmFjayBpbnRvIGFuIGF1ZGlvXG4gICAgICAgICAgICAgKiBjb2RlYy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKG1lZGlhUmVjb3JkZXJPcHRpb25zLm1pbWVUeXBlICE9PSB1bmRlZmluZWQgJiYgbWVkaWFSZWNvcmRlck9wdGlvbnMubWltZVR5cGUuc3RhcnRzV2l0aCgnYXVkaW8vJykgJiYgc3RyZWFtLmdldFZpZGVvVHJhY2tzKCkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICB0aHJvdyBjcmVhdGVOb3RTdXBwb3J0ZWRFcnJvcigpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpc0FjdGl2ZSA9IHRpbWVzbGljZSAhPT0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgcmV0dXJuIHRpbWVzbGljZSA9PT0gdW5kZWZpbmVkID8gc3RhcnQuY2FsbChuYXRpdmVNZWRpYVJlY29yZGVyKSA6IHN0YXJ0LmNhbGwobmF0aXZlTWVkaWFSZWNvcmRlciwgdGltZXNsaWNlKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9KG5hdGl2ZU1lZGlhUmVjb3JkZXIuc3RhcnQpO1xuXG4gICAgICAgIHJldHVybiBuYXRpdmVNZWRpYVJlY29yZGVyO1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZU5hdGl2ZU1lZGlhUmVjb3JkZXJDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uIGNyZWF0ZU5hdGl2ZU1lZGlhUmVjb3JkZXJDb25zdHJ1Y3Rvcih3aW5kb3cpIHtcbiAgICAgIGlmICh3aW5kb3cgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB3aW5kb3cuTWVkaWFSZWNvcmRlciA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IHdpbmRvdy5NZWRpYVJlY29yZGVyO1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlTm90U3VwcG9ydGVkRXJyb3IgPSBmdW5jdGlvbiBjcmVhdGVOb3RTdXBwb3J0ZWRFcnJvcigpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBuZXcgRE9NRXhjZXB0aW9uKCcnLCAnTm90U3VwcG9ydGVkRXJyb3InKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAvLyBAdG9kbyBFZGdlIGlzIHRoZSBvbmx5IGJyb3dzZXIgdGhhdCBkb2VzIG5vdCB5ZXQgYWxsb3cgdG8gY29uc3RydWN0IGEgRE9NRXhjZXB0aW9uLlxuICAgICAgICBlcnIuY29kZSA9IDk7XG4gICAgICAgIGVyci5uYW1lID0gJ05vdFN1cHBvcnRlZEVycm9yJztcbiAgICAgICAgcmV0dXJuIGVycjtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZVJlYWRFbGVtZW50Q29udGVudCA9IGZ1bmN0aW9uIGNyZWF0ZVJlYWRFbGVtZW50Q29udGVudChyZWFkVmFyaWFibGVTaXplSW50ZWdlcikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkYXRhVmlldywgb2Zmc2V0LCB0eXBlKSB7XG4gICAgICAgIHZhciBjaGFubmVsQ291bnQgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IDI7XG4gICAgICAgIHZhciBsZW5ndGhBbmRWYWx1ZSA9IHJlYWRWYXJpYWJsZVNpemVJbnRlZ2VyKGRhdGFWaWV3LCBvZmZzZXQpO1xuXG4gICAgICAgIGlmIChsZW5ndGhBbmRWYWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBsZW5ndGhBbmRWYWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsZW5ndGggPSBsZW5ndGhBbmRWYWx1ZS5sZW5ndGgsXG4gICAgICAgICAgICB2YWx1ZSA9IGxlbmd0aEFuZFZhbHVlLnZhbHVlO1xuXG4gICAgICAgIGlmICh0eXBlID09PSAnbWFzdGVyJykge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb250ZW50OiBudWxsLFxuICAgICAgICAgICAgbGVuZ3RoOiBsZW5ndGhcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9mZnNldCArIGxlbmd0aCArIHZhbHVlID4gZGF0YVZpZXcuYnl0ZUxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGUgPT09ICdiaW5hcnknKSB7XG4gICAgICAgICAgdmFyIG51bWJlck9mU2FtcGxlcyA9ICh2YWx1ZSAvIEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCAtIDEpIC8gY2hhbm5lbENvdW50O1xuICAgICAgICAgIHZhciBjb250ZW50ID0gQXJyYXkuZnJvbSh7XG4gICAgICAgICAgICBsZW5ndGg6IGNoYW5uZWxDb3VudFxuICAgICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KG51bWJlck9mU2FtcGxlcyk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bWJlck9mU2FtcGxlczsgaSArPSAxKSB7XG4gICAgICAgICAgICB2YXIgZWxlbWVudE9mZnNldCA9IGkgKiBjaGFubmVsQ291bnQgKyAxO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNoYW5uZWxDb3VudDsgaiArPSAxKSB7XG4gICAgICAgICAgICAgIGNvbnRlbnRbal1baV0gPSBkYXRhVmlldy5nZXRGbG9hdDMyKG9mZnNldCArIGxlbmd0aCArIChlbGVtZW50T2Zmc2V0ICsgaikgKiBGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb250ZW50OiBjb250ZW50LFxuICAgICAgICAgICAgbGVuZ3RoOiBsZW5ndGggKyB2YWx1ZVxuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGNvbnRlbnQ6IG51bGwsXG4gICAgICAgICAgbGVuZ3RoOiBsZW5ndGggKyB2YWx1ZVxuICAgICAgICB9O1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZVJlYWRFbGVtZW50VHlwZSA9IGZ1bmN0aW9uIGNyZWF0ZVJlYWRFbGVtZW50VHlwZShyZWFkVmFyaWFibGVTaXplSW50ZWdlcikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkYXRhVmlldywgb2Zmc2V0KSB7XG4gICAgICAgIHZhciBsZW5ndGhBbmRWYWx1ZSA9IHJlYWRWYXJpYWJsZVNpemVJbnRlZ2VyKGRhdGFWaWV3LCBvZmZzZXQpO1xuXG4gICAgICAgIGlmIChsZW5ndGhBbmRWYWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBsZW5ndGhBbmRWYWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsZW5ndGggPSBsZW5ndGhBbmRWYWx1ZS5sZW5ndGgsXG4gICAgICAgICAgICB2YWx1ZSA9IGxlbmd0aEFuZFZhbHVlLnZhbHVlO1xuXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gMzUpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGVuZ3RoOiBsZW5ndGgsXG4gICAgICAgICAgICB0eXBlOiAnYmluYXJ5J1xuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWUgPT09IDQ2IHx8IHZhbHVlID09PSA5NyB8fCB2YWx1ZSA9PT0gODg3MTM1NzQgfHwgdmFsdWUgPT09IDEwNjIxMjk3MSB8fCB2YWx1ZSA9PT0gMTM5NjkwMDg3IHx8IHZhbHVlID09PSAxNzIzNTEzOTUgfHwgdmFsdWUgPT09IDI1NjA5NTg2MSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsZW5ndGg6IGxlbmd0aCxcbiAgICAgICAgICAgIHR5cGU6ICdtYXN0ZXInXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbGVuZ3RoOiBsZW5ndGgsXG4gICAgICAgICAgdHlwZTogJ3Vua25vd24nXG4gICAgICAgIH07XG4gICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlUmVhZFZhcmlhYmxlU2l6ZUludGVnZXIgPSBmdW5jdGlvbiBjcmVhdGVSZWFkVmFyaWFibGVTaXplSW50ZWdlcihyZWFkVmFyaWFibGVTaXplSW50ZWdlckxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkYXRhVmlldywgb2Zmc2V0KSB7XG4gICAgICAgIHZhciBsZW5ndGggPSByZWFkVmFyaWFibGVTaXplSW50ZWdlckxlbmd0aChkYXRhVmlldywgb2Zmc2V0KTtcblxuICAgICAgICBpZiAobGVuZ3RoID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBmaXJzdERhdGFCeXRlT2Zmc2V0ID0gb2Zmc2V0ICsgTWF0aC5mbG9vcigobGVuZ3RoIC0gMSkgLyA4KTtcblxuICAgICAgICBpZiAoZmlyc3REYXRhQnl0ZU9mZnNldCArIGxlbmd0aCA+IGRhdGFWaWV3LmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBmaXJzdERhdGFCeXRlID0gZGF0YVZpZXcuZ2V0VWludDgoZmlyc3REYXRhQnl0ZU9mZnNldCk7XG4gICAgICAgIHZhciB2YWx1ZSA9IGZpcnN0RGF0YUJ5dGUgJiAoMSA8PCA4IC0gbGVuZ3RoICUgOCkgLSAxOyAvLyB0c2xpbnQ6ZGlzYWJsZS1saW5lOm5vLWJpdHdpc2VcblxuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgdmFsdWUgPSAodmFsdWUgPDwgOCkgKyBkYXRhVmlldy5nZXRVaW50OChmaXJzdERhdGFCeXRlT2Zmc2V0ICsgaSk7IC8vIHRzbGludDpkaXNhYmxlLWxpbmU6bm8tYml0d2lzZVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBsZW5ndGg6IGxlbmd0aCxcbiAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBFUlJPUl9NRVNTQUdFID0gJ01pc3NpbmcgQXVkaW9Xb3JrbGV0IHN1cHBvcnQuIE1heWJlIHRoaXMgaXMgbm90IHJ1bm5pbmcgaW4gYSBzZWN1cmUgY29udGV4dC4nOyAvLyBAdG9kbyBUaGlzIHNob3VsZCBsaXZlIGluIGEgc2VwYXJhdGUgZmlsZS5cblxuICAgIHZhciBjcmVhdGVQcm9taXNlZEF1ZGlvTm9kZXNFbmNvZGVySWRBbmRQb3J0ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfcmVmID0gX2FzeW5jVG9HZW5lcmF0b3JfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZV9fZGVmYXVsdFtcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlKGF1ZGlvQnVmZmVyLCBhdWRpb0NvbnRleHQsIGNoYW5uZWxDb3VudCwgbWVkaWFTdHJlYW0sIG1pbWVUeXBlKSB7XG4gICAgICAgIHZhciBfeWllbGQkaW5zdGFudGlhdGUsIGVuY29kZXJJZCwgcG9ydCwgYXVkaW9CdWZmZXJTb3VyY2VOb2RlLCBtZWRpYVN0cmVhbUF1ZGlvU291cmNlTm9kZSwgcmVjb3JkZXJBdWRpb1dvcmtsZXROb2RlO1xuXG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lX19kZWZhdWx0W1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAyO1xuICAgICAgICAgICAgICAgIHJldHVybiBtZWRpYUVuY29kZXJIb3N0Lmluc3RhbnRpYXRlKG1pbWVUeXBlLCBhdWRpb0NvbnRleHQuc2FtcGxlUmF0ZSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIF95aWVsZCRpbnN0YW50aWF0ZSA9IF9jb250ZXh0LnNlbnQ7XG4gICAgICAgICAgICAgICAgZW5jb2RlcklkID0gX3lpZWxkJGluc3RhbnRpYXRlLmVuY29kZXJJZDtcbiAgICAgICAgICAgICAgICBwb3J0ID0gX3lpZWxkJGluc3RhbnRpYXRlLnBvcnQ7XG5cbiAgICAgICAgICAgICAgICBpZiAoIShzdGFuZGFyZGl6ZWRBdWRpb0NvbnRleHQuQXVkaW9Xb3JrbGV0Tm9kZSA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDc7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoRVJST1JfTUVTU0FHRSk7XG5cbiAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgIGF1ZGlvQnVmZmVyU291cmNlTm9kZSA9IG5ldyBzdGFuZGFyZGl6ZWRBdWRpb0NvbnRleHQuQXVkaW9CdWZmZXJTb3VyY2VOb2RlKGF1ZGlvQ29udGV4dCwge1xuICAgICAgICAgICAgICAgICAgYnVmZmVyOiBhdWRpb0J1ZmZlclxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIG1lZGlhU3RyZWFtQXVkaW9Tb3VyY2VOb2RlID0gbmV3IHN0YW5kYXJkaXplZEF1ZGlvQ29udGV4dC5NZWRpYVN0cmVhbUF1ZGlvU291cmNlTm9kZShhdWRpb0NvbnRleHQsIHtcbiAgICAgICAgICAgICAgICAgIG1lZGlhU3RyZWFtOiBtZWRpYVN0cmVhbVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJlY29yZGVyQXVkaW9Xb3JrbGV0Tm9kZSA9IHJlY29yZGVyQXVkaW9Xb3JrbGV0LmNyZWF0ZVJlY29yZGVyQXVkaW9Xb3JrbGV0Tm9kZShzdGFuZGFyZGl6ZWRBdWRpb0NvbnRleHQuQXVkaW9Xb3JrbGV0Tm9kZSwgYXVkaW9Db250ZXh0LCB7XG4gICAgICAgICAgICAgICAgICBjaGFubmVsQ291bnQ6IGNoYW5uZWxDb3VudFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwge1xuICAgICAgICAgICAgICAgICAgYXVkaW9CdWZmZXJTb3VyY2VOb2RlOiBhdWRpb0J1ZmZlclNvdXJjZU5vZGUsXG4gICAgICAgICAgICAgICAgICBlbmNvZGVySWQ6IGVuY29kZXJJZCxcbiAgICAgICAgICAgICAgICAgIG1lZGlhU3RyZWFtQXVkaW9Tb3VyY2VOb2RlOiBtZWRpYVN0cmVhbUF1ZGlvU291cmNlTm9kZSxcbiAgICAgICAgICAgICAgICAgIHBvcnQ6IHBvcnQsXG4gICAgICAgICAgICAgICAgICByZWNvcmRlckF1ZGlvV29ya2xldE5vZGU6IHJlY29yZGVyQXVkaW9Xb3JrbGV0Tm9kZVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZSk7XG4gICAgICB9KSk7XG5cbiAgICAgIHJldHVybiBmdW5jdGlvbiBjcmVhdGVQcm9taXNlZEF1ZGlvTm9kZXNFbmNvZGVySWRBbmRQb3J0KF94LCBfeDIsIF94MywgX3g0LCBfeDUpIHtcbiAgICAgICAgcmV0dXJuIF9yZWYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gICAgfSgpO1xuXG4gICAgdmFyIGNyZWF0ZVdlYkF1ZGlvTWVkaWFSZWNvcmRlckZhY3RvcnkgPSBmdW5jdGlvbiBjcmVhdGVXZWJBdWRpb01lZGlhUmVjb3JkZXJGYWN0b3J5KGNyZWF0ZUJsb2JFdmVudCwgY3JlYXRlSW52YWxpZE1vZGlmaWNhdGlvbkVycm9yLCBjcmVhdGVJbnZhbGlkU3RhdGVFcnJvciwgY3JlYXRlTm90U3VwcG9ydGVkRXJyb3IpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoZXZlbnRUYXJnZXQsIG1lZGlhU3RyZWFtLCBtaW1lVHlwZSkge1xuICAgICAgICB2YXIgX2E7XG5cbiAgICAgICAgdmFyIHNhbXBsZVJhdGUgPSAoX2EgPSBtZWRpYVN0cmVhbS5nZXRBdWRpb1RyYWNrcygpWzBdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0U2V0dGluZ3MoKS5zYW1wbGVSYXRlO1xuICAgICAgICB2YXIgYXVkaW9Db250ZXh0ID0gbmV3IHN0YW5kYXJkaXplZEF1ZGlvQ29udGV4dC5NaW5pbWFsQXVkaW9Db250ZXh0KHtcbiAgICAgICAgICBsYXRlbmN5SGludDogJ3BsYXliYWNrJyxcbiAgICAgICAgICBzYW1wbGVSYXRlOiBzYW1wbGVSYXRlXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgbGVuZ3RoID0gTWF0aC5tYXgoMTAyNCwgTWF0aC5jZWlsKGF1ZGlvQ29udGV4dC5iYXNlTGF0ZW5jeSAqIGF1ZGlvQ29udGV4dC5zYW1wbGVSYXRlKSk7XG4gICAgICAgIHZhciBhdWRpb0J1ZmZlciA9IG5ldyBzdGFuZGFyZGl6ZWRBdWRpb0NvbnRleHQuQXVkaW9CdWZmZXIoe1xuICAgICAgICAgIGxlbmd0aDogbGVuZ3RoLFxuICAgICAgICAgIHNhbXBsZVJhdGU6IGF1ZGlvQ29udGV4dC5zYW1wbGVSYXRlXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgYnVmZmVyZWRBcnJheUJ1ZmZlcnMgPSBbXTtcbiAgICAgICAgdmFyIHByb21pc2VkQXVkaW9Xb3JrbGV0TW9kdWxlID0gcmVjb3JkZXJBdWRpb1dvcmtsZXQuYWRkUmVjb3JkZXJBdWRpb1dvcmtsZXRNb2R1bGUoZnVuY3Rpb24gKHVybCkge1xuICAgICAgICAgIGlmIChzdGFuZGFyZGl6ZWRBdWRpb0NvbnRleHQuYWRkQXVkaW9Xb3JrbGV0TW9kdWxlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihFUlJPUl9NRVNTQUdFKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gc3RhbmRhcmRpemVkQXVkaW9Db250ZXh0LmFkZEF1ZGlvV29ya2xldE1vZHVsZShhdWRpb0NvbnRleHQsIHVybCk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgYWJvcnRSZWNvcmRpbmcgPSBudWxsO1xuICAgICAgICB2YXIgaW50ZXJ2YWxJZCA9IG51bGw7XG4gICAgICAgIHZhciBwcm9taXNlZEF1ZGlvTm9kZXNBbmRFbmNvZGVySWQgPSBudWxsO1xuICAgICAgICB2YXIgcHJvbWlzZWRQYXJ0aWFsUmVjb3JkaW5nID0gbnVsbDtcbiAgICAgICAgdmFyIGlzQXVkaW9Db250ZXh0UnVubmluZyA9IHRydWU7XG5cbiAgICAgICAgdmFyIGRpc3BhdGNoRGF0YUF2YWlsYWJsZUV2ZW50ID0gZnVuY3Rpb24gZGlzcGF0Y2hEYXRhQXZhaWxhYmxlRXZlbnQoYXJyYXlCdWZmZXJzKSB7XG4gICAgICAgICAgZXZlbnRUYXJnZXQuZGlzcGF0Y2hFdmVudChjcmVhdGVCbG9iRXZlbnQoJ2RhdGFhdmFpbGFibGUnLCB7XG4gICAgICAgICAgICBkYXRhOiBuZXcgQmxvYihhcnJheUJ1ZmZlcnMsIHtcbiAgICAgICAgICAgICAgdHlwZTogbWltZVR5cGVcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciByZXF1ZXN0TmV4dFBhcnRpYWxSZWNvcmRpbmcgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBfcmVmMiA9IF9hc3luY1RvR2VuZXJhdG9yX19kZWZhdWx0W1wiZGVmYXVsdFwiXSggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWVfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIoZW5jb2RlcklkLCB0aW1lc2xpY2UpIHtcbiAgICAgICAgICAgIHZhciBhcnJheUJ1ZmZlcnM7XG4gICAgICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZV9fZGVmYXVsdFtcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlMiQoX2NvbnRleHQyKSB7XG4gICAgICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDIucHJldiA9IF9jb250ZXh0Mi5uZXh0KSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1lZGlhRW5jb2Rlckhvc3QuZW5jb2RlKGVuY29kZXJJZCwgdGltZXNsaWNlKTtcblxuICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBhcnJheUJ1ZmZlcnMgPSBfY29udGV4dDIuc2VudDtcblxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvbWlzZWRBdWRpb05vZGVzQW5kRW5jb2RlcklkID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgYnVmZmVyZWRBcnJheUJ1ZmZlcnMucHVzaC5hcHBseShidWZmZXJlZEFycmF5QnVmZmVycywgX3RvQ29uc3VtYWJsZUFycmF5X19kZWZhdWx0W1wiZGVmYXVsdFwiXShhcnJheUJ1ZmZlcnMpKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaERhdGFBdmFpbGFibGVFdmVudChhcnJheUJ1ZmZlcnMpO1xuICAgICAgICAgICAgICAgICAgICAgIHByb21pc2VkUGFydGlhbFJlY29yZGluZyA9IHJlcXVlc3ROZXh0UGFydGlhbFJlY29yZGluZyhlbmNvZGVySWQsIHRpbWVzbGljZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLnN0b3AoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIF9jYWxsZWUyKTtcbiAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gcmVxdWVzdE5leHRQYXJ0aWFsUmVjb3JkaW5nKF94NiwgX3g3KSB7XG4gICAgICAgICAgICByZXR1cm4gX3JlZjIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9KCk7XG5cbiAgICAgICAgdmFyIF9yZXN1bWUgPSBmdW5jdGlvbiByZXN1bWUoKSB7XG4gICAgICAgICAgaXNBdWRpb0NvbnRleHRSdW5uaW5nID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm4gYXVkaW9Db250ZXh0LnJlc3VtZSgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBzdG9wID0gZnVuY3Rpb24gc3RvcCgpIHtcbiAgICAgICAgICBpZiAocHJvbWlzZWRBdWRpb05vZGVzQW5kRW5jb2RlcklkID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGFib3J0UmVjb3JkaW5nICE9PSBudWxsKSB7XG4gICAgICAgICAgICBtZWRpYVN0cmVhbS5yZW1vdmVFdmVudExpc3RlbmVyKCdhZGR0cmFjaycsIGFib3J0UmVjb3JkaW5nKTtcbiAgICAgICAgICAgIG1lZGlhU3RyZWFtLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3JlbW92ZXRyYWNrJywgYWJvcnRSZWNvcmRpbmcpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChpbnRlcnZhbElkICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoaW50ZXJ2YWxJZCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcHJvbWlzZWRBdWRpb05vZGVzQW5kRW5jb2RlcklkLnRoZW4oIC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX3JlZjQgPSBfYXN5bmNUb0dlbmVyYXRvcl9fZGVmYXVsdFtcImRlZmF1bHRcIl0oIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUzKF9yZWYzKSB7XG4gICAgICAgICAgICAgIHZhciBjb25zdGFudFNvdXJjZU5vZGUsIGVuY29kZXJJZCwgbWVkaWFTdHJlYW1BdWRpb1NvdXJjZU5vZGUsIHJlY29yZGVyQXVkaW9Xb3JrbGV0Tm9kZSwgYXJyYXlCdWZmZXJzO1xuICAgICAgICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZV9fZGVmYXVsdFtcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlMyQoX2NvbnRleHQzKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQzLnByZXYgPSBfY29udGV4dDMubmV4dCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgY29uc3RhbnRTb3VyY2VOb2RlID0gX3JlZjMuY29uc3RhbnRTb3VyY2VOb2RlLCBlbmNvZGVySWQgPSBfcmVmMy5lbmNvZGVySWQsIG1lZGlhU3RyZWFtQXVkaW9Tb3VyY2VOb2RlID0gX3JlZjMubWVkaWFTdHJlYW1BdWRpb1NvdXJjZU5vZGUsIHJlY29yZGVyQXVkaW9Xb3JrbGV0Tm9kZSA9IF9yZWYzLnJlY29yZGVyQXVkaW9Xb3JrbGV0Tm9kZTtcblxuICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9taXNlZFBhcnRpYWxSZWNvcmRpbmcgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2VkUGFydGlhbFJlY29yZGluZ1tcImNhdGNoXCJdKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLyogQHRvZG8gT25seSBjYXRjaCB0aGUgZXJyb3JzIGNhdXNlZCBieSBhIGR1cGxpY2F0ZSBjYWxsIHRvIGVuY29kZS4gKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZWRQYXJ0aWFsUmVjb3JkaW5nID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDQ7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlY29yZGVyQXVkaW9Xb3JrbGV0Tm9kZS5zdG9wKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICAgIG1lZGlhU3RyZWFtQXVkaW9Tb3VyY2VOb2RlLmRpc2Nvbm5lY3QocmVjb3JkZXJBdWRpb1dvcmtsZXROb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICBjb25zdGFudFNvdXJjZU5vZGUuc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gODtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWVkaWFFbmNvZGVySG9zdC5lbmNvZGUoZW5jb2RlcklkLCBudWxsKTtcblxuICAgICAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICAgICAgYXJyYXlCdWZmZXJzID0gX2NvbnRleHQzLnNlbnQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICBpZiAoIShwcm9taXNlZEF1ZGlvTm9kZXNBbmRFbmNvZGVySWQgPT09IG51bGwpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDEyO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSAxMjtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3VzcGVuZCgpO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2hEYXRhQXZhaWxhYmxlRXZlbnQoW10uY29uY2F0KGJ1ZmZlcmVkQXJyYXlCdWZmZXJzLCBfdG9Db25zdW1hYmxlQXJyYXlfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKGFycmF5QnVmZmVycykpKTtcbiAgICAgICAgICAgICAgICAgICAgICBidWZmZXJlZEFycmF5QnVmZmVycy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgICAgICAgIGV2ZW50VGFyZ2V0LmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdzdG9wJykpO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0sIF9jYWxsZWUzKTtcbiAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChfeDgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIF9yZWY0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0oKSk7XG4gICAgICAgICAgcHJvbWlzZWRBdWRpb05vZGVzQW5kRW5jb2RlcklkID0gbnVsbDtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgc3VzcGVuZCA9IGZ1bmN0aW9uIHN1c3BlbmQoKSB7XG4gICAgICAgICAgaXNBdWRpb0NvbnRleHRSdW5uaW5nID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuIGF1ZGlvQ29udGV4dC5zdXNwZW5kKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgc3VzcGVuZCgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGdldCBtaW1lVHlwZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBtaW1lVHlwZTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgZ2V0IHN0YXRlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2VkQXVkaW9Ob2Rlc0FuZEVuY29kZXJJZCA9PT0gbnVsbCA/ICdpbmFjdGl2ZScgOiBpc0F1ZGlvQ29udGV4dFJ1bm5pbmcgPyAncmVjb3JkaW5nJyA6ICdwYXVzZWQnO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBwYXVzZTogZnVuY3Rpb24gcGF1c2UoKSB7XG4gICAgICAgICAgICBpZiAocHJvbWlzZWRBdWRpb05vZGVzQW5kRW5jb2RlcklkID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIHRocm93IGNyZWF0ZUludmFsaWRTdGF0ZUVycm9yKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpc0F1ZGlvQ29udGV4dFJ1bm5pbmcpIHtcbiAgICAgICAgICAgICAgc3VzcGVuZCgpO1xuICAgICAgICAgICAgICBldmVudFRhcmdldC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgncGF1c2UnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICByZXN1bWU6IGZ1bmN0aW9uIHJlc3VtZSgpIHtcbiAgICAgICAgICAgIGlmIChwcm9taXNlZEF1ZGlvTm9kZXNBbmRFbmNvZGVySWQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgdGhyb3cgY3JlYXRlSW52YWxpZFN0YXRlRXJyb3IoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFpc0F1ZGlvQ29udGV4dFJ1bm5pbmcpIHtcbiAgICAgICAgICAgICAgX3Jlc3VtZSgpO1xuXG4gICAgICAgICAgICAgIGV2ZW50VGFyZ2V0LmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdyZXN1bWUnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzdGFydDogZnVuY3Rpb24gc3RhcnQodGltZXNsaWNlKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG5cbiAgICAgICAgICAgIGlmIChwcm9taXNlZEF1ZGlvTm9kZXNBbmRFbmNvZGVySWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgdGhyb3cgY3JlYXRlSW52YWxpZFN0YXRlRXJyb3IoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG1lZGlhU3RyZWFtLmdldFZpZGVvVHJhY2tzKCkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICB0aHJvdyBjcmVhdGVOb3RTdXBwb3J0ZWRFcnJvcigpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBldmVudFRhcmdldC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnc3RhcnQnKSk7XG4gICAgICAgICAgICB2YXIgYXVkaW9UcmFja3MgPSBtZWRpYVN0cmVhbS5nZXRBdWRpb1RyYWNrcygpOyAvLyBAdG9kbyBUeXBlU2NyaXB0IHY0LjQuMiByZW1vdmVkIHRoZSBjaGFubmVsQ291bnQgcHJvcGVydHkgZnJvbSB0aGUgTWVkaWFUcmFja1NldHRpbmdzIGludGVyZmFjZS5cblxuICAgICAgICAgICAgdmFyIGNoYW5uZWxDb3VudCA9IGF1ZGlvVHJhY2tzLmxlbmd0aCA9PT0gMCA/IDIgOiAoX2EgPSBhdWRpb1RyYWNrc1swXS5nZXRTZXR0aW5ncygpLmNoYW5uZWxDb3VudCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMjtcbiAgICAgICAgICAgIHByb21pc2VkQXVkaW9Ob2Rlc0FuZEVuY29kZXJJZCA9IFByb21pc2UuYWxsKFtfcmVzdW1lKCksIHByb21pc2VkQXVkaW9Xb3JrbGV0TW9kdWxlLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlUHJvbWlzZWRBdWRpb05vZGVzRW5jb2RlcklkQW5kUG9ydChhdWRpb0J1ZmZlciwgYXVkaW9Db250ZXh0LCBjaGFubmVsQ291bnQsIG1lZGlhU3RyZWFtLCBtaW1lVHlwZSk7XG4gICAgICAgICAgICB9KV0pLnRoZW4oIC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHZhciBfcmVmNiA9IF9hc3luY1RvR2VuZXJhdG9yX19kZWZhdWx0W1wiZGVmYXVsdFwiXSggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWVfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTQoX3JlZjUpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3JlZjcsIF9yZWY3JCwgYXVkaW9CdWZmZXJTb3VyY2VOb2RlLCBlbmNvZGVySWQsIG1lZGlhU3RyZWFtQXVkaW9Tb3VyY2VOb2RlLCBwb3J0LCByZWNvcmRlckF1ZGlvV29ya2xldE5vZGUsIGNvbnN0YW50U291cmNlTm9kZTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lX19kZWZhdWx0W1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU0JChfY29udGV4dDQpIHtcbiAgICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQ0LnByZXYgPSBfY29udGV4dDQubmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9yZWY3ID0gX3NsaWNlZFRvQXJyYXlfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKF9yZWY1LCAyKSwgX3JlZjckID0gX3JlZjdbMV0sIGF1ZGlvQnVmZmVyU291cmNlTm9kZSA9IF9yZWY3JC5hdWRpb0J1ZmZlclNvdXJjZU5vZGUsIGVuY29kZXJJZCA9IF9yZWY3JC5lbmNvZGVySWQsIG1lZGlhU3RyZWFtQXVkaW9Tb3VyY2VOb2RlID0gX3JlZjckLm1lZGlhU3RyZWFtQXVkaW9Tb3VyY2VOb2RlLCBwb3J0ID0gX3JlZjckLnBvcnQsIHJlY29yZGVyQXVkaW9Xb3JrbGV0Tm9kZSA9IF9yZWY3JC5yZWNvcmRlckF1ZGlvV29ya2xldE5vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZWRpYVN0cmVhbUF1ZGlvU291cmNlTm9kZS5jb25uZWN0KHJlY29yZGVyQXVkaW9Xb3JrbGV0Tm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDQubmV4dCA9IDQ7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYXVkaW9CdWZmZXJTb3VyY2VOb2RlLm9uZW5kZWQgPSByZXNvbHZlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBhdWRpb0J1ZmZlclNvdXJjZU5vZGUuY29ubmVjdChyZWNvcmRlckF1ZGlvV29ya2xldE5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBhdWRpb0J1ZmZlclNvdXJjZU5vZGUuc3RhcnQoYXVkaW9Db250ZXh0LmN1cnJlbnRUaW1lICsgbGVuZ3RoIC8gYXVkaW9Db250ZXh0LnNhbXBsZVJhdGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBhdWRpb0J1ZmZlclNvdXJjZU5vZGUuZGlzY29ubmVjdChyZWNvcmRlckF1ZGlvV29ya2xldE5vZGUpOyAvLyBCdWcgIzE3OiBTYWZhcmkgZG9lcyB0aHJvdHRsZSB0aGUgcHJvY2Vzc2luZyBvbiBoaWRkZW4gdGFicyBpZiB0aGVyZSBpcyBubyBhY3RpdmUgYXVkaW8gb3V0cHV0LlxuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdGFudFNvdXJjZU5vZGUgPSBuZXcgc3RhbmRhcmRpemVkQXVkaW9Db250ZXh0LkNvbnN0YW50U291cmNlTm9kZShhdWRpb0NvbnRleHQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiAwXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3RhbnRTb3VyY2VOb2RlLm9uZW5kZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb25zdGFudFNvdXJjZU5vZGUuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3RhbnRTb3VyY2VOb2RlLmNvbm5lY3QoYXVkaW9Db250ZXh0LmRlc3RpbmF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0YW50U291cmNlTm9kZS5zdGFydCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ0Lm5leHQgPSAxMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWNvcmRlckF1ZGlvV29ya2xldE5vZGUucmVjb3JkKHBvcnQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aW1lc2xpY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlZFBhcnRpYWxSZWNvcmRpbmcgPSByZXF1ZXN0TmV4dFBhcnRpYWxSZWNvcmRpbmcoZW5jb2RlcklkLCB0aW1lc2xpY2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LmFicnVwdChcInJldHVyblwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0YW50U291cmNlTm9kZTogY29uc3RhbnRTb3VyY2VOb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBlbmNvZGVySWQ6IGVuY29kZXJJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbWVkaWFTdHJlYW1BdWRpb1NvdXJjZU5vZGU6IG1lZGlhU3RyZWFtQXVkaW9Tb3VyY2VOb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICByZWNvcmRlckF1ZGlvV29ya2xldE5vZGU6IHJlY29yZGVyQXVkaW9Xb3JrbGV0Tm9kZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgX2NhbGxlZTQpO1xuICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChfeDkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3JlZjYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0oKSk7XG4gICAgICAgICAgICB2YXIgdHJhY2tzID0gbWVkaWFTdHJlYW0uZ2V0VHJhY2tzKCk7XG5cbiAgICAgICAgICAgIGFib3J0UmVjb3JkaW5nID0gZnVuY3Rpb24gYWJvcnRSZWNvcmRpbmcoKSB7XG4gICAgICAgICAgICAgIHN0b3AoKTtcbiAgICAgICAgICAgICAgZXZlbnRUYXJnZXQuZGlzcGF0Y2hFdmVudChuZXcgRXJyb3JFdmVudCgnZXJyb3InLCB7XG4gICAgICAgICAgICAgICAgZXJyb3I6IGNyZWF0ZUludmFsaWRNb2RpZmljYXRpb25FcnJvcigpXG4gICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIG1lZGlhU3RyZWFtLmFkZEV2ZW50TGlzdGVuZXIoJ2FkZHRyYWNrJywgYWJvcnRSZWNvcmRpbmcpO1xuICAgICAgICAgICAgbWVkaWFTdHJlYW0uYWRkRXZlbnRMaXN0ZW5lcigncmVtb3ZldHJhY2snLCBhYm9ydFJlY29yZGluZyk7XG4gICAgICAgICAgICBpbnRlcnZhbElkID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICB2YXIgY3VycmVudFRyYWNrcyA9IG1lZGlhU3RyZWFtLmdldFRyYWNrcygpO1xuXG4gICAgICAgICAgICAgIGlmICgoY3VycmVudFRyYWNrcy5sZW5ndGggIT09IHRyYWNrcy5sZW5ndGggfHwgY3VycmVudFRyYWNrcy5zb21lKGZ1bmN0aW9uICh0cmFjaywgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJhY2sgIT09IHRyYWNrc1tpbmRleF07XG4gICAgICAgICAgICAgIH0pKSAmJiBhYm9ydFJlY29yZGluZyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGFib3J0UmVjb3JkaW5nKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIDEwMDApO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc3RvcDogc3RvcFxuICAgICAgICB9O1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZVdlYm1QY21NZWRpYVJlY29yZGVyRmFjdG9yeSA9IGZ1bmN0aW9uIGNyZWF0ZVdlYm1QY21NZWRpYVJlY29yZGVyRmFjdG9yeShjcmVhdGVCbG9iRXZlbnQsIGNyZWF0ZUludmFsaWRNb2RpZmljYXRpb25FcnJvciwgY3JlYXRlTm90U3VwcG9ydGVkRXJyb3IsIGRlY29kZVdlYk1DaHVuaywgcmVhZFZhcmlhYmxlU2l6ZUludGVnZXIpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoZXZlbnRUYXJnZXQsIG5hdGl2ZU1lZGlhUmVjb3JkZXJDb25zdHJ1Y3RvciwgbWVkaWFTdHJlYW0sIG1pbWVUeXBlKSB7XG4gICAgICAgIHZhciBhdWRpb1RyYWNrcyA9IG1lZGlhU3RyZWFtLmdldEF1ZGlvVHJhY2tzKCk7XG4gICAgICAgIHZhciBidWZmZXJlZEFycmF5QnVmZmVycyA9IFtdOyAvLyBAdG9kbyBUeXBlU2NyaXB0IHY0LjQuMiByZW1vdmVkIHRoZSBjaGFubmVsQ291bnQgcHJvcGVydHkgZnJvbSB0aGUgTWVkaWFUcmFja1NldHRpbmdzIGludGVyZmFjZS5cblxuICAgICAgICB2YXIgY2hhbm5lbENvdW50ID0gYXVkaW9UcmFja3MubGVuZ3RoID09PSAwID8gdW5kZWZpbmVkIDogYXVkaW9UcmFja3NbMF0uZ2V0U2V0dGluZ3MoKS5jaGFubmVsQ291bnQ7XG4gICAgICAgIHZhciBuYXRpdmVNZWRpYVJlY29yZGVyID0gbmV3IG5hdGl2ZU1lZGlhUmVjb3JkZXJDb25zdHJ1Y3RvcihtZWRpYVN0cmVhbSwge1xuICAgICAgICAgIG1pbWVUeXBlOiAnYXVkaW8vd2VibTtjb2RlY3M9cGNtJ1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHNhbXBsZVJhdGUgPSBhdWRpb1RyYWNrcy5sZW5ndGggPT09IDAgPyB1bmRlZmluZWQgOiBhdWRpb1RyYWNrc1swXS5nZXRTZXR0aW5ncygpLnNhbXBsZVJhdGU7XG4gICAgICAgIHZhciBwcm9taXNlZFBhcnRpYWxSZWNvcmRpbmcgPSBudWxsO1xuXG4gICAgICAgIHZhciBzdG9wUmVjb3JkaW5nID0gZnVuY3Rpb24gc3RvcFJlY29yZGluZygpIHt9OyAvLyB0c2xpbnQ6ZGlzYWJsZS1saW5lOm5vLWVtcHR5XG5cblxuICAgICAgICB2YXIgZGlzcGF0Y2hEYXRhQXZhaWxhYmxlRXZlbnQgPSBmdW5jdGlvbiBkaXNwYXRjaERhdGFBdmFpbGFibGVFdmVudChhcnJheUJ1ZmZlcnMpIHtcbiAgICAgICAgICBldmVudFRhcmdldC5kaXNwYXRjaEV2ZW50KGNyZWF0ZUJsb2JFdmVudCgnZGF0YWF2YWlsYWJsZScsIHtcbiAgICAgICAgICAgIGRhdGE6IG5ldyBCbG9iKGFycmF5QnVmZmVycywge1xuICAgICAgICAgICAgICB0eXBlOiBtaW1lVHlwZVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHJlcXVlc3ROZXh0UGFydGlhbFJlY29yZGluZyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIF9yZWYgPSBfYXN5bmNUb0dlbmVyYXRvcl9fZGVmYXVsdFtcImRlZmF1bHRcIl0oIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoZW5jb2RlcklkLCB0aW1lc2xpY2UpIHtcbiAgICAgICAgICAgIHZhciBhcnJheUJ1ZmZlcnM7XG4gICAgICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZV9fZGVmYXVsdFtcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDI7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtZWRpYUVuY29kZXJIb3N0LmVuY29kZShlbmNvZGVySWQsIHRpbWVzbGljZSk7XG5cbiAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgYXJyYXlCdWZmZXJzID0gX2NvbnRleHQuc2VudDtcblxuICAgICAgICAgICAgICAgICAgICBpZiAobmF0aXZlTWVkaWFSZWNvcmRlci5zdGF0ZSA9PT0gJ2luYWN0aXZlJykge1xuICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlcmVkQXJyYXlCdWZmZXJzLnB1c2guYXBwbHkoYnVmZmVyZWRBcnJheUJ1ZmZlcnMsIF90b0NvbnN1bWFibGVBcnJheV9fZGVmYXVsdFtcImRlZmF1bHRcIl0oYXJyYXlCdWZmZXJzKSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2hEYXRhQXZhaWxhYmxlRXZlbnQoYXJyYXlCdWZmZXJzKTtcbiAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlZFBhcnRpYWxSZWNvcmRpbmcgPSByZXF1ZXN0TmV4dFBhcnRpYWxSZWNvcmRpbmcoZW5jb2RlcklkLCB0aW1lc2xpY2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIF9jYWxsZWUpO1xuICAgICAgICAgIH0pKTtcblxuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiByZXF1ZXN0TmV4dFBhcnRpYWxSZWNvcmRpbmcoX3gsIF94Mikge1xuICAgICAgICAgICAgcmV0dXJuIF9yZWYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9KCk7XG5cbiAgICAgICAgdmFyIHN0b3AgPSBmdW5jdGlvbiBzdG9wKCkge1xuICAgICAgICAgIGlmIChuYXRpdmVNZWRpYVJlY29yZGVyLnN0YXRlID09PSAnaW5hY3RpdmUnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHByb21pc2VkUGFydGlhbFJlY29yZGluZyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcHJvbWlzZWRQYXJ0aWFsUmVjb3JkaW5nW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAvKiBAdG9kbyBPbmx5IGNhdGNoIHRoZSBlcnJvcnMgY2F1c2VkIGJ5IGEgZHVwbGljYXRlIGNhbGwgdG8gZW5jb2RlLiAqL1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBwcm9taXNlZFBhcnRpYWxSZWNvcmRpbmcgPSBudWxsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHN0b3BSZWNvcmRpbmcoKTtcblxuICAgICAgICAgIHN0b3BSZWNvcmRpbmcgPSBmdW5jdGlvbiBzdG9wUmVjb3JkaW5nKCkge307IC8vIHRzbGludDpkaXNhYmxlLWxpbmU6bm8tZW1wdHlcblxuXG4gICAgICAgICAgbmF0aXZlTWVkaWFSZWNvcmRlci5zdG9wKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgbmF0aXZlTWVkaWFSZWNvcmRlci5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBzdG9wKCk7IC8vIEJ1ZyAjMyAmICM0OiBDaHJvbWUgdGhyb3dzIGFuIGVycm9yIGV2ZW50IHdpdGhvdXQgYW55IGVycm9yLlxuXG4gICAgICAgICAgZXZlbnRUYXJnZXQuZGlzcGF0Y2hFdmVudChuZXcgRXJyb3JFdmVudCgnZXJyb3InLCB7XG4gICAgICAgICAgICBlcnJvcjogY3JlYXRlSW52YWxpZE1vZGlmaWNhdGlvbkVycm9yKClcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH0pO1xuICAgICAgICBuYXRpdmVNZWRpYVJlY29yZGVyLmFkZEV2ZW50TGlzdGVuZXIoJ3N0YXJ0JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBldmVudFRhcmdldC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnc3RhcnQnKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGdldCBtaW1lVHlwZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBtaW1lVHlwZTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgZ2V0IHN0YXRlKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5hdGl2ZU1lZGlhUmVjb3JkZXIuc3RhdGU7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHBhdXNlOiBmdW5jdGlvbiBwYXVzZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBuYXRpdmVNZWRpYVJlY29yZGVyLnBhdXNlKCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICByZXN1bWU6IGZ1bmN0aW9uIHJlc3VtZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBuYXRpdmVNZWRpYVJlY29yZGVyLnJlc3VtZSgpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc3RhcnQ6IGZ1bmN0aW9uIHN0YXJ0KHRpbWVzbGljZSkge1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIEJ1ZyAjNjogQ2hyb21lIHdpbGwgZW1pdCBhIGJsb2Igd2l0aG91dCBhbnkgZGF0YSB3aGVuIGFza2VkIHRvIGVuY29kZSBhIE1lZGlhU3RyZWFtIHdpdGggYSB2aWRlbyB0cmFjayBpbnRvIGFuIGF1ZGlvXG4gICAgICAgICAgICAgKiBjb2RlYy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKG1lZGlhU3RyZWFtLmdldFZpZGVvVHJhY2tzKCkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICB0aHJvdyBjcmVhdGVOb3RTdXBwb3J0ZWRFcnJvcigpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobmF0aXZlTWVkaWFSZWNvcmRlci5zdGF0ZSA9PT0gJ2luYWN0aXZlJykge1xuICAgICAgICAgICAgICBpZiAoc2FtcGxlUmF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgc2FtcGxlUmF0ZSBpcyBub3QgZGVmaW5lZC4nKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHZhciBpc1JlY29yZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICB2YXIgaXNTdG9wcGVkID0gZmFsc2U7IC8vIEJ1ZyAjOTogQ2hyb21lIHNvbWV0aW1lcyBmaXJlcyBtb3JlIHRoYW4gb25lIGRhdGFhdmFpbGFibGUgZXZlbnQgd2hpbGUgYmVpbmcgaW5hY3RpdmUuXG5cbiAgICAgICAgICAgICAgdmFyIHBlbmRpbmdJbnZvY2F0aW9ucyA9IDA7XG4gICAgICAgICAgICAgIHZhciBwcm9taXNlZERhdGFWaWV3RWxlbWVudFR5cGVFbmNvZGVySWRBbmRQb3J0ID0gbWVkaWFFbmNvZGVySG9zdC5pbnN0YW50aWF0ZShtaW1lVHlwZSwgc2FtcGxlUmF0ZSk7XG5cbiAgICAgICAgICAgICAgc3RvcFJlY29yZGluZyA9IGZ1bmN0aW9uIHN0b3BSZWNvcmRpbmcoKSB7XG4gICAgICAgICAgICAgICAgaXNTdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICB2YXIgcmVtb3ZlRXZlbnRMaXN0ZW5lciA9IHN1YnNjcmliYWJsZVRoaW5ncy5vbihuYXRpdmVNZWRpYVJlY29yZGVyLCAnZGF0YWF2YWlsYWJsZScpKGZ1bmN0aW9uIChfcmVmMikge1xuICAgICAgICAgICAgICAgIHZhciBkYXRhID0gX3JlZjIuZGF0YTtcbiAgICAgICAgICAgICAgICBwZW5kaW5nSW52b2NhdGlvbnMgKz0gMTtcbiAgICAgICAgICAgICAgICBwcm9taXNlZERhdGFWaWV3RWxlbWVudFR5cGVFbmNvZGVySWRBbmRQb3J0ID0gcHJvbWlzZWREYXRhVmlld0VsZW1lbnRUeXBlRW5jb2RlcklkQW5kUG9ydC50aGVuKCAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgdmFyIF9yZWY0ID0gX2FzeW5jVG9HZW5lcmF0b3JfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZV9fZGVmYXVsdFtcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlMihfcmVmMykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX3JlZjMkZGF0YVZpZXcsIGRhdGFWaWV3LCBfcmVmMyRlbGVtZW50VHlwZSwgZWxlbWVudFR5cGUsIGVuY29kZXJJZCwgcG9ydCwgYXJyYXlCdWZmZXIsIGN1cnJlbnREYXRhVmlldywgbGVuZ3RoQW5kVmFsdWUsIHZhbHVlLCBfZGVjb2RlV2ViTUNodW5rLCBjdXJyZW50RWxlbWVudFR5cGUsIG9mZnNldCwgY29udGVudHMsIHJlbWFpbmluZ0RhdGFWaWV3O1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lX19kZWZhdWx0W1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyJChfY29udGV4dDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDIucHJldiA9IF9jb250ZXh0Mi5uZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcmVmMyRkYXRhVmlldyA9IF9yZWYzLmRhdGFWaWV3LCBkYXRhVmlldyA9IF9yZWYzJGRhdGFWaWV3ID09PSB2b2lkIDAgPyBudWxsIDogX3JlZjMkZGF0YVZpZXcsIF9yZWYzJGVsZW1lbnRUeXBlID0gX3JlZjMuZWxlbWVudFR5cGUsIGVsZW1lbnRUeXBlID0gX3JlZjMkZWxlbWVudFR5cGUgPT09IHZvaWQgMCA/IG51bGwgOiBfcmVmMyRlbGVtZW50VHlwZSwgZW5jb2RlcklkID0gX3JlZjMuZW5jb2RlcklkLCBwb3J0ID0gX3JlZjMucG9ydDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGEuYXJyYXlCdWZmZXIoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXlCdWZmZXIgPSBfY29udGV4dDIuc2VudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZW5kaW5nSW52b2NhdGlvbnMgLT0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50RGF0YVZpZXcgPSBkYXRhVmlldyA9PT0gbnVsbCA/IG5ldyBtdWx0aUJ1ZmZlckRhdGFWaWV3Lk11bHRpQnVmZmVyRGF0YVZpZXcoW2FycmF5QnVmZmVyXSkgOiBuZXcgbXVsdGlCdWZmZXJEYXRhVmlldy5NdWx0aUJ1ZmZlckRhdGFWaWV3KFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXlfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKGRhdGFWaWV3LmJ1ZmZlcnMpLCBbYXJyYXlCdWZmZXJdKSwgZGF0YVZpZXcuYnl0ZU9mZnNldCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoISghaXNSZWNvcmRpbmcgJiYgbmF0aXZlTWVkaWFSZWNvcmRlci5zdGF0ZSA9PT0gJ3JlY29yZGluZycgJiYgIWlzU3RvcHBlZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZW5ndGhBbmRWYWx1ZSA9IHJlYWRWYXJpYWJsZVNpemVJbnRlZ2VyKGN1cnJlbnREYXRhVmlldywgMCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShsZW5ndGhBbmRWYWx1ZSA9PT0gbnVsbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhVmlldzogY3VycmVudERhdGFWaWV3LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudFR5cGU6IGVsZW1lbnRUeXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5jb2RlcklkOiBlbmNvZGVySWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3J0OiBwb3J0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGxlbmd0aEFuZFZhbHVlLnZhbHVlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEodmFsdWUgIT09IDE3MjM1MTM5NSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhVmlldzogZGF0YVZpZXcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50VHlwZTogZWxlbWVudFR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmNvZGVySWQ6IGVuY29kZXJJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcnQ6IHBvcnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzUmVjb3JkaW5nID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9kZWNvZGVXZWJNQ2h1bmsgPSBkZWNvZGVXZWJNQ2h1bmsoY3VycmVudERhdGFWaWV3LCBlbGVtZW50VHlwZSwgY2hhbm5lbENvdW50KSwgY3VycmVudEVsZW1lbnRUeXBlID0gX2RlY29kZVdlYk1DaHVuay5jdXJyZW50RWxlbWVudFR5cGUsIG9mZnNldCA9IF9kZWNvZGVXZWJNQ2h1bmsub2Zmc2V0LCBjb250ZW50cyA9IF9kZWNvZGVXZWJNQ2h1bmsuY29udGVudHM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtYWluaW5nRGF0YVZpZXcgPSBvZmZzZXQgPCBjdXJyZW50RGF0YVZpZXcuYnl0ZUxlbmd0aCA/IG5ldyBtdWx0aUJ1ZmZlckRhdGFWaWV3Lk11bHRpQnVmZmVyRGF0YVZpZXcoY3VycmVudERhdGFWaWV3LmJ1ZmZlcnMsIGN1cnJlbnREYXRhVmlldy5ieXRlT2Zmc2V0ICsgb2Zmc2V0KSA6IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudHMuZm9yRWFjaChmdW5jdGlvbiAoY29udGVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBvcnQucG9zdE1lc3NhZ2UoY29udGVudCwgY29udGVudC5tYXAoZnVuY3Rpb24gKF9yZWY1KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBidWZmZXIgPSBfcmVmNS5idWZmZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBidWZmZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGVuZGluZ0ludm9jYXRpb25zID09PSAwICYmIChuYXRpdmVNZWRpYVJlY29yZGVyLnN0YXRlID09PSAnaW5hY3RpdmUnIHx8IGlzU3RvcHBlZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lZGlhRW5jb2Rlckhvc3QuZW5jb2RlKGVuY29kZXJJZCwgbnVsbCkudGhlbihmdW5jdGlvbiAoYXJyYXlCdWZmZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoRGF0YUF2YWlsYWJsZUV2ZW50KFtdLmNvbmNhdChidWZmZXJlZEFycmF5QnVmZmVycywgX3RvQ29uc3VtYWJsZUFycmF5X19kZWZhdWx0W1wiZGVmYXVsdFwiXShhcnJheUJ1ZmZlcnMpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlcmVkQXJyYXlCdWZmZXJzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50VGFyZ2V0LmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdzdG9wJykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3J0LnBvc3RNZXNzYWdlKFtdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcnQuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhVmlldzogcmVtYWluaW5nRGF0YVZpZXcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50VHlwZTogY3VycmVudEVsZW1lbnRUeXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5jb2RlcklkOiBlbmNvZGVySWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3J0OiBwb3J0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSwgX2NhbGxlZTIpO1xuICAgICAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKF94Mykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3JlZjQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSgpKTtcbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgaWYgKHRpbWVzbGljZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZWREYXRhVmlld0VsZW1lbnRUeXBlRW5jb2RlcklkQW5kUG9ydC50aGVuKGZ1bmN0aW9uIChfcmVmNikge1xuICAgICAgICAgICAgICAgICAgdmFyIGVuY29kZXJJZCA9IF9yZWY2LmVuY29kZXJJZDtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlZFBhcnRpYWxSZWNvcmRpbmcgPSByZXF1ZXN0TmV4dFBhcnRpYWxSZWNvcmRpbmcoZW5jb2RlcklkLCB0aW1lc2xpY2UpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG5hdGl2ZU1lZGlhUmVjb3JkZXIuc3RhcnQoMTAwKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHN0b3A6IHN0b3BcbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVXaW5kb3cgPSBmdW5jdGlvbiBjcmVhdGVXaW5kb3coKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogd2luZG93O1xuICAgIH07XG5cbiAgICB2YXIgcmVhZFZhcmlhYmxlU2l6ZUludGVnZXJMZW5ndGggPSBmdW5jdGlvbiByZWFkVmFyaWFibGVTaXplSW50ZWdlckxlbmd0aChkYXRhVmlldywgb2Zmc2V0KSB7XG4gICAgICBpZiAob2Zmc2V0ID49IGRhdGFWaWV3LmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciBfYnl0ZSA9IGRhdGFWaWV3LmdldFVpbnQ4KG9mZnNldCk7XG5cbiAgICAgIGlmIChfYnl0ZSA+IDEyNykge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cblxuICAgICAgaWYgKF9ieXRlID4gNjMpIHtcbiAgICAgICAgcmV0dXJuIDI7XG4gICAgICB9XG5cbiAgICAgIGlmIChfYnl0ZSA+IDMxKSB7XG4gICAgICAgIHJldHVybiAzO1xuICAgICAgfVxuXG4gICAgICBpZiAoX2J5dGUgPiAxNSkge1xuICAgICAgICByZXR1cm4gNDtcbiAgICAgIH1cblxuICAgICAgaWYgKF9ieXRlID4gNykge1xuICAgICAgICByZXR1cm4gNTtcbiAgICAgIH1cblxuICAgICAgaWYgKF9ieXRlID4gMykge1xuICAgICAgICByZXR1cm4gNjtcbiAgICAgIH1cblxuICAgICAgaWYgKF9ieXRlID4gMSkge1xuICAgICAgICByZXR1cm4gNztcbiAgICAgIH1cblxuICAgICAgaWYgKF9ieXRlID4gMCkge1xuICAgICAgICByZXR1cm4gODtcbiAgICAgIH1cblxuICAgICAgdmFyIGxlbmd0aCA9IHJlYWRWYXJpYWJsZVNpemVJbnRlZ2VyTGVuZ3RoKGRhdGFWaWV3LCBvZmZzZXQgKyAxKTtcbiAgICAgIHJldHVybiBsZW5ndGggPT09IG51bGwgPyBudWxsIDogbGVuZ3RoICsgODtcbiAgICB9O1xuXG4gICAgdmFyIHdyYXBFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gd3JhcEV2ZW50TGlzdGVuZXIodGFyZ2V0LCBldmVudExpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciBkZXNjcmlwdG9yID0ge1xuICAgICAgICAgIHZhbHVlOiB0YXJnZXRcbiAgICAgICAgfTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZXZlbnQsIHtcbiAgICAgICAgICBjdXJyZW50VGFyZ2V0OiBkZXNjcmlwdG9yLFxuICAgICAgICAgIHRhcmdldDogZGVzY3JpcHRvclxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAodHlwZW9mIGV2ZW50TGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICByZXR1cm4gZXZlbnRMaXN0ZW5lci5jYWxsKHRhcmdldCwgZXZlbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGV2ZW50TGlzdGVuZXIuaGFuZGxlRXZlbnQuY2FsbCh0YXJnZXQsIGV2ZW50KTtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBlbmNvZGVyUmVnZXhlcyA9IFtdO1xuICAgIHZhciB3aW5kb3ckMSA9IGNyZWF0ZVdpbmRvdygpO1xuICAgIHZhciBuYXRpdmVCbG9iRXZlbnRDb25zdHJ1Y3RvciA9IGNyZWF0ZU5hdGl2ZUJsb2JFdmVudENvbnN0cnVjdG9yKHdpbmRvdyQxKTtcbiAgICB2YXIgY3JlYXRlQmxvYkV2ZW50ID0gY3JlYXRlQmxvYkV2ZW50RmFjdG9yeShuYXRpdmVCbG9iRXZlbnRDb25zdHJ1Y3Rvcik7XG4gICAgdmFyIGNyZWF0ZVdlYkF1ZGlvTWVkaWFSZWNvcmRlciA9IGNyZWF0ZVdlYkF1ZGlvTWVkaWFSZWNvcmRlckZhY3RvcnkoY3JlYXRlQmxvYkV2ZW50LCBjcmVhdGVJbnZhbGlkTW9kaWZpY2F0aW9uRXJyb3IsIGNyZWF0ZUludmFsaWRTdGF0ZUVycm9yLCBjcmVhdGVOb3RTdXBwb3J0ZWRFcnJvcik7XG4gICAgdmFyIHJlYWRWYXJpYWJsZVNpemVJbnRlZ2VyID0gY3JlYXRlUmVhZFZhcmlhYmxlU2l6ZUludGVnZXIocmVhZFZhcmlhYmxlU2l6ZUludGVnZXJMZW5ndGgpO1xuICAgIHZhciByZWFkRWxlbWVudENvbnRlbnQgPSBjcmVhdGVSZWFkRWxlbWVudENvbnRlbnQocmVhZFZhcmlhYmxlU2l6ZUludGVnZXIpO1xuICAgIHZhciByZWFkRWxlbWVudFR5cGUgPSBjcmVhdGVSZWFkRWxlbWVudFR5cGUocmVhZFZhcmlhYmxlU2l6ZUludGVnZXIpO1xuICAgIHZhciBkZWNvZGVXZWJNQ2h1bmsgPSBjcmVhdGVEZWNvZGVXZWJNQ2h1bmsocmVhZEVsZW1lbnRDb250ZW50LCByZWFkRWxlbWVudFR5cGUpO1xuICAgIHZhciBjcmVhdGVXZWJtUGNtTWVkaWFSZWNvcmRlciA9IGNyZWF0ZVdlYm1QY21NZWRpYVJlY29yZGVyRmFjdG9yeShjcmVhdGVCbG9iRXZlbnQsIGNyZWF0ZUludmFsaWRNb2RpZmljYXRpb25FcnJvciwgY3JlYXRlTm90U3VwcG9ydGVkRXJyb3IsIGRlY29kZVdlYk1DaHVuaywgcmVhZFZhcmlhYmxlU2l6ZUludGVnZXIpO1xuICAgIHZhciBjcmVhdGVFdmVudFRhcmdldCA9IGNyZWF0ZUV2ZW50VGFyZ2V0RmFjdG9yeSh3aW5kb3ckMSk7XG4gICAgdmFyIG5hdGl2ZU1lZGlhUmVjb3JkZXJDb25zdHJ1Y3RvciA9IGNyZWF0ZU5hdGl2ZU1lZGlhUmVjb3JkZXJDb25zdHJ1Y3Rvcih3aW5kb3ckMSk7XG4gICAgdmFyIGNyZWF0ZU5hdGl2ZU1lZGlhUmVjb3JkZXIgPSBjcmVhdGVOYXRpdmVNZWRpYVJlY29yZGVyRmFjdG9yeShjcmVhdGVJbnZhbGlkTW9kaWZpY2F0aW9uRXJyb3IsIGNyZWF0ZU5vdFN1cHBvcnRlZEVycm9yKTtcbiAgICB2YXIgbWVkaWFSZWNvcmRlckNvbnN0cnVjdG9yID0gY3JlYXRlTWVkaWFSZWNvcmRlckNvbnN0cnVjdG9yKGNyZWF0ZU5hdGl2ZU1lZGlhUmVjb3JkZXIsIGNyZWF0ZU5vdFN1cHBvcnRlZEVycm9yLCBjcmVhdGVXZWJBdWRpb01lZGlhUmVjb3JkZXIsIGNyZWF0ZVdlYm1QY21NZWRpYVJlY29yZGVyLCBlbmNvZGVyUmVnZXhlcywgY3JlYXRlRXZlbnRUYXJnZXRDb25zdHJ1Y3RvcihjcmVhdGVFdmVudFRhcmdldCwgd3JhcEV2ZW50TGlzdGVuZXIpLCBuYXRpdmVNZWRpYVJlY29yZGVyQ29uc3RydWN0b3IpO1xuICAgIHZhciBpc1N1cHBvcnRlZCA9IGZ1bmN0aW9uIGlzU3VwcG9ydGVkKCkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUlzU3VwcG9ydGVkUHJvbWlzZSh3aW5kb3ckMSk7XG4gICAgfTtcbiAgICB2YXIgcmVnaXN0ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9yZWYgPSBfYXN5bmNUb0dlbmVyYXRvcl9fZGVmYXVsdFtcImRlZmF1bHRcIl0oIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUocG9ydCkge1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZV9fZGVmYXVsdFtcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBfY29udGV4dC50MCA9IGVuY29kZXJSZWdleGVzO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAzO1xuICAgICAgICAgICAgICAgIHJldHVybiBtZWRpYUVuY29kZXJIb3N0LnJlZ2lzdGVyKHBvcnQpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICBfY29udGV4dC50MSA9IF9jb250ZXh0LnNlbnQ7XG5cbiAgICAgICAgICAgICAgICBfY29udGV4dC50MC5wdXNoLmNhbGwoX2NvbnRleHQudDAsIF9jb250ZXh0LnQxKTtcblxuICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZSk7XG4gICAgICB9KSk7XG5cbiAgICAgIHJldHVybiBmdW5jdGlvbiByZWdpc3RlcihfeCkge1xuICAgICAgICByZXR1cm4gX3JlZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICB9KCk7XG5cbiAgICBleHBvcnRzLk1lZGlhUmVjb3JkZXIgPSBtZWRpYVJlY29yZGVyQ29uc3RydWN0b3I7XG4gICAgZXhwb3J0cy5pc1N1cHBvcnRlZCA9IGlzU3VwcG9ydGVkO1xuICAgIGV4cG9ydHMucmVnaXN0ZXIgPSByZWdpc3RlcjtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/extendable-media-recorder/build/es5/bundle.js\n");

/***/ })

};
;